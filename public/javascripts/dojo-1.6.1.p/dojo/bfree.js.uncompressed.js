/*
	Copyright (c) 2004-2011, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is an optimized version of Dojo, built for deployment and not for
	development. To get sources and documentation, please visit:

		http://dojotoolkit.org
*/

if(!dojo._hasResource["dojo.data.util.filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.filter"] = true;
dojo.provide("dojo.data.util.filter");

dojo.getObject("data.util.filter", true, dojo);

dojo.data.util.filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}
	
};

}

if(!dojo._hasResource["dojox.data.ClientFilter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.ClientFilter"] = true;
dojo.provide("dojox.data.ClientFilter");



// This is an abstract data store module for adding updateable result set functionality to an existing data store class
(function(){
	var cf;
	var addUpdate = function(store,create,remove){
		// create a handler that adds to the list of notifications
		return function(item){
			store._updates.push({
					create:create && item,
					remove:remove && item
				});
			cf.onUpdate();
		}
	};
	cf = dojo.declare("dojox.data.ClientFilter",
		null,
		{
			cacheByDefault: false,
			constructor: function(){
				// summary:
				//		This is an abstract class that data stores can extend to add updateable result set functionality
				// 		as well as client side querying capabilities. This enables
				//		widgets to be aware of how active results change in response to the modifications/notifications.
				//
				//	description:
				//		To a update a result set after a notification (onNew, onSet, and onDelete),
				// 		widgets can call the updateResultSet method. Widgets can use the updated
				//		result sets to determine how to react to notifications, and how to update their displayed results
				//		based on changes.
				//
				// 		This module will use the best available information to update result sets, using query attribute
				// 		objects to determine if items are in a result set, and using the sort arrays to maintain sort
				// 		information. However, queries can be opaque strings, and this module can not update
				// 		results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
				// 		and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
				// 		isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
				//		definition of isUpdateable and matchesQuery
				// 		isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
				// 		matchesQuery(item,request) - item is the item to test, and request is the value arguments object
				//				for the fetch function.
				//
				//		You can define a property on this object instance "cacheByDefault" to a value of true that will
				// 		cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
				// 		This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.
				//
				// example:
				//		to make a updated-result-set data store from an existing data store:
				//	|	dojo.declare("dojox.data.MyLiveDataStore",
				//	|		dojox.data.MyDataStore,dojox.data.ClientFilter], // subclass LiveResultSets if available
				//	|		{}
				//	|	);
				this.onSet = addUpdate(this,true,true);
				this.onNew = addUpdate(this,true,false);
				this.onDelete = addUpdate(this,false,true);
				this._updates= [];
				this._fetchCache = [];
			},
			clearCache: function(){
				//	summary:
				//		Clears the cache of client side queries
				this._fetchCache = [];
			},
			updateResultSet: function(/*Array*/ resultSet, /*Object*/ request){
				//	summary:
				//		Attempts to update the given result set based on previous notifications
				//	resultSet:
				//		The result set array that should be updated
				//	request:
				//		This object follows the same meaning as the keywordArgs passed to a dojo.data.api.Read.fetch.
				//	description:
				// 		This will attempt to update the provide result based on previous notification, adding new items
				// 		from onNew calls, removing deleted items, and updating modified items, and properly removing
				//  	and adding items as required by the query and sort parameters. This function will return:
				//		0: Indicates it could not successfully update the result set
				//		1: Indicates it could successfully handle all the notifications, but no changes were made to the result set
				//		2: Indicates it successfully handled all the notifications and result set has been updated.
				if(this.isUpdateable(request)){
					// we try to avoid rerunning notification updates more than once on the same object for performance
					for(var i = request._version || 0; i < this._updates.length;i++){
						// for each notification,we will update the result set
						var create = this._updates[i].create;
						var remove = this._updates[i].remove;
						if(remove){
							for(var j = 0; j < resultSet.length;j++){
								if(this.getIdentity(resultSet[j]) == this.getIdentity(remove)){
									resultSet.splice(j--,1);
									var updated = true;
								}
							}
						}
						if(create && this.matchesQuery(create,request) && // if there is a new/replacement item and it matches the query
								dojo.indexOf(resultSet,create) == -1){ // and it doesn't already exist in query
							resultSet.push(create); // should this go at the beginning by default instead?
							updated = true;
						}
					}
					if(request.sort && updated){
						// do the sort if needed
						resultSet.sort(this.makeComparator(request.sort.concat()));
					}
					resultSet._fullLength = resultSet.length;
					if(request.count && updated && request.count !== Infinity){
						// do we really need to do this?
						// make sure we still find within the defined paging set
						resultSet.splice(request.count, resultSet.length);
					}
					request._version = this._updates.length;
					return updated ? 2 : 1;
				}
				return 0;
			},
			querySuperSet: function(argsSuper, argsSub){
				//	summary:
				//		Determines whether the provided arguments are super/sub sets of each other
				// argsSuper:
				// 		Dojo Data Fetch arguments
				// argsSub:
				// 		Dojo Data Fetch arguments
				if(argsSuper.query == argsSub.query){
					return {};
				}
				if(!(argsSub.query instanceof Object && // sub query must be an object
						// super query must be non-existent or an object
						(!argsSuper.query || typeof argsSuper.query == 'object'))){
					return false;
				}
				var clientQuery = dojo.mixin({},argsSub.query);
				for(var i in argsSuper.query){
					if(clientQuery[i] == argsSuper.query[i]){
						delete clientQuery[i];
					}else if(!(typeof argsSuper.query[i] == 'string' &&
							// if it is a pattern, we can test to see if it is a sub-pattern
							// FIXME: This is not technically correct, but it will work for the majority of cases
							dojo.data.util.filter.patternToRegExp(argsSuper.query[i]).test(clientQuery[i]))){
						return false;
					}
				}
				return clientQuery;
			},
			//	This is the point in the version notification history at which it is known that the server is in sync, this should
			//	be updated to this._updates.length on commit operations.
			serverVersion: 0,
			
			cachingFetch: function(args){
				var self = this;
				for(var i = 0; i < this._fetchCache.length;i++){
					var cachedArgs = this._fetchCache[i];
					var clientQuery = this.querySuperSet(cachedArgs,args);
					if(clientQuery !== false){
						var defResult = cachedArgs._loading;
						if(!defResult){
							defResult = new dojo.Deferred();
							defResult.callback(cachedArgs.cacheResults);
						}
						defResult.addCallback(function(results){
							results = self.clientSideFetch(dojo.mixin(dojo.mixin({}, args),{query:clientQuery}), results);
							defResult.fullLength = results._fullLength;
							return results;
						});
						args._version = cachedArgs._version;
						break;
					}
				}
				if(!defResult){
					var serverArgs = dojo.mixin({}, args);
					var putInCache = (args.queryOptions || 0).cache;
					var fetchCache = this._fetchCache;
					if(putInCache === undefined ? this.cacheByDefault : putInCache){
						// we are caching this request, so we want to get all the data, and page on the client side
						if(args.start || args.count){
							delete serverArgs.start;
							delete serverArgs.count;
							args.clientQuery = dojo.mixin(args.clientQuery || {}, {
								start: args.start,
								count: args.count
							});
						}
						args = serverArgs;
						fetchCache.push(args);
					}
					defResult= args._loading = this._doQuery(args);
					 
					defResult.addErrback(function(){
						fetchCache.splice(dojo.indexOf(fetchCache, args), 1);
					});
				}
				var version = this.serverVersion;
				
				defResult.addCallback(function(results){
					delete args._loading;
					// update the result set in case anything changed while we were waiting for the fetch
					if(results){
						args._version = typeof args._version == "number" ? args._version : version;
						self.updateResultSet(results,args);
						args.cacheResults = results;
						if(!args.count || results.length < args.count){
							defResult.fullLength = ((args.start)?args.start:0) + results.length;
						}
					}
					return results;
				});
				return defResult;
			},
			isUpdateable: function(/*Object*/ request){
				//	summary:
				//		Returns whether the provide fetch arguments can be used to update an existing list
				//	request:
				//		See dojo.data.api.Read.fetch request
				
				return typeof request.query == "object";
			},
			clientSideFetch: function(/*Object*/ request,/*Array*/ baseResults){
				// summary:
				//		Performs a query on the client side and returns the results as an array
				//
				//	request:
				//		See dojo.data.api.Read.fetch request
				//
				//	baseResults:
				//		This provides the result set to start with for client side querying
				if(request.queryOptions && request.queryOptions.results){
					baseResults = request.queryOptions.results;
				}
				if(request.query){
					// filter by the query
					var results = [];
					for(var i = 0; i < baseResults.length; i++){
						var value = baseResults[i];
						if(value && this.matchesQuery(value,request)){
							results.push(baseResults[i]);
						}
					}
				}else{
					results = request.sort ? baseResults.concat() : baseResults; // we don't want to mutate the baseResults if we are doing a sort
				}
				if(request.sort){
					// do the sort if needed
					results.sort(this.makeComparator(request.sort.concat()));
				}
				return this.clientSidePaging(request, results);
			},
			clientSidePaging: function(/*Object*/ request,/*Array*/ baseResults){
				var start = request.start || 0;
				var finalResults = (start || request.count) ? baseResults.slice(start,start + (request.count || baseResults.length)) : baseResults;
				finalResults._fullLength = baseResults.length;
				return finalResults;
			},
			matchesQuery: function(item,request){
				var query = request.query;
				var ignoreCase = request.queryOptions && request.queryOptions.ignoreCase;
				for(var i in query){
					// if anything doesn't match, than this should be in the query
					var match = query[i];
					var value = this.getValue(item,i);
					if((typeof match == 'string' && (match.match(/[\*\.]/) || ignoreCase)) ?
						!dojo.data.util.filter.patternToRegExp(match, ignoreCase).test(value) :
						value != match){
						return false;
					}
				}
				return true;
			},
			makeComparator: function(sort){
				//	summary:
				// 		returns a comparator function for the given sort order array
				//	sort:
				//		See dojox.data.api.Read.fetch
				var current = sort.shift();
				if(!current){
					// sort order for ties and no sort orders
					return function(){
						return 0;// keep the order unchanged
					};
				}
				var attribute = current.attribute;
				var descending = !!current.descending;
				var next = this.makeComparator(sort);
				var store = this;
				return function(a,b){
					var av = store.getValue(a,attribute);
					var bv = store.getValue(b,attribute);
					if(av != bv){
						return av < bv == descending ? 1 : -1;
					}
					return next(a,b);
				};
			}
		}
	);
	cf.onUpdate = function(){};
})();

}

if(!dojo._hasResource["dojo.date.stamp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.stamp"] = true;
dojo.provide("dojo.date.stamp");

dojo.getObject("date.stamp", true, dojo);

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			dojo.forEach(dojo.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

}

if(!dojo._hasResource["dojox.json.ref"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.json.ref"] = true;
dojo.provide("dojox.json.ref");



dojox.json.ref = {
	// summary:
	// 		Adds advanced JSON {de}serialization capabilities to the base json library.
	// 		This enhances the capabilities of dojo.toJson and dojo.fromJson,
	// 		adding referencing support, date handling, and other extra format handling.
	// 		On parsing, references are resolved. When references are made to
	// 		ids/objects that have been loaded yet, the loader function will be set to
	// 		_loadObject to denote a lazy loading (not loaded yet) object.


	resolveJson: function(/*Object*/ root,/*Object?*/ args){
		// summary:
		// 		Indexes and resolves references in the JSON object.
		// description:
		// 		A JSON Schema object that can be used to advise the handling of the JSON (defining ids, date properties, urls, etc)
		//
		// root:
		//		The root object of the object graph to be processed
		// args:
		//		Object with additional arguments:
		//
		// The *index* parameter.
		//		This is the index object (map) to use to store an index of all the objects.
		// 		If you are using inter-message referencing, you must provide the same object for each call.
		// The *defaultId* parameter.
		//		This is the default id to use for the root object (if it doesn't define it's own id)
		//	The *idPrefix* parameter.
		//		This the prefix to use for the ids as they enter the index. This allows multiple tables
		// 		to use ids (that might otherwise collide) that enter the same global index.
		// 		idPrefix should be in the form "/Service/".  For example,
		//		if the idPrefix is "/Table/", and object is encountered {id:"4",...}, this would go in the
		//		index as "/Table/4".
		//	The *idAttribute* parameter.
		//		This indicates what property is the identity property. This defaults to "id"
		//	The *assignAbsoluteIds* parameter.
		//		This indicates that the resolveJson should assign absolute ids (__id) as the objects are being parsed.
		//
		// The *schemas* parameter
		//		This provides a map of schemas, from which prototypes can be retrieved
		// The *loader* parameter
		//		This is a function that is called added to the reference objects that can't be resolved (lazy objects)
		// return:
		//		An object, the result of the processing
		args = args || {};
		var idAttribute = args.idAttribute || 'id';
		var refAttribute = this.refAttribute;
		var idAsRef = args.idAsRef;
		var prefix = args.idPrefix || '';
		var assignAbsoluteIds = args.assignAbsoluteIds;
		var index = args.index || {}; // create an index if one doesn't exist
		var timeStamps = args.timeStamps;
		var ref,reWalk=[];
		var pathResolveRegex = /^(.*\/)?(\w+:\/\/)|[^\/\.]+\/\.\.\/|^.*\/(\/)/;
		var addProp = this._addProp;
		var F = function(){};
		function walk(it, stop, defaultId, needsPrefix, schema, defaultObject){
			// this walks the new graph, resolving references and making other changes
		 	var i, update, val, id = idAttribute in it ? it[idAttribute] : defaultId;
		 	if(idAttribute in it || ((id !== undefined) && needsPrefix)){
		 		id = (prefix + id).replace(pathResolveRegex,'$2$3');
		 	}
		 	var target = defaultObject || it;
			if(id !== undefined){ // if there is an id available...
				if(assignAbsoluteIds){
					it.__id = id;
				}
				if(args.schemas && (!(it instanceof Array)) && // won't try on arrays to do prototypes, plus it messes with queries
		 					(val = id.match(/^(.+\/)[^\.\[]*$/))){ // if it has a direct table id (no paths)
		 			schema = args.schemas[val[1]];
				}
				// if the id already exists in the system, we should use the existing object, and just
				// update it... as long as the object is compatible
				if(index[id] && ((it instanceof Array) == (index[id] instanceof Array))){
					target = index[id];
					delete target.$ref; // remove this artifact
					delete target._loadObject;
					update = true;
				}else{
				 	var proto = schema && schema.prototype; // and if has a prototype
					if(proto){
						// if the schema defines a prototype, that needs to be the prototype of the object
						F.prototype = proto;
						target = new F();
					}
				}
				index[id] = target; // add the prefix, set _id, and index it
				if(timeStamps){
					timeStamps[id] = args.time;
				}
			}
			while(schema){
				var properties = schema.properties;
				if(properties){
					for(i in it){
						var propertyDefinition = properties[i];
						if(propertyDefinition && propertyDefinition.format == 'date-time' && typeof it[i] == 'string'){
							it[i] = dojo.date.stamp.fromISOString(it[i]);
						}
					}
				}
				schema = schema["extends"];
			}
			var length = it.length;
			for(i in it){
				if(i==length){
					break;
				}
				if(it.hasOwnProperty(i)){
					val=it[i];
					if((typeof val =='object') && val && !(val instanceof Date) && i != '__parent'){
						ref=val[refAttribute] || (idAsRef && val[idAttribute]);
						if(!ref || !val.__parent){
							if(it != reWalk){
								val.__parent = target;
							}
						}
						if(ref){ // a reference was found
							// make sure it is a safe reference
							delete it[i];// remove the property so it doesn't resolve to itself in the case of id.propertyName lazy values
							var path = ref.toString().replace(/(#)([^\.\[])/,'$1.$2').match(/(^([^\[]*\/)?[^#\.\[]*)#?([\.\[].*)?/); // divide along the path
							if(index[(prefix + ref).replace(pathResolveRegex,'$2$3')]){
								ref = index[(prefix + ref).replace(pathResolveRegex,'$2$3')];
							}else if((ref = (path[1]=='$' || path[1]=='this' || path[1]=='') ? root : index[(prefix + path[1]).replace(pathResolveRegex,'$2$3')])){  // a $ indicates to start with the root, otherwise start with an id
								// if there is a path, we will iterate through the path references
								if(path[3]){
									path[3].replace(/(\[([^\]]+)\])|(\.?([^\.\[]+))/g,function(t,a,b,c,d){
										ref = ref && ref[b ? b.replace(/[\"\'\\]/,'') : d];
									});
								}
							}
							if(ref){
								val = ref;
							}else{
								// otherwise, no starting point was found (id not found), if stop is set, it does not exist, we have
								// unloaded reference, if stop is not set, it may be in a part of the graph not walked yet,
								// we will wait for the second loop
								if(!stop){
									var rewalking;
									if(!rewalking){
										reWalk.push(target); // we need to rewalk it to resolve references
									}
									rewalking = true; // we only want to add it once
									val = walk(val, false, val[refAttribute], true, propertyDefinition);
									// create a lazy loaded object
									val._loadObject = args.loader;
								}
							}
						}else{
							if(!stop){ // if we are in stop, that means we are in the second loop, and we only need to check this current one,
								// further walking may lead down circular loops
								val = walk(
									val,
									reWalk==it,
									id === undefined ? undefined : addProp(id, i), // the default id to use
									false,
									propertyDefinition,
									// if we have an existing object child, we want to
									// maintain it's identity, so we pass it as the default object
									target != it && typeof target[i] == 'object' && target[i]
								);
							}
						}
					}
					it[i] = val;
					if(target!=it && !target.__isDirty){// do updates if we are updating an existing object and it's not dirty
						var old = target[i];
						target[i] = val; // only update if it changed
						if(update && val !== old && // see if it is different
								!target._loadObject && // no updates if we are just lazy loading
								!(i.charAt(0) == '_' && i.charAt(1) == '_') && i != "$ref" &&
								!(val instanceof Date && old instanceof Date && val.getTime() == old.getTime()) && // make sure it isn't an identical date
								!(typeof val == 'function' && typeof old == 'function' && val.toString() == old.toString()) && // make sure it isn't an indentical function
								index.onUpdate){
							index.onUpdate(target,i,old,val); // call the listener for each update
						}
					}
				}
			}
	
			if(update && (idAttribute in it || target instanceof Array)){
				// this means we are updating with a full representation of the object, we need to remove deleted
				for(i in target){
					if(!target.__isDirty && target.hasOwnProperty(i) && !it.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && !(target instanceof Array && isNaN(i))){
						if(index.onUpdate && i != "_loadObject" && i != "_idAttr"){
							index.onUpdate(target,i,target[i],undefined); // call the listener for each update
						}
						delete target[i];
						while(target instanceof Array && target.length && target[target.length-1] === undefined){
							// shorten the target if necessary
							target.length--;
						}
					}
				}
			}else{
				if(index.onLoad){
					index.onLoad(target);
				}
			}
			return target;
		}
		if(root && typeof root == 'object'){
			root = walk(root,false,args.defaultId, true); // do the main walk through
			walk(reWalk,false); // re walk any parts that were not able to resolve references on the first round
		}
		return root;
	},


	fromJson: function(/*String*/ str,/*Object?*/ args){
	// summary:
	// 		evaluates the passed string-form of a JSON object.
	//
	// str:
	//		a string literal of a JSON item, for instance:
	//			'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'
	// args: See resolveJson
	//
	// return:
	//		An object, the result of the evaluation
		function ref(target){ // support call styles references as well
			var refObject = {};
			refObject[this.refAttribute] = target;
			return refObject;
		}
		try{
			var root = eval('(' + str + ')'); // do the eval
		}catch(e){
			throw new SyntaxError("Invalid JSON string: " + e.message + " parsing: "+ str);
		}
		if(root){
			return this.resolveJson(root, args);
		}
		return root;
	},
	
	toJson: function(/*Object*/ it, /*Boolean?*/ prettyPrint, /*Object?*/ idPrefix, /*Object?*/ indexSubObjects){
		// summary:
		//		Create a JSON serialization of an object.
		//		This has support for referencing, including circular references, duplicate references, and out-of-message references
		// 		id and path-based referencing is supported as well and is based on http://www.json.com/2007/10/19/json-referencing-proposal-and-library/.
		//
		// it:
		//		an object to be serialized.
		//
		// prettyPrint:
		//		if true, we indent objects and arrays to make the output prettier.
		//		The variable dojo.toJsonIndentStr is used as the indent string
		//		-- to use something other than the default (tab),
		//		change that variable before calling dojo.toJson().
		//
		// idPrefix: The prefix that has been used for the absolute ids
		//
		// return:
		//		a String representing the serialized version of the passed object.
		var useRefs = this._useRefs;
		var addProp = this._addProp;
		var refAttribute = this.refAttribute;
		idPrefix = idPrefix || ''; // the id prefix for this context
		var paths={};
		var generated = {};
		function serialize(it,path,_indentStr){
			if(typeof it == 'object' && it){
				var value;
				if(it instanceof Date){ // properly serialize dates
					return '"' + dojo.date.stamp.toISOString(it,{zulu:true}) + '"';
				}
				var id = it.__id;
				if(id){ // we found an identifiable object, we will just serialize a reference to it... unless it is the root
					if(path != '#' && ((useRefs && !id.match(/#/)) || paths[id])){
						var ref = id;
						if(id.charAt(0)!='#'){
							if(it.__clientId == id){
								ref = "cid:" + id;
							}else if(id.substring(0, idPrefix.length) == idPrefix){ // see if the reference is in the current context
								// a reference with a prefix matching the current context, the prefix should be removed
								ref = id.substring(idPrefix.length);
							}else{
								// a reference to a different context, assume relative url based referencing
								ref = id;
							}
						}
						var refObject = {};
						refObject[refAttribute] = ref;
						return serialize(refObject,'#');
					}
					path = id;
				}else{
					it.__id = path; // we will create path ids for other objects in case they are circular
					generated[path] = it;
				}
				paths[path] = it;// save it here so they can be deleted at the end
				_indentStr = _indentStr || "";
				var nextIndent = prettyPrint ? _indentStr + dojo.toJsonIndentStr : "";
				var newLine = prettyPrint ? "\n" : "";
				var sep = prettyPrint ? " " : "";
	
				if(it instanceof Array){
					var res = dojo.map(it, function(obj,i){
						var val = serialize(obj, addProp(path, i), nextIndent);
						if(typeof val != "string"){
							val = "undefined";
						}
						return newLine + nextIndent + val;
					});
					return "[" + res.join("," + sep) + newLine + _indentStr + "]";
				}
	
				var output = [];
				for(var i in it){
					if(it.hasOwnProperty(i)){
						var keyStr;
						if(typeof i == "number"){
							keyStr = '"' + i + '"';
						}else if(typeof i == "string" && (i.charAt(0) != '_' || i.charAt(1) != '_')){
							// we don't serialize our internal properties __id and __clientId
							keyStr = dojo._escapeString(i);
						}else{
							// skip non-string or number keys
							continue;
						}
						var val = serialize(it[i],addProp(path, i),nextIndent);
						if(typeof val != "string"){
							// skip non-serializable values
							continue;
						}
						output.push(newLine + nextIndent + keyStr + ":" + sep + val);
					}
				}
				return "{" + output.join("," + sep) + newLine + _indentStr + "}";
			}else if(typeof it == "function" && dojox.json.ref.serializeFunctions){
				return it.toString();
			}
	
			return dojo.toJson(it); // use the default serializer for primitives
		}
		var json = serialize(it,'#','');
		if(!indexSubObjects){
			for(var i in generated)  {// cleanup the temporary path-generated ids
				delete generated[i].__id;
			}
		}
		return json;
	},
	_addProp: function(id, prop){
		return id + (id.match(/#/) ? id.length == 1 ? '' : '.' : '#') + prop;
	},
	//	refAttribute: String
	//		This indicates what property is the reference property. This acts like the idAttribute
	// 		except that this is used to indicate the current object is a reference or only partially
	// 		loaded. This defaults to "$ref".
	refAttribute: "$ref",
	_useRefs: false,
	serializeFunctions: false
}

}

if(!dojo._hasResource["dojox.rpc.Rest"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.rpc.Rest"] = true;
dojo.provide("dojox.rpc.Rest");

// Note: This doesn't require dojox.rpc.Service, and if you want it you must require it
// yourself, and you must load it prior to dojox.rpc.Rest.

// summary:
// 		This provides a HTTP REST service with full range REST verbs include PUT,POST, and DELETE.
// description:
// 		A normal GET query is done by using the service directly:
// 		| var restService = dojox.rpc.Rest("Project");
// 		| restService("4");
//		This will do a GET for the URL "/Project/4".
//		| restService.put("4","new content");
//		This will do a PUT to the URL "/Project/4" with the content of "new content".
//		You can also use the SMD service to generate a REST service:
// 		| var services = dojox.rpc.Service({services: {myRestService: {transport: "REST",...
// 		| services.myRestService("parameters");
//
// 		The modifying methods can be called as sub-methods of the rest service method like:
//  	| services.myRestService.put("parameters","data to put in resource");
//  	| services.myRestService.post("parameters","data to post to the resource");
//  	| services.myRestService['delete']("parameters");
	if(dojox.rpc && dojox.rpc.transportRegistry){
		// register it as an RPC service if the registry is available
		dojox.rpc.transportRegistry.register(
			"REST",
			function(str){return str == "REST";},
			{
				getExecutor : function(func,method,svc){
					return new dojox.rpc.Rest(
						method.name,
						(method.contentType||svc._smd.contentType||"").match(/json|javascript/), // isJson
						null,
						function(id, args){
							var request = svc._getRequest(method,[id]);
							request.url= request.target + (request.data ? '?'+  request.data : '');
							if(args && (args.start >= 0 || args.count >= 0)){
								request.headers = request.headers || {};
								request.headers.Range = "items=" + (args.start || '0') + '-' +
									(("count" in args && args.count != Infinity) ?
										(args.count + (args.start || 0) - 1) : '');
							}
							return request;
						}
					);
				}
			}
		);
	}
	var drr;

	function index(deferred, service, range, id){
		deferred.addCallback(function(result){
			if(deferred.ioArgs.xhr && range){
					// try to record the total number of items from the range header
					range = deferred.ioArgs.xhr.getResponseHeader("Content-Range");
					deferred.fullLength = range && (range=range.match(/\/(.*)/)) && parseInt(range[1]);
			}
			return result;
		});
		return deferred;
	}
	drr = dojox.rpc.Rest = function(/*String*/path, /*Boolean?*/isJson, /*Object?*/schema, /*Function?*/getRequest){
		// summary:
		//		Creates a REST service using the provided path.
		var service;
		// it should be in the form /Table/
		service = function(id, args){
			return drr._get(service, id, args);
		};
		service.isJson = isJson;
		service._schema = schema;
		// cache:
		//		This is an object that provides indexing service
		// 		This can be overriden to take advantage of more complex referencing/indexing
		// 		schemes
		service.cache = {
			serialize: isJson ? ((dojox.json && dojox.json.ref) || dojo).toJson : function(result){
				return result;
			}
		};
		// the default XHR args creator:
		service._getRequest = getRequest || function(id, args){
			if(dojo.isObject(id)){
				id = dojo.objectToQuery(id);
				id = id ? "?" + id: "";
			}
			if(args && args.sort && !args.queryStr){
				id += (id ? "&" : "?") + "sort("
				for(var i = 0; i<args.sort.length; i++){
					var sort = args.sort[i];
					id += (i > 0 ? "," : "") + (sort.descending ? '-' : '+') + encodeURIComponent(sort.attribute);
				}
				id += ")";
			}
			var request = {
				url: path + (id == null ? "" : id),
				handleAs: isJson ? 'json' : 'text',
				contentType: isJson ? 'application/json' : 'text/plain',
				sync: dojox.rpc._sync,
				headers: {
					Accept: isJson ? 'application/json,application/javascript' : '*/*'
				}
			};
			if(args && (args.start >= 0 || args.count >= 0)){
				request.headers.Range = "items=" + (args.start || '0') + '-' +
					(("count" in args && args.count != Infinity) ?
						(args.count + (args.start || 0) - 1) : '');
			}
			dojox.rpc._sync = false;
			return request;
		};
		// each calls the event handler
		function makeRest(name){
			service[name] = function(id,content){
				return drr._change(name,service,id,content); // the last parameter is to let the OfflineRest know where to store the item
			};
		}
		makeRest('put');
		makeRest('post');
		makeRest('delete');
		// record the REST services for later lookup
		service.servicePath = path;
		return service;
	};

	drr._index={};// the map of all indexed objects that have gone through REST processing
	drr._timeStamps={};
	// these do the actual requests
	drr._change = function(method,service,id,content){
		// this is called to actually do the put, post, and delete
		var request = service._getRequest(id);
		request[method+"Data"] = content;
		return index(dojo.xhr(method.toUpperCase(),request,true),service);
	};

	drr._get= function(service,id, args){
		args = args || {};
		// this is called to actually do the get
		return index(dojo.xhrGet(service._getRequest(id, args)), service, (args.start >= 0 || args.count >= 0), id);
	};

}

if(!dojo._hasResource["dojox.rpc.JsonRest"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.rpc.JsonRest"] = true;
dojo.provide("dojox.rpc.JsonRest");



	var dirtyObjects = [];
	var Rest = dojox.rpc.Rest;
	var jr;
	function resolveJson(service, deferred, value, defaultId){
		var timeStamp = deferred.ioArgs && deferred.ioArgs.xhr && deferred.ioArgs.xhr.getResponseHeader("Last-Modified");
		if(timeStamp && Rest._timeStamps){
			Rest._timeStamps[defaultId] = timeStamp;
		}
		var hrefProperty = service._schema && service._schema.hrefProperty;
		if(hrefProperty){
			dojox.json.ref.refAttribute = hrefProperty;
		}
		value = value && dojox.json.ref.resolveJson(value, {
			defaultId: defaultId,
			index: Rest._index,
			timeStamps: timeStamp && Rest._timeStamps,
			time: timeStamp,
			idPrefix: service.servicePath.replace(/[^\/]*$/,''),
			idAttribute: jr.getIdAttribute(service),
			schemas: jr.schemas,
			loader:	jr._loader,
			idAsRef: service.idAsRef,
			assignAbsoluteIds: true
		});
		dojox.json.ref.refAttribute  = "$ref";
		return value;
	}
	jr = dojox.rpc.JsonRest={
		serviceClass: dojox.rpc.Rest,
		conflictDateHeader: "If-Unmodified-Since",
		commit: function(kwArgs){
			// summary:
			//		Saves the dirty data using REST Ajax methods

			kwArgs = kwArgs || {};
			var actions = [];
			var alreadyRecorded = {};
			var savingObjects = [];
			for(var i = 0; i < dirtyObjects.length; i++){
				var dirty = dirtyObjects[i];
				var object = dirty.object;
				var old = dirty.old;
				var append = false;
				if(!(kwArgs.service && (object || old) &&
						(object || old).__id.indexOf(kwArgs.service.servicePath)) && dirty.save){
					delete object.__isDirty;
					if(object){
						if(old){
							// changed object
							var pathParts;
							if((pathParts = object.__id.match(/(.*)#.*/))){ // it is a path reference
								// this means it is a sub object, we must go to the parent object and save it
								object = Rest._index[pathParts[1]];
							}
							if(!(object.__id in alreadyRecorded)){// if it has already been saved, we don't want to repeat it
								// record that we are saving
								alreadyRecorded[object.__id] = object;
								if(kwArgs.incrementalUpdates
									&& !pathParts){ // I haven't figured out how we would do incremental updates on sub-objects yet
									// make an incremental update using a POST
									var incremental = (typeof kwArgs.incrementalUpdates == 'function' ?
										kwArgs.incrementalUpdates : function(){
											incremental = {};
											for(var j in object){
												if(object.hasOwnProperty(j)){
													if(object[j] !== old[j]){
														incremental[j] = object[j];
													}
												}else if(old.hasOwnProperty(j)){
													// we can't use incremental updates to remove properties
													return null;
												}
											}
											return incremental;
										})(object, old);
								}
								
								if(incremental){
									actions.push({method:"post",target:object, content: incremental});
								}
								else{
									actions.push({method:"put",target:object,content:object});
								}
							}
						}else{
							// new object
							var service = jr.getServiceAndId(object.__id).service;
							var idAttribute = jr.getIdAttribute(service);
							if((idAttribute in object) && !kwArgs.alwaysPostNewItems){
								// if the id attribute is specified, then we should know the location
								actions.push({method:"put",target:object, content:object});
							}else{
								actions.push({method:"post",target:{__id:service.servicePath},
														content:object});
							}
						}
					}else if(old){
						// deleted object
						actions.push({method:"delete",target:old});
					}//else{ this would happen if an object is created and then deleted, don't do anything
					savingObjects.push(dirty);
					dirtyObjects.splice(i--,1);
				}
			}
			dojo.connect(kwArgs,"onError",function(){
				if(kwArgs.revertOnError !== false){
					var postCommitDirtyObjects = dirtyObjects;
					dirtyObjects = savingObjects;
					var numDirty = 0; // make sure this does't do anything if it is called again
					jr.revert(); // revert if there was an error
					dirtyObjects = postCommitDirtyObjects;
				}
				else{
					dirtyObjects = dirtyObjects.concat(savingObjects);
				}
			});
			jr.sendToServer(actions, kwArgs);
			return actions;
		},
		sendToServer: function(actions, kwArgs){
			var xhrSendId;
			var plainXhr = dojo.xhr;
			var left = actions.length;// this is how many changes are remaining to be received from the server
			var i, contentLocation;
			var timeStamp;
			var conflictDateHeader = this.conflictDateHeader;
			// add headers for extra information
			dojo.xhr = function(method,args){
				// keep the transaction open as we send requests
				args.headers = args.headers || {};
				// the last one should commit the transaction
				args.headers['Transaction'] = actions.length - 1 == i ? "commit" : "open";
				if(conflictDateHeader && timeStamp){
					args.headers[conflictDateHeader] = timeStamp;
				}
				if(contentLocation){
					args.headers['Content-ID'] = '<' + contentLocation + '>';
				}
				return plainXhr.apply(dojo,arguments);
			};
			for(i =0; i < actions.length;i++){ // iterate through the actions to execute
				var action = actions[i];
				dojox.rpc.JsonRest._contentId = action.content && action.content.__id; // this is used by OfflineRest
				var isPost = action.method == 'post';
				timeStamp = action.method == 'put' && Rest._timeStamps[action.content.__id];
				if(timeStamp){
					// update it now
					Rest._timeStamps[action.content.__id] = (new Date()) + '';
				}
				// send the content location to the server
				contentLocation = isPost && dojox.rpc.JsonRest._contentId;
				var serviceAndId = jr.getServiceAndId(action.target.__id);
				var service = serviceAndId.service;
				var dfd = action.deferred = service[action.method](
									serviceAndId.id.replace(/#/,''), // if we are using references, we need eliminate #
									dojox.json.ref.toJson(action.content, false, service.servicePath, true)
								);
				(function(object, dfd, service){
					dfd.addCallback(function(value){
						try{
							// Implements id assignment per the HTTP specification
							var newId = dfd.ioArgs.xhr && dfd.ioArgs.xhr.getResponseHeader("Location");
							//TODO: match URLs if the servicePath is relative...
							if(newId){
								// if the path starts in the middle of an absolute URL for Location, we will use the just the path part
								var startIndex = newId.match(/(^\w+:\/\/)/) && newId.indexOf(service.servicePath);
								newId = startIndex > 0 ? newId.substring(startIndex) : (service.servicePath + newId).
										// now do simple relative URL resolution in case of a relative URL.
										replace(/^(.*\/)?(\w+:\/\/)|[^\/\.]+\/\.\.\/|^.*\/(\/)/,'$2$3');
								object.__id = newId;
								Rest._index[newId] = object;
							}
							value = resolveJson(service, dfd, value, object && object.__id);
						}catch(e){}
						if(!(--left)){
							if(kwArgs.onComplete){
								kwArgs.onComplete.call(kwArgs.scope, actions);
							}
						}
						return value;
					});
				})(action.content, dfd, service);
								
				dfd.addErrback(function(value){
					
					// on an error we want to revert, first we want to separate any changes that were made since the commit
					left = -1; // first make sure that success isn't called
					kwArgs.onError.call(kwArgs.scope, value);
				});
			}
			// revert back to the normal XHR handler
			dojo.xhr = plainXhr;
			
		},
		getDirtyObjects: function(){
			return dirtyObjects;
		},
		revert: function(service){
			// summary:
			//		Reverts all the changes made to JSON/REST data
			for(var i = dirtyObjects.length; i > 0;){
				i--;
				var dirty = dirtyObjects[i];
				var object = dirty.object;
				var old = dirty.old;
				var store = dojox.data._getStoreForItem(object || old);
				
				if(!(service && (object || old) &&
					(object || old).__id.indexOf(service.servicePath))){
					// if we are in the specified store or if this is a global revert
					if(object && old){
						// changed
						for(var j in old){
							if(old.hasOwnProperty(j) && object[j] !== old[j]){
								if(store){
									store.onSet(object, j, object[j], old[j]);
								}
								object[j] = old[j];
							}
						}
						for(j in object){
							if(!old.hasOwnProperty(j)){
								if(store){
									store.onSet(object, j, object[j]);
								}
								delete object[j];
							}
						}
					}else if(!old){
						// was an addition, remove it
						if(store){
							store.onDelete(object);
						}
					}else{
						// was a deletion, we will add it back
						if(store){
							store.onNew(old);
						}
					}
					delete (object || old).__isDirty;
					dirtyObjects.splice(i, 1);
				}
			}
		},
		changing: function(object,_deleting){
			// summary:
			//		adds an object to the list of dirty objects.  This object
			//		contains a reference to the object itself as well as a
			//		cloned and trimmed version of old object for use with
			//		revert.
			if(!object.__id){
				return;
			}
			object.__isDirty = true;
			//if an object is already in the list of dirty objects, don't add it again
			//or it will overwrite the premodification data set.
			for(var i=0; i<dirtyObjects.length; i++){
				var dirty = dirtyObjects[i];
				if(object==dirty.object){
					if(_deleting){
						// we are deleting, no object is an indicator of deletiong
						dirty.object = false;
						if(!this._saveNotNeeded){
							dirty.save = true;
						}
					}
					return;
				}
			}
			var old = object instanceof Array ? [] : {};
			for(i in object){
				if(object.hasOwnProperty(i)){
					old[i] = object[i];
				}
			}
			dirtyObjects.push({object: !_deleting && object, old: old, save: !this._saveNotNeeded});
		},
		deleteObject: function(object){
			// summary:
			//		deletes an object
			//	object:
			//  	object to delete
			this.changing(object,true);
		},
		getConstructor: function(/*Function|String*/service, schema){
			// summary:
			// 		Creates or gets a constructor for objects from this service
			if(typeof service == 'string'){
				var servicePath = service;
				service = new dojox.rpc.Rest(service,true);
				this.registerService(service, servicePath, schema);
			}
			if(service._constructor){
				return service._constructor;
			}
			service._constructor = function(data){
				// summary:
				//		creates a new object for this table
				//
				//	data:
				//		object to mixed in
				var self = this;
				var args = arguments;
				var properties;
				var initializeCalled;
				function addDefaults(schema){
					if(schema){
						addDefaults(schema['extends']);
						properties = schema.properties;
						for(var i in properties){
							var propDef = properties[i];
							if(propDef && (typeof propDef == 'object') && ("default" in propDef)){
								self[i] = propDef["default"];
							}
						}
					}
					if(schema && schema.prototype && schema.prototype.initialize){
						initializeCalled = true;
						schema.prototype.initialize.apply(self, args);
					}
				}
				addDefaults(service._schema);
				if(!initializeCalled && data && typeof data == 'object'){
					dojo.mixin(self,data);
				}
				var idAttribute = jr.getIdAttribute(service);
				Rest._index[this.__id = this.__clientId =
						service.servicePath + (this[idAttribute] ||
							Math.random().toString(16).substring(2,14) + '@' + ((dojox.rpc.Client && dojox.rpc.Client.clientId) || "client"))] = this;
				if(dojox.json.schema && properties){
					dojox.json.schema.mustBeValid(dojox.json.schema.validate(this, service._schema));
				}
				dirtyObjects.push({object:this, save: true});
			};
			return dojo.mixin(service._constructor, service._schema, {load:service});
		},
		fetch: function(absoluteId){
			// summary:
			//		Fetches a resource by an absolute path/id and returns a dojo.Deferred.
			var serviceAndId = jr.getServiceAndId(absoluteId);
			return this.byId(serviceAndId.service,serviceAndId.id);
		},
		getIdAttribute: function(service){
			// summary:
			//		Return the ids attribute used by this service (based on it's schema).
			//		Defaults to "id", if not other id is defined
			var schema = service._schema;
			var idAttr;
			if(schema){
				if(!(idAttr = schema._idAttr)){
					for(var i in schema.properties){
						if(schema.properties[i].identity || (schema.properties[i].link == "self")){
							schema._idAttr = idAttr = i;
						}
					}
				}
			}
			return idAttr || 'id';
		},
		getServiceAndId: function(/*String*/absoluteId){
			// summary:
			//		Returns the REST service and the local id for the given absolute id. The result
			// 		is returned as an object with a service property and an id property
			//	absoluteId:
			//		This is the absolute id of the object
			var serviceName = '';
			
			for(var service in jr.services){
				if((absoluteId.substring(0, service.length) == service) && (service.length >= serviceName.length)){
					serviceName = service;
				}
			}
			if (serviceName){
				return {service: jr.services[serviceName], id:absoluteId.substring(serviceName.length)};
			}
			var parts = absoluteId.match(/^(.*\/)([^\/]*)$/);
			return {service: new jr.serviceClass(parts[1], true), id:parts[2]};
		},
		services:{},
		schemas:{},
		registerService: function(/*Function*/ service, /*String*/ servicePath, /*Object?*/ schema){
			//	summary:
			//		Registers a service for as a JsonRest service, mapping it to a path and schema
			//	service:
			//		This is the service to register
			//	servicePath:
			//		This is the path that is used for all the ids for the objects returned by service
			//	schema:
			//		This is a JSON Schema object to associate with objects returned by this service
			servicePath = service.servicePath = servicePath || service.servicePath;
			service._schema = jr.schemas[servicePath] = schema || service._schema || {};
			jr.services[servicePath] = service;
		},
		byId: function(service, id){
			// if caching is allowed, we look in the cache for the result
			var deferred, result = Rest._index[(service.servicePath || '') + id];
			if(result && !result._loadObject){// cache hit
				deferred = new dojo.Deferred();
				deferred.callback(result);
				return deferred;
			}
			return this.query(service, id);
		},
		query: function(service, id, args){
			var deferred = service(id, args);
			
			deferred.addCallback(function(result){
				if(result.nodeType && result.cloneNode){
					// return immediately if it is an XML document
					return result;
				}
				return resolveJson(service, deferred, result, typeof id != 'string' || (args && (args.start || args.count)) ? undefined: id);
			});
			return deferred;
		},
		_loader: function(callback){
			// load a lazy object
			var serviceAndId = jr.getServiceAndId(this.__id);
			var self = this;
			jr.query(serviceAndId.service, serviceAndId.id).addBoth(function(result){
				// if they are the same this means an object was loaded, otherwise it
				// might be a primitive that was loaded or maybe an error
				if(result == self){
					// we can clear the flag, so it is a loaded object
					delete result.$ref;
					delete result._loadObject;
				}else{
					// it is probably a primitive value, we can't change the identity of an object to
					//	the loaded value, so we will keep it lazy, but define the lazy loader to always
					//	return the loaded value
					self._loadObject = function(callback){
						callback(result);
					};
				}
				callback(result);
			});
		},
		isDirty: function(item){
			// summary
			//		returns true if the item is marked as dirty or true if there are any dirty items
			if(!item){
				return !!dirtyObjects.length;
			}
			return item.__isDirty;
		}
		
	};

}

if(!dojo._hasResource["dojox.data.ServiceStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.ServiceStore"] = true;
dojo.provide("dojox.data.ServiceStore");


// note that dojox.rpc.Service is not required, you can create your own services

// A ServiceStore is a readonly data store that provides a data.data interface to an RPC service.
// var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
// var serviceStore = new dojox.data.ServiceStore({service:myServices.ServiceStore});
//
// The ServiceStore also supports lazy loading. References can be made to objects that have not been loaded.
//	For example if a service returned:
// {"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
//
// And this object has accessed using the dojo.data API:
// var obj = serviceStore.getValue(myObject,"lazyLoadedObject");
// The object would automatically be requested from the server (with an object id of "obj2").
//

dojo.declare("dojox.data.ServiceStore",
	// ClientFilter is intentionally not required, ServiceStore does not need it, and is more
	// lightweight without it, but if it is provided, the ServiceStore will use it.
	dojox.data.ClientFilter||null,{
		service: null,
		constructor: function(options){
			//summary:
			//		ServiceStore constructor, instantiate a new ServiceStore
			// 		A ServiceStore can be configured from a JSON Schema. Queries are just
			// 		passed through to the underlying services
			//
			// options:
			// 		Keyword arguments
			// The *schema* parameter
			//		This is a schema object for this store. This should be JSON Schema format.
			//
			// The *service* parameter
			// 		This is the service object that is used to retrieve lazy data and save results
			// 		The function should be directly callable with a single parameter of an object id to be loaded
			//
			// The *idAttribute* parameter
			//		Defaults to 'id'. The name of the attribute that holds an objects id.
			//		This can be a preexisting id provided by the server.
			//		If an ID isn't already provided when an object
			//		is fetched or added to the store, the autoIdentity system
			//		will generate an id for it and add it to the index.
			//
			// The *estimateCountFactor* parameter
			// 		This parameter is used by the ServiceStore to estimate the total count. When
			//		paging is indicated in a fetch and the response includes the full number of items
			//	 	requested by the fetch's count parameter, then the total count will be estimated
			//		to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
			//		does not support paging, and the response is the full set of items, where the
			// 		total count is equal to the numer of items returned. If the server does support
			//		paging, an estimateCountFactor of 2 is a good value for estimating the total count
			//		It is also possible to override _processResults if the server can provide an exact
			// 		total count.
			//
			// The *syncMode* parameter
			//		Setting this to true will set the store to using synchronous calls by default.
			//		Sync calls return their data immediately from the calling function, so
			//		callbacks are unnecessary. This will only work with a synchronous capable service.
			//
			// description:
			//		ServiceStore can do client side caching and result set updating if
			// 		dojox.data.ClientFilter is loaded. Do this add:
			//	|	
			//		prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
			//		To utilize client side filtering with a subclass, you can break queries into
			//		client side and server side components by putting client side actions in
			//		clientFilter property in fetch calls. For example you could override fetch:
			//	|	fetch: function(args){
				//	|		// do the sorting and paging on the client side
	 			//	|		args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
	 			//	|		// args.query will be passed to the service object for the server side handling
	 			//	|		return this.inherited(arguments);
			//	|	}
			//		When extending this class, if you would like to create lazy objects, you can follow
			//		the example from dojox.data.tests.stores.ServiceStore:
			// |	var lazyItem = {
			// |		_loadObject: function(callback){
			// |			this.name="loaded";
			// |			delete this._loadObject;
			// |			callback(this);
			// |		}
			// |	};
			//setup a byId alias to the api call
			this.byId=this.fetchItemByIdentity;
			this._index = {};
			// if the advanced json parser is enabled, we can pass through object updates as onSet events
			if(options){
				dojo.mixin(this,options);
			}
			// We supply a default idAttribute for parser driven construction, but if no id attribute
			//	is supplied, it should be null so that auto identification takes place properly
			this.idAttribute = (options && options.idAttribute) || (this.schema && this.schema._idAttr);
		},
		schema: null,
		idAttribute: "id",
		labelAttribute: "label",
		syncMode: false,
		estimateCountFactor: 1,
		getSchema: function(){
			return this.schema;
		},

		loadLazyValues:true,

		getValue: function(/*Object*/ item, /*String*/property, /*value?*/defaultValue){
			// summary:
			//	Gets the value of an item's 'property'
			//
			//	item:
			//		The item to get the value from
			//	property:
			//		property to look up value for
			//	defaultValue:
			//		the default value

			var value = item[property];
			return value || // return the plain value since it was found;
						(property in item ? // a truthy value was not found, see if we actually have it
							value : // we do, so we can return it
							item._loadObject ? // property was not found, maybe because the item is not loaded, we will try to load it synchronously so we can get the property
								(dojox.rpc._sync = true) && arguments.callee.call(this,dojox.data.ServiceStore.prototype.loadItem({item:item}) || {}, property, defaultValue) : // load the item and run getValue again
								defaultValue);// not in item -> return default value
		},
		getValues: function(item, property){
			// summary:
			//		Gets the value of an item's 'property' and returns
			//		it.	If this value is an array it is just returned,
			//		if not, the value is added to an array and that is returned.
			//
			//	item: /* object */
			//	property: /* string */
			//		property to look up value for

			var val = this.getValue(item,property);
			if(val instanceof Array){
				return val;
			}
			if(!this.isItemLoaded(val)){
				dojox.rpc._sync = true;
				val = this.loadItem({item:val});
			}
			return val instanceof Array ? val : val === undefined ? [] : [val];
		},

		getAttributes: function(item){
			// summary:
			//	Gets the available attributes of an item's 'property' and returns
			//	it as an array.
			//
			//	item: /* object */

			var res = [];
			for(var i in item){
				if(item.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_')){
					res.push(i);
				}
			}
			return res;
		},

		hasAttribute: function(item,attribute){
			// summary:
			//		Checks to see if item has attribute
			//
			//	item: /* object */
			//	attribute: /* string */
			return attribute in item;
		},

		containsValue: function(item, attribute, value){
			// summary:
			//		Checks to see if 'item' has 'value' at 'attribute'
			//
			//	item: /* object */
			//	attribute: /* string */
			//	value: /* anything */
			return dojo.indexOf(this.getValues(item,attribute),value) > -1;
		},


		isItem: function(item){
			// summary:
			//		Checks to see if the argument is an item
			//
			//	item: /* object */
			//	attribute: /* string */

			// we have no way of determining if it belongs, we just have object returned from
			// 	service queries
			return (typeof item == 'object') && item && !(item instanceof Date);
		},

		isItemLoaded: function(item){
			// summary:
			//		Checks to see if the item is loaded.
			//
			//		item: /* object */

			return item && !item._loadObject;
		},

		loadItem: function(args){
			// summary:
			// 		Loads an item and calls the callback handler. Note, that this will call the callback
			// 		handler even if the item is loaded. Consequently, you can use loadItem to ensure
			// 		that an item is loaded is situations when the item may or may not be loaded yet.
			// 		If you access a value directly through property access, you can use this to load
			// 		a lazy value as well (doesn't need to be an item).
			//
			//	example:
			//		store.loadItem({
			//			item: item, // this item may or may not be loaded
			//			onItem: function(item){
			// 				// do something with the item
			//			}
			//		});

			var item;
			if(args.item._loadObject){
				args.item._loadObject(function(result){
					item = result; // in synchronous mode this can allow loadItem to return the value
					delete item._loadObject;
					var func = result instanceof Error ? args.onError : args.onItem;
					if(func){
						func.call(args.scope, result);
					}
				});
			}else if(args.onItem){
				// even if it is already loaded, we will use call the callback, this makes it easier to
				// use when it is not known if the item is loaded (you can always safely call loadItem).
				args.onItem.call(args.scope, args.item);
			}
			return item;
		},
		_currentId : 0,
		_processResults : function(results, deferred){
			// this should return an object with the items as an array and the total count of
			// items (maybe more than currently in the result set).
			// for example:
			//	| {totalCount:10, items: [{id:1},{id:2}]}

			// index the results, assigning ids as necessary

			if(results && typeof results == 'object'){
				var id = results.__id;
				if(!id){// if it hasn't been assigned yet
					if(this.idAttribute){
						// use the defined id if available
						id = results[this.idAttribute];
					}else{
						id = this._currentId++;
					}
					if(id !== undefined){
						var existingObj = this._index[id];
						if(existingObj){
							for(var j in existingObj){
								delete existingObj[j]; // clear it so we can mixin
							}
							results = dojo.mixin(existingObj,results);
						}
						results.__id = id;
						this._index[id] = results;
					}
				}
				for(var i in results){
					results[i] = this._processResults(results[i], deferred).items;
				}
				var count = results.length;
			}
			return {totalCount: deferred.request.count == count ? (deferred.request.start || 0) + count * this.estimateCountFactor : count, items: results};
		},
		close: function(request){
			return request && request.abort && request.abort();
		},
		fetch: function(args){
			// summary:
			//		See dojo.data.api.Read.fetch
			//
			// The *queryOptions.cache* parameter
			//		If true, indicates that the query result should be cached for future use. This is only available
			// 		if dojox.data.ClientFilter has been loaded before the ServiceStore
			//
			//	The *syncMode* parameter
			//		Indicates that the call should be fetch synchronously if possible (this is not always possible)
			//
			// The *clientFetch* parameter
			//		This is a fetch keyword argument for explicitly doing client side filtering, querying, and paging

			args = args || {};

			if("syncMode" in args ? args.syncMode : this.syncMode){
				dojox.rpc._sync = true;
			}
			var self = this;

			var scope = args.scope || self;
			var defResult = this.cachingFetch ? this.cachingFetch(args) : this._doQuery(args);
			defResult.request = args;
			defResult.addCallback(function(results){
				if(args.clientFetch){
					results = self.clientSideFetch({query:args.clientFetch,sort:args.sort,start:args.start,count:args.count},results);
				}
				var resultSet = self._processResults(results, defResult);
				results = args.results = resultSet.items;
				if(args.onBegin){
					args.onBegin.call(scope, resultSet.totalCount, args);
				}
				if(args.onItem){
					for(var i=0; i<results.length;i++){
						args.onItem.call(scope, results[i], args);
					}
				}
				if(args.onComplete){
					args.onComplete.call(scope, args.onItem ? null : results, args);
				}
				return results;
			});
			defResult.addErrback(args.onError && function(err){
				return args.onError.call(scope, err, args);
			});
			args.abort = function(){
				// abort the request
				defResult.cancel();
			};
			args.store = this;
			return args;
		},
		_doQuery: function(args){
			var query= typeof args.queryStr == 'string' ? args.queryStr : args.query;
			return this.service(query);
		},
		getFeatures: function(){
			// summary:
			// 		return the store feature set

			return {
				"dojo.data.api.Read": true,
				"dojo.data.api.Identity": true,
				"dojo.data.api.Schema": this.schema
			};
		},

		getLabel: function(item){
			// summary
			//		returns the label for an item. Just gets the "label" attribute.
			//
			return this.getValue(item,this.labelAttribute);
		},

		getLabelAttributes: function(item){
			// summary:
			//		returns an array of attributes that are used to create the label of an item
			return [this.labelAttribute];
		},

		//Identity API Support


		getIdentity: function(item){
			return item.__id;
		},

		getIdentityAttributes: function(item){
			// summary:
			//		returns the attributes which are used to make up the
			//		identity of an item.	Basically returns this.idAttribute

			return [this.idAttribute];
		},

		fetchItemByIdentity: function(args){
			// summary:
			//		fetch an item by its identity, by looking in our index of what we have loaded
			var item = this._index[(args._prefix || '') + args.identity];
			if(item){
				// the item exists in the index
				if(item._loadObject){
					// we have a handle on the item, but it isn't loaded yet, so we need to load it
					args.item = item;
					return this.loadItem(args);
				}else if(args.onItem){
					// it's already loaded, so we can immediately callback
					args.onItem.call(args.scope, item);
				}
			}else{
				// convert the different spellings
				return this.fetch({
						query: args.identity,
						onComplete: args.onItem,
						onError: args.onError,
						scope: args.scope
					}).results;
			}
			return item;
		}

	}
);

}

if(!dojo._hasResource["dojox.data.JsonRestStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.JsonRestStore"] = true;
dojo.provide("dojox.data.JsonRestStore");




dojo.declare("dojox.data.JsonRestStore",
	dojox.data.ServiceStore,
	{
		constructor: function(options){
			//summary:
			//		JsonRestStore is a Dojo Data store interface to JSON HTTP/REST web
			//		storage services that support read and write through GET, PUT, POST, and DELETE.
			// options:
			// 		Keyword arguments
			//
			// The *schema* parameter
			//		This is a schema object for this store. This should be JSON Schema format.
			//
			// The *service* parameter
			// 		This is the service object that is used to retrieve lazy data and save results
			// 		The function should be directly callable with a single parameter of an object id to be loaded
			// 		The function should also have the following methods:
			// 			put(id,value) - puts the value at the given id
			// 			post(id,value) - posts (appends) the value at the given id
			// 			delete(id) - deletes the value corresponding to the given id
			//		Note that it is critical that the service parses responses as JSON.
			//		If you are using dojox.rpc.Service, the easiest way to make sure this
			// 		happens is to make the responses have a content type of
			// 		application/json. If you are creating your own service, make sure you
			//		use handleAs: "json" with your XHR requests.
			//
			// The *target* parameter
			// 		This is the target URL for this Service store. This may be used in place
			// 		of a service parameter to connect directly to RESTful URL without
			// 		using a dojox.rpc.Service object.
			//
			// The *idAttribute* parameter
			//		Defaults to 'id'. The name of the attribute that holds an objects id.
			//		This can be a preexisting id provided by the server.
			//		If an ID isn't already provided when an object
			//		is fetched or added to the store, the autoIdentity system
			//		will generate an id for it and add it to the index.
			//
			// The *syncMode* parameter
			//		Setting this to true will set the store to using synchronous calls by default.
			//		Sync calls return their data immediately from the calling function, so
			//		callbacks are unnecessary
			//
			//	description:
			//		The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
			// 		When using a Rest store on a public network, it is important to implement proper security measures to
			//		control access to resources.
			//		On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
			//		GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
			// 			query (like /table/?name=foo).
			//		PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
			// 			provide the modified object
			//		POST - This should create a new object. The URL will correspond to the target store (like /table/)
			// 			and the body should be the properties of the new object. The server's response should include a
			// 			Location header that indicates the id of the newly created object. This id will be used for subsequent
			// 			PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
			//			the temporary randomly generated id used by client, and this location is used for subsequent
			// 			PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
			// 			to receiving a response from the server.
			// 		DELETE - This should delete an object by id.
			// 		These articles include more detailed information on using the JsonRestStore:
			//		http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
			//		http://blog.medryx.org/2008/07/24/jsonreststore-overview/
			//
			//	example:
			// 		A JsonRestStore takes a REST service or a URL and uses it the remote communication for a
			// 		read/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:
			// 	|	new JsonRestStore({target:"/MyData/"});
			//	example:
			// 		To use a JsonRestStore with a service, you should create a
			// 		service with a REST transport. This can be configured with an SMD:
			//	|	{
			//	|		services: {
			//	|			jsonRestStore: {
			//	|				transport: "REST",
			//	|				envelope: "URL",
			//	|				target: "store.php",
			//	|				contentType:"application/json",
			//	|				parameters: [
			//	|					{name: "location", type: "string", optional: true}
			//	|				]
			//	|			}
			//	|		}
			//	|	}
			// 		The SMD can then be used to create service, and the service can be passed to a JsonRestStore. For example:
			//	|	var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
			//	|	var jsonStore = new dojox.data.JsonRestStore({service:myServices.jsonRestStore});
			//	example:
			//		The JsonRestStore also supports lazy loading. References can be made to objects that have not been loaded.
			//		For example if a service returned:
			//	|	{"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
			// 		And this object has accessed using the dojo.data API:
			//	|	var obj = jsonStore.getValue(myObject,"lazyLoadedObject");
			//		The object would automatically be requested from the server (with an object id of "obj2").
			//

			dojo.connect(dojox.rpc.Rest._index,"onUpdate",this,function(obj,attrName,oldValue,newValue){
				var prefix = this.service.servicePath;
				if(!obj.__id){
					console.log("no id on updated object ", obj);
				}else if(obj.__id.substring(0,prefix.length) == prefix){
					this.onSet(obj,attrName,oldValue,newValue);
				}
			});
			this.idAttribute = this.idAttribute || 'id';// no options about it, we have to have identity

			if(typeof options.target == 'string'){
				options.target = options.target.match(/\/$/) || this.allowNoTrailingSlash ? options.target : (options.target + '/');
				if(!this.service){
					this.service = dojox.rpc.JsonRest.services[options.target] ||
							dojox.rpc.Rest(options.target, true);
					// create a default Rest service
				}
			}

			dojox.rpc.JsonRest.registerService(this.service, options.target, this.schema);
			this.schema = this.service._schema = this.schema || this.service._schema || {};
			// wrap the service with so it goes through JsonRest manager
			this.service._store = this;
			this.service.idAsRef = this.idAsRef;
			this.schema._idAttr = this.idAttribute;
			var constructor = dojox.rpc.JsonRest.getConstructor(this.service);
			var self = this;
			this._constructor = function(data){
				constructor.call(this, data);
				self.onNew(this);
			}
			this._constructor.prototype = constructor.prototype;
			this._index = dojox.rpc.Rest._index;
		},
		
		// summary:
		//		Will load any schemas referenced content-type header or in Link headers
		loadReferencedSchema: true,
		// summary:
		//		Treat objects in queries as partially loaded objects
		idAsRef: false,
		referenceIntegrity: true,
		target:"",
		// summary:
		// 		Allow no trailing slash on target paths. This is generally discouraged since
		// 		it creates prevents simple scalar values from being used a relative URLs.
		// 		Disabled by default.
		allowNoTrailingSlash: false,
		//Write API Support
		newItem: function(data, parentInfo){
			// summary:
			//		adds a new item to the store at the specified point.
			//		Takes two parameters, data, and options.
			//
			//	data: /* object */
			//		The data to be added in as an item.
			data = new this._constructor(data);
			if(parentInfo){
				// get the previous value or any empty array
				var values = this.getValue(parentInfo.parent,parentInfo.attribute,[]);
				// set the new value
				values = values.concat([data]);
				data.__parent = values;
				this.setValue(parentInfo.parent, parentInfo.attribute, values);
			}
			return data;
		},
		deleteItem: function(item){
			// summary:
			//		deletes item and any references to that item from the store.
			//
			//	item:
			//		item to delete
			//

			//	If the desire is to delete only one reference, unsetAttribute or
			//	setValue is the way to go.
			var checked = [];
			var store = dojox.data._getStoreForItem(item) || this;
			if(this.referenceIntegrity){
				// cleanup all references
				dojox.rpc.JsonRest._saveNotNeeded = true;
				var index = dojox.rpc.Rest._index;
				var fixReferences = function(parent){
					var toSplice;
					// keep track of the checked ones
					checked.push(parent);
					// mark it checked so we don't run into circular loops when encountering cycles
					parent.__checked = 1;
					for(var i in parent){
						if(i.substring(0,2) != "__"){
							var value = parent[i];
							if(value == item){
								if(parent != index){ // make sure we are just operating on real objects
									if(parent instanceof Array){
										// mark it as needing to be spliced, don't do it now or it will mess up the index into the array
										(toSplice = toSplice || []).push(i);
									}else{
										// property, just delete it.
										(dojox.data._getStoreForItem(parent) || store).unsetAttribute(parent, i);
									}
								}
							}else{
								if((typeof value == 'object') && value){
									if(!value.__checked){
										// recursively search
										fixReferences(value);
									}
									if(typeof value.__checked == 'object' && parent != index){
										// if it is a modified array, we will replace it
										(dojox.data._getStoreForItem(parent) || store).setValue(parent, i, value.__checked);
									}
								}
							}
						}
					}
					if(toSplice){
						// we need to splice the deleted item out of these arrays
						i = toSplice.length;
						parent = parent.__checked = parent.concat(); // indicates that the array is modified
						while(i--){
							parent.splice(toSplice[i], 1);
						}
						return parent;
					}
					return null;
				};
				// start with the index
				fixReferences(index);
				dojox.rpc.JsonRest._saveNotNeeded = false;
				var i = 0;
				while(checked[i]){
					// remove the checked marker
					delete checked[i++].__checked;
				}
			}
			dojox.rpc.JsonRest.deleteObject(item);

			store.onDelete(item);
		},
		changing: function(item,_deleting){
			// summary:
			//		adds an item to the list of dirty items.	This item
			//		contains a reference to the item itself as well as a
			//		cloned and trimmed version of old item for use with
			//		revert.
			dojox.rpc.JsonRest.changing(item,_deleting);
		},

		setValue: function(item, attribute, value){
			// summary:
			//		sets 'attribute' on 'item' to 'value'

			var old = item[attribute];
			var store = item.__id ? dojox.data._getStoreForItem(item) : this;
			if(dojox.json.schema && store.schema && store.schema.properties){
				// if we have a schema and schema validator available we will validate the property change
				dojox.json.schema.mustBeValid(dojox.json.schema.checkPropertyChange(value,store.schema.properties[attribute]));
			}
			if(attribute == store.idAttribute){
				throw new Error("Can not change the identity attribute for an item");
			}
			store.changing(item);
			item[attribute]=value;
			if(value && !value.__parent){
				value.__parent = item;
			}
			store.onSet(item,attribute,old,value);
		},
		setValues: function(item, attribute, values){
			// summary:
			//	sets 'attribute' on 'item' to 'value' value
			//	must be an array.


			if(!dojo.isArray(values)){
				throw new Error("setValues expects to be passed an Array object as its value");
			}
			this.setValue(item,attribute,values);
		},

		unsetAttribute: function(item, attribute){
			// summary:
			//		unsets 'attribute' on 'item'

			this.changing(item);
			var old = item[attribute];
			delete item[attribute];
			this.onSet(item,attribute,old,undefined);
		},
		save: function(kwArgs){
			// summary:
			//		Saves the dirty data using REST Ajax methods. See dojo.data.api.Write for API.
			//
			//	kwArgs.global:
			//		This will cause the save to commit the dirty data for all
			// 		JsonRestStores as a single transaction.
			//
			//	kwArgs.revertOnError
			//		This will cause the changes to be reverted if there is an
			//		error on the save. By default a revert is executed unless
			//		a value of false is provide for this parameter.
			//
			//	kwArgs.incrementalUpdates
			//		For items that have been updated, if this is enabled, the server will be sent a POST request
			// 		with a JSON object containing the changed properties. By default this is
			// 		not enabled, and a PUT is used to deliver an update, and will include a full
			// 		serialization of all the properties of the item/object.
			//		If this is true, the POST request body will consist of a JSON object with
			// 		only the changed properties. The incrementalUpdates parameter may also
			//		be a function, in which case it will be called with the updated and previous objects
			//		and an object update representation can be returned.
			//
			//	kwArgs.alwaysPostNewItems
			//		If this is true, new items will always be sent with a POST request. By default
			//		this is not enabled, and the JsonRestStore will send a POST request if
			//		the item does not include its identifier (expecting server assigned location/
			//		identifier), and will send a PUT request if the item does include its identifier
			//		(the PUT will be sent to the URI corresponding to the provided identifier).

			if(!(kwArgs && kwArgs.global)){
				(kwArgs = kwArgs || {}).service = this.service;
			}
			if("syncMode" in kwArgs ? kwArgs.syncMode : this.syncMode){
				dojox.rpc._sync = true;
			}

			var actions = dojox.rpc.JsonRest.commit(kwArgs);
			this.serverVersion = this._updates && this._updates.length;
			return actions;
		},

		revert: function(kwArgs){
			// summary
			//		returns any modified data to its original state prior to a save();
			//
			//	kwArgs.global:
			//		This will cause the revert to undo all the changes for all
			// 		JsonRestStores in a single operation.
			dojox.rpc.JsonRest.revert(kwArgs && kwArgs.global && this.service);
		},

		isDirty: function(item){
			// summary
			//		returns true if the item is marked as dirty.
			return dojox.rpc.JsonRest.isDirty(item);
		},
		isItem: function(item, anyStore){
			//	summary:
			//		Checks to see if a passed 'item'
			//		really belongs to this JsonRestStore.
			//
			//	item: /* object */
			//		The value to test for being an item
			//	anyStore: /* boolean*/
			//		If true, this will return true if the value is an item for any JsonRestStore,
			//		not just this instance
			return item && item.__id && (anyStore || this.service == dojox.rpc.JsonRest.getServiceAndId(item.__id).service);
		},
		_doQuery: function(args){
			var query= typeof args.queryStr == 'string' ? args.queryStr : args.query;
			var deferred = dojox.rpc.JsonRest.query(this.service,query, args);
			var self = this;
			if(this.loadReferencedSchema){
				deferred.addCallback(function(result){
					var contentType = deferred.ioArgs && deferred.ioArgs.xhr && deferred.ioArgs.xhr.getResponseHeader("Content-Type");
					var schemaRef = contentType && contentType.match(/definedby\s*=\s*([^;]*)/);
					if(contentType && !schemaRef){
						schemaRef = deferred.ioArgs.xhr.getResponseHeader("Link");
						schemaRef = schemaRef && schemaRef.match(/<([^>]*)>;\s*rel="?definedby"?/);
					}
					schemaRef = schemaRef && schemaRef[1];
					if(schemaRef){
						var serviceAndId = dojox.rpc.JsonRest.getServiceAndId((self.target + schemaRef).replace(/^(.*\/)?(\w+:\/\/)|[^\/\.]+\/\.\.\/|^.*\/(\/)/,"$2$3"));
						var schemaDeferred = dojox.rpc.JsonRest.byId(serviceAndId.service, serviceAndId.id);
						schemaDeferred.addCallbacks(function(newSchema){
							dojo.mixin(self.schema, newSchema);
							return result;
						}, function(error){
							console.error(error); // log it, but don't let it cause the main request to fail
							return result;
						});
						return schemaDeferred;
					}
					return undefined;//don't change anything, and deal with the stupid post-commit lint complaints
				});
			}
			return deferred;
		},
		_processResults: function(results, deferred){
			// index the results
			var count = results.length;
			// if we don't know the length, and it is partial result, we will guess that it is twice as big, that will work for most widgets
			return {totalCount:deferred.fullLength || (deferred.request.count == count ? (deferred.request.start || 0) + count * 2 : count), items: results};
		},

		getConstructor: function(){
			// summary:
			// 		Gets the constructor for objects from this store
			return this._constructor;
		},
		getIdentity: function(item){
			var id = item.__clientId || item.__id;
			if(!id){
				return id;
			}
			var prefix = this.service.servicePath.replace(/[^\/]*$/,'');
			// support for relative or absolute referencing with ids
			return id.substring(0,prefix.length) != prefix ?	id : id.substring(prefix.length); // String
		},
		fetchItemByIdentity: function(args){
			var id = args.identity;
			var store = this;
			// if it is an absolute id, we want to find the right store to query
			if(id.toString().match(/^(\w*:)?\//)){
				var serviceAndId = dojox.rpc.JsonRest.getServiceAndId(id);
				store = serviceAndId.service._store;
				args.identity = serviceAndId.id;
			}
			args._prefix = store.service.servicePath.replace(/[^\/]*$/,'');
			return store.inherited(arguments);
		},
		//Notifcation Support

		onSet: function(){},
		onNew: function(){},
		onDelete: 	function(){},

		getFeatures: function(){
			// summary:
			// 		return the store feature set
			var features = this.inherited(arguments);
			features["dojo.data.api.Write"] = true;
			features["dojo.data.api.Notification"] = true;
			return features;
		},

		getParent: function(item){
			//	summary:
			//		Returns the parent item (or query) for the given item
			//	item:
			//		The item to find the parent of

			return item && item.__parent;
		}


	}
);
dojox.data.JsonRestStore.getStore = function(options, Class){
	//	summary:
	//		Will retrieve or create a store using the given options (the same options
	//		that are passed to JsonRestStore constructor. Returns a JsonRestStore instance
	//	options:
	//		See the JsonRestStore constructor
	//	Class:
	//		Constructor to use (for creating stores from JsonRestStore subclasses).
	// 		This is optional and defaults to JsonRestStore.
	if(typeof options.target == 'string'){
		options.target = options.target.match(/\/$/) || options.allowNoTrailingSlash ?
				options.target : (options.target + '/');
		var store = (dojox.rpc.JsonRest.services[options.target] || {})._store;
		if(store){
			return store;
		}
	}
	return new (Class || dojox.data.JsonRestStore)(options);
};
dojox.data._getStoreForItem = function(item){
	if(item.__id){
		var serviceAndId = dojox.rpc.JsonRest.getServiceAndId(item.__id);
		if(serviceAndId && serviceAndId.service._store){
			return serviceAndId.service._store;
		}else{
			var servicePath = item.__id.toString().match(/.*\//)[0];
			return new dojox.data.JsonRestStore({target:servicePath});
		}
	}
	return null;
};
dojox.json.ref._useRefs = true; // Use referencing when identifiable objects are referenced

}

if(!dojo._hasResource['bfree.api.Error']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Error'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 5:12 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Error');

dojo.declare('bfree.api.Error', null,{

    status: 400,
	message: '',
    innerMessage: '',
	err: null,
	name: null,
	lineNumber: -1,
	fileName: null,
	stack: null,

    //err: can be an javascript error object OR
    //an error object returned from a call to the JsonRestStore
	constructor: function(message, err){

		this.message = message;
		this.err = err;

        if(this.err){
            if(this.err.hasOwnProperty('status')){
                this.status = this.err.status;
            }
            if(this.err.hasOwnProperty('responseText')){
                this.innerMessage = this.err.responseText;
            }
            else if(this.err.hasOwnProperty('message')){
                this.innerMessage = this.err.message;
            }
            else if(this.err.hasOwnProperty('description')){
                this.innerMessage = this.err.description;
            }
        }

	},

    getContent: function(showDetails){
        var msg = this.message;

        if((showDetails) && (this.innerMessage))
            msg += ':<br>' + this.innerMessage;

        return msg;
    },

    getMessage: function(showDetails){
        var msg = this.message;

        if((showDetails) && (this.innerMessage))
            msg += ':\n' + this.innerMessage;

        return msg;
    }


});

}

if(!dojo._hasResource['bfree.api.Utilities']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Utilities'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.Utilities');

dojo.declare('bfree.api.Utilities', null,{
});

bfree.api.Utilities.uniqueIdBase = (new Date()).getTime();

bfree.api.Utilities.randomNumber = function(args){
	var l = args.lowerBound;
	var u = args.upperBound;
	
	return (Math.floor(Math.random() * (u - l)) + l);
}

bfree.api.Utilities.readablizeBytes = function(args){
	var strBytes = ''
    var bytes = args.bytes;
	
	if((bytes == null) || (bytes == Number.NaN))
		return '???';
		
	if(bytes < 1)
		return '0 bytes';
				
	var s = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
    var e = Math.floor(Math.log(bytes)/Math.log(1024));

    if(e > 0){
        strBytes = (bytes / Math.pow(1024, Math.floor(e))).toFixed(2) + ' ' + s[e];
    }
    else{
        strBytes = (bytes / Math.pow(1024, Math.floor(e))).toFixed(0) + ' ' + s[e];
    }

    return strBytes;
}

bfree.api.Utilities.readabilizeSeconds = function(args){
	 var s = args.seconds;
	 
	 var d = Number(s);
	 var h = Math.floor(d / 3600);
	 var m = Math.floor(d % 3600 / 60);
	 var s = Math.floor(d % 3600 % 60);
	 
	 return ((h > 0 ? h + ":" : "") + (m > 0 ? (h > 0 && m < 10 ? "0" : "") + m + ":" : "0:") + (s < 10 ? "0" : "") + s);
};

bfree.api.Utilities.generateUniqueId = function(args){
	return bfree.api.Utilities.uniqueIdBase++;
};

bfree.api.Utilities.isArray = function(arr){
    return arr.constructor == Array;
}

bfree.api.Utilities.generateUniqueName = function(args){	
	var names = args.names;	
	var baseName = args.base_name;
	var appendix = (args.appendix) ? args.appendix : '({index})'


	var currName = baseName;
	var i = 0;
	while(++i){
		
		var idx = dojo.indexOf(names, currName);
		if(idx < 0)
			break;

		currName = dojo.replace('{baseName}' + appendix , { baseName: baseName, index: i });
	}	
	
	return currName;
}

bfree.api.Utilities.getFileExtension = function(args){
	var fileName = args.file_name;
	
	var pos = fileName.lastIndexOf('.');
	if(pos < 1)
		return '';
		
	return fileName.substring(pos); 
}

bfree.api.Utilities.getFileName = function(args){
	var file_name = args.file_name;
	var pos = file_name.lastIndexOf('.');
	if(pos < 1)
		return file_name;
		
	return file_name.substring(0, pos); 
}

bfree.api.Utilities.saveUrl = function(args){
	var url = args.url;
	var winName = args.window_name;

	var winArgs = dojo.string.substitute(
								'width=10,height=10,top=-20,left=-20,toolbar=0,resizable=1,location=0,directories=0,status=0,menubar=0',
								[])

    window.location.href = url;
}

bfree.api.Utilities.getBox = function(args){

    var windowBox = dojo.window.getBox();

    var screenW = windowBox.w;
    var screenH = windowBox.h;

    var winW = screenW * args.scale;
    var winH = screenH * args.scale;
    var winT = (screenH / 2) - (winH / 2);
    var winL = (screenW / 2) - (winW / 2);

    return {w: winW, h: winH, t: winT, l: winL };


};

bfree.api.Utilities.getFormatStore=function(){

    var items = [
        {
            id: bfree.api.DataTypes.types.BOOLEAN + ':' + bfree.api.CellDefinition.formats.none,
            format_id: bfree.api.CellDefinition.formats.none,
            data_type_id: bfree.api.DataTypes.types.BOOLEAN,
            name: 'None'
        },
        {
            id: bfree.api.DataTypes.types.DATETIME + ':' + bfree.api.CellDefinition.formats.none,
            format_id: bfree.api.CellDefinition.formats.none,
            data_type_id: bfree.api.DataTypes.types.DATETIME,
            name: 'None'
        },
        {
            id: bfree.api.DataTypes.types.DATETIME + ':' + bfree.api.CellDefinition.formats.datetime,
            format_id: bfree.api.CellDefinition.formats.datetime,
            data_type_id: bfree.api.DataTypes.types.DATETIME,
            name: 'Date'
        },
        {
            id: bfree.api.DataTypes.types.FLOAT + ':' + bfree.api.CellDefinition.formats.none,
            format_id: bfree.api.CellDefinition.formats.none,
            data_type_id: bfree.api.DataTypes.types.FLOAT,
            name: 'None'
        },
        {
            id: bfree.api.DataTypes.types.INTEGER + ':' + bfree.api.CellDefinition.formats.none,
            format_id: bfree.api.CellDefinition.formats.none,
            data_type_id: bfree.api.DataTypes.types.INTEGER,
            name: 'None'
        },
        {
            id: bfree.api.DataTypes.types.INTEGER + ':' + bfree.api.CellDefinition.formats.size,
            format_id: bfree.api.CellDefinition.formats.size,
            data_type_id: bfree.api.DataTypes.types.INTEGER,
            name: 'File Size'
        },
        {
            id: bfree.api.DataTypes.types.STRING + ':' + bfree.api.CellDefinition.formats.none,
            format_id: bfree.api.CellDefinition.formats.none,
            data_type_id: bfree.api.DataTypes.types.STRING,
            name: 'None'
        },
        {
            id: bfree.api.DataTypes.types.TEXT + ':' + bfree.api.CellDefinition.formats.none,
            format_id: bfree.api.CellDefinition.formats.none,
            data_type_id: bfree.api.DataTypes.types.TEXT,
            name: 'None'
        }
    ];

    return new bfree.api.ItemFileWriteStore({
        data: {
            identifier: 'id',
            label: 'name',
            items: items
        }
    });
};

bfree.api.Utilities.viewUrl = function(args){
    var box = args.windowBox;
	var url = args.url;
	var winName = args.window_name;
				
	var winArgs = dojo.string.substitute(
								'width=${0},height=${1},top=${2},left=${3},toolbar=0,resizable=1,location=0,directories=0,status=0,menubar=0,scrollbars=1',
								[box.w, box.h, box.t, box.l])

//    window.open(url, winName, winArgs).focus();
    var win = parent.frames['zoneframe'].open('about:blank', winName, winArgs);
    win.document.location.href = url;
    win.focus();
	//
};

bfree.api.Utilities.formatDate= function(date){
    //UTC month is 0 based?
    //date and year are not
    var monthS=(date.getUTCMonth()+1).toString();
    var dateS=date.getUTCDate().toString();
    var hourS=date.getUTCHours().toString();
    monthS=monthS.length==1?"0"+monthS:monthS;
    dateS=dateS.length==1?"0"+dateS:dateS;
    hourS=hourS.length==1?"0"+hourS:hourS;

    return date.getUTCFullYear()+'-'+
           monthS+'-'+
           dateS+'T'+
           hourS+':00:00Z';
};

bfree.api.Utilities.validateEmail=function(str){
    // These comments use the following terms from RFC2822:
    // local-part, domain, domain-literal and dot-atom.
    // Does the address contain a local-part followed an @ followed by a domain?
    // Note the use of lastIndexOf to find the last @ in the address
    // since a valid email address may have a quoted @ in the local-part.
    // Does the domain name have at least two parts, i.e. at least one dot,
    // after the @? If not, is it a domain-literal?
    // This will accept some invalid email addresses
    // BUT it doesn't reject valid ones.
    var atSym = str.lastIndexOf("@");
    if (atSym < 1) { return false; } // no local-part
    if (atSym == str.length - 1) { return false; } // no domain
    if (atSym > 64) { return false; } // there may only be 64 octets in the local-part
    if (str.length - atSym > 255) { return false; } // there may only be 255 octets in the domain

    // Is the domain plausible?
    var lastDot = str.lastIndexOf(".");
    // Check if it is a dot-atom such as example.com
    if (lastDot > atSym + 1 && lastDot < str.length - 1) { return true; }
    //  Check if could be a domain-literal.
    if (str.charAt(atSym + 1) == '[' &&  str.charAt(str.length - 1) == ']') { return true; }
    return false;
};



}

if(!dojo._hasResource['bfree.api._Collection']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api._Collection'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:10 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api._Collection');






dojo.declare('bfree.api._Collection', null,{
	store: null,
	target: null,
	schema: null,
    syncMode: true,
	cache: false,
	first: null,
    isLoaded: false,

	_fetch_onComplete: function(items, request){

        this.isLoaded = true;
		if((items != null) && (items.length > 1)){
			this.first = items[0];
		}

        this.onFetchComplete(items);
	},

    _getExistingNames: function(args){
		var names = [];
		var items = this.fetch();
		var exclude = null;

		if(args)
			exclude = args.exclude;

		dojo.forEach(items, function(item){
			if ((item != exclude) &&  (this.store.hasAttribute(item, 'name'))) {
				names.push(item.name);
			}
		}, this);

		return names;
	},

    _getIdentity: function(item){

        var id = item.id;
        if(id){
            return id;
        }

        id = item.__clientId || item.__id;

        if(!id){
            return id;
        }

        var prefix = this.service.servicePath.replace(/[^\/]*$/,'');
        // support for relative or absolute referencing with ids
        return id.substring(0,prefix.length) != prefix ?	id : id.substring(prefix.length); // String
    },

	_initialize: function(){
		this.store = new dojox.data.JsonRestStore({
			target: this.target,
			idAttribute: 'id',
			labelAttribute: 'name',
			schema: this.schema,
			syncMode: this.syncMode,
			cacheByDefault: this.cache,
            clearOnClose: true,
			loadLazyValues: false,
            alwaysPostNewItems: true
		});

        this.store.getIdentity = dojo.hitch(this.store, this._getIdentity);

	},

    clearCache: function(){
        this.store.clearCache();
    },

    clone: function(args){
		this.store.changing(args.item);
	},

	/**
	 * Creates a new instance of bfree.api._Collection
 	 * @constructor
	 */
	constructor: function(){
		//dojo.connect(this.store, 'onSet', this, this.onSet);
	},

    containsValue: function(item, attribute, value){
        return this.store.containsValue(item, attribute, value);
    },

	create: function(args){
		var newItem = this.store.newItem(args);
		this.store.changing(newItem);
		return newItem;
	},

    destroy: function(args){
        var no_save = (args) ? args.no_save : false;

        try{

            this.store.deleteItem(args.item);
            if(!no_save)
                this.save({
                    alwaysPostNewItems: true,
                    onComplete: ((args) && (args.onComplete)) ? args.onComplete : function () { },
                    scope: ((args) && (args.scope)) ? args.scope : this
                });

        }
        finally{
            //seems to bug where isDirty flag is not reverted when deletion error occurs
            args.item.__isDirty = false;
        }

    },

	fetch: function(args){

		var fetchObj = this.store.fetch({
			query:{},
			queryOptions:{
				cache: this.cache
			},
			onComplete: dojo.hitch(this, this._fetch_onComplete)
		});

		return fetchObj.results;
	},

	fetchById: function(args){
		var item = this.store.fetchItemByIdentity({
			identity: args.id
		});
		return item;
	},

    fetchByName: function(name){
        var _item = null;

        function  __onComplete(items, request){
			dojo.some(items, function(item){
                if(item.name == name){
                    _item = item;
                    return false;
                }
            }, this);
		}

		this.store.fetch({
            query:{},
            queryOptions:{cache: true},
            onComplete: __onComplete
        });

        return _item;
    },

    fetchItemsByName: function(name){
        var _items = new Array();

        function  __onComplete(items, request){
			dojo.some(items, function(item){
                if(item.name == name){
                    _items.push(item);
                }
            }, this);
		}

		this.store.fetch({
            query:{},
            queryOptions:{cache: true},
            onComplete: __onComplete
        });

        return _items;
    },

	forEach: function(callback, scope){

		function  __onComplete(items, request){
			dojo.forEach(items, callback, scope);
		}

		this.store.fetch({query:{}, onComplete: __onComplete});
	},

	isDirty: function(args){
		var item = (args) ? args.item : null;
		return this.store.isDirty(item);
	},

    isNew: function(args){
		return ((args.item.id == undefined) || (args.item.id == null));
	},

    invalidate: function(identity){
        //Remove item if exists (force refresh from server);
        var prefix = this.store.service.servicePath.replace(/[^\/]*$/,'');
        var full_id = (prefix || '') + identity;
        var item = this.store._index[full_id];
        if(item)
            delete this.store._index[full_id];
    },

	loadItem: function(args){
        var err = null;
		var item = args.item;

        if(args.callback)
            args.onItem = args.callback;

        var _scope = (args.scope) ? args.scope : this;

		this.store.loadItem({
			item: item,
            scope: _scope,
			onItem: args.onItem,
            onError: args.onError
		});

	},

    merge: function(itemDst, itemSrc){

        for(var prop in itemDst){

            var dstVal = itemDst[prop];

             //don't worry about object props (but dates OK)
            if((dstVal != null) && (typeof dstVal == 'object') && (typeof dstVal.getMonth != 'function'))
                continue;

            if(itemSrc.hasOwnProperty(prop)){
                var srcVal = itemSrc[prop];
                if(srcVal != dstVal){
                    this.store.setValue(itemDst, prop, srcVal);
                }
            }
        }

    },

    onFetchComplete: function(items){
    },

	query: function(args){
		var items = [];

		var queryResults = this.store.fetch({
			query: args.query,
			queryOptions: { cache: false },
			sort: args.sort
		});

		if((queryResults) && (queryResults.results))
			items = queryResults.results;

		return items;
	},

    refresh: function(){
        this.store.clearCache();
        this.fetch();
    },

    refreshAsync: function(args){

        this.store.fetchItemByIdentity({
            scope: args.scope,
            identity: args.identity,
            onItem: args.onItem,
            onError: args.onError
        });

    },

    refreshItem: function(item_id){

        var retval = this.store.fetch({
            query: item_id,
            queryOptions: { cache: false }
        });

        return retval.results;

    },

	revert: function(args){
		this.store.revert();
	},

	save: function(args){
		var err = null;

        args = (!args) ?
            {
                scope: this,
                onComplete: function() { }
            } :
            args;


		function _onError(errData){
			err = new bfree.api.Error(errData.responseText, errData);
		}

		this.store.save({
            alwaysPostNewItems: true,
            revertOnError: false,
			onError: _onError,
            onComplete: ((args) && (args.onComplete)) ? args.onComplete : function () { },
            scope: ((args) && (args.scope)) ? args.scope : this
		});

		if(err){
            throw err;
        }

	},

    setDirty: function(item){
        this.store.changing(item);
    },

	setValue: function(item, attr, value){
		this.store.setValue(item, attr, value);
	},

    getValue: function(item, attr){
        return this.store.getValue(item, attr);
    },

    generateUniqueName: function(args){
		var names = this.getExistingNames();
		var baseName = args.base_name;
        var appendix = args.appendix;

		return bfree.api.Utilities.generateUniqueName({
			names: names,
			base_name: baseName,
            appendix: appendix
		});
    },

    getExistingNames: function(args){
		var names = [];
		var items = this.fetch();
        var exclude = null;

		if(args)
			exclude = args.exclude;

		dojo.forEach(items, function(item){
			if ((item != exclude) &&  (this.store.hasAttribute(item, 'name'))) {
				names.push(item.name);
			}
		}, this);

        return names;
	},

    fetchDirtyItems: function(args){
		var dirtyItems = [];

		var queryResults = this.store.fetch({
			query: {__isDirty: true},
			queryOptions: { cache: false }
		});

		if((queryResults) && (queryResults.results))
			dirtyItems = queryResults.results;

		return dirtyItems;
	}


});

}

if(!dojo._hasResource['bfree.api._Object']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api._Object'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 26/09/11
 * Time: 10:47 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api._Object');

dojo.declare('bfree.api._Object', null,{
    id: null,
    name: null,
    created_at: null,
    created_by: null,
    updated_at: null,
    updated_by: null,

    constructor: function(args){

        if((this.created_at != null) && (typeof this.created_at == 'string'))
            this.created_at = dojo.date.stamp.fromISOString(this.created_at);
        if((this.updated_at != null) && (typeof this.updated_at == 'string'))
            this.updated_at = dojo.date.stamp.fromISOString(this.created_at);

    },

    valueEquals: function(property, value){

        if(!this.hasOwnProperty(property))
            return false;

        var myValue = this[property];
        if((myValue == null) && (value == null))
            return true;

        //in the case of string compare empty string to null = 'true'
        if((typeof myValue == 'string') || (typeof value == 'string')){
            myValue = (myValue == null) ? '' : myValue;
            value = (value == null) ? '' : value;
        }

        return (myValue == value);
    },

    getId: function(){
        return (this.$ref ? this.$ref : this.id);
    },

    isNew: function(){
        return ((this.id == undefined) || (this.id == null));
    },

    isValid: function(){
        return true;
    }

});

}

if(!dojo._hasResource['bfree.api.Account']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Account'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:03 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Account');



dojo.declare('bfree.api.Account', [bfree.api._Object], {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    isValid: function(){
        var valid=true;

        if(String.isBlank(this.name)){
            valid=false;
        }

        if(String.isBlank(this.email)){
            valid=false;
        }

        return valid;
    }
});

bfree.api.Account.AccountTypes = {
    'FREE_TRIAL':   0x00,
    'ACTIVE':       0x01
}

bfree.api.Account.BillingTypes = {
    'MONTHLY':  0x00,
    'YEARLY':   0x01
}


bfree.api.Account.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'status': {
 	        type: 'integer',
 		    'default': ''
 		},
        'first_name': {
 	        type: 'string',
 		    'default': ''
 		},
        'last_name': {
 	        type: 'string',
 		    'default': ''
 		},
        'address': {
 	        type: 'string',
 		    'default': ''
 		},
        'province': {
 	        type: 'string',
 		    'default': ''
 		},
        'postal_code': {
 	        type: 'string',
 		    'default': ''
 		},
        'country': {
 	        type: 'string',
 		    'default': ''
 		},
        'phone': {
 	        type: 'string',
 		    'default': ''
 		},
        'billing_type': {
 	        type: 'integer',
 		    'default': ''
 		},
        'customer_code': {
 	        type: 'string',
 		    'default': ''
 		},
        'account_type': {
 	        type: 'integer',
 		    'default': ''
 		},
        'trial_period': {
            type: 'integer',
            'default': 0
        },
        'email': {
 	        type: 'string',
 		    'default': ''
 		},
        'password': {
 	        type: 'string',
 		    'default': ''
 		},
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        }
 	},
	prototype: new bfree.api.Account()
 };



}

if(!dojo._hasResource['bfree.api.XhrHelper']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.XhrHelper'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 5:06 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.XhrHelper');



/**
 * Class to wrap DOJO AJAX calls
 * @classDecription Class to wrap DOJO AJAX calls, specifically handling success/error conditions
 * @author ScottH
 * @version 1.1
 * @since 1.0
 */
dojo.declare('bfree.api.XhrHelper', null,{

});

bfree.api.XhrHelper._doXhrAction = function(xhrFn, args){
	var rsp = null;
	var err =  null;

	function _onComplete(response, ioArgs){
		rsp = response;
	}
	function _onError(response, ioArgs){
		err = new bfree.api.Error(response.responseText, response);
	}

	args.contentType = 'application/json';
	args.handleAs = 'json';
	args.sync = true;
	args.load = _onComplete;
	args.error = _onError;

	xhrFn(args);

	if (err != null)
		throw err; //new Error(err.message);

	return rsp;
}

/**
 * Performs a XHR GET AJAX call
 * @param {Object} args Consisting of:
 *     target {String}: the URL to request data from
 *     getData {Object}:  data to be passed to server
 * @return {Object} response from server
 * @author ScottH
 * @version 1.1
 * @since 1.0
 * @memberOf bfree.api.XhrHelper (Static)
 */
bfree.api.XhrHelper.doGetAction = function(args){

    var getDataJson = (args.getData) ? dojo.toJson(args.getData) : null;

	var xhrArgs = {
		url: args.target,
		content: getDataJson
	};

	return bfree.api.XhrHelper._doXhrAction(dojo.xhrGet, xhrArgs);

};

bfree.api.XhrHelper.doPostAction = function(args){

    var postData = args.postData;
    var postDataJson = dojo.toJson(postData);

	var xhrArgs = {
		url: args.target,
		postData: postDataJson
	};

	return bfree.api.XhrHelper._doXhrAction(dojo.xhrPost, xhrArgs);
};

bfree.api.XhrHelper.doPutAction = function(args){

    var putData = args.putData;
    var putDataJson = dojo.toJson(putData);

    var xhrArgs = {
        url: args.target,
        putData: putDataJson
    }

    return bfree.api.XhrHelper._doXhrAction(dojo.xhrPut, xhrArgs);

};

bfree.api.XhrHelper.authenticity_token = null;
bfree.api.XhrHelper.originalXhr = dojo.xhr;
dojo.xhr = function(httpVerb, xhrArgs, hasHTTPBody){

    if(bfree.api.XhrHelper.authenticity_token !=  null){
        if(httpVerb.toUpperCase() == 'POST'){
            var postData = (xhrArgs.postData) ? dojo.fromJson(xhrArgs.postData) : {};
            postData['authenticity_token'] = bfree.api.XhrHelper.authenticity_token;
            xhrArgs.postData = dojo.toJson(postData);
        }
        if(httpVerb.toUpperCase() == 'PUT'){
            var putData = (xhrArgs.putData) ? dojo.fromJson(xhrArgs.putData) : {};
            putData['authenticity_token'] = bfree.api.XhrHelper.authenticity_token;
            xhrArgs.putData = dojo.toJson(putData);
        }
        if(httpVerb.toUpperCase() == 'DELETE'){
            xhrArgs.rawBody = dojo.toJson({ authenticity_token: bfree.api.XhrHelper.authenticity_token});
        }
    }

    //fix for Opera: doesn't allow 'Range' to be set for xhr.setRequestHeader: crazy?
    if((xhrArgs.headers) && xhrArgs.headers.hasOwnProperty('Range')){
        xhrArgs.headers['dojo-Range'] = xhrArgs.headers['Range'];
    }

    return bfree.api.XhrHelper.originalXhr(httpVerb, xhrArgs, hasHTTPBody);
}

}

if(!dojo._hasResource['bfree.api.Accounts']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Accounts'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:08 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Accounts');




dojo.declare('bfree.api.Accounts', [bfree.api._Collection],{

	/**
	 * Creates a new instance of bfree.api.Libraries
 	 * @constructor
	 */
	constructor: function(args){
		this.target = bfree.api.Accounts.TRGT;
		this.schema = bfree.api.Account.schema;
		this.cache = true;

		this._initialize();
	}
});

bfree.api.Accounts.generatePassword = function(args){
	var len = args.length;
	var charset = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	var pword = '';

	for(var i = 0; i < len; i++){
		pword += charset.charAt(Math.floor(Math.random()*(charset.length)));
	}
	return pword;
};

bfree.api.Accounts.TRGT = '/accounts';

}

if(!dojo._hasResource['bfree.api.RkoUser']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.RkoUser'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:03 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.RkoUser');



dojo.declare('bfree.api.RkoUser', [bfree.api._Object], {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    isValid: function(){
        var valid=true;
        if(String.isBlank(this.name)){
            valid=false;
        }
        return valid;
    }
});

bfree.api.RkoUser.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'password': {
            type: 'string'
        },
        'first_name': {
            type: 'string'
        },
        'last_name': {
            type: 'string'
        },
        'email': {
            type: 'string'
        },
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        }
 	},
	prototype: new bfree.api.RkoUser()
 };



}

if(!dojo._hasResource['bfree.api.RkoUsers']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.RkoUsers'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:08 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.RkoUsers');




dojo.declare('bfree.api.RkoUsers', [bfree.api._Collection],{

	/**
	 * Creates a new instance of bfree.api.Libraries
 	 * @constructor
	 */
	constructor: function(args){
		this.target = bfree.api.RkoUsers.TRGT;
		this.schema = bfree.api.RkoUser.schema;
		this.cache = true;

		this._initialize();
	},

    logon: function(username, password){
        var postData = {
            username: username,
            password: password
        };

        var result = bfree.api.XhrHelper.doPostAction({
            target: bfree.api.RkoUsers.LOGIN_URL,
            postData: postData
        });

        return new bfree.api.RkoUser(result);
    },

    logoff: function(){
      var url = bfree.api.RkoUsers.LOGOUT_URL;

        var postData = {
        };

        var results = bfree.api.XhrHelper.doPostAction({
            target: url,
            postData: postData
        });

        return results;
    }

});

bfree.api.RkoUsers.generatePassword = function(args){
	var len = args.length;
	var charset = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	var pword = '';

	for(var i = 0; i < len; i++){
		pword += charset.charAt(Math.floor(Math.random()*(charset.length)));
	}
	return pword;
};

bfree.api.RkoUsers.LOGIN_URL = '/rko_users/logon.json';
bfree.api.RkoUsers.LOGOUT_URL = '/rko_users/logout.json';

bfree.api.RkoUsers.TRGT = '/rko_users';

}

if(!dojo._hasResource["dojo.regexp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.regexp"] = true;
dojo.provide("dojo.regexp");

dojo.getObject("regexp", true, dojo);

/*=====
dojo.regexp = {
	// summary: Regular expressions and Builder resources
};
=====*/

dojo.regexp.escapeString = function(/*String*/str, /*String?*/except){
	//	summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

dojo.regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	//	summary:
	//		Builds a regular expression that groups subexpressions
	//	description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return dojo.regexp.group(b.join("|"), nonCapture); // String
};

dojo.regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

}

if(!dojo._hasResource["dojo.i18n"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.i18n"] = true;
dojo.provide("dojo.i18n");

dojo.getObject("i18n", true, dojo);

/*=====
dojo.i18n = {
	// summary: Utility classes to enable loading of resources for internationalization (i18n)
};
=====*/

// when using a real AMD loader, dojo.i18n.getLocalization is already defined by dojo/lib/backCompat
dojo.i18n.getLocalization = dojo.i18n.getLocalization || function(/*String*/packageName, /*String*/bundleName, /*String?*/locale){
	//	summary:
	//		Returns an Object containing the localization for a given resource
	//		bundle in a package, matching the specified locale.
	//	description:
	//		Returns a hash containing name/value pairs in its prototypesuch
	//		that values can be easily overridden.  Throws an exception if the
	//		bundle is not found.  Bundle must have already been loaded by
	//		`dojo.requireLocalization()` or by a build optimization step.  NOTE:
	//		try not to call this method as part of an object property
	//		definition (`var foo = { bar: dojo.i18n.getLocalization() }`).  In
	//		some loading situations, the bundle may not be available in time
	//		for the object definition.  Instead, call this method inside a
	//		function that is run after all modules load or the page loads (like
	//		in `dojo.addOnLoad()`), or in a widget lifecycle method.
	//	packageName:
	//		package which is associated with this resource
	//	bundleName:
	//		the base filename of the resource bundle (without the ".js" suffix)
	//	locale:
	//		the variant to load (optional).  By default, the locale defined by
	//		the host environment: dojo.locale

	locale = dojo.i18n.normalizeLocale(locale);

	// look for nearest locale match
	var elements = locale.split('-');
	var module = [packageName,"nls",bundleName].join('.');
		var bundle = dojo._loadedModules[module];
	if(bundle){
		var localization;
		for(var i = elements.length; i > 0; i--){
			var loc = elements.slice(0, i).join('_');
			if(bundle[loc]){
				localization = bundle[loc];
				break;
			}
		}
		if(!localization){
			localization = bundle.ROOT;
		}

		// make a singleton prototype so that the caller won't accidentally change the values globally
		if(localization){
			var clazz = function(){};
			clazz.prototype = localization;
			return new clazz(); // Object
		}
	}

	throw new Error("Bundle not found: " + bundleName + " in " + packageName+" , locale=" + locale);
};

dojo.i18n.normalizeLocale = function(/*String?*/locale){
	//	summary:
	//		Returns canonical form of locale, as used by Dojo.
	//
	//  description:
	//		All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	//		the user agent's locale unless overridden by djConfig.

	var result = locale ? locale.toLowerCase() : dojo.locale;
	if(result == "root"){
		result = "ROOT";
	}
	return result; // String
};

dojo.i18n._requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale, /*String?*/availableFlatLocales){
	//	summary:
	//		See dojo.requireLocalization()
	//	description:
	// 		Called by the bootstrap, but factored out so that it is only
	// 		included in the build when needed.

	var targetLocale = dojo.i18n.normalizeLocale(locale);
 	var bundlePackage = [moduleName, "nls", bundleName].join(".");
	// NOTE:
	//		When loading these resources, the packaging does not match what is
	//		on disk.  This is an implementation detail, as this is just a
	//		private data structure to hold the loaded resources.  e.g.
	//		`tests/hello/nls/en-us/salutations.js` is loaded as the object
	//		`tests.hello.nls.salutations.en_us={...}` The structure on disk is
	//		intended to be most convenient for developers and translators, but
	//		in memory it is more logical and efficient to store in a different
	//		order.  Locales cannot use dashes, since the resulting path will
	//		not evaluate as valid JS, so we translate them to underscores.

	//Find the best-match locale to load if we have available flat locales.
	var bestLocale = "";
	if(availableFlatLocales){
		var flatLocales = availableFlatLocales.split(",");
		for(var i = 0; i < flatLocales.length; i++){
			//Locale must match from start of string.
			//Using ["indexOf"] so customBase builds do not see
			//this as a dojo._base.array dependency.
			if(targetLocale["indexOf"](flatLocales[i]) == 0){
				if(flatLocales[i].length > bestLocale.length){
					bestLocale = flatLocales[i];
				}
			}
		}
		if(!bestLocale){
			bestLocale = "ROOT";
		}
	}

	//See if the desired locale is already loaded.
	var tempLocale = availableFlatLocales ? bestLocale : targetLocale;
	var bundle = dojo._loadedModules[bundlePackage];
	var localizedBundle = null;
	if(bundle){
		if(dojo.config.localizationComplete && bundle._built){return;}
		var jsLoc = tempLocale.replace(/-/g, '_');
		var translationPackage = bundlePackage+"."+jsLoc;
		localizedBundle = dojo._loadedModules[translationPackage];
	}

	if(!localizedBundle){
		bundle = dojo["provide"](bundlePackage);
		var syms = dojo._getModuleSymbols(moduleName);
		var modpath = syms.concat("nls").join("/");
		var parent;

		dojo.i18n._searchLocalePath(tempLocale, availableFlatLocales, function(loc){
			var jsLoc = loc.replace(/-/g, '_');
			var translationPackage = bundlePackage + "." + jsLoc;
			var loaded = false;
			if(!dojo._loadedModules[translationPackage]){
				// Mark loaded whether it's found or not, so that further load attempts will not be made
				dojo["provide"](translationPackage);
				var module = [modpath];
				if(loc != "ROOT"){module.push(loc);}
				module.push(bundleName);
				var filespec = module.join("/") + '.js';
				loaded = dojo._loadPath(filespec, null, function(hash){
					hash = hash.root || hash;
					// Use singleton with prototype to point to parent bundle, then mix-in result from loadPath
					var clazz = function(){};
					clazz.prototype = parent;
					bundle[jsLoc] = new clazz();
					for(var j in hash){ bundle[jsLoc][j] = hash[j]; }
				});
			}else{
				loaded = true;
			}
			if(loaded && bundle[jsLoc]){
				parent = bundle[jsLoc];
			}else{
				bundle[jsLoc] = parent;
			}

			if(availableFlatLocales){
				//Stop the locale path searching if we know the availableFlatLocales, since
				//the first call to this function will load the only bundle that is needed.
				return true;
			}
		});
	}

	//Save the best locale bundle as the target locale bundle when we know the
	//the available bundles.
	if(availableFlatLocales && targetLocale != bestLocale){
		bundle[targetLocale.replace(/-/g, '_')] = bundle[bestLocale.replace(/-/g, '_')];
	}
};

(function(){
	// If other locales are used, dojo.requireLocalization should load them as
	// well, by default.
	//
	// Override dojo.requireLocalization to do load the default bundle, then
	// iterate through the extraLocale list and load those translations as
	// well, unless a particular locale was requested.

	var extra = dojo.config.extraLocale;
	if(extra){
		if(!extra instanceof Array){
			extra = [extra];
		}

		var req = dojo.i18n._requireLocalization;
		dojo.i18n._requireLocalization = function(m, b, locale, availableFlatLocales){
			req(m,b,locale, availableFlatLocales);
			if(locale){return;}
			for(var i=0; i<extra.length; i++){
				req(m,b,extra[i], availableFlatLocales);
			}
		};
	}
})();

dojo.i18n._searchLocalePath = function(/*String*/locale, /*Boolean*/down, /*Function*/searchFunc){
	//	summary:
	//		A helper method to assist in searching for locale-based resources.
	//		Will iterate through the variants of a particular locale, either up
	//		or down, executing a callback function.  For example, "en-us" and
	//		true will try "en-us" followed by "en" and finally "ROOT".

	locale = dojo.i18n.normalizeLocale(locale);

	var elements = locale.split('-');
	var searchlist = [];
	for(var i = elements.length; i > 0; i--){
		searchlist.push(elements.slice(0, i).join('-'));
	}
	searchlist.push(false);
	if(down){searchlist.reverse();}

	for(var j = searchlist.length - 1; j >= 0; j--){
		var loc = searchlist[j] || "ROOT";
		var stop = searchFunc(loc);
		if(stop){ break; }
	}
};

dojo.i18n._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated){
	//	summary:
	//		Load built, flattened resource bundles, if available for all
	//		locales used in the page. Only called by built layer files.

	function preload(locale){
		locale = dojo.i18n.normalizeLocale(locale);
		dojo.i18n._searchLocalePath(locale, true, function(loc){
			for(var i=0; i<localesGenerated.length;i++){
				if(localesGenerated[i] == loc){
					dojo["require"](bundlePrefix+"_"+loc);
					return true; // Boolean
				}
			}
			return false; // Boolean
		});
	}
	preload();
	var extra = dojo.config.extraLocale||[];
	for(var i=0; i<extra.length; i++){
		preload(extra[i]);
	}
};

}

if(!dojo._hasResource["dojo.string"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.string"] = true;
dojo.provide("dojo.string");

dojo.getObject("string", true, dojo);

/*=====
dojo.string = {
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	//	summary:
	//		Efficiently replicate a string `n` times.
	//	str:
	//		the string to replicate
	//	num:
	//		number of times to replicate the string
	
	if(num <= 0 || !str){ return ""; }
	
	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	//	summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	//	text:
	//		the string to pad
	//	size:
	//		length to provide padding
	//	ch:
	//		character to pad, defaults to '0'
	//	end:
	//		adds padding at the end if true, otherwise pads at start
	//	example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	//	summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	//	template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	//	map:
	//		hash to search for substitutions
	//	transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	//	thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	//	example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	//	example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	//	example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || dojo.global;
	transform = transform ?
		dojo.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = dojo.getObject(key, false, map);
			if(format){
				value = dojo.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

/*=====
dojo.string.trim = function(str){
	//	summary:
	//		Trims whitespace from both sides of the string
	//	str: String
	//		String to be trimmed
	//	returns: String
	//		Returns the trimmed string
	//	description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	dojo.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

}

if(!dojo._hasResource["dojo.number"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.number"] = true;
dojo.provide("dojo.number");





dojo.getObject("number", true, dojo);

/*=====
dojo.number = {
	// summary: localized formatting and parsing routines for Number
}

dojo.number.__FormatOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	places: Number?
	//		fixed number of decimal places to show.  This overrides any
	//		information in the provided pattern.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means do not round.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	fractional: Boolean?
	//		If false, show no decimal places, overriding places and pattern settings.
	this.pattern = pattern;
	this.type = type;
	this.places = places;
	this.round = round;
	this.locale = locale;
	this.fractional = fractional;
}
=====*/

dojo.number.format = function(/*Number*/value, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Format a Number as a String, using locale-specific settings
	// description:
	//		Create a string from a Number using a known localized pattern.
	//		Formatting patterns appropriate to the locale are chosen from the
	//		[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and
	//		delimiters.
	//		If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
	// value:
	//		the number to be formatted

	options = dojo.mixin({}, options || {});
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	options.customs = bundle;
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
	if(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null
	return dojo.number._applyPattern(value, pattern, options); // String
};

//dojo.number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\.0*#*)?/; // not precise, but good enough
dojo.number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/; // not precise, but good enough

dojo.number._applyPattern = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Apply pattern to format value as a string using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted.
	// pattern:
	//		a pattern string as described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// options: dojo.number.__FormatOptions?
	//		_applyPattern is usually called via `dojo.number.format()` which
	//		populates an extra property in the options parameter, "customs".
	//		The customs object specifies group and decimal parameters if set.

	//TODO: support escapes
	options = options || {};
	var group = options.customs.group,
		decimal = options.customs.decimal,
		patternList = pattern.split(';'),
		positivePattern = patternList[0];
	pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);

	//TODO: only test against unescaped
	if(pattern.indexOf('%') != -1){
		value *= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		value *= 1000; // per mille
	}else if(pattern.indexOf('\u00a4') != -1){
		group = options.customs.currencyGroup || group;//mixins instead?
		decimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?
		pattern = pattern.replace(/\u00a4{1,3}/, function(match){
			var prop = ["symbol", "currency", "displayName"][match.length-1];
			return options[prop] || options.currency || "";
		});
	}else if(pattern.indexOf('E') != -1){
		throw new Error("exponential notation not supported");
	}
	
	//TODO: support @ sig figs?
	var numberPatternRE = dojo.number._numberPatternRE;
	var numberPattern = positivePattern.match(numberPatternRE);
	if(!numberPattern){
		throw new Error("unable to find a number expression in pattern: "+pattern);
	}
	if(options.fractional === false){ options.places = 0; }
	return pattern.replace(numberPatternRE,
		dojo.number._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));
};

dojo.number.round = function(/*Number*/value, /*Number?*/places, /*Number?*/increment){
	//	summary:
	//		Rounds to the nearest value with the given number of decimal places, away from zero
	//	description:
	//		Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	//		Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	//		fractional increments also, such as the nearest quarter.
	//		NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.
	//	value:
	//		The number to round
	//	places:
	//		The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	//		Must be non-negative.
	//	increment:
	//		Rounds next place to nearest value of increment/10.  10 by default.
	//	example:
	//		>>> dojo.number.round(-0.5)
	//		-1
	//		>>> dojo.number.round(162.295, 2)
	//		162.29  // note floating point error.  Should be 162.3
	//		>>> dojo.number.round(10.71, 0, 2.5)
	//		10.75
	var factor = 10 / (increment || 10);
	return (factor * +value).toFixed(places) / factor; // Number
};

if((0.9).toFixed() == 0){
	// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit
	// is just after the rounding place and is >=5
	(function(){
		var round = dojo.number.round;
		dojo.number.round = function(v, p, m){
			var d = Math.pow(10, -p || 0), a = Math.abs(v);
			if(!v || a >= d || a * Math.pow(10, p + 1) < 5){
				d = 0;
			}
			return round(v, p, m) + (v > 0 ? d : -d);
		};
	})();
}

/*=====
dojo.number.__FormatAbsoluteOptions = function(){
	//	decimal: String?
	//		the decimal separator
	//	group: String?
	//		the group separator
	//	places: Number?|String?
	//		number of decimal places.  the range "n,m" will format to m places.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means don't round.
	this.decimal = decimal;
	this.group = group;
	this.places = places;
	this.round = round;
}
=====*/

dojo.number._formatAbsolute = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatAbsoluteOptions?*/options){
	// summary:
	//		Apply numeric pattern to absolute value using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted, ignores sign
	// pattern:
	//		the number portion of a pattern (e.g. `#,##0.00`)
	options = options || {};
	if(options.places === true){options.places=0;}
	if(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit

	var patternParts = pattern.split("."),
		comma = typeof options.places == "string" && options.places.indexOf(","),
		maxPlaces = options.places;
	if(comma){
		maxPlaces = options.places.substring(comma + 1);
	}else if(!(maxPlaces >= 0)){
		maxPlaces = (patternParts[1] || []).length;
	}
	if(!(options.round < 0)){
		value = dojo.number.round(value, maxPlaces, options.round);
	}

	var valueParts = String(Math.abs(value)).split("."),
		fractional = valueParts[1] || "";
	if(patternParts[1] || options.places){
		if(comma){
			options.places = options.places.substring(0, comma);
		}
		// Pad fractional with trailing zeros
		var pad = options.places !== undefined ? options.places : (patternParts[1] && patternParts[1].lastIndexOf("0") + 1);
		if(pad > fractional.length){
			valueParts[1] = dojo.string.pad(fractional, pad, '0', true);
		}

		// Truncate fractional
		if(maxPlaces < fractional.length){
			valueParts[1] = fractional.substr(0, maxPlaces);
		}
	}else{
		if(valueParts[1]){ valueParts.pop(); }
	}

	// Pad whole with leading zeros
	var patternDigits = patternParts[0].replace(',', '');
	pad = patternDigits.indexOf("0");
	if(pad != -1){
		pad = patternDigits.length - pad;
		if(pad > valueParts[0].length){
			valueParts[0] = dojo.string.pad(valueParts[0], pad);
		}

		// Truncate whole
		if(patternDigits.indexOf("#") == -1){
			valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
		}
	}

	// Add group separators
	var index = patternParts[0].lastIndexOf(','),
		groupSize, groupSize2;
	if(index != -1){
		groupSize = patternParts[0].length - index - 1;
		var remainder = patternParts[0].substr(0, index);
		index = remainder.lastIndexOf(',');
		if(index != -1){
			groupSize2 = remainder.length - index - 1;
		}
	}
	var pieces = [];
	for(var whole = valueParts[0]; whole;){
		var off = whole.length - groupSize;
		pieces.push((off > 0) ? whole.substr(off) : whole);
		whole = (off > 0) ? whole.slice(0, off) : "";
		if(groupSize2){
			groupSize = groupSize2;
			delete groupSize2;
		}
	}
	valueParts[0] = pieces.reverse().join(options.group || ",");

	return valueParts.join(options.decimal || ".");
};

/*=====
dojo.number.__RegexpOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	places: Number|String?
	//		number of decimal places to accept: Infinity, a positive number, or
	//		a range "n,m".  Defined by pattern or Infinity if pattern not provided.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.places = places;
}
=====*/
dojo.number.regexp = function(/*dojo.number.__RegexpOptions?*/options){
	//	summary:
	//		Builds the regular needed to parse a number
	//	description:
	//		Returns regular expression with positive and negative match, group
	//		and decimal separators
	return dojo.number._parseInfo(options).regexp; // String
};

dojo.number._parseInfo = function(/*Object?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale),
		pattern = options.pattern || bundle[(options.type || "decimal") + "Format"],
//TODO: memoize?
		group = bundle.group,
		decimal = bundle.decimal,
		factor = 1;

	if(pattern.indexOf('%') != -1){
		factor /= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		factor /= 1000; // per mille
	}else{
		var isCurrency = pattern.indexOf('\u00a4') != -1;
		if(isCurrency){
			group = bundle.currencyGroup || group;
			decimal = bundle.currencyDecimal || decimal;
		}
	}

	//TODO: handle quoted escapes
	var patternList = pattern.split(';');
	if(patternList.length == 1){
		patternList.push("-" + patternList[0]);
	}

	var re = dojo.regexp.buildGroupRE(patternList, function(pattern){
		pattern = "(?:"+dojo.regexp.escapeString(pattern, '.')+")";
		return pattern.replace(dojo.number._numberPatternRE, function(format){
			var flags = {
				signed: false,
				separator: options.strict ? group : [group,""],
				fractional: options.fractional,
				decimal: decimal,
				exponent: false
				},

				parts = format.split('.'),
				places = options.places;

			// special condition for percent (factor != 1)
			// allow decimal places even if not specified in pattern
			if(parts.length == 1 && factor != 1){
			    parts[1] = "###";
			}
			if(parts.length == 1 || places === 0){
				flags.fractional = false;
			}else{
				if(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0') + 1 : Infinity; }
				if(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified
				if(!options.places && (places < parts[1].length)){ places += "," + parts[1].length; }
				flags.places = places;
			}
			var groups = parts[0].split(',');
			if(groups.length > 1){
				flags.groupSize = groups.pop().length;
				if(groups.length > 1){
					flags.groupSize2 = groups.pop().length;
				}
			}
			return "("+dojo.number._realNumberRegexp(flags)+")";
		});
	}, true);

	if(isCurrency){
		// substitute the currency symbol for the placeholder in the pattern
		re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function(match, before, target, after){
			var prop = ["symbol", "currency", "displayName"][target.length-1],
				symbol = dojo.regexp.escapeString(options[prop] || options.currency || "");
			before = before ? "[\\s\\xa0]" : "";
			after = after ? "[\\s\\xa0]" : "";
			if(!options.strict){
				if(before){before += "*";}
				if(after){after += "*";}
				return "(?:"+before+symbol+after+")?";
			}
			return before+symbol+after;
		});
	}

//TODO: substitute localized sign/percent/permille/etc.?

	// normalize whitespace and return
	return {regexp: re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: group, decimal: decimal, factor: factor}; // Object
};

/*=====
dojo.number.__ParseOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by pattern
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.fractional = fractional;
}
=====*/
dojo.number.parse = function(/*String*/expression, /*dojo.number.__ParseOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Number, using
	//		locale-specific settings.
	// description:
	//		Create a Number from a string using a known localized pattern.
	//		Formatting patterns are chosen appropriate to the locale
	//		and follow the syntax described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
    	//		Note that literal characters in patterns are not supported.
	// expression:
	//		A string representation of a Number
	var info = dojo.number._parseInfo(options),
		results = (new RegExp("^"+info.regexp+"$")).exec(expression);
	if(!results){
		return NaN; //NaN
	}
	var absoluteMatch = results[1]; // match for the positive expression
	if(!results[1]){
		if(!results[2]){
			return NaN; //NaN
		}
		// matched the negative pattern
		absoluteMatch =results[2];
		info.factor *= -1;
	}

	// Transform it to something Javascript can parse as a number.  Normalize
	// decimal point and strip out group separators or alternate forms of whitespace
	absoluteMatch = absoluteMatch.
		replace(new RegExp("["+info.group + "\\s\\xa0"+"]", "g"), "").
		replace(info.decimal, ".");
	// Adjust for negative sign, percent, etc. as necessary
	return absoluteMatch * info.factor; //Number
};

/*=====
dojo.number.__RealNumberRegexpFlags = function(){
	//	places: Number?
	//		The integer number of decimal places or a range given as "n,m".  If
	//		not given, the decimal part is optional and the number of places is
	//		unlimited.
	//	decimal: String?
	//		A string for the character used as the decimal point.  Default
	//		is ".".
	//	fractional: Boolean?|Array?
	//		Whether decimal places are used.  Can be true, false, or [true,
	//		false].  Default is [true, false] which means optional.
	//	exponent: Boolean?|Array?
	//		Express in exponential notation.  Can be true, false, or [true,
	//		false]. Default is [true, false], (i.e. will match if the
	//		exponential part is present are not).
	//	eSigned: Boolean?|Array?
	//		The leading plus-or-minus sign on the exponent.  Can be true,
	//		false, or [true, false].  Default is [true, false], (i.e. will
	//		match if it is signed or unsigned).  flags in regexp.integer can be
	//		applied.
	this.places = places;
	this.decimal = decimal;
	this.fractional = fractional;
	this.exponent = exponent;
	this.eSigned = eSigned;
}
=====*/

dojo.number._realNumberRegexp = function(/*dojo.number.__RealNumberRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression to match a real number in exponential
	//		notation

	// assign default values to missing parameters
	flags = flags || {};
	//TODO: use mixin instead?
	if(!("places" in flags)){ flags.places = Infinity; }
	if(typeof flags.decimal != "string"){ flags.decimal = "."; }
	if(!("fractional" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }
	if(!("exponent" in flags)){ flags.exponent = [true, false]; }
	if(!("eSigned" in flags)){ flags.eSigned = [true, false]; }

	var integerRE = dojo.number._integerRegexp(flags),
		decimalRE = dojo.regexp.buildGroupRE(flags.fractional,
		function(q){
			var re = "";
			if(q && (flags.places!==0)){
				re = "\\" + flags.decimal;
				if(flags.places == Infinity){
					re = "(?:" + re + "\\d+)?";
				}else{
					re += "\\d{" + flags.places + "}";
				}
			}
			return re;
		},
		true
	);

	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
		function(q){
			if(q){ return "([eE]" + dojo.number._integerRegexp({ signed: flags.eSigned}) + ")"; }
			return "";
		}
	);

	var realRE = integerRE + decimalRE;
	// allow for decimals without integers, e.g. .25
	if(decimalRE){realRE = "(?:(?:"+ realRE + ")|(?:" + decimalRE + "))";}
	return realRE + exponentRE; // String
};

/*=====
dojo.number.__IntegerRegexpFlags = function(){
	//	signed: Boolean?
	//		The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	//		Default is `[true, false]`, (i.e. will match if it is signed
	//		or unsigned).
	//	separator: String?
	//		The character used as the thousands separator. Default is no
	//		separator. For more than one symbol use an array, e.g. `[",", ""]`,
	//		makes ',' optional.
	//	groupSize: Number?
	//		group size between separators
	//	groupSize2: Number?
	//		second grouping, where separators 2..n have a different interval than the first separator (for India)
	this.signed = signed;
	this.separator = separator;
	this.groupSize = groupSize;
	this.groupSize2 = groupSize2;
}
=====*/

dojo.number._integerRegexp = function(/*dojo.number.__IntegerRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression that matches an integer

	// assign default values to missing parameters
	flags = flags || {};
	if(!("signed" in flags)){ flags.signed = [true, false]; }
	if(!("separator" in flags)){
		flags.separator = "";
	}else if(!("groupSize" in flags)){
		flags.groupSize = 3;
	}

	var signRE = dojo.regexp.buildGroupRE(flags.signed,
		function(q){ return q ? "[-+]" : ""; },
		true
	);

	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
		function(sep){
			if(!sep){
				return "(?:\\d+)";
			}

			sep = dojo.regexp.escapeString(sep);
			if(sep == " "){ sep = "\\s"; }
			else if(sep == "\xa0"){ sep = "\\s\\xa0"; }

			var grp = flags.groupSize, grp2 = flags.groupSize2;
			//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933
			if(grp2){
				var grp2RE = "(?:0|[1-9]\\d{0," + (grp2-1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
				return ((grp-grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp-1) + "}))" : grp2RE;
			}
			return "(?:0|[1-9]\\d{0," + (grp-1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
		},
		true
	);

	return signRE + numberRE; // String
};

}

if(!dojo._hasResource["dojox.validate.regexp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.validate.regexp"] = true;
dojo.provide("dojox.validate.regexp");



dojo.mixin(dojox.validate.regexp, {
	
	ipAddress: function(/*Object?*/flags){
		// summary: Builds a RE that matches an IP Address
		//
		// description:
		//  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
		//  Supports 2 formats for Ipv6.
		//
		// flags  An object.  All flags are boolean with default = true.
		//    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
		//    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
		//    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
		//    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
		//    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
		//      Case insensitive.  Zero padding allowed.
		//    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
		//	FIXME: ipv6 can be written multiple ways IIRC
		//    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
		//      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.allowDottedDecimal != "boolean"){ flags.allowDottedDecimal = true; }
		if(typeof flags.allowDottedHex != "boolean"){ flags.allowDottedHex = true; }
		if(typeof flags.allowDottedOctal != "boolean"){ flags.allowDottedOctal = true; }
		if(typeof flags.allowDecimal != "boolean"){ flags.allowDecimal = true; }
		if(typeof flags.allowHex != "boolean"){ flags.allowHex = true; }
		if(typeof flags.allowIPv6 != "boolean"){ flags.allowIPv6 = true; }
		if(typeof flags.allowHybrid != "boolean"){ flags.allowHybrid = true; }

		// decimal-dotted IP address RE.
		var dottedDecimalRE =
			// Each number is between 0-255.  Zero padding is not allowed.
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.
		var dottedHexRE = "(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]";

		// dotted octal IP address RE.  Each number is between 0000-0377.
		// Zero padding is allowed, but each number must have at least 4 characters.
		var dottedOctalRE = "(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]";

		// decimal IP address RE.  A decimal number between 0-4294967295.
		var decimalRE =  "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" +
			"4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";

		// hexadecimal IP address RE.
		// A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.
		var hexRE = "0[xX]0*[\\da-fA-F]{1,8}";

		// IPv6 address RE.
		// The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,
		// where x is between 0000-ffff. Zero padding is optional. Case insensitive.
		var ipv6RE = "([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}";

		// IPv6/IPv4 Hybrid address RE.
		// The format is written as six groups of four hexadecimal digits,
		// followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d
		var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" +
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// Build IP Address RE
		var a = [];
		if(flags.allowDottedDecimal){ a.push(dottedDecimalRE); }
		if(flags.allowDottedHex){ a.push(dottedHexRE); }
		if(flags.allowDottedOctal){ a.push(dottedOctalRE); }
		if(flags.allowDecimal){ a.push(decimalRE); }
		if(flags.allowHex){ a.push(hexRE); }
		if(flags.allowIPv6){ a.push(ipv6RE); }
		if(flags.allowHybrid){ a.push(hybridRE); }

		var ipAddressRE = "";
		if(a.length > 0){
			ipAddressRE = "(" + a.join("|") + ")";
		}
		return ipAddressRE; // String
	},

	host: function(/*Object?*/flags){
		// summary: Builds a RE that matches a host
		// description: A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.
		// flags: An object.
		//	  flags.allowNamed Allow a named host for local networks. Default is false.
		//    flags.allowIP  Allow an IP address for hostname.  Default is true.
		//    flags.allowLocal  Allow the host to be "localhost".  Default is false.
		//    flags.allowPort  Allow a port number to be present.  Default is true.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};

		if(typeof flags.allowIP != "boolean"){ flags.allowIP = true; }
		if(typeof flags.allowLocal != "boolean"){ flags.allowLocal = false; }
		if(typeof flags.allowPort != "boolean"){ flags.allowPort = true; }
		if(typeof flags.allowNamed != "boolean"){ flags.allowNamed = false; }

		//TODO: support unicode hostnames?
		// Domain name labels can not end with a dash.
		var domainLabelRE = "(?:[\\da-zA-Z](?:[-\\da-zA-Z]{0,61}[\\da-zA-Z])?)";
		var domainNameRE = "(?:[a-zA-Z](?:[-\\da-zA-Z]{0,6}[\\da-zA-Z])?)"; // restricted version to allow backwards compatibility with allowLocal, allowIP

		// port number RE
		var portRE = flags.allowPort ? "(\\:\\d+)?" : "";

		// build host RE
		var hostNameRE = "((?:" + domainLabelRE + "\\.)+" + domainNameRE + "\\.?)";
		if(flags.allowIP){ hostNameRE += "|" +  dojox.validate.regexp.ipAddress(flags); }
		if(flags.allowLocal){ hostNameRE += "|localhost"; }
		if(flags.allowNamed){ hostNameRE += "|^[^-][a-zA-Z0-9_-]*"; }
		return "(" + hostNameRE + ")" + portRE; // String

	},

	url: function(/*Object?*/flags){
		// summary: Builds a regular expression that matches a URL
		//
		// flags: An object
		//    flags.scheme  Can be true, false, or [true, false].
		//      This means: required, not allowed, or match either one.
		//    flags in regexp.host can be applied.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(!("scheme" in flags)){ flags.scheme = [true, false]; }

		// Scheme RE
		var protocolRE = dojo.regexp.buildGroupRE(flags.scheme,
			function(q){ if(q){ return "(https?|ftps?)\\://"; } return ""; }
		);

		// Path and query and anchor RE
		var pathRE = "(/(?:[^?#\\s/]+/)*(?:[^?#\\s/]+(?:\\?[^?#\\s/]*)?(?:#[A-Za-z][\\w.:-]*)?)?)?";

		return protocolRE + dojox.validate.regexp.host(flags) + pathRE;
	},

	emailAddress: function(/*Object?*/flags){

		// summary: Builds a regular expression that matches an email address
		//
		//flags: An object
		//    flags.allowCruft  Allow address like <mailto:foo@yahoo.com>.  Default is false.
		//    flags in regexp.host can be applied.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if (typeof flags.allowCruft != "boolean") { flags.allowCruft = false; }
		flags.allowPort = false; // invalid in email addresses

		// user name RE per rfc5322
		var usernameRE = "([!#-'*+\\-\\/-9=?A-Z^-~]+[.])*[!#-'*+\\-\\/-9=?A-Z^-~]+";

		// build emailAddress RE
		var emailAddressRE = usernameRE + "@" + dojox.validate.regexp.host(flags);

		// Allow email addresses with cruft
		if ( flags.allowCruft ) {
			emailAddressRE = "<?(mailto\\:)?" + emailAddressRE + ">?";
		}

		return emailAddressRE; // String
	},

	emailAddressList: function(/*Object?*/flags){
		// summary: Builds a regular expression that matches a list of email addresses.
		//
		// flags: An object.
		//    flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
		//    flags in regexp.emailAddress can be applied.
		//    flags in regexp.host can be applied.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.listSeparator != "string"){ flags.listSeparator = "\\s;,"; }

		// build a RE for an Email Address List
		var emailAddressRE = dojox.validate.regexp.emailAddress(flags);
		var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" +
			emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";

		return emailAddressListRE; // String
	},
	
	numberFormat: function(/*Object?*/flags){
		// summary: Builds a regular expression to match any sort of number based format
		// description:
		//  Use this method for phone numbers, social security numbers, zip-codes, etc.
		//  The RE can match one format or one of multiple formats.
		//
		//  Format
		//    #        Stands for a digit, 0-9.
		//    ?        Stands for an optional digit, 0-9 or nothing.
		//    All other characters must appear literally in the expression.
		//
		//  Example
		//    "(###) ###-####"       ->   (510) 542-9742
		//    "(###) ###-#### x#???" ->   (510) 542-9742 x153
		//    "###-##-####"          ->   506-82-1089       i.e. social security number
		//    "#####-####"           ->   98225-1649        i.e. zip code
		//
		// flags:  An object
		//    flags.format  A string or an Array of strings for multiple formats.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.format == "undefined"){ flags.format = "###-###-####"; }

		// Converts a number format to RE.
		var digitRE = function(format){
			// escape all special characters, except '?'
			return dojo.regexp.escapeString(format, "?")
				// Now replace '?' with Regular Expression
				.replace(/\?/g, "\\d?")
				// replace # with Regular Expression
				.replace(/#/g, "\\d")
			;
		};

		// build RE for multiple number formats
		return dojo.regexp.buildGroupRE(flags.format, digitRE); //String
	}
	
});

dojox.validate.regexp.ca = {
	
	postalCode: function(){
		// summary: String regular Express to match Canadain Postal Codes
		return "([A-Z][0-9][A-Z] [0-9][A-Z][0-9])";
	},

	province: function(){
		// summary: a regular expression to match Canadian Province Abbreviations
		return "(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)";
	}
	
};

dojox.validate.regexp.us = {
	
	state: function(/*Object?*/flags){
		// summary: A regular expression to match US state and territory abbreviations
		//
		// flags  An object.
		//    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
		//    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.allowTerritories != "boolean"){ flags.allowTerritories = true; }
		if(typeof flags.allowMilitary != "boolean"){ flags.allowMilitary = true; }

		// state RE
		var statesRE =
			"AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" +
			"NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";

		// territories RE
		var territoriesRE = "AS|FM|GU|MH|MP|PW|PR|VI";

		// military states RE
		var militaryRE = "AA|AE|AP";

		// Build states and territories RE
		if(flags.allowTerritories){ statesRE += "|" + territoriesRE; }
		if(flags.allowMilitary){ statesRE += "|" + militaryRE; }

		return "(" + statesRE + ")"; // String
	}
	
};


}

if(!dojo._hasResource["dojox.validate._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.validate._base"] = true;
dojo.provide("dojox.validate._base");
dojo.experimental("dojox.validate");

		// dojo core expressions
		// dojo number expressions
 	// additional expressions

dojox.validate.isText = function(/*String*/value, /*Object?*/flags){
	// summary:
	//	Checks if a string has non whitespace characters.
	//	Parameters allow you to constrain the length.
	//
	// value: A string
	// flags: {length: Number, minlength: Number, maxlength: Number}
	//    flags.length  If set, checks if there are exactly flags.length number of characters.
	//    flags.minlength  If set, checks if there are at least flags.minlength number of characters.
	//    flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.
	
	flags = (typeof flags == "object") ? flags : {};
	
	// test for text
	if(/^\s*$/.test(value)){ return false; } // Boolean
	
	// length tests
	if(typeof flags.length == "number" && flags.length != value.length){ return false; } // Boolean
	if(typeof flags.minlength == "number" && flags.minlength > value.length){ return false; } // Boolean
	if(typeof flags.maxlength == "number" && flags.maxlength < value.length){ return false; } // Boolean
	
	return true; // Boolean

}

dojox.validate._isInRangeCache = {};
dojox.validate.isInRange = function(/*String*/value, /*Object?*/flags){
	// summary:
	//	Validates whether a string denoting a number
	//	is between a max and min.
	//
	// value: A string
	// flags: {max:Number, min:Number, decimal:String}
	//    flags.max  A number, which the value must be less than or equal to for the validation to be true.
	//    flags.min  A number, which the value must be greater than or equal to for the validation to be true.
	//    flags.decimal  The character used for the decimal point.  Default is ".".
	
	value = dojo.number.parse(value, flags);
	if(isNaN(value)){
		return false; // Boolean
	}
    
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	var max = (typeof flags.max == "number") ? flags.max : Infinity,
		min = (typeof flags.min == "number") ? flags.min : -Infinity,
		dec = (typeof flags.decimal == "string") ? flags.decimal : ".",
	
		cache = dojox.validate._isInRangeCache,
		cacheIdx = value + "max" + max + "min" + min + "dec" + dec
	;
	if(typeof cache[cacheIdx] != "undefined"){
		return cache[cacheIdx];
	}

	cache[cacheIdx] = !(value < min || value > max);
	return cache[cacheIdx]; // Boolean

}

dojox.validate.isNumberFormat = function(/* String */value, /* Object? */flags){
	// summary: Validates any sort of number based format
	//
	// description:
	//		Validates any sort of number based format. Use it for phone numbers,
	//		social security numbers, zip-codes, etc. The value can be validated
	//		against one format or one of multiple formats.
	//
	// Format Definition
	// |   #        Stands for a digit, 0-9.
	// |   ?        Stands for an optional digit, 0-9 or nothing.
	//    All other characters must appear literally in the expression.
	//
	// example:
	// |  "(###) ###-####"       ->   (510) 542-9742
	// |  "(###) ###-#### x#???" ->   (510) 542-9742 x153
	// |  "###-##-####"          ->   506-82-1089       i.e. social security number
	// |  "#####-####"           ->   98225-1649        i.e. zip code
	//
	// value: A string
	//
	// flags: Object?
	//		FIXME: make pseudo-object for this
	//		format: String
	//
	//    flags.format  A string or an Array of strings for multiple formats.
	//
	// example:
	// | // returns true:
	// | dojox.validate.isNumberFormat("123-45", { format:"###-##" });
	//
	// example:
	// 		Check Multiple formats:
	// |	dojox.validate.isNumberFormat("123-45", {
	// |		format:["### ##","###-##","## ###"]
	// |	});
	//

	var re = new RegExp("^" + dojox.validate.regexp.numberFormat(flags) + "$", "i");
	return re.test(value); // Boolean
}

dojox.validate.isValidLuhn = function(/* String */value){
	// summary: Validate a String value against the Luhn algorithm.
	// description:
	//		Validate a String value against the Luhn algorithm to verify
	//		its integrity.
	
	var sum = 0, parity, curDigit;
	if(!dojo.isString(value)){
		value = String(value);
	}
	value = value.replace(/[- ]/g,''); //ignore dashes and whitespaces
	parity = value.length % 2;

	for(var i = 0; i < value.length; i++){
		curDigit = parseInt(value.charAt(i));
		if(i % 2 == parity){
			curDigit *= 2;
		}
		if(curDigit > 9){
			curDigit -= 9;
		}
		sum += curDigit;
	}
	return !(sum % 10); // Boolean
}


}

if(!dojo._hasResource["dojox.validate"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.validate"] = true;
dojo.provide("dojox.validate");


}

if(!dojo._hasResource["dojo.io.script"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.io.script"] = true;
dojo.provide("dojo.io.script");

dojo.getObject("io", true, dojo);

/*=====
dojo.declare("dojo.io.script.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply to this
		//		type as well, EXCEPT "handleAs". It is not applicable to
		//		dojo.io.script.get() calls, since it is implied by the usage of
		//		"jsonp" (response will be a JSONP call returning JSON)
		//		or the response is pure JavaScript defined in
		//		the body of the script that was attached.
		//	callbackParamName: String
		//		Deprecated as of Dojo 1.4 in favor of "jsonp", but still supported for
		// 		legacy code. See notes for jsonp property.
		//	jsonp: String
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		//	checkString: String
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use callbackParamName instead).
		//	frameDoc: Document
		//		The Document object for a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
		this.callbackParamName = callbackParamName;
		this.jsonp = jsonp;
		this.checkString = checkString;
		this.frameDoc = frameDoc;
	}
});
=====*/
(function(){
	var loadEvent = dojo.isIE ? "onreadystatechange" : "load",
		readyRegExp = /complete|loaded/;

	dojo.io.script = {
		get: function(/*dojo.io.script.__ioArgs*/args){
			//	summary:
			//		sends a get request using a dynamically created script tag.
			var dfd = this._makeScriptDeferred(args);
			var ioArgs = dfd.ioArgs;
			dojo._ioAddQueryToUrl(ioArgs);
	
			dojo._ioNotifyStart(dfd);

			if(this._canAttach(ioArgs)){
				var node = this.attach(ioArgs.id, ioArgs.url, args.frameDoc);

				//If not a jsonp callback or a polling checkString case, bind
				//to load event on the script tag.
				if(!ioArgs.jsonp && !ioArgs.args.checkString){
					var handle = dojo.connect(node, loadEvent, function(evt){
						if(evt.type == "load" || readyRegExp.test(node.readyState)){
							dojo.disconnect(handle);
							ioArgs.scriptLoaded = evt;
						}
					});
				}
			}

			dojo._ioWatch(dfd, this._validCheck, this._ioCheck, this._resHandle);
			return dfd;
		},
	
		attach: function(/*String*/id, /*String*/url, /*Document?*/frameDocument){
			//	summary:
			//		creates a new <script> tag pointing to the specified URL and
			//		adds it to the document.
			//	description:
			//		Attaches the script element to the DOM.  Use this method if you
			//		just want to attach a script to the DOM and do not care when or
			//		if it loads.
			var doc = (frameDocument || dojo.doc);
			var element = doc.createElement("script");
			element.type = "text/javascript";
			element.src = url;
			element.id = id;
			element.charset = "utf-8";
			return doc.getElementsByTagName("head")[0].appendChild(element);
		},
	
		remove: function(/*String*/id, /*Document?*/frameDocument){
			//summary: removes the script element with the given id, from the given frameDocument.
			//If no frameDocument is passed, the current document is used.
			dojo.destroy(dojo.byId(id, frameDocument));
			
			//Remove the jsonp callback on dojo.io.script, if it exists.
			if(this["jsonp_" + id]){
				delete this["jsonp_" + id];
			}
		},
	
		_makeScriptDeferred: function(/*Object*/args){
			//summary:
			//		sets up a Deferred object for an IO request.
			var dfd = dojo._ioSetArgs(args, this._deferredCancel, this._deferredOk, this._deferredError);
	
			var ioArgs = dfd.ioArgs;
			ioArgs.id = dojo._scopeName + "IoScript" + (this._counter++);
			ioArgs.canDelete = false;
	
			//Special setup for jsonp case
			ioArgs.jsonp = args.callbackParamName || args.jsonp;
			if(ioArgs.jsonp){
				//Add the jsonp parameter.
				ioArgs.query = ioArgs.query || "";
				if(ioArgs.query.length > 0){
					ioArgs.query += "&";
				}
				ioArgs.query += ioArgs.jsonp
					+ "="
					+ (args.frameDoc ? "parent." : "")
					+ dojo._scopeName + ".io.script.jsonp_" + ioArgs.id + "._jsonpCallback";
	
				ioArgs.frameDoc = args.frameDoc;
	
				//Setup the Deferred to have the jsonp callback.
				ioArgs.canDelete = true;
				dfd._jsonpCallback = this._jsonpCallback;
				this["jsonp_" + ioArgs.id] = dfd;
			}
			return dfd; // dojo.Deferred
		},
		
		_deferredCancel: function(/*Deferred*/dfd){
			//summary: canceller function for dojo._ioSetArgs call.
	
			//DO NOT use "this" and expect it to be dojo.io.script.
			dfd.canceled = true;
			if(dfd.ioArgs.canDelete){
				dojo.io.script._addDeadScript(dfd.ioArgs);
			}
		},
	
		_deferredOk: function(/*Deferred*/dfd){
			//summary: okHandler function for dojo._ioSetArgs call.
	
			//DO NOT use "this" and expect it to be dojo.io.script.
			var ioArgs = dfd.ioArgs;
	
			//Add script to list of things that can be removed.
			if(ioArgs.canDelete){
				dojo.io.script._addDeadScript(ioArgs);
			}
	
			//Favor JSONP responses, script load events then lastly ioArgs.
			//The ioArgs are goofy, but cannot return the dfd since that stops
			//the callback chain in Deferred. The return value is not that important
			//in that case, probably a checkString case.
			return ioArgs.json || ioArgs.scriptLoaded || ioArgs;
		},
	
		_deferredError: function(/*Error*/error, /*Deferred*/dfd){
			//summary: errHandler function for dojo._ioSetArgs call.
	
			if(dfd.ioArgs.canDelete){
				//DO NOT use "this" and expect it to be dojo.io.script.
				if(error.dojoType == "timeout"){
					//For timeouts, remove the script element immediately to
					//avoid a response from it coming back later and causing trouble.
					dojo.io.script.remove(dfd.ioArgs.id, dfd.ioArgs.frameDoc);
				}else{
					dojo.io.script._addDeadScript(dfd.ioArgs);
				}
			}
			console.log("dojo.io.script error", error);
			return error;
		},
	
		_deadScripts: [],
		_counter: 1,
	
		_addDeadScript: function(/*Object*/ioArgs){
			//summary: sets up an entry in the deadScripts array.
			dojo.io.script._deadScripts.push({id: ioArgs.id, frameDoc: ioArgs.frameDoc});
			//Being extra paranoid about leaks:
			ioArgs.frameDoc = null;
		},
	
		_validCheck: function(/*Deferred*/dfd){
			//summary: inflight check function to see if dfd is still valid.
	
			//Do script cleanup here. We wait for one inflight pass
			//to make sure we don't get any weird things by trying to remove a script
			//tag that is part of the call chain (IE 6 has been known to
			//crash in that case).
			var _self = dojo.io.script;
			var deadScripts = _self._deadScripts;
			if(deadScripts && deadScripts.length > 0){
				for(var i = 0; i < deadScripts.length; i++){
					//Remove the script tag
					_self.remove(deadScripts[i].id, deadScripts[i].frameDoc);
					deadScripts[i].frameDoc = null;
				}
				dojo.io.script._deadScripts = [];
			}
	
			return true;
		},
	
		_ioCheck: function(/*Deferred*/dfd){
			//summary: inflight check function to see if IO finished.
			var ioArgs = dfd.ioArgs;
			//Check for finished jsonp
			if(ioArgs.json || (ioArgs.scriptLoaded && !ioArgs.args.checkString)){
				return true;
			}
	
			//Check for finished "checkString" case.
			var checkString = ioArgs.args.checkString;
			if(checkString && eval("typeof(" + checkString + ") != 'undefined'")){
				return true;
			}
	
			return false;
		},
	
		_resHandle: function(/*Deferred*/dfd){
			//summary: inflight function to handle a completed response.
			if(dojo.io.script._ioCheck(dfd)){
				dfd.callback(dfd);
			}else{
				//This path should never happen since the only way we can get
				//to _resHandle is if _ioCheck is true.
				dfd.errback(new Error("inconceivable dojo.io.script._resHandle error"));
			}
		},
	
		_canAttach: function(/*Object*/ioArgs){
			//summary: A method that can be overridden by other modules
			//to control when the script attachment occurs.
			return true;
		},
		
		_jsonpCallback: function(/*JSON Object*/json){
			//summary:
			//		generic handler for jsonp callback. A pointer to this function
			//		is used for all jsonp callbacks.  NOTE: the "this" in this
			//		function will be the Deferred object that represents the script
			//		request.
			this.ioArgs.json = json;
		}
	};
})();

}

if(!dojo._hasResource['bfree.api.Server']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Server'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:03 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Server');





//dojo.require("dojo.io.XhrIframeProxy");

dojo.declare('bfree.api.Server', [bfree.api._Object], {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    isValid: function(){
        var valid=true;

        if(String.isEmpty(this.name)){
            valid=false;
        }

        if(this.protocol!='http'&&this.protocol!='https'){
            valid=false;
        }

        if(String.isEmpty(this.host)){
            valid=false;
        }

        if(!bfree.api.Server.validateHost(this)){
            valid=false;
        }

        if(!bfree.api.Server.validatePort(this.port)){
            valid=false;
        }
        return valid;
    }
});

bfree.api.Server.validateHost=function(server){
    var regex = new RegExp('^'+dojox.validate.regexp.url({allowPort: false, allowDottedHex: false, allowDottedOctal: false, allowDecimal: false, allowHex: false})+'$');
//    console.log(regex.test(host));
//    console.log(regex.exec(host));
//    console.log(host.match(regex));
//    if(host.indexOf('www.')!=0){
//        return false;
//    }

    var valid=regex.test(server.host);

    return valid;
};

bfree.api.Server.validatePort=function(value){
    if(value==null||value==''){
        return true;
    }

    value=value.toString();

    //prevents numbers with trailing
    //characters from being valid
    var i=Number(value);

    if(isNaN(i)){
        return false;
    }

    //Number(value) parses 2e3 as a valid number
    if(value.indexOf('e')>=0){
        return false;
    }

    return (i>=0&&i<=65535)
};

bfree.api.Server.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'protocol': {
 	        type: 'string',
 		    'default': ''
 		},
        'host': {
 	        type: 'string',
 		    'default': ''
 		},
        'port': {
 	        type: 'integer',
 		    'default': ''
 		},
        'active': {
 	        type: 'boolean',
 		    'default': ''
 		},
        'current': {
 	        type: 'boolean',
 		    'default': ''
 		},
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        }
 	},
	prototype: new bfree.api.Server()
 };



}

if(!dojo._hasResource['bfree.api.Servers']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Servers'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:08 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Servers');




dojo.declare('bfree.api.Servers', [bfree.api._Collection],{

	/**
	 * Creates a new instance of bfree.api.Libraries
 	 * @constructor
	 */
	constructor: function(args){
		this.target = bfree.api.Servers.TRGT;
		this.schema = bfree.api.Server.schema;
		this.cache = true;

		this._initialize();
	}
});

bfree.api.Servers.TRGT = '/servers';

}

if(!dojo._hasResource['bfree.api._Configurable']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api._Configurable'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 29/01/12
 * Time: 7:55 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api._Configurable');

dojo.declare('bfree.api._Configurable', null,{

    configuration: {
        configuration_settings: []
    },

    constructor: function(args){

    },

    getValue: function(name){

        var value = null;

        dojo.some(this.configuration.configuration_settings, function(setting, idx){
            if(setting.name.toLowerCase() == name.toLowerCase()){
                value = setting.value;
                return true;
            }
            return false
        }, this);

        return value;
    }

});

}

if(!dojo._hasResource['bfree.api.Group']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Group'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 26/09/11
 * Time: 10:55 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Group');



dojo.declare('bfree.api.Group', [bfree.api._Object], {
    description: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    isValid: function(){
        var isValid = true;

		if (String.isEmpty(this.name.trim())) {
            isValid = false;
		}

		return isValid;
	}

});

bfree.api.Group.schema = {
	type: 'object',
	properties: {
		'id': {
			type: 'integer'
		},
        'name': {
			type: 'string',
			'default': ''
		},
        'description': {
            type: 'string'
        },
        'active_users': {
            type: 'array',
            items: {
                type: 'integer'
            }
        },
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'created_by': {
            type: 'string'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_by': {
            type: 'string'
        }
	},
	prototype: new bfree.api.Group()
};

}

if(!dojo._hasResource['bfree.api.Groups']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Groups'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 26/09/11
 * Time: 10:55 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Groups');




dojo.declare('bfree.api.Groups', [bfree.api._Collection],{
    zone: null,

    _matchesQuery: function(item,request){

        //query returns array of choice list values,
        //exclude them.
        if(dojo.isArray(item) || (item.hasOwnProperty('user_id')))
            return false;

        var query = request.query;
        var ignoreCase = request.queryOptions && request.queryOptions.ignoreCase;
        for(var i in query){
            // if anything doesn't match, than this should be in the query
            var match = query[i];
            var value = this.getValue(item,i);
            if((typeof match == 'string' && (match.match(/[\*\.]/) || ignoreCase)) ?
                !dojo.data.util.filter.patternToRegExp(match, ignoreCase).test(value) :
                value != match){
                return false;
            }
        }
        return true;
    },

    constructor: function(args){
        this.zone = args.zone;
        this.target = dojo.replace(bfree.api.Groups.TRGT, this.zone);
		this.schema = bfree.api.Group.schema;
		this.cache = true;

		this._initialize();
        this.store.matchesQuery  = dojo.hitch(this, this._matchesQuery);
    },

    getAdmin: function(){
        var admin = null;

        this.forEach(function(item){
            if(item.is_admin)
                admin = item;
        }, this);

        return admin;
    },

    getEveryone: function(){
        var everyone = null;

        this.forEach(function(item){
            if(item.is_everyone)
                everyone = item;
        }, this);

        return everyone;
    }

});

bfree.api.Groups.TRGT = '/zones/{subdomain}/groups';

}

if(!dojo._hasResource['bfree.api._Securable']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api._Securable'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 19/10/11
 * Time: 9:58 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api._Securable');



dojo.declare('bfree.api._Securable', null,{

    securable_type: null,
    active_permissions: 0x00000000,

    constructor: function(args){

    },

    hasRights: function(permissionFlag){
        return ((this.active_permissions & permissionFlag) == permissionFlag);
    },

    getAcl: function(zone){
        var url = dojo.replace(bfree.api._Securable.GETACL_URL, [zone.subdomain, this.id, this.securable_type] );
        var getData = null;

        var results = bfree.api.XhrHelper.doGetAction({
            target: url,
            getData: getData
        });

        return new bfree.api.Acl(results);
    },

    setAcl: function(zone, acl){
        var url = dojo.replace(bfree.api._Securable.SETACL_URL, [zone.subdomain, this.id, this.securable_type]);
        var data = acl;

        return bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: data
        });


    }

});

bfree.api._Securable.types = {
    'Library': 'Library',
    'Folder': 'Folder',
    'Document': 'Document',
    'Reference': 'Reference'
}

bfree.api._Securable.permissions = {
    'NONE':             0x00000000,
    'VIEW':             0x00000001,
    'READ_METADATA':    0x00000002,
    'WRITE_METADATA':   0x00000004,
    'VERSION':          0x00000008,
    'CREATE_DOCUMENTS': 0x00000010,
    'CREATE_FOLDERS':   0x00000020,
    'CREATE_VIEWS':     0x00000040,
    'DELETE_ITEMS':     0x00000080,
    'READ_ACL':         0x00000100,
    'WRITE_ACL':        0x00000200,
    'ADMIN':            0x7FFFFFF
}


bfree.api._Securable.GETACL_URL = '/zones/{0}/acls/{1}.json?securable_type={2}';
bfree.api._Securable.SETACL_URL = '/zones/{0}/acls/{1}.json?securable_type={2}';

}

if(!dojo._hasResource['bfree.api.ChoiceList']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ChoiceList'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.ChoiceList');


dojo.declare('bfree.api.ChoiceList', [bfree.api._Object],{

	constructor: function(/* Object */args){
        dojo.safeMixin(this, ((!args) ? { } : args));
	},

    isValid: function(){
        var isValid = true;

		if (String.isEmpty(this.name.trim())) {
            isValid = false;
		}

        if((!this.data_type_id) || (this.data_type_id < 1)){
            isValid = false;
        }

		return isValid;
	}
});

bfree.api.ChoiceList.schema = {
	type: 'object',
	properties: {
		'id': {
			type: 'integer'
		},
		'name': {
			type: 'string',
			'default': 'Property'
		},
		'data_type_id': {
			type: 'integer'
		},
        'choice_values': {
            type: 'array',
            'default': [],
            items: {
                type: 'object',
                properties: {
                    'sort_order': {
                        type: 'integer'
                    },
                    'name': {
                        type: 'string'
                    },
                    'value': {
                        type: 'string'
                    }
                }
            }
        },
        'created_at': {
            type: 'string',
            format: 'date-time',
            'default': dojo.date.stamp.toISOString(new Date(), {zulu: true})
        },
        'created_by': {
            type: 'string',
            'default': ''
        },
        'updated_at': {
            type: 'string',
            format: 'date-time',
            'default': dojo.date.stamp.toISOString(new Date(), {zulu: true})
        },
        'updated_by': {
            type: 'string',
            'default': ''
        }
	},
    prototype: new bfree.api.ChoiceList()
};

}

if(!dojo._hasResource['bfree.api.DataType']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.DataType'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 2:46 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.DataType');

dojo.declare('bfree.api.DataType', null, {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    defaultMaxLength: function(){
        var max_length = null;

        switch(this.prefix){
            case 'str':
                max_length = 255;
                break;
            case 'txt':
                max_length = 4096;
                break;
        }

        return max_length;

    },

    isBoolean: function(){
        return (this.prefix == 'bln');
    },

    isDateTime: function(){
        return (this.prefix == 'dtt');
    },

    isFloat: function(){
        return (this.prefix == 'flt');
    },

    isInteger: function(){
        return (this.prefix == 'int');
    },

    isString: function(){
        return (this.prefix == 'str');
    },

    isText: function(){
        return (this.prefix == 'txt');
    }



});

bfree.api.DataType.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'prefix': {
            type: 'string'
        }
 	},
	prototype: new bfree.api.DataType()
 };

}

if(!dojo._hasResource['bfree.api.DataTypes']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.DataTypes'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 2:46 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.DataTypes');



dojo.declare('bfree.api.DataTypes', [bfree.api._Collection],{

    constructor: function(args){
        this.zone = null;
        this.target = bfree.api.DataTypes.TRGT;
		this.schema = bfree.api.DataType.schema;
		this.cache = true;

		this._initialize();
    }

});

bfree.api.DataTypes.types = {
    'VOID':     0,
    'BOOLEAN':  1,
    'INTEGER':  2,
    'FLOAT':    3,
    'DATETIME': 4,
    'STRING':   5,
    'TEXT':     6
};

bfree.api.DataTypes.TRGT = '/data_types';

}

if(!dojo._hasResource['bfree.api.ChoiceLists']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ChoiceLists'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.ChoiceLists');





dojo.declare('bfree.api.ChoiceLists', [bfree.api._Collection],{

    _matchesQuery: function(item,request){

        //query returns array of choice list values,
        //exclude them.
        if(dojo.isArray(item) || (item.hasOwnProperty('sort_order')))
            return false;

        var query = request.query;
        var ignoreCase = request.queryOptions && request.queryOptions.ignoreCase;
        for(var i in query){
            // if anything doesn't match, than this should be in the query
            var match = query[i];
            var value = this.getValue(item,i);
            if((typeof match == 'string' && (match.match(/[\*\.]/) || ignoreCase)) ?
                !dojo.data.util.filter.patternToRegExp(match, ignoreCase).test(value) :
                value != match){
                return false;
            }
        }
        return true;
    },

	constructor: function(/* Object */args){
        this.zone=args.zone;
        this.library=args.library;
		this.target = dojo.replace(bfree.api.ChoiceLists.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.ChoiceList.schema;
        this.cache = true;

        this._initialize();
        this.store.matchesQuery  = dojo.hitch(this, this._matchesQuery);

	},

	isValidItem: function(args){
		var isValid = this.inherited(arguments);
		var item = args.item;
		var choiceValues = args.choice_values;
		
		if(!isValid) return;
		
		if (item.name.length < 1) {
			throw new Error('Choice List \'Name\' is empty or invalid');
		}
		
		if((!choiceValues) || (choiceValues.length < 1)){
			throw new Error('Choice List \'' + item.name + '\' does not contain any values');
		}
				
		return true;
	}
});

bfree.api.ChoiceLists.TRGT="/zones/{0}/libraries/{1}/choice_lists"

}

if(!dojo._hasResource['bfree.api.Acl']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Acl'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 12/10/11
 * Time: 2:53 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Acl');

dojo.declare('bfree.api.Acl', null, {

    id: null,
    inherited: false,
    acl_entries: [],

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    getAdministrator: function(){
        for(var i = 0; i < this.acl_entries.length; i++){
            var entry = this.acl_entries[i];
            if((entry.grantee_type.toLowerCase() == 'group') && (entry.grantee.name.toLowerCase() == 'administrators')){
                return this.acl_entries[i];
            }
        }
    },

    getEveryone: function(zone){
        var everyoneEntry = null;


        dojo.some(this.acl_entries, function(acl_entry, idx){
            var grantee = (acl_entry.grantee_type.toLowerCase() == 'group') ?
                             zone.getGroups().fetchById({id: acl_entry.grantee_id}) :
                             zone.getUsers().fetchById({id: acl_entry.grantee_id});

            if(grantee.isInstanceOf(bfree.api.Group) && grantee.is_everyone){
                everyoneEntry = acl_entry;
            }

            return (everyoneEntry != null);
        }, this);

        return everyoneEntry;
    },

    hasAccess: function(zone, activeUser, activeGroup){

        var explicitUser = Number.NaN;
        var explicitGroup = Number.NaN;
        var everyone = Number.NaN;

        dojo.forEach(this.acl_entries, function(entry, idx){
            var role = zone.getRoles().fetchById({id: entry.role_id});

            var grantee = (entry.grantee_type.toLowerCase() == 'group') ?
                             zone.getGroups().fetchById({id: entry.grantee_id}) :
                             zone.getUsers().fetchById({id: entry.grantee_id});

            if((grantee.isInstanceOf(bfree.api.User)) && (entry.grantee_id == activeUser.id)){
                explicitUser = role.permissions;
            }
            else if((grantee.isInstanceOf(bfree.api.Group)) && (entry.grantee_id == activeGroup.id)){
                explicitGroup = role.permissions;
            }
            else if((grantee.isInstanceOf(bfree.api.Group)) && (grantee.is_everyone)){
                everyone = role.permissions;
            }

        }, this);


        if(!isNaN(explicitUser))
            return (explicitUser > 0);
        if(!isNaN(explicitGroup))
            return (explicitGroup > 0);
        if(!isNaN(everyone))
            return (everyone > 0);

        return false;
    }

});

bfree.api.Acl.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
        'inherit_state':{
            type: 'integer'
        },
        'inherited': {
            type: 'boolean',
            'default': false
        }
 	},
	prototype: new bfree.api.Acl()
 };

}

if(!dojo._hasResource['bfree.api.Operator']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Operator'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/11/11
 * Time: 8:46 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Operator');

dojo.declare('bfree.api.Operator', null, {

    id: null,
    name: null,
    value: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    }

});

bfree.api.Operator.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'value': {
            type: 'string'
        },
        'no_rhs': {
            type: 'boolean'
        }

 	},
	prototype: new bfree.api.Operator()
 };


}

if(!dojo._hasResource['bfree.api.Operators']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Operators'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/11/11
 * Time: 8:46 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Operators');



dojo.declare('bfree.api.Operators', [bfree.api._Collection],{

    _andOp: null,

    _fetch_onComplete: function(items, request){

        this.isLoaded = true;
		if((items != null) && (items.length > 1)){
			this.first = items[0];
		}

        dojo.forEach(items, function(item,idx){
            if(item.name == 'and')
                this._andOp = item;
        }, this);

	},

    constructor: function(args){
        this.target = bfree.api.Operators.TRGT;
		this.schema = bfree.api.Operator.schema;
		this.cache = true;

		this._initialize();
    },

    byDataType: function(id){
        var ops = []

        this.forEach(function(item){
            if(item.data_type_id == id)
                ops.push(item);
        }, this);

        return ops;
    },

    getAndOp: function(){
        return this._andOp;
    }


});

bfree.api.Operators.TRGT = '/operators';

}

if(!dojo._hasResource['bfree.api.Application']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Application'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 24/11/11
 * Time: 1:30 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Application');




dojo.declare('bfree.api.Application', null,{
});


bfree.api.Application._data_types = null;
bfree.api.Application._operators = null;

bfree.api.Application.getDataTypes = function(){

    if(!bfree.api.Application._data_types){
        bfree.api.Application._data_types = new bfree.api.DataTypes();
        bfree.api.Application._data_types.fetch();
    }
    return bfree.api.Application._data_types;
};

bfree.api.Application.getOperators = function(){

    if(!bfree.api.Application._operators){
        bfree.api.Application._operators = new bfree.api.Operators();
        bfree.api.Application._operators.fetch();
    }
    return bfree.api.Application._operators;
};

}

if(!dojo._hasResource['bfree.api.Version']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Version'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/09/11
 * Time: 12:00 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Version');



dojo.declare('bfree.api.Version', [bfree.api._Object], {
    zone: null,
    library: null,
    document: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    copyLocal: function(args){
        var zone = args.zone;
        var library = args.library;
        var document = args.document;

        var url = dojo.replace(bfree.api.Version.CP_TRGT, [zone.subdomain, library.id, document.id, this.id]);
        bfree.api.Utilities.saveUrl({
            url: url,
            window_name: 'versa_save'
        });

	},

    view: function(args){
        var zone = args.zone;
        var library = args.library;
        var document = args.document;

        var url = dojo.replace(bfree.api.Version.VW_TRGT, [zone.subdomain, library.id, document.id, this.id]);

        bfree.api.Utilities.viewUrl({
            windowBox: args.windowBox,
            url: url,
            window_name: 'versa_viewer'
        });
	}

});

bfree.api.Version.VW_TRGT = '/zones/{0}/libraries/{1}/documents/{2}/download/?disposition=inline&version_id={3}';
bfree.api.Version.CP_TRGT = '/zones/{0}/libraries/{1}/documents/{2}/download/?disposition=attachment&version_id={3}';


bfree.api.Version.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'binary_file_name': {
 			type: 'string',
 			'default': ''
 		},
        'binary_content_type': {
 			type: 'string',
 			'default': ''
 		}
 	},
	prototype: new bfree.api.Version()
 };

}

if(!dojo._hasResource['bfree.api.Versions']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Versions'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 19/09/11
 * Time: 1:14 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Versions');



dojo.declare('bfree.api.Versions', [bfree.api._Collection],{
    zone: null,
    library: null,
    document: null,

    constructor: function(args){
        this.zone = args.zone;
        this.library = args.library;
        this.document = args.document;
        this.target = dojo.replace(bfree.api.Versions.TRGT, [this.zone.subdomain, this.library.id, this.document.getId()]);
		this.schema = bfree.api.Version.schema;
		this.cache = true;

		this._initialize();
    }

});

bfree.api.Versions.TRGT = '/zones/{0}/libraries/{1}/documents/{2}/versions';

}

if(!dojo._hasResource['versa.api.PermissionSet']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.api.PermissionSet'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/03/12
 * Time: 11:51 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.api.PermissionSet');

dojo.declare('versa.api.PermissionSet', null,{

    _values: null,

    constructor: function(args){
        var seed = (args) ? args : false;
        this._values = new Array();
        for(var p in versa.api.PermissionIndices){
            var idx = versa.api.PermissionIndices[p];
            this._values[idx] = seed;
        }
    },

    andSet: function(prmSet){
        var resultSet = new versa.api.PermissionSet(true);

        for(var p in versa.api.PermissionIndices){
            var idx = versa.api.PermissionIndices[p];
            resultSet._values[idx] = (this._values[idx] && prmSet._values[idx]);
        }

        return resultSet;
    },

    orSet: function(prmSet){
        var resultSet = new versa.api.PermissionSet();

        for(var p in versa.api.PermissionIndices){
            var idx = versa.api.PermissionIndices[p];
            resultSet._values[idx] = (this._values[idx] || prmSet._values[idx]);
        }

        return resultSet;
    },

    getValue: function(index){
        return this._values[index];
    },

    setValue: function(index, value){
        this._values[index] = value;
    }


});

versa.api.PermissionIndices = {
    'CREATE':       0x00,
    'VIEW':         0x01,
    'COPY':         0x02,
    'EDIT':         0x03,
    'MOVE':         0x04,
    'CKO':          0x05,
    'CKI':          0x06,
    'CANCEL_CKO':   0x07,
    'VERSION':      0x08,
    'DELETE':       0x09,
    'SECURE':       0x0A,
    'RESTORE':      0x0B,
    'DESTROY':      0x0C

}

}

if(!dojo._hasResource['bfree.api.Document']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Document'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 26/09/11
 * Time: 11:24 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Document');












dojo.declare('bfree.api.Document', [bfree.api._Object, bfree.api._Securable], {
    zone: null,
    library: null,

    checked_out_by: '',
    document_type_id: null,
    library: null,
    state: 0x0000,  //NONE

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));

        this.securable_type = bfree.api._Securable.types.Document;

        if((this.created_at != null) && (typeof this.created_at == 'string'))
            this.created_at = dojo.date.stamp.fromISOString(this.created_at);
        if((this.updated_at != null) && (typeof this.updated_at == 'string'))
            this.updated_at = dojo.date.stamp.fromISOString(this.created_at);

    },

    copyLocal: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Document.CP_TRGT, [zone.subdomain, library.id, this.getId()]);
        bfree.api.Utilities.saveUrl({
            url: url,
            window_name: 'versa_save'
        });

	},

    file: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Document.FILE_TRGT,  [zone.subdomain, library.id, this.getId()]);
        var putData = {
            folder_id: args.folder.id
        };

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return true;
    },

    getFullVersion: function(){
        //Changed to hide minor version support (for now)
        /*
        var version = {
            major_version_number: (this.current_version) ? this.current_version.major_version_number: this.major_version_number,
            minor_version_number: (this.current_version) ? this.current_version.minor_version_number: this.minor_version_number
        }
        return dojo.replace('{major_version_number}.{minor_version_number}', version);
        */
        return this.major_version_number;
    },

    getPermissionSet: function(folder, library, user){
        var prmSet = new versa.api.PermissionSet();

        prmSet.setValue(versa.api.PermissionIndices.VIEW, this.hasRights(bfree.api._Securable.permissions.VIEW));
        prmSet.setValue(versa.api.PermissionIndices.COPY, this.hasRights(bfree.api._Securable.permissions.VIEW));
        prmSet.setValue(versa.api.PermissionIndices.EDIT, this.hasRights(bfree.api._Securable.permissions.WRITE_METADATA));
        prmSet.setValue(versa.api.PermissionIndices.MOVE, prmSet.getValue(versa.api.PermissionIndices.EDIT));
        prmSet.setValue(versa.api.PermissionIndices.CKO, (this.hasRights(bfree.api._Securable.permissions.VERSION) && this.getState(bfree.api.Document.states.CHECKED_IN)));
        prmSet.setValue(versa.api.PermissionIndices.CKI, (this.hasRights(bfree.api._Securable.permissions.VERSION) && this.getState(bfree.api.Document.states.CHECKED_OUT) && (this.checked_out_by == user.name)));
        prmSet.setValue(versa.api.PermissionIndices.CANCEL_CKO, prmSet.getValue(versa.api.PermissionIndices.CKI));
        prmSet.setValue(versa.api.PermissionIndices.DELETE, this.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS));
        prmSet.setValue(versa.api.PermissionIndices.SECURE, this.hasRights(bfree.api._Securable.permissions.WRITE_ACL));

        prmSet.setValue(versa.api.PermissionIndices.RESTORE, this.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS));
        prmSet.setValue(versa.api.PermissionIndices.DESTROY, this.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS));

        return prmSet;
    },

    getState: function(stateFlag){
       return ((this.state & stateFlag) == stateFlag);
    },

    getVersions: function(args){

        if(!this._versions){
            this._versions = new bfree.api.Versions({zone: args.zone, library: args.library, document: this});
        }
        return this._versions;
    },

    isDeleted: function(){
        return this.getState(bfree.api.Document.states.DELETED);
    },

    restore: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Document.RESTORE_TRGT,  [zone.subdomain, library.getId(), this.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return true;
    },

    setState: function(stateFlag, isSet){

        if(isSet){
            this.state = this.state | stateFlag;
        }
        else{
            this.state = this.state & ~stateFlag;
        }

        return this.state;
    },


    unfile: function(args){

        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Document.UNFILE_TRGT,  [zone.subdomain, library.id, this.id]);
        var putData = {
        };

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return true
    },

    validate: function(args){

        if(!this.document_type_id){
            this.state |= bfree.api.Document.states.INVALID;
            return false;
        }

        var documentType = args.library.getDocumentTypes().fetchById({id: this.document_type_id});
        var propertyDefinitions = args.library.getPropertyDefinitions();
        var dataTypes = bfree.api.Application.getDataTypes();

        var isValid = dojo.every(documentType.property_mappings, function(item, idx){
            var valid = true;

            if(item.is_required){
                var propertyDefinition = propertyDefinitions.fetchById({id: item.property_definition_id});
                var dataType = dataTypes.fetchById({id: propertyDefinition.data_type_id});

                if(!propertyDefinition) return false;
                var value = this[propertyDefinition.column_name];

                if(dataType.isString()){
                    valid = !String.isEmpty(value);
                }

            }

            return valid;
        }, this);

        this.setState(bfree.api.Document.states.INVALID, !isValid);

        return isValid;
    },

    view: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Document.VW_TRGT, [zone.subdomain, library.id, this.getId()]);

        bfree.api.Utilities.viewUrl({
            windowBox: args.windowBox,
            url: url,
            window_name: 'versa_viewer'
        });
	}

});

bfree.api.Document.getIconUrl = function(content_type, size){
    return dojo.replace('/icons/{0}?size={1}', [encodeURIComponent(content_type), size]);
}

bfree.api.Document.getStateIcon = function(state){
    var icon = 'none.16.png';

    switch(state){
        case (bfree.api.Document.states.PENDING || bfree.api.Document.states.UPLOADED):
            icon = 'pending.16.gif';
            break;
        case bfree.api.Document.states.PENDING:
            icon = 'pending.16.gif';
            break;
        case bfree.api.Document.states.UPLOADED:
            icon = 'uploaded.16.png';
            break;
        case bfree.api.Document.states.CHECKED_IN:
            icon = 'cki.16.png';
            break;
        case bfree.api.Document.states.INVALID:
            icon = 'invalid.16.png';
            break;
        case bfree.api.Document.states.ERROR:
            icon = 'error.16.png'
            break;
    }

    return icon;
}

bfree.api.Document.getStateMessage = function(state){
    var msg = '';

    switch(state){
        case (bfree.api.Document.states.PENDING || bfree.api.Document.states.UPLOADED):
            msg = 'The file is being added to VersaFile';
            break;
        case bfree.api.Document.states.PENDING:
            msg = 'Uploading...';
            break;
        case bfree.api.Document.states.UPLOADED:
            msg = 'The file has been uploaded and is ready for checkin';
            break;
        case bfree.api.Document.states.CHECKED_IN:
            msg = 'The file has been added to VersaFile';
            break;
        case bfree.api.Document.states.INVALID:
            msg = 'The file contains missing or invalid property values';
            break;
        case bfree.api.Document.states.ERROR:
            msg = 'An error occurred';
            break;
    }

    return msg;

}

bfree.api.Document.VW_TRGT = '/zones/{0}/libraries/{1}/documents/{2}/download/?disposition=inline';
bfree.api.Document.CP_TRGT = '/zones/{0}/libraries/{1}/documents/{2}/download/?disposition=attachment';
bfree.api.Document.CKO_TRGT = '/zones/{0}/libraries/{1}/documents/{2}/checkout.json';
bfree.api.Document.CKI_TRGT  = '/zones/{0}/libraries/{1}/documents/{2}/checkin.json';
bfree.api.Document.XCKO_TRGT = '/zones/{0}/libraries/{1}/documents/{2}/cancel_checkout.json';
bfree.api.Document.FILE_TRGT  = '/zones/{0}/libraries/{1}/documents/{2}/file.json';
bfree.api.Document.UNFILE_TRGT  = '/zones/{0}/libraries/{1}/documents/{2}/unfile.json';
bfree.api.Document.RESTORE_TRGT  = '/zones/{0}/libraries/{1}/documents/{2}/restore.json';
bfree.api.Document.SDEL_TRGT  = '/zones/{0}/libraries/{1}/documents/{2}/soft_delete.json';

bfree.api.Document.states = {
    'NONE':         0x0000,
    'PENDING':      0x0001,
    'UPLOADED':     0x0002,
    'BUSY':         0x0004,
    'INDEXED':      0x0010,
    'CHECKED_IN':   0x0020,
    'CHECKED_OUT':  0x0040,
    'INVALID':      0x0400,
    'DELETED':      0x0800,
    'ERROR':        0x8000
};

bfree.api.Document.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
        'document_type_id': {
            type: 'integer'
        },
 		'name': {
 			type: 'string',
 			'default': '',
             'required': true
 		},
        'created_at': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'created_by': {
            type: ['string', 'null'],
            'default': ''
        },
        'checked_out_by': {
            type: ['string', 'null']
        },
        'state': {
            type: 'integer',
            'default': bfree.api.Document.states.PENDING
        },
        'updated_at': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'updated_by': {
            type: ['string', 'null'],
            'default': ''
        },
        'prp_dtt001': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'prp_dtt002': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'prp_dtt003': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'prp_dtt004': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'prp_dtt005': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'prp_dtt006': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'prp_dtt007': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'prp_dtt008': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        }

 	},
	prototype: new bfree.api.Document()
 };

}

if(!dojo._hasResource['bfree.api.Documents']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Documents'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 26/09/11
 * Time: 11:24 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Documents');




dojo.declare('bfree.api.Documents', [bfree.api._Collection],{
    library: null,

    _isUpdateable: function(request){
        return false;
    },

    /*
    _onDelete: function(item){
        item.state |= bfree.api.Document.states.DELETED;
    },
    */

    _softDelete: function(item){
        var url = dojo.replace(bfree.api.Documents.SDEL_TRGT,  [this.zone.subdomain, this.library.getId(), item.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return result;
    },

    constructor: function(args){

        this.zone = args.zone;
        this.library = args.library;
        this.target = dojo.replace(bfree.api.Documents.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.Document.schema;
		this.cache = false;
        this.syncMode = false;

		this._initialize();
        this.store.isUpdateable = dojo.hitch(this, this._isUpdateable);

        //dojo.connect(this.store, 'onDelete', this._onDelete);

    },

    destroy: function(args){
        var item = args.item;

        if((item.isInstanceOf(bfree.api.Document)) && (args.soft)){
            item = this._softDelete(item);
            this.store.onDelete(item);
        }
        else{
            this.inherited('destroy', arguments);
        }
    },

    empty_recycling: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Documents.EMPTY,  [zone.subdomain, library.id]);

        var result = bfree.api.XhrHelper.doPostAction({
            target: url,
            postData: {}
        });

        return true;
    },

    export_query: function(args){

        var queryStr = dojo.objectToQuery(args.query);

        var sortStr = dojo.replace('sort({0}{1})',
            [   (args.sort.descending ? '-' : '+'),
                encodeURIComponent(args.sort.attribute)]) ;

        var frmt = 'json';
        switch(args.type){
            case bfree.api.Documents.ExportTypes.CSV:
                frmt = 'csv';
                break;
            case bfree.api.Documents.ExportTypes.PDF:
                frmt = 'pdf';
                break;
            case bfree.api.Documents.ExportTypes.XML:
                frmt = 'xml'
                break;
        }

        var url = dojo.replace(bfree.api.Documents.EXPORT_TRGT, [args.zone.subdomain, args.library.id, queryStr, sortStr, frmt]);

        if(args.type == bfree.api.Documents.ExportTypes.PDF){
           bfree.api.Utilities.viewUrl({
                windowBox: args.windowBox,
                url: url,
                window_name: 'versa_save'
            });
        }
        else{
           bfree.api.Utilities.saveUrl({
                url: url,
                window_name: 'versa_save'
            });
        }
    },

    isValid: function(args){
        this.validate(args);
        return this.getState(bfree.api.Document.states.INVALID);
    },

    print_query: function(args){

        var queryStr = dojo.objectToQuery(args.query);

        var sortStr = dojo.replace('sort({0}{1})',
            [   (args.sort.descending ? '-' : '+'),
                encodeURIComponent(args.sort.attribute)]) ;

        var url = dojo.replace(bfree.api.Documents.EXPORT_TRGT, [args.zone.subdomain, args.library.id, queryStr, sortStr, 'html'])

        bfree.api.Utilities.viewUrl({
            windowBox: args.windowBox,
            url: url,
            window_name: 'versa_printer'
        });

    }


});

bfree.api.Documents.States = { pending: 0x0000, checked_in: 0x0001, checked_out: 0x0002, busy: 0x4000, deleted: 0x8000 }
bfree.api.Documents.ExportTypes = { 'NONE':  0x0000, 'CSV':   0x001, 'PDF':   0x0002, 'XML':   0x0003 }

bfree.api.Documents.TRGT = '/zones/{0}/libraries/{1}/documents';
bfree.api.Documents.PRINT_TRGT = '/zones/{0}/libraries/{1}/documents?{2}&{3}';
bfree.api.Documents.EXPORT_TRGT = '/zones/{0}/libraries/{1}/documents.{4}?{2}&{3}';
bfree.api.Documents.EMPTY = '/zones/{0}/libraries/{1}/documents/empty';
bfree.api.Documents.SDEL_TRGT  = '/zones/{0}/libraries/{1}/documents/{2}/soft_delete.json';

bfree.api.Documents.isCheckedOut = function(args){
    var state
    if(args.document){
        state=args.document.state;
    }else if(args.state){
        state=args.state;
    }
    return ((state & bfree.api.Documents.States.checked_out) > 0);
};

bfree.api.Documents.isBusy = function(args){
	return ((args.state & bfree.api.Documents.States.busy) > 0);
};


}

if(!dojo._hasResource['versa.api.Formatter']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.api.Formatter'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/03/12
 * Time: 3:39 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.api.Formatter');

dojo.declare('versa.api.Formatter', null,{
});

versa.api.Formatter.formatDateTime = function(value){
    var frmt_value = value;

    if(String.isEmpty(value))
        return '';

    if(typeof value == 'string')
        frmt_value = dojo.date.stamp.fromISOString(value);

    return dojo.date.locale.format(frmt_value, {selector: 'date', formatLength: 'medium'})
}

}

if(!dojo._hasResource['bfree.api.PropertyMapping']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.PropertyMapping'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.PropertyMapping');




dojo.declare('bfree.api.PropertyMapping', [bfree.api._Object],{

	constructor: function(/* Object */args){		
        dojo.safeMixin(this, ((!args) ? { } : args));
	},

    /*
    formatValue: function(property_definition, value){
        var frmt_value = null;

        if(property_definition.isDateType()){
            frmt_value = versa.api.Formatter.formatDateTime(value);
        }
        else{
            frmt_value = value;
        }

        return frmt_value;
    }
    */
	
});

bfree.api.PropertyMapping.compare = function(item1, item2){
    return item1.sort_order-item2.sort_order;
}

bfree.api.PropertyMapping.formatValue = function(property_definition, value){
    var frmt_value = null;

    if(property_definition.isTypeDate()){
        frmt_value = versa.api.Formatter.formatDateTime(value);
    }
    else{
        frmt_value = value;
    }

    return frmt_value;
}

bfree.api.PropertyMapping.schema = {
	type: 'object',
	properties: {
		'id': {
			type: 'integer'
		},
		'document_type_id': {
			type: 'integer'
		},
		'property_definition_id': {
			type: 'integer'
		},
		'name': {
			type: 'string',
			'default': 'Property'
		},	
		'sort_order': {
			type: 'integer',
			'default': 1
		},
		'is_required': {
			type: 'boolean',
			'default': false
		},
		'choice_list_id': {
			type: 'integer',
			'default': null
		},
		'default_value': {
			type: 'string',
			'default': null
		}
	}
};

}

if(!dojo._hasResource['bfree.api.DocumentType']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.DocumentType'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/11/11
 * Time: 4:05 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.DocumentType');





dojo.declare('bfree.api.DocumentType', [bfree.api._Object], {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    getMetrics: function(args){

        var url = dojo.replace(bfree.api.DocumentType.MT_TRGT,  [args.zone.subdomain, args.library.id, this.id]);
        var result = bfree.api.XhrHelper.doGetAction({
            target: url
        });

        return true;
    },

    isValid: function(){
        var isValid = true;

		if (String.isEmpty(this.name.trim())) {
            isValid = false;
		}

		return isValid;
	}

});

bfree.api.DocumentType.MT_TRGT = '/zones/{0}/libraries/{1}/document_types/{2}/dtmetrics.json';

bfree.api.DocumentType.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'is_system': {
            type: 'boolean',
            'default': false
        },
        'property_mappings': {
            type: 'array',
            'default': [],
            items: {
                type: 'object',
                properties: {
                    'property_definition_id': {
                        type: 'integer'
                    },
                    'choice_list_id': {
                        type: 'integer'
                    },
                    'default_value': {
                        type: 'string'
                    },
                    'is_required': {
                        type: 'boolean'
                    },
                    'sort_order': {
                        type: 'integer'
                    },
                    prototype: new bfree.api.PropertyMapping()
                }
            }
        },
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'created_by': {
            type: 'string'
        },
        'description': {
            type: 'string',
            'default': ''
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_by': {
            type: 'string'
        }
 	},
	prototype: new bfree.api.DocumentType()
 };

}

if(!dojo._hasResource['bfree.api.DocumentTypes']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.DocumentTypes'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/11/11
 * Time: 4:05 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.DocumentTypes');



dojo.declare('bfree.api.DocumentTypes', [bfree.api._Collection],{
    library: null,

    _isUpdateable: function(request){
        return false;
    },

    //this method prevents sub-objects from being included in the query
    //and being drawn on the grid
    _matchesQuery: function(item,request){

        //query returns array of property mappings,
        //exclude them.
        if(dojo.isArray(item) || (item.hasOwnProperty('sort_order')))
            return false;

        var query = request.query;
        var ignoreCase = request.queryOptions && request.queryOptions.ignoreCase;
        for(var i in query){
            // if anything doesn't match, than this should be in the query
            var match = query[i];
            var value = this.getValue(item,i);
            if((typeof match == 'string' && (match.match(/[\*\.]/) || ignoreCase)) ?
                !dojo.data.util.filter.patternToRegExp(match, ignoreCase).test(value) :
                value != match){
                return false;
            }
        }
        return true;
    },

    constructor: function(args){
        this.zone = args.zone;
        this.library = args.library;
        this.target = dojo.replace(bfree.api.DocumentTypes.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.DocumentType.schema;
		this.cache = true;

		this._initialize();
//        this.store.isUpdateable = dojo.hitch(this, this._isUpdateable);
        this.store.matchesQuery  = dojo.hitch(this, this._matchesQuery);
    },

    getMetrics: function(args){

        var url = dojo.replace(bfree.api.DocumentTypes.MT_TRGT,  [args.zone.subdomain, args.library.id]);
        var result = bfree.api.XhrHelper.doGetAction({
            target: url
        });

        return result;
    },

    getSystem: function(){
        var system_types = [];

        this.forEach(function(item){
            if(item.is_system)
                system_types.push(item);
        }, this);

        if(system_types.length < 1)
            throw new Error('No system-defined document types were found');

        return system_types;
    }

});

bfree.api.DocumentTypes.TRGT = '/zones/{0}/libraries/{1}/document_types';
bfree.api.DocumentTypes.MT_TRGT = '/zones/{0}/libraries/{1}/document_types/dtmetrics.json';

}

if(!dojo._hasResource['bfree.api.Search']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Search'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/11/11
 * Time: 2:41 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Search');



dojo.declare('bfree.api.Search', [bfree.api._Object], {

    type: 0,
    queryData: null,
    view_definition_id: null,

    _getAdvancedQuery: function(){
        return {
            type: this.type,
            query: dojo.toJson(this.queryData),
            view: this.view_definition_id
        }
    },

    _getFolderQuery: function(){
        return {
            type: this.type,
            query: this.queryData,
            view: this.view_definition_id
        }
    },

    _getSimpleQuery: function(){
        return {
            type: this.type,
            query: this.queryData,
            view: this.view_definition_id
        }
    },

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args))
    },

    getQuery: function(){

        var query = { type: bfree.api.Search.types.NONE };

        switch(this.type){
            case bfree.api.Search.types.FOLDER:
            case bfree.api.Search.types.TRASH:
                query = this._getFolderQuery();
                break;
            case bfree.api.Search.types.SIMPLE:
                query = this._getSimpleQuery();
                break;
            case bfree.api.Search.types.ADVANCED:
                query = this._getAdvancedQuery();
                break;
            case bfree.api.Search.types.TRASH:
                break;
        }

        return query;
    }

});


bfree.api.Search.types =  {
    'NONE':     0x00,
    'FOLDER':   0x01,
    'SIMPLE':   0x02,
    'ADVANCED': 0x03,
    'TRASH':    0x04
};




}

if(!dojo._hasResource['bfree.api.Folder']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Folder'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 24/10/11
 * Time: 9:58 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Folder');






dojo.declare('bfree.api.Folder', [bfree.api._Object, bfree.api._Securable], {

    _activeQuery: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
        this.securable_type = bfree.api._Securable.types.Folder;
    },

    getActiveQuery: function(){

        if(!this._activeQuery){
            this._activeQuery = new bfree.api.Search({
                type: (this.isTrash() ? bfree.api.Search.types.TRASH : bfree.api.Search.types.FOLDER),
                queryData: this.getId(),
                view_definition_id: this.view_definition_id
            });
        }

        return this._activeQuery;
    },

    getPermissionSet: function(library, user){
        var prmSet = new versa.api.PermissionSet();

        prmSet.setValue(versa.api.PermissionIndices.VIEW, true);
        prmSet.setValue(versa.api.PermissionIndices.COPY, true);
        prmSet.setValue(versa.api.PermissionIndices.EDIT, this.hasRights(bfree.api._Securable.permissions.WRITE_METADATA) && (!this.isSpecial() || this.isShare()) && (!this.isRoot()));
        prmSet.setValue(versa.api.PermissionIndices.CREATE, this.hasRights(bfree.api._Securable.permissions.CREATE_FOLDERS) && (!(this.isTrash() || this.isSearch() || this.isShare())));
        prmSet.setValue(versa.api.PermissionIndices.FILE, this.hasRights(bfree.api._Securable.permissions.CREATE_DOCUMENTS) && (!this.isSpecial()));
        prmSet.setValue(versa.api.PermissionIndices.DELETE, this.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS) && (!this.isSpecial() && (!this.isRoot())));
        prmSet.setValue(versa.api.PermissionIndices.SECURE, this.hasRights(bfree.api._Securable.permissions.WRITE_ACL) && (!this.isSpecial() || this.isShare()));

        return prmSet;
    },

    isRoot: function(){
        return (this.folder_type == bfree.api.Folder.FolderTypes.ROOT);
    },

    isSearch: function(){
        return (this.folder_type == bfree.api.Folder.FolderTypes.SEARCH);
    },

    isShare: function(){
        return (this.folder_type == bfree.api.Folder.FolderTypes.SHARE);
    },

    isShareRoot: function(){
        return (this.folder_type == bfree.api.Folder.FolderTypes.SHARE_ROOT);
    },

    isSpecial: function(){
        return (this.folder_type == bfree.api.Folder.FolderTypes.SEARCH ||
                   this.folder_type == bfree.api.Folder.FolderTypes.TRASH ||
                   this.folder_type == bfree.api.Folder.FolderTypes.SHARE ||
                   this.folder_type == bfree.api.Folder.FolderTypes.SHARE_ROOT);
    },

    isTrash: function(){
        return (this.folder_type == bfree.api.Folder.FolderTypes.TRASH);
    },

    setActiveQuery: function(query){
        this._activeQuery = query;
        this._activeQuery.view_definition_id = this.view_definition_id;
    }
});

bfree.api.Folder.FolderTypes = {
    'ROOT':         0x0000,
    'CONTENT':      0x0001,
    'SHARE_ROOT':   0x0010,
    'SHARE':        0x0011,
    'SEARCH':       0x0020,
    'TRASH':        0x0040
}

bfree.api.Folder.getIconUrl = function(folder, size){
    var iconName = 'content';

    switch(folder.folder_type){
        case bfree.api.Folder.FolderTypes.TRASH:
            iconName = 'recyclebin';
            break;
        case bfree.api.Folder.FolderTypes.SEARCH:
            iconName = 'search';
            break;
        case bfree.api.Folder.FolderTypes.SHARE_ROOT:
            iconName = 'share_root';
            break;

    }

    return dojo.replace('/images/mimetypes/{0}/{1}.png', [size, iconName]);
}

bfree.api.Folder.getTypeLabel = function(folder){
    var label = 'Content';

    switch(folder.folder_type){
        case bfree.api.Folder.FolderTypes.TRASH:
            label = 'Deleted Items';
            break;
        case bfree.api.Folder.FolderTypes.SEARCH:
            label = 'Search Results';
            break;
        case bfree.api.Folder.FolderTypes.SHARE_ROOT:
            label = 'Shared Folders';
            break;
        case bfree.api.Folder.FolderTypes.SHARE:
            label = 'Shared Files';
            break;
    }

    return label;
}

bfree.api.Folder.sort = function(item1, item2){

    //ORDER for non-content folder types
    if((item1.folder_type != bfree.api.Folder.FolderTypes.CONTENT) ||
        (item2.folder_type != bfree.api.Folder.FolderTypes.CONTENT)){

        //Order should be:
        // - Trash
        // - Search
        // - Share
        // - Content....
        if(item1.folder_type > item2.folder_type)
            return -1;
        return 1;
    }

    //Sort by name
    if(item1.name == item2.name){
        return 0;
    }

    //Alphabetically for all else (case-insensitive)
    return (item1.name?item1.name:'').toLowerCase() < (item2.name?item2.name:'').toLowerCase() ? -1 : 1;
};

bfree.api.Folder.permissionIndices = {
    'CREATE':       0x00,
    'VIEW':         0x01,
    'FILE':         0x02,
    'DELETE':       0x03,
    'SECURE':       0x04

}

/*
bfree.api.Folder.getPermissionSet = function(folder, library, user){
    var arr = new Array();
    var isLibNull = (library == null);
    var isFldNull = ((isLibNull) || (folder == null));
    var isSystem = ((!isFldNull) && ((folder.root) || (folder.is_trash) || (folder.is_search)));

    arr[bfree.api.Folder.permissionIndices.CREATE] = ((!isFldNull)
        && ((!folder.is_trash) && (!folder.is_search))
        && (folder.hasRights(bfree.api._Securable.permissions.CREATE_FOLDERS)));
    arr[bfree.api.Folder.permissionIndices.EDIT] = ((!isFldNull)
        && (!isSystem)
        && (folder.hasRights(bfree.api._Securable.permissions.WRITE_METADATA)));
    arr[bfree.api.Folder.permissionIndices.FILE] = ((!isFldNull)
        && (!folder.is_trash)
        && (!folder.is_search)
        && (folder.hasRights(bfree.api._Securable.permissions.CREATE_DOCUMENTS)));
    arr[bfree.api.Folder.permissionIndices.DELETE] = ((!isFldNull)
            && (!isSystem)
            && (folder.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS)));
    arr[bfree.api.Folder.permissionIndices.SECURE] = ((!isFldNull)
            && (!folder.is_search)
            && (folder.hasRights(bfree.api._Securable.permissions.WRITE_ACL)));

    return arr;
}
*/


bfree.api.Folder.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
        'folder_type': {
            type: 'integer'
        },
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'expiry': {
            type: ['string', 'object', 'null'],
            format: 'date-time'
        },
        'created_at': {
            type: 'string',
            format: 'date-time',
            'default': dojo.date.stamp.toISOString(new Date(), {zulu: true})
        },
        'created_by': {
            type: 'string',
            'default': ''
        },
        'updated_at': {
            type: 'string',
            format: 'date-time',
            'default': dojo.date.stamp.toISOString(new Date(), {zulu: true})
        },
        'updated_by': {
            type: 'string',
            'default': ''
        },
        'text_path':{
            type: 'string',
            'default':''
        },
        'document_count':{
            type: 'integer',
            'default': 0
        }
 	},
	prototype: new bfree.api.Folder()
 };

}

if(!dojo._hasResource['bfree.api.Folders']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Folders'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 24/10/11
 * Time: 9:58 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Folders');




dojo.declare('bfree.api.Folders', [bfree.api._Collection],{
    library: null,

    _searchFolder: null,
    _shareRootFolder: null,
    _trashFolder: null,

    _getExistingNames: function(parentItem){

        var names = [];

        if((parentItem) && (parentItem.children)){
            dojo.forEach(parentItem.children, function(folderItem){
		        names.push(folderItem.name);
	        });
        }

		return names;
	},

    _isUpdateable: function(request){

        if(request.query.hasOwnProperty('parent_id'))
            return true;

        return typeof request.query == "object";
    },

    _matchesQuery: function(item, request){;
        return true;
    },

    constructor: function(args){

        this.zone = args.zone;
        this.library = args.library;
        this.target = dojo.replace(bfree.api.Folders.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.Folder.schema;
		this.cache = true;

        this._initialize();
        this.store.isUpdateable  = dojo.hitch(this, this._isUpdateable);
    },

    generateUniqueName: function(args){
		var names = this._getExistingNames(args.parent);
		var baseName = args.base_name;

		return bfree.api.Utilities.generateUniqueName({
			names: names,
			base_name: baseName
		});
	},

    getSearchFolder: function(){

        if(!this._searchFolder){
            this.forEach(function(item){
                dojo.every(item.children, function(item, idx){
                    if(item.isSearch())
                        this._searchFolder = item;
                    return (!this._searchFolder);
                }, this);
            }, this);
        }

        return this._searchFolder;
    },

    getShareRootFolder: function(){

        if(!this._shareRootFolder){
            this.forEach(function(item){
                dojo.every(item.children, function(item, idx){
                    if(item.isShareRoot())
                        this._shareRootFolder = item;
                    return (!this._shareRootFolder);
                }, this);
            }, this);
        }

        return this._shareRootFolder;
    },

    getTrashFolder: function(){

        if(!this._trashFolder){
            this.forEach(function(item){
                dojo.every(item.children, function(item, idx){
                    if(item.isTrash())
                        this._trashFolder = item;
                    return (!this._trashFolder);
                }, this);
            }, this);
        }

        return this._trashFolder;

    },

    getTextPath: function(args){
        var item=args.item;

        if(item.parent_id){
            var parent=this.fetchById({id: item.parent_id});
            return this.getTextPath({item: parent})+'/'+item.name;
        }else{
            return '/'+item.name
        }
//        return this.name;
    }

});

bfree.api.Folders.TRGT = '/zones/{0}/libraries/{1}/folders';

bfree.api.Folders.generateUniqueName = function(args){
	var parentItem = args.folder;
	var names = [];

	dojo.forEach(parentItem.children, function(folderItem){
		names.push(folderItem.name);
	});

	return bfree.api.Utilities.generateUniqueName({
		names: names,
		base_name: args.base_name
	});

};

}

if(!dojo._hasResource['bfree.api.PropertyDefinition']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.PropertyDefinition'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/11/11
 * Time: 10:11 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.PropertyDefinition');



dojo.declare('bfree.api.PropertyDefinition', [bfree.api._Object], {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    getDbName: function(){
        //return dojo.replace("{table_name}.{column_name}", this);
        return dojo.replace("{table_name}.{column_name}", this);
    },

    isTypeDate: function(){
        return this.data_type_id == bfree.api.DataTypes.types.DATETIME;
    },

    isTypeText: function(){
       return this.data_type_id == bfree.api.DataTypes.types.TEXT
    },

    isTypeInteger: function(){
        return this.data_type_id==bfree.api.DataTypes.types.INTEGER;
    },

    isTypeFloat: function(){
        return this.data_type_id==bfree.api.DataTypes.types.FLOAT;
    },

    isTypeAnyNumber: function(){
        return this.data_type_id==bfree.api.DataTypes.types.INTEGER||
               this.data_type_id==bfree.api.DataTypes.types.FLOAT
    },

    isValid: function(){
        var isValid = true;

		if (String.isEmpty(this.name.trim())) {
            isValid = false;
		}

        if(!this.data_type_id){
            isValid = false;
        }

		return isValid;
	}


});

bfree.api.Cardinality = {
    'Single': 0x01,
    'Multiple': 0x02
}

bfree.api.PropertyDefinition.compare = function(a, b){
    return a.sort_id-b.sort_id;
};

bfree.api.PropertyDefinition.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'cardinality': {
            type: 'integer',
            'default': bfree.api.Cardinality.Single
         },
        'column_name': {
            type: 'string'
        },
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'created_by': {
            type: 'string'
        },
        'data_type_id': {
            type: 'integer'
        },
        'description': {
            type: 'string',
            'default': ''
        },
        'is_readonly': {
            type: 'boolean',
            'default': false
        },
        'is_system': {
            type: 'boolean',
            'default': false
        },
        'max_length': {
            type: 'max_length'
        },
        'table_name': {
            type: 'string'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_by': {
            type: 'string'
        }
 	},
	prototype: new bfree.api.PropertyDefinition()
 };

}

if(!dojo._hasResource['bfree.api.PropertyDefinitions']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.PropertyDefinitions'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/11/11
 * Time: 10:11 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.PropertyDefinitions');



dojo.declare('bfree.api.PropertyDefinitions', [bfree.api._Collection],{
    library: null,

    constructor: function(args){
        this.zone = args.zone;
        this.library = args.library;
        this.target = dojo.replace(bfree.api.PropertyDefinitions.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.PropertyDefinition.schema;
		this.cache = true;

		this._initialize();
    },

    fetchByDbName: function(dbName){
        var _item = null;

        function  __onComplete(items, request){
			dojo.some(items, function(item){
                if(item.getDbName() == dbName){
                    _item = item;
                    return false;
                }
            }, this);
		}

		this.store.fetch({
            query:{},
            queryOptions:{cache: true},
            onComplete: __onComplete
        });

        return _item;
    },

    getNameProperty: function(){
        var name_propdef = null;

        this.forEach(function(item){
            if(item.is_name)
                name_propdef = item;
        }, this);

        return name_propdef;
    }

});

bfree.api.PropertyDefinitions.TRGT = '/zones/{0}/libraries/{1}/property_definitions';

}

if(!dojo._hasResource['bfree.api.Reference']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Reference'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/04/12
 * Time: 12:36 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Reference');






dojo.declare('bfree.api.Reference', [bfree.api._Object, bfree.api._Securable], {
    zone: null,
    library: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
        this.securable_type = bfree.api._Securable.types.Reference;
    },

    cancelCheckout: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Reference.XCKO_TRGT,  [zone.subdomain, library.id, this.getId()]);

        var putData = {
        };

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return true;
    },

    checkin: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Reference.CKI_TRGT,  [zone.subdomain, library.id, this.getId()]);
        var putData = dojo.fromJson(dojox.json.ref.toJson(this, false, '', true));;

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return true;
    },

    checkout: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Reference.CKO_TRGT,  [zone.subdomain, library.id, this.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return true;
    },

    copyLocal: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = (args.version_id) ?
                        dojo.replace(bfree.api.Reference.CPV_TRGT, [zone.subdomain, library.id, this.getId(), args.version_id]) :
                        dojo.replace(bfree.api.Reference.CP_TRGT, [zone.subdomain, library.id, this.getId()]);

        bfree.api.Utilities.saveUrl({
            url: url,
            window_name: 'versa_save'
        });

	},

    file: function(args){
        var zone = args.zone;
        var library = args.library;
        var folder = args.folder;

        var url = dojo.replace(bfree.api.Reference.FILE_TRGT,  [zone.subdomain, library.id, this.getId(), folder.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        //simulate removal from current results.
        library.getReferences().store.onDelete(this);
        return true;
    },

    getPermissionSet: function(folder, library, user){
        var prmSet = new versa.api.PermissionSet();

        prmSet.setValue(versa.api.PermissionIndices.VIEW, this.hasRights(bfree.api._Securable.permissions.VIEW));
        prmSet.setValue(versa.api.PermissionIndices.COPY, this.hasRights(bfree.api._Securable.permissions.VIEW));
        prmSet.setValue(versa.api.PermissionIndices.EDIT, this.hasRights(bfree.api._Securable.permissions.WRITE_METADATA));
        prmSet.setValue(versa.api.PermissionIndices.MOVE, prmSet.getValue(versa.api.PermissionIndices.EDIT));
        prmSet.setValue(versa.api.PermissionIndices.CKO, (this.hasRights(bfree.api._Securable.permissions.VERSION) && this.getState(bfree.api.Document.states.CHECKED_IN)));
        prmSet.setValue(versa.api.PermissionIndices.CKI, (this.hasRights(bfree.api._Securable.permissions.VERSION) && this.getState(bfree.api.Document.states.CHECKED_OUT) && (this.checked_out_by == user.name)));
        prmSet.setValue(versa.api.PermissionIndices.CANCEL_CKO, prmSet.getValue(versa.api.PermissionIndices.CKI));
        prmSet.setValue(versa.api.PermissionIndices.DELETE, this.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS));
        prmSet.setValue(versa.api.PermissionIndices.SECURE, this.hasRights(bfree.api._Securable.permissions.WRITE_ACL));

        prmSet.setValue(versa.api.PermissionIndices.RESTORE, this.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS));
        prmSet.setValue(versa.api.PermissionIndices.DESTROY, this.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS));

        return prmSet;
    },

    getState: function(stateFlag){
       return ((this.state & stateFlag) == stateFlag);
    },

    isDeleted: function(){
        return this.getState(bfree.api.Document.states.DELETED);
    },

    isShare: function(){
        return this.reference_type == bfree.api.Reference.types.SHARE;
    },

    restore: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Reference.RESTORE_TRGT,  [zone.subdomain, library.getId(), this.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        //simulate removal from 'recycle bin'.
        library.getReferences().store.onDelete(this);
        return true;
    },

    share: function(args){
        var zone = args.zone;
        var library = args.library;
        var folder = args.folder;

        var url = dojo.replace(bfree.api.Reference.SHARE_TRGT,  [zone.subdomain, library.id, this.getId(), folder.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return true;
    },

    unshare: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = dojo.replace(bfree.api.Reference.UNSHARE_TRGT,  [zone.subdomain, library.id, this.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        //simulate removal from current results.
        library.getReferences().store.onDelete(this);

        return true;
    },

    view: function(args){
        var zone = args.zone;
        var library = args.library;

        var url = (args.version_id) ?
                        dojo.replace(bfree.api.Reference.VWV_TRGT, [zone.subdomain, library.id, this.getId(), args.version_id]) :
                        dojo.replace(bfree.api.Reference.VW_TRGT, [zone.subdomain, library.id, this.getId()]);


        bfree.api.Utilities.viewUrl({
            windowBox: args.windowBox,
            url: url,
            window_name: 'versa_viewer'
        });
	}

});

bfree.api.Reference.VW_TRGT = '/zones/{0}/libraries/{1}/references/{2}/download/?disposition=inline'
bfree.api.Reference.VWV_TRGT = '/zones/{0}/libraries/{1}/references/{2}/download/?disposition=inline&version_id={3}'
bfree.api.Reference.CP_TRGT = '/zones/{0}/libraries/{1}/references/{2}/download/?disposition=attachment';
bfree.api.Reference.CPV_TRGT = '/zones/{0}/libraries/{1}/references/{2}/download/?disposition=attachment&version_id={3}';
bfree.api.Reference.CKO_TRGT = '/zones/{0}/libraries/{1}/references/{2}/checkout.json';
bfree.api.Reference.CKI_TRGT  = '/zones/{0}/libraries/{1}/references/{2}/checkin.json';
bfree.api.Reference.XCKO_TRGT = '/zones/{0}/libraries/{1}/references/{2}/cancel_checkout.json';
bfree.api.Reference.FILE_TRGT = '/zones/{0}/libraries/{1}/references/{2}/file.json?folder_id={3}';
bfree.api.Reference.SHARE_TRGT = '/zones/{0}/libraries/{1}/references/{2}/share.json?folder_id={3}'
bfree.api.Reference.UNSHARE_TRGT = '/zones/{0}/libraries/{1}/references/{2}/unshare.json?'
bfree.api.Reference.RESTORE_TRGT  = '/zones/{0}/libraries/{1}/references/{2}/restore.json';

bfree.api.Reference.types = {
    'CONTENT':  0x0000,
    'SHARE':    0x0011,
    'TRASH':    0x0012
}

bfree.api.Reference.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
        'reference_type': {
            type: 'integer'
        },
        'state': {
            type: 'integer',
            'default': bfree.api.Document.states.PENDING
        }
 	},

	prototype: new bfree.api.Reference()
 };

}

if(!dojo._hasResource['bfree.api.References']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.References'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/04/12
 * Time: 12:32 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.References');



dojo.declare('bfree.api.References', bfree.api._Collection,{
    library: null,
    zone: null,

    _isUpdateable: function(request){
        return false;
    },

    _softDelete: function(item){
        var url = dojo.replace(bfree.api.References.SDEL_TRGT,  [this.zone.subdomain, this.library.getId(), item.getId()]);
        var putData = {};

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: putData
        });

        return result;
    },

    constructor: function(args){

        this.zone = args.zone;
        this.library = args.library;
        this.target = dojo.replace(bfree.api.References.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.Reference.schema;
		this.cache = false;

		this._initialize();
        this.store.isUpdateable = dojo.hitch(this, this._isUpdateable);
    },

    destroy: function(args){
        var item = args.item;

        if((item.isInstanceOf(bfree.api.Reference)) && (args.soft)){
            item = this._softDelete(item);
            this.store.onDelete(item);
        }
        else{
            this.inherited('destroy', arguments);
        }

    },

    export_query: function(args){
        var queryStr = dojo.objectToQuery(args.query);

        var sortStr = dojo.replace('sort({0}{1})',
            [   (args.sort.descending ? '-' : '+'),
                encodeURIComponent(args.sort.attribute)]) ;

        var frmt = 'json';
        switch(args.type){
            case bfree.api.References.ExportTypes.CSV:
                frmt = 'csv';
                break;
            case bfree.api.References.ExportTypes.PDF:
                frmt = 'pdf';
                break;
            case bfree.api.References.ExportTypes.XML:
                frmt = 'xml'
                break;
        }

        var url = dojo.replace(bfree.api.References.EXPORT_TRGT, [args.zone.subdomain, args.library.id, queryStr, sortStr, frmt]);

        if(args.type == bfree.api.Documents.ExportTypes.PDF){
           bfree.api.Utilities.viewUrl({
                windowBox: args.windowBox,
                url: url,
                window_name: 'versa_save'
            });
        }
        else{
           bfree.api.Utilities.saveUrl({
                url: url,
                window_name: 'versa_save'
            });
        }
    },

    print_query: function(args){

        var queryStr = dojo.objectToQuery(args.query);

        var sortStr = dojo.replace('sort({0}{1})',
            [   (args.sort.descending ? '-' : '+'),
                encodeURIComponent(args.sort.attribute)]) ;

        var url = dojo.replace(bfree.api.References.PRINT_TRGT, [args.zone.subdomain, args.library.id, queryStr, sortStr, 'html'])

        bfree.api.Utilities.viewUrl({
            windowBox: args.windowBox,
            url: url,
            window_name: 'versa_printer'
        });

    }

});

bfree.api.References.ExportTypes = { 'NONE':  0x0000, 'CSV':   0x001, 'PDF':   0x0002, 'XML':   0x0003 }

bfree.api.References.TRGT = '/zones/{0}/libraries/{1}/references';
bfree.api.References.SDEL_TRGT  = '/zones/{0}/libraries/{1}/references/{2}/soft_delete.json';
bfree.api.References.PRINT_TRGT = '/zones/{0}/libraries/{1}/references?{2}&{3}';
bfree.api.References.EXPORT_TRGT = '/zones/{0}/libraries/{1}/references.{4}?{2}&{3}';

}

if(!dojo._hasResource['bfree.api.ViewMapping']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ViewMapping'] = true;
/**
 * @author aarons
 */
dojo.provide('bfree.api.ViewMapping');




dojo.declare('bfree.api.ViewMapping', [bfree.api._Object],{
	constructor: function(/* Object */args){
        if(args) dojo.safeMixin(this, args);
	}
	
});

bfree.api.ViewMapping.compare = function(item1, item2){
    return item1.sort_order-item2.sort_order;
};

bfree.api.ViewMapping.schema = {
	type: 'object',
	properties: {
        'library_id': {
            type: 'integer'
        },
		'folder_id': {
			type: 'integer'
		},
        'user_id': {
			type: 'integer'
		},
        'view_id': {
			type: 'integer'
		}
	}
};

}

if(!dojo._hasResource['bfree.api.ViewMappings']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ViewMappings'] = true;
/**
 * @author aarons
 */
dojo.provide('bfree.api.ViewMappings');





dojo.declare('bfree.api.ViewMappings', [bfree.api._Collection],{
	
	constructor: function(/* Object */args){
        this.zone = args.zone;
        this.library = args.library;
        this.target = dojo.replace(bfree.api.ViewMappings.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.ViewMapping.schema;
        this.cache = false;

        this._initialize();
	},

    getMapping: function(folder_id, user_id){
        return this.query({query:dojo.replace('?folder_id={0}&user_id={1}', [folder_id, user_id])})
    }
	
});

bfree.api.ViewMappings.TRGT='/zones/{0}/libraries/{1}/view_mappings';

}

if(!dojo._hasResource['bfree.api.Library']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Library'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 22/09/11
 * Time: 4:49 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Library');











dojo.declare('bfree.api.Library', [bfree.api._Object, bfree.api._Securable], {
    zone: null,

    _choiceLists: null,
    _documents: null,
    _documentTypes: null,
    _folders: null,
    _propertyDefinitions: null,
    _references: null,
    _viewDefinitions: null,
    _viewMappings: null,
    _cellDefinitions: null,

    description: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
        this.securable_type = bfree.api._Securable.types.Library
    },

    createShare: function(args){

        var shareRoot = this.getFolders().getShareRootFolder();
        var parentInfo = { parent: shareRoot, attribute: 'children' };

        var share = this.getFolders().store.newItem({
            name: args.name,
            folder_type: bfree.api.Folder.FolderTypes.SHARE,
            parent_id: shareRoot.getId(),
            password: args.password,
            expiry: args.expiry,
            seed_id: (args.seed) ? args.seed.getId() : null,
            children: []
        }, parentInfo);

       return share;
    },

    empty_trash: function(args){
        var zone = args.zone;

        var url = dojo.replace(bfree.api.Library.EMPTYTRASH_TRGT,  [zone.subdomain, this.getId()]);

        var result = bfree.api.XhrHelper.doPutAction({
            target: url,
            putData: {}
        });

        return true;
    },

    getChoiceLists: function(){

        if(!this._choiceLists){
            this._choiceLists = new bfree.api.ChoiceLists({
                zone: this.zone,
                library: this
            });
        }

        return this._choiceLists;
    },

    getDocuments: function(){

        if(!this._documents){
            this._documents = new bfree.api.Documents({
                zone: this.zone,
                library: this
            });
        }

        return this._documents;
    },

    getDocumentTypes: function(){

       if(!this._documentTypes){
            this._documentTypes = new bfree.api.DocumentTypes({
                zone: this.zone,
                library: this
            });
        }

        return this._documentTypes;

    },

    getFolders: function(){

        if(!this._folders){
            this._folders = new bfree.api.Folders({
                zone: this.zone,
                library: this
            });
        }

        return this._folders;

    },

    getPropertyDefinitions: function(){

       if(!this._propertyDefinitions){
            this._propertyDefinitions = new bfree.api.PropertyDefinitions({
                zone: this.zone,
                library: this
            });
        }

        return this._propertyDefinitions;
    },

    getPropertyMappings: function(){
        if(!this._propertyMappings){
            this._propertyMappings = new bfree.api.PropertyMappings({
                zone: this.zone,
                library: this
            })
        }
        return this._propertyMappings;
    },

    getReferences: function(){
        if(!this._references){
            this._references = new bfree.api.References({
                zone: this.zone,
                library: this
            })
        }

        return this._references;
    },

    getViewDefinitions: function(){

        if(!this._viewDefinitions){
            this._viewDefinitions = new bfree.api.ViewDefinitions({
                zone: this.zone,
                library: this
            });
        }

        return this._viewDefinitions;

    },

    getViewMappings: function(){

        if(!this._viewMappings){
            this._viewMappings = new bfree.api.ViewMappings({
                zone: this.zone,
                library: this
            });
        }

        return this._viewMappings;

    },

    getCellDefinitions: function(){

        if(!this._cellDefinitions){
            this._cellDefinitions = new bfree.api.CellDefinitions({
                zone: this.zone,
                library: this
            });
        }

        return this._cellDefinitions;

    }

});

bfree.api.Library.EMPTYTRASH_TRGT = '/zones/{0}/libraries/{1}/empty_trash.json';


bfree.api.Library.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'description': {
            type: 'string'
        },
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'created_by': {
            type: 'string'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_by': {
            type: 'string'
        }
 	},
	prototype: new bfree.api.Library()
 };

}

if(!dojo._hasResource['bfree.api.Libraries']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Libraries'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 22/09/11
 * Time: 4:49 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Libraries');



dojo.declare('bfree.api.Libraries', [bfree.api._Collection],{
    zone: null,

    constructor: function(args){
        this.zone = args.zone;
        this.target = dojo.replace(bfree.api.Libraries.TRGT, this.zone);
		this.schema = bfree.api.Library.schema;
		this.cache = true;

		this._initialize();
    }

});

bfree.api.Libraries.TRGT = '/zones/{subdomain}/libraries';

}

if(!dojo._hasResource['bfree.api.Role']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Role'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 11/10/11
 * Time: 3:39 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Role');



dojo.declare('bfree.api.Role', [bfree.api._Object], {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    }

});

bfree.api.Role.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'created_by': {
            type: 'string'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_by': {
            type: 'string'
        }

 	},
	prototype: new bfree.api.Role()
 };


}

if(!dojo._hasResource['bfree.api.Roles']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Roles'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 11/10/11
 * Time: 3:39 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Roles');



dojo.declare('bfree.api.Roles', [bfree.api._Collection],{
    zone: null,

    constructor: function(args){
        this.zone = args.zone;
        this.target = dojo.replace(bfree.api.Roles.TRGT, this.zone);
		this.schema = bfree.api.Role.schema;
		this.cache = true;

		this._initialize();
    }


});

bfree.api.Roles.TRGT = '/zones/{subdomain}/roles';

}

if(!dojo._hasResource['bfree.api.User']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.User'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/09/11
 * Time: 12:00 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.User');



dojo.declare('bfree.api.User', [bfree.api._Object], {
    email: null,
    first_name: null,
    last_name: null,
    group: null,
    reset_password: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    getAvatarUrl: function(args){
      return dojo.replace(bfree.api.User.AVT_TRGT , [args.zone.subdomain, this.id]);
    },

    getFullName: function(){

        var fullName = (this.last_name == null) ? '' : this.last_name;

        if((this.first_name != null) && (this.first_name != '')){
            fullName += (fullName == '') ? this.first_name : ', ' + this.first_name;
        }

        return (fullName.length < 1) ? this.name : fullName;
    },

    isValid: function(){
        var isValid = true;

		if (String.isEmpty(this.name)) {
            isValid = false;
			//throw new Error('User\'s \'Name\' is empty or invalid');
		}

        if(this.name.length<4){
            isValid = false;
        }

        if(this.name.indexOf(' ')>=0){
            isValid = false;
        }

        if(!bfree.api.Utilities.validateEmail(this.email)){
            isValid=false;
        }

        if(this.password){
            if(String.isEmpty(this.password) || (this.password.length < 8)){
                isValid = false;
            }
        }

        /*
        if(this.isNew()){
            if(String.isEmpty(this.password) || (this.password.length < 8)){
                isValid = false;
            }
        }else{
            if(!)
            if(!(!password||password==null||password==""||password.length==0)){
                if(password.length>0&&password.length<8){
                    isValid=false;
                }
            }
        }
        */

        if(String.isEmpty(this.email)){
            isValid=false;
        }

		return isValid;
	}

});

bfree.api.User.AVT_TRGT = '/zones/{0}/users/{1}/avatar';

bfree.api.User.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'email': {
            type: 'string',
            'default': ''
        },
        'first_name': {
            type: 'string',
            'default': ''
        },
        'last_name': {
            type: 'string',
            'default': ''
        },
        'password': {
            type: 'string',
            'default': ''
        },
        'active_group':{
            type: 'integer',
            'default': 0
        },
        'created_at': {
            type: 'string',
            format: 'date-time',
            'default': dojo.date.stamp.toISOString(new Date(), {zulu: true})
        },
        'created_by': {
            type: 'string',
            'default': ''
        },
        'updated_at': {
            type: 'string',
            format: 'date-time',
            'default': dojo.date.stamp.toISOString(new Date(), {zulu: true})
        },
        'updated_by': {
            type: 'string',
            'default': ''
        }

 	},
	prototype: new bfree.api.User()
 };

}

if(!dojo._hasResource['bfree.api.Users']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Users'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 19/09/11
 * Time: 1:14 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Users');



dojo.declare('bfree.api.Users', [bfree.api._Collection],{
    zone: null,

    constructor: function(args){
        this.zone = args.zone;
        this.target = dojo.replace(bfree.api.Users.TRGT, this.zone);
		this.schema = bfree.api.User.schema;
		this.cache = true;

		this._initialize();
    },

    getAdmin: function(){
        var admin = null;

        this.forEach(function(item){
            if(item.is_admin)
                admin = item;
        }, this);

        return admin;
    },

    reset: function(fingerprint, newPassword){
        bfree.api.XhrHelper.doPostAction({
            target: dojo.replace(bfree.api.Users.RESET_TRGT, this.zone),
            postData: {
                f:fingerprint,
                newPassword:newPassword
            }
        })
    }

});

bfree.api.Users.generatePassword = function(args){
	var len = args.length;
	var charset = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	var pword = '';

	for(var i = 0; i < len; i++){
		pword += charset.charAt(Math.floor(Math.random()*(charset.length)));
	}
	return pword;
};

bfree.api.Users.TRGT = '/zones/{subdomain}/users';
bfree.api.Users.RESET_TRGT = '/zones/{subdomain}/users/reset';

}

if(!dojo._hasResource['bfree.api.PropertyMappings']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.PropertyMappings'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.PropertyMappings');





dojo.declare('bfree.api.PropertyMappings', [bfree.api._Collection],{
	
	constructor: function(/* Object */args){
        this.zone = args.zone;
        this.library = args.library;
        this.target = dojo.replace(bfree.api.PropertyMappings.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.PropertyMapping.schema;
        this.cache = true;

        this._initialize();
	}
	
});

bfree.api.PropertyMappings.getDefault= function(propMap, propDefs){
    var propertyDefinition=propDefs.fetchById({id: propMap.property_definition_id});
    if(propertyDefinition.isTypeDate()&&propMap.default_type==bfree.api.PropertyMapping.types.date.floating){
        var date=new Date();
        date.setDate(date.getDate()+parseInt(propMap.default_value));
        return date;
    }else{
        if(propMap.default_value){
            if(propertyDefinition.isTypeInteger()){
                return parseInt(propMap.default_value);
            }else if(propertyDefinition.isTypeFloat()){
                return parseFloat(propMap.default_value);
            }
            return propMap.default_value;
        }
    }
    return null;
};

bfree.api.PropertyMappings.TRGT='/zones/{0}/libraries/{1}/property_mappings';

}

if(!dojo._hasResource['bfree.api.ViewDefinition']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ViewDefinition'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.ViewDefinition');





dojo.declare('bfree.api.ViewDefinition', bfree.api._Object,{

    _view: null,

    constructor: function(/* Object */args){
        dojo.safeMixin(this, ((!args) ? { } : args));
	},

    _generate: function(library){

        var view = {
            name: this.name,
            id: this.getId(),
            sort_column: 1,
            cells: []
        };

        dojo.forEach(this.cell_definitions, function(item, idx){

            var cell = {
                field: dojo.replace('{table_name}.{column_name}', item),
                name: String.isBlank(item.label) ? '&nbsp;': item.label,
                width: item.width,
                noresize: item.noresize,
                style: item.style,
                date_format: item.date_format
            }

            cell.get = this._generateGetFn(item, library);
            cell.formatter = this._generateFormatterFn(item);

            view.cells.push(cell);

            if(cell.field == this.sort_by)
                view.sort_column = (this.is_desc) ? ((idx + 1) * -1) : (idx + 1);

        }, this);

        return view;

    },

    _generateFormatterFn: function(cell_definition){
        var fn = bfree.api.CellDefinition.formatData;

        switch(cell_definition.formatter){
            case bfree.api.CellDefinition.formats.icon:
                fn = bfree.api.CellDefinition.formatIcon;
                break;
            case bfree.api.CellDefinition.formats.size:
                fn = bfree.api.CellDefinition.formatSize;
                break;
            case bfree.api.CellDefinition.formats.status:
                fn = bfree.api.CellDefinition.formatStatus;
                break;
        }

        return fn;
    },

    _generateGetFn: function(cell_definition, library){
        var fn = null

        switch(cell_definition.table_name){
            case 'versions':
                fn = dojo.hitch([this, cell_definition], bfree.api.ViewDefinition._getVersionAttrFn);
                break;
            case 'documents':
                fn = dojo.hitch([this, cell_definition], bfree.api.ViewDefinition._getDocumentAttrFn);
                break;
            case 'document_types':
                fn = dojo.hitch([this, cell_definition, library], bfree.api.ViewDefinition._getDocumentTypeAttrFn);
                break;
        }

        return fn;
    },

    _formatDateTime: function(cellDef, datetime){
        return versa.api.Formatter.formatDateTime(datetime);
	},

    getCellByField: function(field){
        var cell = null;

        dojo.some(this.cell_definitions, function(cell_definition, idx){
            if(bfree.api.CellDefinition.getDbName(cell_definition) == field)
                cell = cell_definition;
            return (cell);
        }, this);

        return cell;
    },

    getView: function(library){

        /*
        if(!this._view){
            this._view = this._generate(library);
        }

        return this._view;
        */
        return this._generate(library);
    },

    isValid: function(){
        var isValid = true;

		if (String.isEmpty(this.name.trim())) {
            isValid = false;
		}

        if (String.isEmpty(this.sort_by)){
            isValid = false;
        }

		return isValid;
	},

    findColumn: function(table, column){
        for(var i=0;i<this.cell_definitions.length;i++){
            //turn into method
            if(this.cell_definitions[i].table_name&&
               this.cell_definitions[i].column_name&&
               table==this.cell_definitions[i].table_name&&
               column==this.cell_definitions[i].column_name){
                return this.cell_definitions[i];
            }
        }
        return null;
    }

});

bfree.api.ViewDefinition.getCustomName = function(user, folder){
    return dojo.replace('{0}.{1}', [user.name, folder.name]);
}

bfree.api.ViewDefinition._getDocumentAttrFn =  function(rowIndex, item){
    var value = '';
    var viewDef = this[0];
    var cellDef = this[1];

    if(!item)
        return value;

    var column = cellDef.column_name

    switch(column){
        case 'created_at':
        case 'updated_at':
            value = viewDef._formatDateTime(cellDef, item[column]);
            break;
        default:
            if (/prp_dtt/.test(column) && item[column]) {
                value = viewDef._formatDateTime(cellDef, item[column]);
            }
            else {
                value = item[column];
            }
            break;
    }

    return value;
};

bfree.api.ViewDefinition._getDocumentTypeAttrFn = function(rowIndex, item){
    var value = '';

    var viewDef = this[0];
    var cellDef = this[1];
    var activeLibrary = this[2];

    if((!item))
        return value;

    switch(cellDef.column_name){
        case 'name':
            value = item.document_type_name;
            break;
    }

    return value;
};

bfree.api.ViewDefinition._getVersionAttrFn = function(rowIndex, item){
    var value = null;
    var viewDef = this[0];
    var cellDef = this[1];

    if(!item)
        return value;

    try{
        switch(cellDef.column_name){
            case 'binary_content_type':
                value = item.binary_content_type
                break;
            case 'version_number':
                value = item.major_version_number;
                break;
            case 'binary_file_size':
                value = item.binary_file_size;
                break;
        }
    }
    catch(e){
        console.log(e);
    }
    return (!value) ? '' : value;
};



bfree.api.ViewDefinition.compare=function(viewA, viewB){

    if((!viewA) && (viewB))
        return -1;
    if((viewA) && (!viewB))
        return 1;
    if((!viewA) && (!viewB))
        return 0;

    if((!viewA.name) && (viewB.name))
        return -1;
    if((viewA.name) && (!viewB.name))
        return 1;
    if((!viewA.name) && (!viewB.name))
        return 0;

    if(viewA.name.toLowerCase() == viewB.name.toLowerCase()){
        return 0;
    }

    return (viewA.name.toLowerCase() < viewB.name.toLowerCase()) ? -1 : 1;
}

bfree.api.ViewDefinition.schema = {
	type: 'object',
	properties: {
		'id': {
			type: 'integer'
		},
		'name': {
			type: 'string'			
		},
        'description': {
            type: 'string'
        },
        'is_desc': {
            type: 'boolean',
			'default': false
        },
        'is_template': {
            type: 'boolean',
			'default': false
        },
		'scope': {
			type: 'string',
			'default': '*'
		},
		'sort_by': {
			type: 'string'
		},
        'cell_definitions': {
            type: 'array',
            'default': [],
            'items': {
                type: 'object',
                properties: {
                    'table_name': {
                        type: 'string'
                    },
                    'column_name': {
                        type: 'string'
                    },
                    'name': {
                        type: 'string'
                    },
                    'label': {
                        type: 'string'
                    },
                    'column_order': {
                        type: 'integer'
                    },
                    'formatter': {
                        type: 'integer'
                    },
                    'date_format': {
                        type: 'string'
                    },
                    'width': {
                        type: 'string'
                    }
                }
            }
        },
		'created_at': {
			type: 'date',
			format: 'date-time'
		},
		'created_by': {
			type: 'string',
			'default': ''			
		},
		'updated_at': {
			type: 'date',
			format: 'date-time'
		},
		'updated_by': {
			type: 'string',
			'default': ''
		}
	},
    prototype: bfree.api.ViewDefinition.prototype
}

}

if(!dojo._hasResource["dojo.dnd.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.common"] = true;
dojo.provide("dojo.dnd.common");

dojo.getObject("dnd", true, dojo);

dojo.dnd.getCopyKeyState = dojo.isCopyKey;

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

}

if(!dojo._hasResource["dojo.parser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.parser"] = true;
dojo.provide("dojo.parser");



new Date("X"); // workaround for #11279, new Date("") == NaN

dojo.parser = new function(){
	// summary:
	//		The Dom/Widget parsing package

	var d = dojo;

	function val2type(/*Object*/ value){
		// summary:
		//		Returns name of type of given value.

		if(d.isString(value)){ return "string"; }
		if(typeof value == "number"){ return "number"; }
		if(typeof value == "boolean"){ return "boolean"; }
		if(d.isFunction(value)){ return "function"; }
		if(d.isArray(value)){ return "array"; } // typeof [] == "object"
		if(value instanceof Date) { return "date"; } // assume timestamp
		if(value instanceof d._Url){ return "url"; }
		return "object";
	}

	function str2obj(/*String*/ value, /*String*/ type){
		// summary:
		//		Convert given string value to given type
		switch(type){
			case "string":
				return value;
			case "number":
				return value.length ? Number(value) : NaN;
			case "boolean":
				// for checked/disabled value might be "" or "checked".	 interpret as true.
				return typeof value == "boolean" ? value : !(value.toLowerCase()=="false");
			case "function":
				if(d.isFunction(value)){
					// IE gives us a function, even when we say something like onClick="foo"
					// (in which case it gives us an invalid function "function(){ foo }").
					//	Therefore, convert to string
					value=value.toString();
					value=d.trim(value.substring(value.indexOf('{')+1, value.length-1));
				}
				try{
					if(value === "" || value.search(/[^\w\.]+/i) != -1){
						// The user has specified some text for a function like "return x+5"
						return new Function(value);
					}else{
						// The user has specified the name of a function like "myOnClick"
						// or a single word function "return"
						return d.getObject(value, false) || new Function(value);
					}
				}catch(e){ return new Function(); }
			case "array":
				return value ? value.split(/\s*,\s*/) : [];
			case "date":
				switch(value){
					case "": return new Date("");	// the NaN of dates
					case "now": return new Date();	// current date
					default: return d.date.stamp.fromISOString(value);
				}
			case "url":
				return d.baseUrl + value;
			default:
				return d.fromJson(value);
		}
	}

	var dummyClass = {}, instanceClasses = {
		// map from fully qualified name (like "dijit.Button") to structure like
		// { cls: dijit.Button, params: {label: "string", disabled: "boolean"} }
	};

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	// TODO: remove this in 2.0, when we stop caching parameters.
	d.connect(d, "extend", function(){
		instanceClasses = {};
	});

	function getProtoInfo(cls, params){
		// cls: A prototype
		//		The prototype of the class to check props on
		// params: Object
		//		The parameters object to mix found parameters onto.
		for(var name in cls){
			if(name.charAt(0)=="_"){ continue; }	// skip internal properties
			if(name in dummyClass){ continue; }		// skip "constructor" and "toString"
			params[name] = val2type(cls[name]);
		}
		return params;
	}

	function getClassInfo(/*String*/ className, /*Boolean*/ skipParamsLookup){
		// summary:
		//		Maps a widget name string like "dijit.form.Button" to the widget constructor itself,
		//		and a list of that widget's parameters and their types
		// className:
		//		fully qualified name (like "dijit.form.Button")
		// returns:
		//		structure like
		//			{
		//				cls: dijit.Button,
		//				params: { label: "string", disabled: "boolean"}
		//			}

		var c = instanceClasses[className];
		if(!c){
			// get pointer to widget class
			var cls = d.getObject(className), params = null;
			if(!cls){ return null; }		// class not defined [yet]
			if(!skipParamsLookup){ // from fastpath, we don't need to lookup the attrs on the proto because they are explicit
				params = getProtoInfo(cls.prototype, {})
			}
			c = { cls: cls, params: params };
			
		}else if(!skipParamsLookup && !c.params){
			// if we're calling getClassInfo and have a cls proto, but no params info, scan that cls for params now
			// and update the pointer in instanceClasses[className]. This happens when a widget appears in another
			// widget's template which still uses dojoType, but an instance of the widget appears prior with a data-dojo-type,
			// skipping this lookup the first time.
			c.params = getProtoInfo(c.cls.prototype, {});
		}
		
		return c;
	}

	this._functionFromScript = function(script, attrData){
		// summary:
		//		Convert a <script type="dojo/method" args="a, b, c"> ... </script>
		//		into a function
		// script: DOMNode
		//		The <script> DOMNode
		// attrData: String
		//		For HTML5 compliance, searches for attrData + "args" (typically
		//		"data-dojo-args") instead of "args"
		var preamble = "";
		var suffix = "";
		var argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args"));
		if(argsStr){
			d.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			d.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	};

	this.instantiate = function(/* Array */nodes, /* Object? */mixin, /* Object? */args){
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a startup method to allow them to connect with
		//		any children.
		// nodes: Array
		//		Array of nodes or objects like
		//	|		{
		//	|			type: "dijit.form.Button",
		//	|			node: DOMNode,
		//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
		//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
		//	|		}
		// mixin: Object?
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// args: Object?
		//		An object used to hold kwArgs for instantiation.
		//		See parse.args argument for details.

		var thelist = [],
		mixin = mixin||{};
		args = args||{};

		// TODO: for 2.0 default to data-dojo- regardless of scopeName (or maybe scopeName won't exist in 2.0)
		var attrName = (args.scope || d._scopeName) + "Type",	// typically "dojoType"
			attrData = "data-" + (args.scope || d._scopeName) + "-";	// typically "data-dojo-"

		d.forEach(nodes, function(obj){
			if(!obj){ return; }

			// Get pointers to DOMNode, dojoType string, and clsInfo (metadata about the dojoType), etc.
			var node, type, clsInfo, clazz, scripts, fastpath;
			if(obj.node){
				// new format of nodes[] array, object w/lots of properties pre-computed for me
				node = obj.node;
				type = obj.type;
				fastpath = obj.fastpath;
				clsInfo = obj.clsInfo || (type && getClassInfo(type, fastpath));
				clazz = clsInfo && clsInfo.cls;
				scripts = obj.scripts;
			}else{
				// old (backwards compatible) format of nodes[] array, simple array of DOMNodes. no fastpath/data-dojo-type support here.
				node = obj;
				type = attrName in mixin ? mixin[attrName] : node.getAttribute(attrName);
				clsInfo = type && getClassInfo(type);
				clazz = clsInfo && clsInfo.cls;
				scripts = (clazz && (clazz._noScript || clazz.prototype._noScript) ? [] :
							d.query("> script[type^='dojo/']", node));
			}
			if(!clsInfo){
				throw new Error("Could not load class '" + type);
			}

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};
				
			if(args.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				d._mixin(params, args.defaults);
			}
			if(obj.inherited){
				// settings from dir=rtl or lang=... on a node above this node
				d._mixin(params, obj.inherited);
			}
			
			// mix things found in data-dojo-props into the params
			if(fastpath){
				var extra = node.getAttribute(attrData + "props");
				if(extra && extra.length){
					try{
						extra = d.fromJson.call(args.propsThis, "{" + extra + "}");
						d._mixin(params, extra);
					}catch(e){
						// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
						throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
					}
				}

				// For the benefit of _Templated, check if node has data-dojo-attach-point/data-dojo-attach-event
				// and mix those in as though they were parameters
				var attachPoint = node.getAttribute(attrData + "attach-point");
				if(attachPoint){
					params.dojoAttachPoint = attachPoint;
				}
				var attachEvent = node.getAttribute(attrData + "attach-event");
				if(attachEvent){
					params.dojoAttachEvent = attachEvent;
				}
				dojo.mixin(params, mixin);
			}else{
				// FIXME: we need something like "deprecateOnce()" to throw dojo.deprecation for something.
				// remove this logic in 2.0
				// read parameters (ie, attributes) specified on DOMNode

				var attributes = node.attributes;

				// clsInfo.params lists expected params like {"checked": "boolean", "n": "number"}
				for(var name in clsInfo.params){
					var item = name in mixin ? { value:mixin[name], specified:true } : attributes.getNamedItem(name);
					if(!item || (!item.specified && (!dojo.isIE || name.toLowerCase()!="value"))){ continue; }
					var value = item.value;
					// Deal with IE quirks for 'class' and 'style'
					switch(name){
					case "class":
						value = "className" in mixin ? mixin.className : node.className;
						break;
					case "style":
						value = "style" in mixin ? mixin.style : (node.style && node.style.cssText); // FIXME: Opera?
					}
					var _type = clsInfo.params[name];
					if(typeof value == "string"){
						params[name] = str2obj(value, _type);
					}else{
						params[name] = value;
					}
				}
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" event="foo"> tags are dojo.connected after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var connects = [],	// functions to connect after instantiation
				calls = [];		// functions to call after instantiation

			d.forEach(scripts, function(script){
				node.removeChild(script);
				// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
				var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
					type = script.getAttribute("type"),
					nf = d.parser._functionFromScript(script, attrData);
				if(event){
					if(type == "dojo/connect"){
						connects.push({event: event, func: nf});
					}else{
						params[event] = nf;
					}
				}else{
					calls.push(nf);
				}
			});

			var markupFactory = clazz.markupFactory || clazz.prototype && clazz.prototype.markupFactory;
			// create the instance
			var instance = markupFactory ? markupFactory(params, node, clazz) : new clazz(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			// FIXME: in 2.0, drop jsId support. use data-dojo-id instead
			var jsname = (node.getAttribute(attrData + "id") || node.getAttribute("jsId"));
			if(jsname){
				d.setObject(jsname, instance);
			}

			// process connections and startup functions
			d.forEach(connects, function(connect){
				d.connect(instance, connect.event, null, connect.func);
			});
			d.forEach(calls, function(func){
				func.call(instance);
			});
		});

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		if(!mixin._started){
			// TODO: for 2.0, when old instantiate() API is desupported, store parent-child
			// relationships in the nodes[] array so that no getParent() call is needed.
			// Note that will  require a parse() call from ContentPane setting a param that the
			// ContentPane is the parent widget (so that the parse doesn't call startup() on the
			// ContentPane's children)
			d.forEach(thelist, function(instance){
				if( !args.noStart && instance  &&
					dojo.isFunction(instance.startup) &&
					!instance._started &&
					(!instance.getParent || !instance.getParent())
				){
					instance.startup();
				}
			});
		}
		return thelist;
	};

	this.parse = function(rootNode, args){
		// summary:
		//		Scan the DOM for class instances, and instantiate them.
		//
		// description:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them. Searches for either data-dojo-type="Class" or
		//		dojoType="Class" where "Class" is a a fully qualified class name,
		//		like `dijit.form.Button`
		//
		//		Using `data-dojo-type`:
		//		Attributes using can be mixed into the parameters used to instantitate the
		//		Class by using a `data-dojo-props` attribute on the node being converted.
		//		`data-dojo-props` should be a string attribute to be converted from JSON.
		//
		//		Using `dojoType`:
		//		Attributes are read from the original domNode and converted to appropriate
		//		types by looking up the Class prototype values. This is the default behavior
		//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
		//		go away in Dojo 2.0.
		//
		// rootNode: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `args`
		//		object can be passed in this place. If the `args` object has a
		//		`rootNode` member, that is used.
		//
		// args: Object
		//		a kwArgs object passed along to instantiate()
		//
		//			* noStart: Boolean?
		//				when set will prevent the parser from calling .startup()
		//				when locating the nodes.
		//			* rootNode: DomNode?
		//				identical to the function's `rootNode` argument, though
		//				allowed to be passed in via this `args object.
		//			* template: Boolean
		//				If true, ignores ContentPane's stopParser flag and parses contents inside of
		//				a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
		//				nested inside the ContentPane to work.
		//			* inherited: Object
		//				Hash possibly containing dir and lang settings to be applied to
		//				parsed widgets, unless there's another setting on a sub-node that overrides
		//			* scope: String
		//				Root for attribute names to search for.   If scopeName is dojo,
		//				will search for data-dojo-type (or dojoType).   For backwards compatibility
		//				reasons defaults to dojo._scopeName (which is "dojo" except when
		//				multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		//			* propsThis: Object
		//				If specified, "this" referenced from data-dojo-props will refer to propsThis.
		//				Intended for use from the widgets-in-template feature of `dijit._Templated`
		//
		// example:
		//		Parse all widgets on a page:
		//	|		dojo.parser.parse();
		//
		// example:
		//		Parse all classes within the node with id="foo"
		//	|		dojo.parser.parse(dojo.byId('foo'));
		//
		// example:
		//		Parse all classes in a page, but do not call .startup() on any
		//		child
		//	|		dojo.parser.parse({ noStart: true })
		//
		// example:
		//		Parse all classes in a node, but do not call .startup()
		//	|		dojo.parser.parse(someNode, { noStart:true });
		//	|		// or
		//	|		dojo.parser.parse({ noStart:true, rootNode: someNode });

		// determine the root node based on the passed arguments.
		var root;
		if(!args && rootNode && rootNode.rootNode){
			args = rootNode;
			root = args.rootNode;
		}else{
			root = rootNode;
		}
		root = root ? dojo.byId(root) : dojo.body();
		args = args || {};

		var attrName = (args.scope || d._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (args.scope || d._scopeName) + "-";	// typically "data-dojo-"

		function scan(parent, list){
			// summary:
			//		Parent is an Object representing a DOMNode, with or without a dojoType specified.
			//		Scan parent's children looking for nodes with dojoType specified, storing in list[].
			//		If parent has a dojoType, also collects <script type=dojo/*> children and stores in parent.scripts[].
			// parent: Object
			//		Object representing the parent node, like
			//	|	{
			//	|		node: DomNode,			// scan children of this node
			//	|		inherited: {dir: "rtl"},	// dir/lang setting inherited from above node
			//	|
			//	|		// attributes only set if node has dojoType specified
			//	|		scripts: [],			// empty array, put <script type=dojo/*> in here
			//	|		clsInfo: { cls: dijit.form.Button, ...}
			//	|	}
			// list: DomNode[]
			//		Output array of objects (same format as parent) representing nodes to be turned into widgets

			// Effective dir and lang settings on parent node, either set directly or inherited from grandparent
			var inherited = dojo.clone(parent.inherited);
			dojo.forEach(["dir", "lang"], function(name){
				// TODO: what if this is a widget and dir/lang are declared in data-dojo-props?
				var val = parent.node.getAttribute(name);
				if(val){
					inherited[name] = val;
				}
			});

			// if parent is a widget, then search for <script type=dojo/*> tags and put them in scripts[].
			var scripts = parent.clsInfo && !parent.clsInfo.cls.prototype._noScript ? parent.scripts : null;

			// unless parent is a widget with the stopParser flag set, continue search for dojoType, recursively
			var recurse = (!parent.clsInfo || !parent.clsInfo.cls.prototype.stopParser) || (args && args.template);

			// scan parent's children looking for dojoType and <script type=dojo/*>
			for(var child = parent.node.firstChild; child; child = child.nextSibling){
				if(child.nodeType == 1){
					// FIXME: desupport dojoType in 2.0. use data-dojo-type instead
					var type, html5 = recurse && child.getAttribute(attrData + "type");
					if(html5){
						type = html5;
					}else{
						// fallback to backward compatible mode, using dojoType. remove in 2.0
						type = recurse && child.getAttribute(attrName);
					}
					
					var fastpath = html5 == type;

					if(type){
						// if dojoType/data-dojo-type specified, add to output array of nodes to instantiate
						var params = {
							"type": type,
							fastpath: fastpath,
							clsInfo: getClassInfo(type, fastpath), // note: won't find classes declared via dojo.Declaration
							node: child,
							scripts: [], // <script> nodes that are parent's children
							inherited: inherited // dir & lang attributes inherited from parent
						};
						list.push(params);

						// Recurse, collecting <script type="dojo/..."> children, and also looking for
						// descendant nodes with dojoType specified (unless the widget has the stopParser flag),
						scan(params, list);
					}else if(scripts && child.nodeName.toLowerCase() == "script"){
						// if <script type="dojo/...">, save in scripts[]
						type = child.getAttribute("type");
						if (type && /^dojo\/\w/i.test(type)) {
							scripts.push(child);
						}
					}else if(recurse){
						// Recurse, looking for grandchild nodes with dojoType specified
						scan({
							node: child,
							inherited: inherited
						}, list);
					}
				}
			}
		}

		// Ignore bogus entries in inherited hash like {dir: ""}
		var inherited = {};
		if(args && args.inherited){
			for(var key in args.inherited){
				if(args.inherited[key]){ inherited[key] = args.inherited[key]; }
			}
		}

		// Make list of all nodes on page w/dojoType specified
		var list = [];
		scan({
			node: root,
			inherited: inherited
		}, list);

		// go build the object instances
		var mixin = args && args.template ? {template: true} : null;
		return this.instantiate(list, mixin, args); // Array
	};
}();

//Register the parser callback. It should be the first callback
//after the a11y test.

(function(){
	var parseRunner = function(){
		if(dojo.config.parseOnLoad){
			dojo.parser.parse();
		}
	};

	// FIXME: need to clobber cross-dependency!!
	if(dojo.getObject("dijit.wai.onload") === dojo._loaders[0]){
		dojo._loaders.splice(1, 0, parseRunner);
	}else{
		dojo._loaders.unshift(parseRunner);
	}
})();

}

if(!dojo._hasResource["dojo.dnd.Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Container"] = true;
dojo.provide("dojo.dnd.Container");




/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/

/*=====
dojo.declare("dojo.dnd.__ContainerArgs", [], {
	creator: function(){
		// summary:
		//		a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
	},

	// skipForm: Boolean
	//		don't start the drag operation, if clicked on form elements
	skipForm: false,

	// dropParent: Node||String
	//		node or node's id to use as the parent node for dropped items
	//		(must be underneath the 'node' parameter in the DOM)
	dropParent: null,

	// _skipStartup: Boolean
	//		skip startup(), which collects children, for deferred initialization
	//		(this is used in the markup mode)
	_skipStartup: false
});

dojo.dnd.Item = function(){
	// summary:
	//		Represents (one of) the source node(s) being dragged.
	//		Contains (at least) the "type" and "data" attributes.
	// type: String[]
	//		Type(s) of this item, by default this is ["text"]
	// data: Object
	//		Logical representation of the object being dragged.
	//		If the drag object's type is "text" then data is a String,
	//		if it's another type then data could be a different Object,
	//		perhaps a name/value hash.
	
	this.type = type;
	this.data = data;
}
=====*/

dojo.declare("dojo.dnd.Container", null, {
	// summary:
	//		a Container object, which knows when mouse hovers over it,
	//		and over which element it hovers
	
	// object attributes (for markup)
	skipForm: false,
	
	/*=====
	// current: DomNode
	//		The DOM node the mouse is currently hovered over
	current: null,
	
	// map: Hash<String, dojo.dnd.Item>
	//		Map from an item's id (which is also the DOMNode's id) to
	//		the dojo.dnd.Item itself.
	map: {},
	=====*/
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Container
		// node: Node
		//		node or node's id to build the container on
		// params: dojo.dnd.__ContainerArgs
		//		a dictionary of parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dojo.byId(params.dropParent);
		
		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		dojo.addClass(this.node, "dojoDndContainer");
		
		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			dojo.connect(this.node, "onmouseover", this, "onMouseOver"),
			dojo.connect(this.node, "onmouseout",  this, "onMouseOut"),
			// cancel text selection and text dragging
			dojo.connect(this.node, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.node, "onselectstart", this, "onSelectStart")
		];
	},
	
	// object attributes (for markup)
	creator: function(){
		// summary:
		//		creator function, dummy at the moment
	},
	
	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary:
		//		returns a data item by its key (id)
		return this.map[key];	// dojo.dnd.Item
	},
	setItem: function(/*String*/ key, /*dojo.dnd.Item*/ data){
		// summary:
		//		associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary:
		//		removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over a data map skipping members that
		//		are present in the empty object (IE and/or 3rd-party libraries).
		o = o || dojo.global;
		var m = this.map, e = dojo.dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary:
		//		removes all data items from the map
		this.map = {};
	},
	
	// methods
	getAllNodes: function(){
		// summary:
		//		returns a list (an array) of all valid child nodes
		return dojo.query("> .dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dojo.dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary:
		//		inserts an array of new nodes before/after an anchor node
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		if(anchor){
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.insertBefore(t.node, anchor);
			}
		}else{
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares this object to be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Container(node, params);
	},
	startup: function(){
		// summary:
		//		collects valid child items and populate the map
		
		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary:
		//		event processor for onmouseover
		// e: Event
		//		mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary:
		//		event processor for onmouseout
		// e: Event
		//		mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skipForm || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary:
		//		changes a named state to new state value
		// type: String
		//		a name of the state to change
		// newState: String
		//		new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary:
		//		adds a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.addClass(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary:
		//		removes a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.removeClass(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary:
		//		gets a child, which is under the mouse at the moment, or null
		// e: Event
		//		a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(parent == this.parent && dojo.hasClass(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(/*dojo.dnd.Item*/ item, /*String*/ hint){
		// summary:
		//		adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!dojo.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dojo.dnd.getUniqueId(); }
		dojo.addClass(t.node, "dojoDndItem");
		return t;
	}
});

dojo.dnd._createNode = function(tag){
	// summary:
	//		returns a function, which creates an element of given tag
	//		(SPAN by default) and sets its innerHTML to given text
	// tag: String
	//		a tag name or empty for SPAN
	if(!tag){ return dojo.dnd._createSpan; }
	return function(text){	// Function
		return dojo.create(tag, {innerHTML: text});	// Node
	};
};

dojo.dnd._createTrTd = function(text){
	// summary:
	//		creates a TR/TD structure with given text as an innerHTML of TD
	// text: String
	//		a text for TD
	var tr = dojo.create("tr");
	dojo.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dojo.dnd._createSpan = function(text){
	// summary:
	//		creates a SPAN element with given text as its innerHTML
	// text: String
	//		a text for SPAN
	return dojo.create("span", {innerHTML: text});	// Node
};

// dojo.dnd._defaultCreatorNodes: Object
//		a dictionary that maps container tag names to child tag names
dojo.dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dojo.dnd._defaultCreator = function(node){
	// summary:
	//		takes a parent node, and returns an appropriate creator function
	// node: Node
	//		a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dojo.dnd._createTrTd :
			dojo.dnd._createNode(dojo.dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && dojo.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dojo.dnd._createSpan : c)(String(data));
		}
		if(!n.id){
			n.id = dojo.dnd.getUniqueId();
		}
		return {node: n, data: data, type: type};
	};
};

}

if(!dojo._hasResource["dojo.dnd.Selector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Selector"] = true;
dojo.provide("dojo.dnd.Selector");




/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

/*=====
dojo.declare("dojo.dnd.__SelectorArgs", [dojo.dnd.__ContainerArgs], {
	//	singular: Boolean
	//		allows selection of only one element, if true
	singular: false,

	//	autoSync: Boolean
	//		autosynchronizes the source with its list of DnD nodes,
	autoSync: false
});
=====*/

dojo.declare("dojo.dnd.Selector", dojo.dnd.Container, {
	// summary:
	//		a Selector object, which knows how to select its children
	
	/*=====
	// selection: Set<String>
	//		The set of id's that are currently selected, such that this.selection[id] == 1
	//		if the node w/that id is selected.  Can iterate over selected node's id's like:
	//	|		for(var id in this.selection)
	selection: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		constructor of the Selector
		// node: Node||String
		//		node or node's id to build the selector on
		// params: dojo.dnd.__SelectorArgs?
		//		a dictionary of parameters
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			dojo.connect(this.node, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.node, "onmouseup",   this, "onMouseUp"));
	},
	
	// object attributes (for markup)
	singular: false,	// is singular property
	
	// methods
	getSelectedNodes: function(){
		// summary:
		//		returns a list (an array) of selected nodes
		var t = new dojo.NodeList();
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dojo.byId(i));
		}
		return t;	// NodeList
	},
	selectNone: function(){
		// summary:
		//		unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary:
		//		selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dojo.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary:
		//		deletes all selected items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dojo.byId(i);
			this.delItem(i);
			dojo.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over selected items;
		//		see `dojo.dnd.Container.forInItems()` for details
		o = o || dojo.global;
		var s = this.selection, e = dojo.dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		
		dojo.dnd.Selector.superclass.sync.call(this);
		
		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}
		
		// fix the selection
		var t = [], e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		dojo.forEach(t, function(i){
			delete this.selection[i];
		}, this);
		
		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary:
		//		inserts new data items (see `dojo.dnd.Container.insertNodes()` method for details)
		// addSelected: Boolean
		//		all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		dojo.dnd.Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Selector(node, params);
	},

	// mouse events
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dojo.isCopyKey(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(e.button === dojo.mouseButtons.LEFT){
				// accept the left button and stop the event
				// for IE we don't stop event when multiple buttons are pressed
				dojo.stopEvent(e);
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dojo.isCopyKey(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0;
					for(; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dojo.isCopyKey(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dojo.isCopyKey(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(e){
		// summary
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		this.simpleSelection = false;
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.disconnect(this.onmousemoveEvent);
		delete this.onmousemoveEvent;
	},
	_removeSelection: function(){
		// summary:
		//		unselects all items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dojo.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

}

if(!dojo._hasResource["dojo.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.window"] = true;
dojo.provide("dojo.window");

dojo.getObject("window", true, dojo);

dojo.window.getBox = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var scrollRoot = (dojo.doc.compatMode == 'BackCompat') ? dojo.body() : dojo.doc.documentElement;

	// get scroll position
	var scroll = dojo._docScroll(); // scrollRoot.scrollTop/Left should work
	return { w: scrollRoot.clientWidth, h: scrollRoot.clientHeight, l: scroll.x, t: scroll.y };
};

dojo.window.get = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(dojo.isIE && window !== document.parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc.parentWindow || doc.defaultView;	//	Window
};

dojo.window.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	
	// don't rely on node.scrollIntoView working just because the function is there

	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
		node = dojo.byId(node);
		var doc = node.ownerDocument || dojo.doc,
			body = doc.body || dojo.body(),
			html = doc.documentElement || body.parentNode,
			isIE = dojo.isIE, isWK = dojo.isWebKit;
		// if an untested browser, then use the native method
		if((!(dojo.isMoz || isIE || isWK || dojo.isOpera) || node == body || node == html) && (typeof node.scrollIntoView != "undefined")){
			node.scrollIntoView(false); // short-circuit to native if possible
			return;
		}
		var backCompat = doc.compatMode == 'BackCompat',
			clientAreaRoot = (isIE >= 9 && node.ownerDocument.parentWindow.frameElement)
				? ((html.clientHeight > 0 && html.clientWidth > 0 && (body.clientHeight == 0 || body.clientWidth == 0 || body.clientHeight > html.clientHeight || body.clientWidth > html.clientWidth)) ? html : body)
				: (backCompat ? body : html),
			scrollRoot = isWK ? body : clientAreaRoot,
			rootWidth = clientAreaRoot.clientWidth,
			rootHeight = clientAreaRoot.clientHeight,
			rtl = !dojo._isBodyLtr(),
			nodePos = pos || dojo.position(node),
			el = node.parentNode,
			isFixed = function(el){
				return ((isIE <= 6 || (isIE && backCompat))? false : (dojo.style(el, 'position').toLowerCase() == "fixed"));
			};
		if(isFixed(node)){ return; } // nothing to do

		while(el){
			if(el == body){ el = scrollRoot; }
			var elPos = dojo.position(el),
				fixedPos = isFixed(el);
	
			if(el == scrollRoot){
				elPos.w = rootWidth; elPos.h = rootHeight;
				if(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
				if(elPos.x < 0 || !isIE){ elPos.x = 0; } // IE can have values > 0
				if(elPos.y < 0 || !isIE){ elPos.y = 0; }
			}else{
				var pb = dojo._getPadBorderExtents(el);
				elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
				var clientSize = el.clientWidth,
					scrollBarSize = elPos.w - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.w = clientSize;
					elPos.x += (rtl && (isIE || el.clientLeft > pb.l/*Chrome*/)) ? scrollBarSize : 0;
				}
				clientSize = el.clientHeight;
				scrollBarSize = elPos.h - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.h = clientSize;
				}
			}
			if(fixedPos){ // bounded by viewport, not parents
				if(elPos.y < 0){
					elPos.h += elPos.y; elPos.y = 0;
				}
				if(elPos.x < 0){
					elPos.w += elPos.x; elPos.x = 0;
				}
				if(elPos.y + elPos.h > rootHeight){
					elPos.h = rootHeight - elPos.y;
				}
				if(elPos.x + elPos.w > rootWidth){
					elPos.w = rootWidth - elPos.x;
				}
			}
			// calculate overflow in all 4 directions
			var l = nodePos.x - elPos.x, // beyond left: < 0
				t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
				r = l + nodePos.w - elPos.w, // beyond right: > 0
				bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
			if(r * l > 0){
				var s = Math[l < 0? "max" : "min"](l, r);
				if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }
				nodePos.x += el.scrollLeft;
				el.scrollLeft += s;
				nodePos.x -= el.scrollLeft;
			}
			if(bot * t > 0){
				nodePos.y += el.scrollTop;
				el.scrollTop += Math[t < 0? "max" : "min"](t, bot);
				nodePos.y -= el.scrollTop;
			}
			el = (el != scrollRoot) && !fixedPos && el.parentNode;
		}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

}

if(!dojo._hasResource["dojo.dnd.autoscroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.autoscroll"] = true;
dojo.provide("dojo.dnd.autoscroll");


dojo.getObject("dnd", true, dojo);

dojo.dnd.getViewport = dojo.window.getBox;

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.window.getBox(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n);
			if(s.overflow.toLowerCase() in dojo.dnd._validOverflow){
				var b = dojo._getContentBox(n, s), t = dojo.position(n, true);
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				var w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2),
					h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2),
					rx = e.pageX - t.x, ry = e.pageY - t.y, dx = 0, dy = 0;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft;
					ry += dojo.body().scrollTop;
				}
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
				}
				//console.log("ry =", ry, "b.h =", b.h, "h =", h);
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
				}
				var oldLeft = n.scrollLeft, oldTop = n.scrollTop;
				n.scrollLeft = n.scrollLeft + dx;
				n.scrollTop  = n.scrollTop  + dy;
				if(oldLeft != n.scrollLeft || oldTop != n.scrollTop){ return; }
			}
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

}

if(!dojo._hasResource["dojo.dnd.Avatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Avatar"] = true;
dojo.provide("dojo.dnd.Avatar");



dojo.declare("dojo.dnd.Avatar", null, {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),
			tr = dojo.create("tr", null, b),
			td = dojo.create("td", null, tr),
			icon = this.isA11y ? dojo.create("span", {
						id : "a11yIcon",
						innerHTML : this.manager.copy ? '+' : "<"
					}, td) : null,
			span = dojo.create("span", {
				innerHTML: source.generateText ? this._generateText() : ""
			}, td),
			k = Math.min(5, this.manager.nodes.length), i = 0;
		// we have to set the opacity on IE only after the node is live
		dojo.attr(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary:
		//		destructor for the avatar; called to remove all references so it can be garbage-collected
		dojo.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary:
		//		updates the avatar to reflect the current DnD state
		dojo[(this.manager.canDropFlag ? "add" : "remove") + "Class"](this.node, "dojoDndAvatarCanDrop");
		if (this.isA11y){
			var icon = dojo.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy) {
				text = '< '; // canDrop && move
			}else if (!this.manager.canDropFlag && !this.manager.copy) {
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		dojo.query(("tr.dojoDndAvatarHeader td span" +(this.isA11y ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this._generateText();
			}, this);
	},
	_generateText: function(){
		// summary: generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

}

if(!dojo._hasResource["dojo.dnd.Manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Manager"] = true;
dojo.provide("dojo.dnd.Manager");





dojo.declare("dojo.dnd.Manager", null, {
	// summary:
	//		the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,
	
	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c);
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		dojo.removeClass(dojo.body(), ["dojoDndCopy", "dojoDndMove"]);
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed
		return new dojo.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},
	
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.isCopyKey(e)));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.isCopyKey(e))),
				params = [this.source, this.nodes, copy, this.target, e];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},
	
	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	
	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.replaceClass(dojo.body(),
			"dojoDnd" + (this.copy ? "Copy" : "Move"),
			"dojoDnd" + (this.copy ? "Move" : "Copy"));
	}
});

// dojo.dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dojo.dnd._manager = null;

dojo.dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new dojo.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

}

if(!dojo._hasResource["dojo.dnd.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Source"] = true;
dojo.provide("dojo.dnd.Source");




/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
dojo.dnd.__SourceArgs = function(){
	//	summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	//	isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	//	accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	//	autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	//	copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	//	delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	//	horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	//	selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	//	selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	//	withHandles: Boolean?
	//		allows dragging only by handles, false by default
	//  generateText: Boolean?
	//		generate text node for drag and drop, true by default
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.delay = delay;
	this.horizontal = horizontal;
	this.selfCopy = selfCopy;
	this.selfAccept = selfAccept;
	this.withHandles = withHandles;
	this.generateText = true;
}
=====*/

dojo.declare("dojo.dnd.Source", dojo.dnd.Selector, {
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target
	
	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,
	
	constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params){
		// summary:
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params:
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo.dnd.Source` instance
		dojo.mixin(this, dojo.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			dojo.addClass(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start",  this, "onDndStart"),
			dojo.subscribe("/dnd/drop",   this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},
	
	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		checks if the target can accept nodes from this source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary:
		//		Returns true if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		the "copy" key was pressed
		// self: Boolean?
		//		optional flag that means that we are about to drop on itself
		
		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == dojo.dnd.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Source.superclass.destroy.call(this);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Source(node, params);
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		dojo.dnd.Source.superclass.onMouseMove.call(this, e);
		var m = dojo.dnd.manager();
		if(!this.isDragging){
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dojo.isCopyKey(e), true));
				}
			}
		}
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = dojo.position(this.current, true);
				}
				if(this.horizontal){
					before = (e.pageX - this.targetBox.x) < (this.targetBox.w / 2);
				}else{
					before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}
	},
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dojo.dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			dojo.dnd.Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			dojo.dnd.Source.superclass.onMouseUp.call(this, e);
		}
	},
	
	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		topic event processor for /dnd/source/over, called when detected a current source
		// source: Object
		//		the source which has the mouse over it
		if(this != source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = dojo.dnd.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			dojo.dnd.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary:
		//		topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		// target: Object
		//		the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary:
		//		topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},
	
	// local events
	onDrop: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from an external source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from the same target/source
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node, hint){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged away from this target, and it is not disabled
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		dojo.dnd.Source.superclass.onOverEvent.call(this);
		dojo.dnd.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.dnd.Source.superclass.onOutEvent.call(this);
		dojo.dnd.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary:
		//		assigns a class to the current target anchor based on "before" status
		// before: Boolean
		//		insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary:
		//		removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary:
		//		changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary:
		//		checks if user clicked on "approved" items
		// e: Event
		//		mouse event
		
		// accept only the left mouse button
		if(!dojo.mouseButtons.isLeft(e)){ return false; }
		
		if(!this.withHandles){ return true; }
		
		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(dojo.hasClass(node, "dojoDndHandle")){ return true; }
			if(dojo.hasClass(node, "dojoDndItem") || dojo.hasClass(node, "dojoDndIgnore")){ break; }
		}
		return false;	// Boolean
	}
});

dojo.declare("dojo.dnd.Target", dojo.dnd.Source, {
	// summary: a Target object, which can be used as a DnD target
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Target --- see the `dojo.dnd.Source.constructor` for details
		this.isSource = false;
		dojo.removeClass(this.node, "dojoDndSource");
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Target(node, params);
	}
});

dojo.declare("dojo.dnd.AutoSource", dojo.dnd.Source, {
	// summary:
	//		a source that syncs its DnD nodes by default
	
	constructor: function(node, params){
		// summary:
		//		constructor of the AutoSource --- see the Source constructor for details
		this.autoSync = true;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.AutoSource(node, params);
	}
});

}

if(!dojo._hasResource["dijit._base.manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.manager"] = true;
dojo.provide("dijit._base.manager");


dojo.declare("dijit.WidgetSet", null, {
	// summary:
	//		A set of widgets indexed by id. A default instance of this class is
	//		available as `dijit.registry`
	//
	// example:
	//		Create a small list of widgets:
	//		|	var ws = new dijit.WidgetSet();
	//		|	ws.add(dijit.byId("one"));
	//		| 	ws.add(dijit.byId("two"));
	//		|	// destroy both:
	//		|	ws.forEach(function(w){ w.destroy(); });
	//
	// example:
	//		Using dijit.registry:
	//		|	dijit.registry.forEach(function(w){ /* do something */ });

	constructor: function(){
		this._hash = {};
		this.length = 0;
	},

	add: function(/*dijit._Widget*/ widget){
		// summary:
		//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
		//
		// widget: dijit._Widget
		//		Any dijit._Widget subclass.
		if(this._hash[widget.id]){
			throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
		}
		this._hash[widget.id] = widget;
		this.length++;
	},

	remove: function(/*String*/ id){
		// summary:
		//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
		//		removes the reference.
		if(this._hash[id]){
			delete this._hash[id];
			this.length--;
		}
	},

	forEach: function(/*Function*/ func, /* Object? */thisObj){
		// summary:
		//		Call specified function for each widget in this set.
		//
		// func:
		//		A callback function to run for each item. Is passed the widget, the index
		//		in the iteration, and the full hash, similar to `dojo.forEach`.
		//
		// thisObj:
		//		An optional scope parameter
		//
		// example:
		//		Using the default `dijit.registry` instance:
		//		|	dijit.registry.forEach(function(widget){
		//		|		console.log(widget.declaredClass);
		//		|	});
		//
		// returns:
		//		Returns self, in order to allow for further chaining.

		thisObj = thisObj || dojo.global;
		var i = 0, id;
		for(id in this._hash){
			func.call(thisObj, this._hash[id], i++, this._hash);
		}
		return this;	// dijit.WidgetSet
	},

	filter: function(/*Function*/ filter, /* Object? */thisObj){
		// summary:
		//		Filter down this WidgetSet to a smaller new WidgetSet
		//		Works the same as `dojo.filter` and `dojo.NodeList.filter`
		//
		// filter:
		//		Callback function to test truthiness. Is passed the widget
		//		reference and the pseudo-index in the object.
		//
		// thisObj: Object?
		//		Option scope to use for the filter function.
		//
		// example:
		//		Arbitrary: select the odd widgets in this list
		//		|	dijit.registry.filter(function(w, i){
		//		|		return i % 2 == 0;
		//		|	}).forEach(function(w){ /* odd ones */ });

		thisObj = thisObj || dojo.global;
		var res = new dijit.WidgetSet(), i = 0, id;
		for(id in this._hash){
			var w = this._hash[id];
			if(filter.call(thisObj, w, i++, this._hash)){
				res.add(w);
			}
		}
		return res; // dijit.WidgetSet
	},

	byId: function(/*String*/ id){
		// summary:
		//		Find a widget in this list by it's id.
		// example:
		//		Test if an id is in a particular WidgetSet
		//		| var ws = new dijit.WidgetSet();
		//		| ws.add(dijit.byId("bar"));
		//		| var t = ws.byId("bar") // returns a widget
		//		| var x = ws.byId("foo"); // returns undefined

		return this._hash[id];	// dijit._Widget
	},

	byClass: function(/*String*/ cls){
		// summary:
		//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
		//
		// cls: String
		//		The Class to scan for. Full dot-notated string.
		//
		// example:
		//		Find all `dijit.TitlePane`s in a page:
		//		|	dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });

		var res = new dijit.WidgetSet(), id, widget;
		for(id in this._hash){
			widget = this._hash[id];
			if(widget.declaredClass == cls){
				res.add(widget);
			}
		 }
		 return res; // dijit.WidgetSet
},

	toArray: function(){
		// summary:
		//		Convert this WidgetSet into a true Array
		//
		// example:
		//		Work with the widget .domNodes in a real Array
		//		|	dojo.map(dijit.registry.toArray(), function(w){ return w.domNode; });

		var ar = [];
		for(var id in this._hash){
			ar.push(this._hash[id]);
		}
		return ar;	// dijit._Widget[]
},

	map: function(/* Function */func, /* Object? */thisObj){
		// summary:
		//		Create a new Array from this WidgetSet, following the same rules as `dojo.map`
		// example:
		//		|	var nodes = dijit.registry.map(function(w){ return w.domNode; });
		//
		// returns:
		//		A new array of the returned values.
		return dojo.map(this.toArray(), func, thisObj); // Array
	},

	every: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.every` acting explicitly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first false return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(!func.call(thisObj, this._hash[i], x++, this._hash)){
				return false; // Boolean
			}
		}
		return true; // Boolean
	},

	some: function(func, thisObj){
		// summary:
		// 		A synthetic clone of `dojo.some` acting explictly on this WidgetSet
		//
		// func: Function
		//		A callback function run for every widget in this list. Exits loop
		//		when the first true return is encountered.
		//
		// thisObj: Object?
		//		Optional scope parameter to use for the callback

		thisObj = thisObj || dojo.global;
		var x = 0, i;
		for(i in this._hash){
			if(func.call(thisObj, this._hash[i], x++, this._hash)){
				return true; // Boolean
			}
		}
		return false; // Boolean
	}

});

(function(){

	/*=====
	dijit.registry = {
		// summary:
		//		A list of widgets on a page.
		// description:
		//		Is an instance of `dijit.WidgetSet`
	};
	=====*/
	dijit.registry = new dijit.WidgetSet();

	var hash = dijit.registry._hash,
		attr = dojo.attr,
		hasAttr = dojo.hasAttr,
		style = dojo.style;

	dijit.byId = function(/*String|dijit._Widget*/ id){
		// summary:
		//		Returns a widget by it's id, or if passed a widget, no-op (like dojo.byId())
		return typeof id == "string" ? hash[id] : id; // dijit._Widget
	};

	var _widgetTypeCtr = {};
	dijit.getUniqueId = function(/*String*/widgetType){
		// summary:
		//		Generates a unique id for a given widgetType
	
		var id;
		do{
			id = widgetType + "_" +
				(widgetType in _widgetTypeCtr ?
					++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
		}while(hash[id]);
		return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
	};
	
	dijit.findWidgets = function(/*DomNode*/ root){
		// summary:
		//		Search subtree under root returning widgets found.
		//		Doesn't search for nested widgets (ie, widgets inside other widgets).
	
		var outAry = [];
	
		function getChildrenHelper(root){
			for(var node = root.firstChild; node; node = node.nextSibling){
				if(node.nodeType == 1){
					var widgetId = node.getAttribute("widgetId");
					if(widgetId){
						var widget = hash[widgetId];
						if(widget){	// may be null on page w/multiple dojo's loaded
							outAry.push(widget);
						}
					}else{
						getChildrenHelper(node);
					}
				}
			}
		}
	
		getChildrenHelper(root);
		return outAry;
	};
	
	dijit._destroyAll = function(){
		// summary:
		//		Code to destroy all widgets and do other cleanup on page unload
	
		// Clean up focus manager lingering references to widgets and nodes
		dijit._curFocus = null;
		dijit._prevFocus = null;
		dijit._activeStack = [];
	
		// Destroy all the widgets, top down
		dojo.forEach(dijit.findWidgets(dojo.body()), function(widget){
			// Avoid double destroy of widgets like Menu that are attached to <body>
			// even though they are logically children of other widgets.
			if(!widget._destroyed){
				if(widget.destroyRecursive){
					widget.destroyRecursive();
				}else if(widget.destroy){
					widget.destroy();
				}
			}
		});
	};
	
	if(dojo.isIE){
		// Only run _destroyAll() for IE because we think it's only necessary in that case,
		// and because it causes problems on FF.  See bug #3531 for details.
		dojo.addOnWindowUnload(function(){
			dijit._destroyAll();
		});
	}
	
	dijit.byNode = function(/*DOMNode*/ node){
		// summary:
		//		Returns the widget corresponding to the given DOMNode
		return hash[node.getAttribute("widgetId")]; // dijit._Widget
	};
	
	dijit.getEnclosingWidget = function(/*DOMNode*/ node){
		// summary:
		//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
		//		the node is not contained within the DOM tree of any widget
		while(node){
			var id = node.getAttribute && node.getAttribute("widgetId");
			if(id){
				return hash[id];
			}
			node = node.parentNode;
		}
		return null;
	};

	var shown = (dijit._isElementShown = function(/*Element*/ elem){
		var s = style(elem);
		return (s.visibility != "hidden")
			&& (s.visibility != "collapsed")
			&& (s.display != "none")
			&& (attr(elem, "type") != "hidden");
	});
	
	dijit.hasDefaultTabStop = function(/*Element*/ elem){
		// summary:
		//		Tests if element is tab-navigable even without an explicit tabIndex setting
	
		// No explicit tabIndex setting, need to investigate node type
		switch(elem.nodeName.toLowerCase()){
			case "a":
				// An <a> w/out a tabindex is only navigable if it has an href
				return hasAttr(elem, "href");
			case "area":
			case "button":
			case "input":
			case "object":
			case "select":
			case "textarea":
				// These are navigable by default
				return true;
			case "iframe":
				// If it's an editor <iframe> then it's tab navigable.
				var body;
				try{
					// non-IE
					var contentDocument = elem.contentDocument;
					if("designMode" in contentDocument && contentDocument.designMode == "on"){
						return true;
					}
					body = contentDocument.body;
				}catch(e1){
					// contentWindow.document isn't accessible within IE7/8
					// if the iframe.src points to a foreign url and this
					// page contains an element, that could get focus
					try{
						body = elem.contentWindow.document.body;
					}catch(e2){
						return false;
					}
				}
				return body.contentEditable == 'true' || (body.firstChild && body.firstChild.contentEditable == 'true');
			default:
				return elem.contentEditable == 'true';
		}
	};
	
	var isTabNavigable = (dijit.isTabNavigable = function(/*Element*/ elem){
		// summary:
		//		Tests if an element is tab-navigable
	
		// TODO: convert (and rename method) to return effective tabIndex; will save time in _getTabNavigable()
		if(attr(elem, "disabled")){
			return false;
		}else if(hasAttr(elem, "tabIndex")){
			// Explicit tab index setting
			return attr(elem, "tabIndex") >= 0; // boolean
		}else{
			// No explicit tabIndex setting, so depends on node type
			return dijit.hasDefaultTabStop(elem);
		}
	});

	dijit._getTabNavigable = function(/*DOMNode*/ root){
		// summary:
		//		Finds descendants of the specified root node.
		//
		// description:
		//		Finds the following descendants of the specified root node:
		//		* the first tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the last tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the first element in document order with the lowest
		//		  positive tabIndex value
		//		* the last element in document order with the highest
		//		  positive tabIndex value
		var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};
		function radioName(node) {
			// If this element is part of a radio button group, return the name for that group.
			return node && node.tagName.toLowerCase() == "input" &&
				node.type && node.type.toLowerCase() == "radio" &&
				node.name && node.name.toLowerCase();
		}
		var walkTree = function(/*DOMNode*/parent){
			dojo.query("> *", parent).forEach(function(child){
				// Skip hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
				// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
				if((dojo.isIE && child.scopeName!=="HTML") || !shown(child)){
					return;
				}

				if(isTabNavigable(child)){
					var tabindex = attr(child, "tabIndex");
					if(!hasAttr(child, "tabIndex") || tabindex == 0){
						if(!first){ first = child; }
						last = child;
					}else if(tabindex > 0){
						if(!lowest || tabindex < lowestTabindex){
							lowestTabindex = tabindex;
							lowest = child;
						}
						if(!highest || tabindex >= highestTabindex){
							highestTabindex = tabindex;
							highest = child;
						}
					}
					var rn = radioName(child);
					if(dojo.attr(child, "checked") && rn) {
						radioSelected[rn] = child;
					}
				}
				if(child.nodeName.toUpperCase() != 'SELECT'){
					walkTree(child);
				}
			});
		};
		if(shown(root)){ walkTree(root) }
		function rs(node) {
			// substitute checked radio button for unchecked one, if there is a checked one with the same name.
			return radioSelected[radioName(node)] || node;
		}
		return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
	}
	dijit.getFirstInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is first in the tabbing order
		var elems = dijit._getTabNavigable(dojo.byId(root));
		return elems.lowest ? elems.lowest : elems.first; // DomNode
	};
	
	dijit.getLastInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is last in the tabbing order
		var elems = dijit._getTabNavigable(dojo.byId(root));
		return elems.last ? elems.last : elems.highest; // DomNode
	};
	
	/*=====
	dojo.mixin(dijit, {
		// defaultDuration: Integer
		//		The default animation speed (in ms) to use for all Dijit
		//		transitional animations, unless otherwise specified
		//		on a per-instance basis. Defaults to 200, overrided by
		//		`djConfig.defaultDuration`
		defaultDuration: 200
	});
	=====*/
	
	dijit.defaultDuration = dojo.config["defaultDuration"] || 200;

})();

}

if(!dojo._hasResource["dojo.Stateful"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.Stateful"] = true;
dojo.provide("dojo.Stateful");


dojo.declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	// example:
	//	|	var obj = new dojo.Stateful();
	//	|	obj.watch("foo", function(){
	//	|		console.log("foo changed to " + this.get("foo"));
	//	|	});
	//	|	obj.set("foo","bar");
	postscript: function(mixin){
		if(mixin){
			dojo.mixin(this, mixin);
		}
	},
	
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		// 		this just retrieves the object's property.
		// 		For example:
		//	|	stateful = new dojo.Stateful({foo: 3});
		//	|	stateful.get("foo") // returns 3
		//	|	stateful.foo // returns 3
		
		return this[name];
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		// 		the property. A programmatic setter may be defined in subclasses.
		// 		For example:
		//	|	stateful = new dojo.Stateful();
		//	|	stateful.watch(function(name, oldValue, value){
		//	|		// this will be called on the set below
		//	|	}
		//	|	stateful.set(foo, 5);
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	myObj.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
			}
			return this;
		}
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this;
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		//	name:
		//		Indicates the property to watch. This is optional (the callback may be the
		// 		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		// 		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		//	callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		// 		second argument as the old value and the third argument as the new value.
		
		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
                        propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							try{
								propertyCallbacks[i].call(self, name, oldValue, value);
							}catch(e){
								console.error(e);
							}
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);
		return {
			unwatch: function(){
				propertyCallbacks.splice(dojo.indexOf(propertyCallbacks, callback), 1);
			}
		};
	}
	
});

}

if(!dojo._hasResource["dijit._WidgetBase"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._WidgetBase"] = true;
dojo.provide("dijit._WidgetBase");




(function(){

dojo.declare("dijit._WidgetBase", dojo.Stateful, {
	// summary:
	//		Future base class for all Dijit widgets.
	//		_Widget extends this class adding support for various features needed by desktop.

	// id: [const] String
	//		A unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	id: "",

	// lang: [const] String
	//		Rarely used.  Overrides the default Dojo locale used to render this widget,
	//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	//		Value must be among the list of locales specified during by the Dojo bootstrap,
	//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
	lang: "",

	// dir: [const] String
	//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
	//		default direction.
	dir: "",

	// class: String
	//		HTML class attribute
	"class": "",

	// style: String||Object
	//		HTML style attributes as cssText string or name/value hash
	style: "",

	// title: String
	//		HTML title attribute.
	//
	//		For form widgets this specifies a tooltip to display when hovering over
	//		the widget (just like the native HTML title attribute).
	//
	//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
	//		etc., it's used to specify the tab label, accordion pane title, etc.
	title: "",

	// tooltip: String
	//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	//		this specifies the tooltip to appear when the mouse is hovered over that text.
	tooltip: "",

	// baseClass: [protected] String
	//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
	//		widget state.
	baseClass: "",

	// srcNodeRef: [readonly] DomNode
	//		pointer to original DOM node
	srcNodeRef: null,

	// domNode: [readonly] DomNode
	//		This is our visible representation of the widget! Other DOM
	//		Nodes may by assigned to other properties, usually through the
	//		template system's dojoAttachPoint syntax, but the domNode
	//		property is the canonical "top level" node in widget UI.
	domNode: null,

	// containerNode: [readonly] DomNode
	//		Designates where children of the source DOM node will be placed.
	//		"Children" in this case refers to both DOM nodes and widgets.
	//		For example, for myWidget:
	//
	//		|	<div dojoType=myWidget>
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//		|	</div>
	//
	//		containerNode would point to:
	//
	//		|		<b> here's a plain DOM node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//
	//		In templated widgets, "containerNode" is set via a
	//		dojoAttachPoint assignment.
	//
	//		containerNode must be defined for any widget that accepts innerHTML
	//		(like ContentPane or BorderContainer or even Button), and conversely
	//		is null for widgets that don't, like TextBox.
	containerNode: null,

/*=====
	// _started: Boolean
	//		startup() has completed.
	_started: false,
=====*/

	// attributeMap: [protected] Object
	//		attributeMap sets up a "binding" between attributes (aka properties)
	//		of the widget and the widget's DOM.
	//		Changes to widget attributes listed in attributeMap will be
	//		reflected into the DOM.
	//
	//		For example, calling set('title', 'hello')
	//		on a TitlePane will automatically cause the TitlePane's DOM to update
	//		with the new title.
	//
	//		attributeMap is a hash where the key is an attribute of the widget,
	//		and the value reflects a binding to a:
	//
	//		- DOM node attribute
	// |		focus: {node: "focusNode", type: "attribute"}
	// 		Maps this.focus to this.focusNode.focus
	//
	//		- DOM node innerHTML
	//	|		title: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		title: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		myClass: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		There are also some shorthands for backwards compatibility:
	//		- string --> { node: string, type: "attribute" }, for example:
	//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
	//		- "" --> { node: "domNode", type: "attribute" }
	attributeMap: {id:"", dir:"", lang:"", "class":"", style:"", title:""},

	// _blankGif: [protected] String
	//		Path to a blank 1x1 image.
	//		Used by <img> nodes in templates that really get their image via CSS background-image.
	_blankGif: (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")).toString(),

	//////////// INITIALIZATION METHODS ///////////////////////////////////////

	postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
		// summary:
		//		Kicks off widget instantiation.  See create() for details.
		// tags:
		//		private
		this.create(params, srcNodeRef);
	},

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// summary:
		//		Kick off the life-cycle of a widget
		// params:
		//		Hash of initialization parameters for widget, including
		//		scalar values (like title, duration etc.) and functions,
		//		typically callbacks like onClick.
		// srcNodeRef:
		//		If a srcNodeRef (DOM node) is specified:
		//			- use srcNodeRef.innerHTML as my contents
		//			- if this is a behavioral widget then apply behavior
		//			  to that srcNodeRef
		//			- otherwise, replace srcNodeRef with my generated DOM
		//			  tree
		// description:
		//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
		//		etc.), some of which of you'll want to override. See http://docs.dojocampus.org/dijit/_Widget
		//		for a discussion of the widget creation lifecycle.
		//
		//		Of course, adventurous developers could override create entirely, but this should
		//		only be done as a last resort.
		// tags:
		//		private

		// store pointer to original DOM tree
		this.srcNodeRef = dojo.byId(srcNodeRef);

		// For garbage collection.  An array of handles returned by Widget.connect()
		// Each handle returned from Widget.connect() is an array of handles from dojo.connect()
		this._connects = [];

		// For garbage collection.  An array of handles returned by Widget.subscribe()
		// The handle returned from Widget.subscribe() is the handle returned from dojo.subscribe()
		this._subscribes = [];

		// mix in our passed parameters
		if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){ this.id = this.srcNodeRef.id; }
		if(params){
			this.params = params;
			dojo._mixin(this, params);
		}
		this.postMixInProperties();

		// generate an id for the widget if one wasn't specified
		// (be sure to do this before buildRendering() because that function might
		// expect the id to be there.)
		if(!this.id){
			this.id = dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		}
		dijit.registry.add(this);

		this.buildRendering();

		if(this.domNode){
			// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
			// Also calls custom setters for all attributes with custom setters.
			this._applyAttributes();

			// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
			// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
			// widget being attached to the DOM since it isn't when a widget is created programmatically like
			// new MyWidget({}).   See #11635.
			var source = this.srcNodeRef;
			if(source && source.parentNode && this.domNode !== source){
				source.parentNode.replaceChild(this.domNode, source);
			}
		}

		if(this.domNode){
			// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
			// assuming that dojo._scopeName even exists in 2.0
			this.domNode.setAttribute("widgetId", this.id);
		}
		this.postCreate();

		// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
		if(this.srcNodeRef && !this.srcNodeRef.parentNode){
			delete this.srcNodeRef;
		}

		this._created = true;
	},

	_applyAttributes: function(){
		// summary:
		//		Step during widget creation to copy all widget attributes to the
		//		DOM as per attributeMap and _setXXXAttr functions.
		// description:
		//		Skips over blank/false attribute values, unless they were explicitly specified
		//		as parameters to the widget, since those are the default anyway,
		//		and setting tabIndex="" is different than not setting tabIndex at all.
		//
		//		It processes the attributes in the attribute map first, and then
		//		it goes through and processes the attributes for the _setXXXAttr
		//		functions that have been specified
		// tags:
		//		private
		var condAttrApply = function(attr, scope){
			if((scope.params && attr in scope.params) || scope[attr]){
				scope.set(attr, scope[attr]);
			}
		};

		// Do the attributes in attributeMap
		for(var attr in this.attributeMap){
			condAttrApply(attr, this);
		}

		// And also any attributes with custom setters
		dojo.forEach(this._getSetterAttributes(), function(a){
			if(!(a in this.attributeMap)){
				condAttrApply(a, this);
			}
		}, this);
	},

	_getSetterAttributes: function(){
		// summary:
		//		Returns list of attributes with custom setters for this widget
		var ctor = this.constructor;
		if(!ctor._setterAttrs){
			var r = (ctor._setterAttrs = []),
				attrs,
				proto = ctor.prototype;
			for(var fxName in proto){
				if(dojo.isFunction(proto[fxName]) && (attrs = fxName.match(/^_set([a-zA-Z]*)Attr$/)) && attrs[1]){
					r.push(attrs[1].charAt(0).toLowerCase() + attrs[1].substr(1));
				}
			}
		}
		return ctor._setterAttrs;	// String[]
	},

	postMixInProperties: function(){
		// summary:
		//		Called after the parameters to the widget have been read-in,
		//		but before the widget template is instantiated. Especially
		//		useful to set properties that are referenced in the widget
		//		template.
		// tags:
		//		protected
	},

	buildRendering: function(){
		// summary:
		//		Construct the UI for this widget, setting this.domNode
		// description:
		//		Most widgets will mixin `dijit._Templated`, which implements this
		//		method.
		// tags:
		//		protected

		if(!this.domNode){
			// Create root node if it wasn't created by _Templated
			this.domNode = this.srcNodeRef || dojo.create('div');
		}

		// baseClass is a single class name or occasionally a space-separated list of names.
		// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
		// TODO: make baseClass custom setter
		if(this.baseClass){
			var classes = this.baseClass.split(" ");
			if(!this.isLeftToRight()){
				classes = classes.concat( dojo.map(classes, function(name){ return name+"Rtl"; }));
			}
			dojo.addClass(this.domNode, classes);
		}
	},

	postCreate: function(){
		// summary:
		//		Processing after the DOM fragment is created
		// description:
		//		Called after the DOM fragment has been created, but not necessarily
		//		added to the document.  Do not include any operations which rely on
		//		node dimensions or placement.
		// tags:
		//		protected
	},

	startup: function(){
		// summary:
		//		Processing after the DOM fragment is added to the document
		// description:
		//		Called after a widget and its children have been created and added to the page,
		//		and all related widgets have finished their create() cycle, up through postCreate().
		//		This is useful for composite widgets that need to control or layout sub-widgets.
		//		Many layout widgets can use this as a wiring phase.
		this._started = true;
	},

	//////////// DESTROY FUNCTIONS ////////////////////////////////

	destroyRecursive: function(/*Boolean?*/ preserveDom){
		// summary:
		// 		Destroy this widget and its descendants
		// description:
		//		This is the generic "destructor" function that all widget users
		// 		should call to cleanly discard with a widget. Once a widget is
		// 		destroyed, it is removed from the manager object.
		// preserveDom:
		//		If true, this method will leave the original DOM structure
		//		alone of descendant Widgets. Note: This will NOT work with
		//		dijit._Templated widgets.

		this._beingDestroyed = true;
		this.destroyDescendants(preserveDom);
		this.destroy(preserveDom);
	},

	destroy: function(/*Boolean*/ preserveDom){
		// summary:
		// 		Destroy this widget, but not its descendants.
		//		This method will, however, destroy internal widgets such as those used within a template.
		// preserveDom: Boolean
		//		If true, this method will leave the original DOM structure alone.
		//		Note: This will not yet work with _Templated widgets

		this._beingDestroyed = true;
		this.uninitialize();
		var d = dojo,
			dfe = d.forEach,
			dun = d.unsubscribe;
		dfe(this._connects, function(array){
			dfe(array, d.disconnect);
		});
		dfe(this._subscribes, function(handle){
			dun(handle);
		});

		// destroy widgets created as part of template, etc.
		dfe(this._supportingWidgets || [], function(w){
			if(w.destroyRecursive){
				w.destroyRecursive();
			}else if(w.destroy){
				w.destroy();
			}
		});

		this.destroyRendering(preserveDom);
		dijit.registry.remove(this.id);
		this._destroyed = true;
	},

	destroyRendering: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Destroys the DOM nodes associated with this widget
		// preserveDom:
		//		If true, this method will leave the original DOM structure alone
		//		during tear-down. Note: this will not work with _Templated
		//		widgets yet.
		// tags:
		//		protected

		if(this.bgIframe){
			this.bgIframe.destroy(preserveDom);
			delete this.bgIframe;
		}

		if(this.domNode){
			if(preserveDom){
				dojo.removeAttr(this.domNode, "widgetId");
			}else{
				dojo.destroy(this.domNode);
			}
			delete this.domNode;
		}

		if(this.srcNodeRef){
			if(!preserveDom){
				dojo.destroy(this.srcNodeRef);
			}
			delete this.srcNodeRef;
		}
	},

	destroyDescendants: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendants.
		// preserveDom:
		//		If true, the preserveDom attribute is passed to all descendant
		//		widget's .destroy() method. Not for use with _Templated
		//		widgets.

		// get all direct descendants and destroy them recursively
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
	},

	uninitialize: function(){
		// summary:
		//		Stub function. Override to implement custom widget tear-down
		//		behavior.
		// tags:
		//		protected
		return false;
	},

	////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

	_setClassAttr: function(/*String*/ value){
		// summary:
		//		Custom setter for the CSS "class" attribute
		// tags:
		//		protected
		var mapNode = this[this.attributeMap["class"] || 'domNode'];
		dojo.replaceClass(mapNode, value, this["class"]);
		this._set("class", value);
	},

	_setStyleAttr: function(/*String||Object*/ value){
		// summary:
		//		Sets the style attribute of the widget according to value,
		//		which is either a hash like {height: "5px", width: "3px"}
		//		or a plain string
		// description:
		//		Determines which node to set the style on based on style setting
		//		in attributeMap.
		// tags:
		//		protected

		var mapNode = this[this.attributeMap.style || 'domNode'];

		// Note: technically we should revert any style setting made in a previous call
		// to his method, but that's difficult to keep track of.

		if(dojo.isObject(value)){
			dojo.style(mapNode, value);
		}else{
			if(mapNode.style.cssText){
				mapNode.style.cssText += "; " + value;
			}else{
				mapNode.style.cssText = value;
			}
		}

		this._set("style", value);
	},

	_attrToDom: function(/*String*/ attr, /*String*/ value){
		// summary:
		//		Reflect a widget attribute (title, tabIndex, duration etc.) to
		//		the widget DOM, as specified in attributeMap.
		//		Note some attributes like "type"
		//		cannot be processed this way as they are not mutable.
		//
		// tags:
		//		private

		var commands = this.attributeMap[attr];
		dojo.forEach(dojo.isArray(commands) ? commands : [commands], function(command){

			// Get target node and what we are doing to that node
			var mapNode = this[command.node || command || "domNode"];	// DOM node
			var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

			switch(type){
				case "attribute":
					if(dojo.isFunction(value)){ // functions execute in the context of the widget
						value = dojo.hitch(this, value);
					}

					// Get the name of the DOM node attribute; usually it's the same
					// as the name of the attribute in the widget (attr), but can be overridden.
					// Also maps handler names to lowercase, like onSubmit --> onsubmit
					var attrName = command.attribute ? command.attribute :
						(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

					dojo.attr(mapNode, attrName, value);
					break;
				case "innerText":
					mapNode.innerHTML = "";
					mapNode.appendChild(dojo.doc.createTextNode(value));
					break;
				case "innerHTML":
					mapNode.innerHTML = value;
					break;
				case "class":
					dojo.replaceClass(mapNode, value, this[attr]);
					break;
			}
		}, this);
	},

	get: function(name){
		// summary:
		//		Get a property from a widget.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property from a widget. The property may
		//		potentially be retrieved via a getter method. If no getter is defined, this
		// 		just retrieves the object's property.
		// 		For example, if the widget has a properties "foo"
		//		and "bar" and a method named "_getFooAttr", calling:
		//	|	myWidget.get("foo");
		//		would be equivalent to writing:
		//	|	widget._getFooAttr();
		//		and:
		//	|	myWidget.get("bar");
		//		would be equivalent to writing:
		//	|	widget.bar;
		var names = this._getAttrNames(name);
		return this[names.g] ? this[names.g]() : this[name];
	},
	
	set: function(name, value){
		// summary:
		//		Set a property on a widget
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a widget which may potentially be handled by a
		// 		setter in the widget.
		// 		For example, if the widget has a properties "foo"
		//		and "bar" and a method named "_setFooAttr", calling:
		//	|	myWidget.set("foo", "Howdy!");
		//		would be equivalent to writing:
		//	|	widget._setFooAttr("Howdy!");
		//		and:
		//	|	myWidget.set("bar", 3);
		//		would be equivalent to writing:
		//	|	widget.bar = 3;
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	myWidget.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
			}
			return this;
		}
		var names = this._getAttrNames(name);
		if(this[names.s]){
			// use the explicit setter
			var result = this[names.s].apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// if param is specified as DOM node attribute, copy it
			if(name in this.attributeMap){
				this._attrToDom(name, value);
			}
			this._set(name, value);
		}
		return result || this;
	},
	
	_attrPairNames: {},		// shared between all widgets
	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.charAt(0).toUpperCase() + name.substr(1);
		return (apn[name] = {
			n: name+"Node",
			s: "_set"+uc+"Attr",
			g: "_get"+uc+"Attr"
		});
	},

	_set: function(/*String*/ name, /*anything*/ value){
		// summary:
		//		Helper function to set new value for specified attribute, and call handlers
		//		registered with watch() if the value has changed.
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks && this._created && value !== oldValue){
			this._watchCallbacks(name, oldValue, value);
		}
	},

	toString: function(){
		// summary:
		//		Returns a string that represents the widget
		// description:
		//		When a widget is cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversible
		//		serialization.
		return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		return this.containerNode ? dojo.query('[widgetId]', this.containerNode).map(dijit.byNode) : []; // dijit._Widget[]
	},

	getChildren: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		Does not return nested widgets, nor widgets that are part of this widget's template.
		return this.containerNode ? dijit.findWidgets(this.containerNode) : []; // dijit._Widget[]
	},

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		Events connected with `this.connect` are disconnected upon
		//		destruction.
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var handles = [dojo._connect(obj, event, this, method)];
		this._connects.push(handles);
		return handles;		// _Widget.Handle
	},

	disconnect: function(/* _Widget.Handle */ handles){
		// summary:
		//		Disconnects handle created by `connect`.
		//		Also removes handle from this widget's list of connects.
		// tags:
		//		protected
		for(var i=0; i<this._connects.length; i++){
			if(this._connects[i] == handles){
				dojo.forEach(handles, dojo.disconnect);
				this._connects.splice(i, 1);
				return;
			}
		}
	},

	subscribe: function(
			/*String*/ topic,
			/*String|Function*/ method){
		// summary:
		//		Subscribes to the specified topic and calls the specified method
		//		of this object and registers for unsubscribe() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.subscribe, except with the
		//		implicit use of this widget as the target object.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when /my/topic is published, this button changes its label to
		//	|   // be the parameter of the topic.
		//	|	btn.subscribe("/my/topic", function(v){
		//	|		this.set("label", v);
		//	|	});
		var handle = dojo.subscribe(topic, this, method);

		// return handles for Any widget that may need them
		this._subscribes.push(handle);
		return handle;
	},

	unsubscribe: function(/*Object*/ handle){
		// summary:
		//		Unsubscribes handle created by this.subscribe.
		//		Also removes handle from this widget's list of subscriptions
		for(var i=0; i<this._subscribes.length; i++){
			if(this._subscribes[i] == handle){
				dojo.unsubscribe(handle);
				this._subscribes.splice(i, 1);
				return;
			}
		}
	},

	isLeftToRight: function(){
		// summary:
		//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
		// tags:
		//		protected
		return this.dir ? (this.dir == "ltr") : dojo._isBodyLtr(); //Boolean
	},

	placeAt: function(/* String|DomNode|_Widget */reference, /* String?|Int? */position){
		// summary:
		//		Place this widget's domNode reference somewhere in the DOM based
		//		on standard dojo.place conventions, or passing a Widget reference that
		//		contains and addChild member.
		//
		// description:
		//		A convenience function provided in all _Widgets, providing a simple
		//		shorthand mechanism to put an existing (or newly created) Widget
		//		somewhere in the dom, and allow chaining.
		//
		// reference:
		//		The String id of a domNode, a domNode reference, or a reference to a Widget posessing
		//		an addChild method.
		//
		// position:
		//		If passed a string or domNode reference, the position argument
		//		accepts a string just as dojo.place does, one of: "first", "last",
		//		"before", or "after".
		//
		//		If passed a _Widget reference, and that widget reference has an ".addChild" method,
		//		it will be called passing this widget instance into that method, supplying the optional
		//		position index passed.
		//
		// returns:
		//		dijit._Widget
		//		Provides a useful return of the newly created dijit._Widget instance so you
		//		can "chain" this function by instantiating, placing, then saving the return value
		//		to a variable.
		//
		// example:
		// | 	// create a Button with no srcNodeRef, and place it in the body:
		// | 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
		// | 	// now, 'button' is still the widget reference to the newly created button
		// | 	dojo.connect(button, "onClick", function(e){ console.log('click'); });
		//
		// example:
		// |	// create a button out of a node with id="src" and append it to id="wrapper":
		// | 	var button = new dijit.form.Button({},"src").placeAt("wrapper");
		//
		// example:
		// |	// place a new button as the first element of some div
		// |	var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");
		//
		// example:
		// |	// create a contentpane and add it to a TabContainer
		// |	var tc = dijit.byId("myTabs");
		// |	new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

		if(reference.declaredClass && reference.addChild){
			reference.addChild(this, position);
		}else{
			dojo.place(this.domNode, reference, position);
		}
		return this;
	}
});

})();

}

if(!dojo._hasResource["dijit._base.focus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.focus"] = true;
dojo.provide("dijit._base.focus");




// summary:
//		These functions are used to query or set the focus and selection.
//
//		Also, they trace when widgets become activated/deactivated,
//		so that the widget can fire _onFocus/_onBlur events.
//		"Active" here means something similar to "focused", but
//		"focus" isn't quite the right word because we keep track of
//		a whole stack of "active" widgets.  Example: ComboButton --> Menu -->
//		MenuItem.  The onBlur event for ComboButton doesn't fire due to focusing
//		on the Menu or a MenuItem, since they are considered part of the
//		ComboButton widget.  It only happens when focus is shifted
//		somewhere completely different.

dojo.mixin(dijit, {
	// _curFocus: DomNode
	//		Currently focused item on screen
	_curFocus: null,

	// _prevFocus: DomNode
	//		Previously focused item on screen
	_prevFocus: null,

	isCollapsed: function(){
		// summary:
		//		Returns true if there is no text selected
		return dijit.getBookmark().isCollapsed;
	},

	getBookmark: function(){
		// summary:
		//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
		var bm, rg, tg, sel = dojo.doc.selection, cf = dijit._curFocus;

		if(dojo.global.getSelection){
			//W3C Range API for selections.
			sel = dojo.global.getSelection();
			if(sel){
				if(sel.isCollapsed){
					tg = cf? cf.tagName : "";
					if(tg){
						//Create a fake rangelike item to restore selections.
						tg = tg.toLowerCase();
						if(tg == "textarea" ||
								(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
							sel = {
								start: cf.selectionStart,
								end: cf.selectionEnd,
								node: cf,
								pRange: true
							};
							return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
						}
					}
					bm = {isCollapsed:true};
					if(sel.rangeCount){
						bm.mark = sel.getRangeAt(0).cloneRange();
					}
				}else{
					rg = sel.getRangeAt(0);
					bm = {isCollapsed: false, mark: rg.cloneRange()};
				}
			}
		}else if(sel){
			// If the current focus was a input of some sort and no selection, don't bother saving
			// a native bookmark.  This is because it causes issues with dialog/page selection restore.
			// So, we need to create psuedo bookmarks to work with.
			tg = cf ? cf.tagName : "";
			tg = tg.toLowerCase();
			if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
				if(sel.type && sel.type.toLowerCase() == "none"){
					return {
						isCollapsed: true,
						mark: null
					}
				}else{
					rg = sel.createRange();
					return {
						isCollapsed: rg.text && rg.text.length?false:true,
						mark: {
							range: rg,
							pRange: true
						}
					};
				}
			}
			bm = {};

			//'IE' way for selections.
			try{
				// createRange() throws exception when dojo in iframe
				//and nothing selected, see #9632
				rg = sel.createRange();
				bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
			}catch(e){
				bm.isCollapsed = true;
				return bm;
			}
			if(sel.type.toUpperCase() == 'CONTROL'){
				if(rg.length){
					bm.mark=[];
					var i=0,len=rg.length;
					while(i<len){
						bm.mark.push(rg.item(i++));
					}
				}else{
					bm.isCollapsed = true;
					bm.mark = null;
				}
			}else{
				bm.mark = rg.getBookmark();
			}
		}else{
			console.warn("No idea how to store the current selection for this browser!");
		}
		return bm; // Object
	},

	moveToBookmark: function(/*Object*/bookmark){
		// summary:
		//		Moves current selection to a bookmark
		// bookmark:
		//		This should be a returned object from dijit.getBookmark()

		var _doc = dojo.doc,
			mark = bookmark.mark;
		if(mark){
			if(dojo.global.getSelection){
				//W3C Rangi API (FF, WebKit, Opera, etc)
				var sel = dojo.global.getSelection();
				if(sel && sel.removeAllRanges){
					if(mark.pRange){
						var r = mark;
						var n = r.node;
						n.selectionStart = r.start;
						n.selectionEnd = r.end;
					}else{
						sel.removeAllRanges();
						sel.addRange(mark);
					}
				}else{
					console.warn("No idea how to restore selection for this browser!");
				}
			}else if(_doc.selection && mark){
				//'IE' way.
				var rg;
				if(mark.pRange){
					rg = mark.range;
				}else if(dojo.isArray(mark)){
					rg = _doc.body.createControlRange();
					//rg.addElement does not have call/apply method, so can not call it directly
					//rg is not available in "range.addElement(item)", so can't use that either
					dojo.forEach(mark, function(n){
						rg.addElement(n);
					});
				}else{
					rg = _doc.body.createTextRange();
					rg.moveToBookmark(mark);
				}
				rg.select();
			}
		}
	},

	getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
		// summary:
		//		Called as getFocus(), this returns an Object showing the current focus
		//		and selected text.
		//
		//		Called as getFocus(widget), where widget is a (widget representing) a button
		//		that was just pressed, it returns where focus was before that button
		//		was pressed.   (Pressing the button may have either shifted focus to the button,
		//		or removed focus altogether.)   In this case the selected text is not returned,
		//		since it can't be accurately determined.
		//
		// menu: dijit._Widget or {domNode: DomNode} structure
		//		The button that was just pressed.  If focus has disappeared or moved
		//		to this button, returns the previous focus.  In this case the bookmark
		//		information is already lost, and null is returned.
		//
		// openedForWindow:
		//		iframe in which menu was opened
		//
		// returns:
		//		A handle to restore focus/selection, to be passed to `dijit.focus`
		var node = !dijit._curFocus || (menu && dojo.isDescendant(dijit._curFocus, menu.domNode)) ? dijit._prevFocus : dijit._curFocus;
		return {
			node: node,
			bookmark: (node == dijit._curFocus) && dojo.withGlobal(openedForWindow || dojo.global, dijit.getBookmark),
			openedForWindow: openedForWindow
		}; // Object
	},

	focus: function(/*Object || DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			dijit._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && dojo.withGlobal(openedForWindow || dojo.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				dojo.withGlobal(openedForWindow || dojo.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	},

	// _activeStack: dijit._Widget[]
	//		List of currently active widgets (focused widget and it's ancestors)
	_activeStack: [],

	registerIframe: function(/*DomNode*/ iframe){
		// summary:
		//		Registers listeners on the specified iframe so that any click
		//		or focus event on that iframe (or anything in it) is reported
		//		as a focus/click event on the <iframe> itself.
		// description:
		//		Currently only used by editor.
		// returns:
		//		Handle to pass to unregisterIframe()
		return dijit.registerWin(iframe.contentWindow, iframe);
	},

	unregisterIframe: function(/*Object*/ handle){
		// summary:
		//		Unregisters listeners on the specified iframe created by registerIframe.
		//		After calling be sure to delete or null out the handle itself.
		// handle:
		//		Handle returned by registerIframe()

		dijit.unregisterWin(handle);
	},

	registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
		// summary:
		//		Registers listeners on the specified window (either the main
		//		window or an iframe's window) to detect when the user has clicked somewhere
		//		or focused somewhere.
		// description:
		//		Users should call registerIframe() instead of this method.
		// targetWindow:
		//		If specified this is the window associated with the iframe,
		//		i.e. iframe.contentWindow.
		// effectiveNode:
		//		If specified, report any focus events inside targetWindow as
		//		an event on effectiveNode, rather than on evt.target.
		// returns:
		//		Handle to pass to unregisterWin()

		// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

		var mousedownListener = function(evt){
			dijit._justMouseDowned = true;
			setTimeout(function(){ dijit._justMouseDowned = false; }, 0);
			
			// workaround weird IE bug where the click is on an orphaned node
			// (first time clicking a Select/DropDownButton inside a TooltipDialog)
			if(dojo.isIE && evt && evt.srcElement && evt.srcElement.parentNode == null){
				return;
			}

			dijit._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
		};
		//dojo.connect(targetWindow, "onscroll", ???);

		// Listen for blur and focus events on targetWindow's document.
		// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
		// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
		// fire.
		// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
		// (at least for FF) the focus event doesn't fire on <html> or <body>.
		var doc = dojo.isIE ? targetWindow.document.documentElement : targetWindow.document;
		if(doc){
			if(dojo.isIE){
				targetWindow.document.body.attachEvent('onmousedown', mousedownListener);
				var activateListener = function(evt){
					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// Should consider those more like a mouse-click than a focus....
					if(evt.srcElement.tagName.toLowerCase() != "#document" &&
						dijit.isTabNavigable(evt.srcElement)){
						dijit._onFocusNode(effectiveNode || evt.srcElement);
					}else{
						dijit._onTouchNode(effectiveNode || evt.srcElement);
					}
				};
				doc.attachEvent('onactivate', activateListener);
				var deactivateListener =  function(evt){
					dijit._onBlurNode(effectiveNode || evt.srcElement);
				};
				doc.attachEvent('ondeactivate', deactivateListener);

				return function(){
					targetWindow.document.detachEvent('onmousedown', mousedownListener);
					doc.detachEvent('onactivate', activateListener);
					doc.detachEvent('ondeactivate', deactivateListener);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}else{
				doc.body.addEventListener('mousedown', mousedownListener, true);
				var focusListener = function(evt){
					dijit._onFocusNode(effectiveNode || evt.target);
				};
				doc.addEventListener('focus', focusListener, true);
				var blurListener = function(evt){
					dijit._onBlurNode(effectiveNode || evt.target);
				};
				doc.addEventListener('blur', blurListener, true);

				return function(){
					doc.body.removeEventListener('mousedown', mousedownListener, true);
					doc.removeEventListener('focus', focusListener, true);
					doc.removeEventListener('blur', blurListener, true);
					doc = null;	// prevent memory leak (apparent circular reference via closure)
				};
			}
		}
	},

	unregisterWin: function(/*Handle*/ handle){
		// summary:
		//		Unregisters listeners on the specified window (either the main
		//		window or an iframe's window) according to handle returned from registerWin().
		//		After calling be sure to delete or null out the handle itself.

		// Currently our handle is actually a function
		handle && handle();
	},

	_onBlurNode: function(/*DomNode*/ node){
		// summary:
		// 		Called when focus leaves a node.
		//		Usually ignored, _unless_ it *isn't* follwed by touching another node,
		//		which indicates that we tabbed off the last field on the page,
		//		in which case every widget is marked inactive
		dijit._prevFocus = dijit._curFocus;
		dijit._curFocus = null;

		if(dijit._justMouseDowned){
			// the mouse down caused a new widget to be marked as active; this blur event
			// is coming late, so ignore it.
			return;
		}

		// if the blur event isn't followed by a focus event then mark all widgets as inactive.
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
		}
		dijit._clearActiveWidgetsTimer = setTimeout(function(){
			delete dijit._clearActiveWidgetsTimer;
			dijit._setStack([]);
			dijit._prevFocus = null;
		}, 100);
	},

	_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
		// summary:
		//		Callback when node is focused or mouse-downed
		// node:
		//		The node that was touched.
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		// ignore the recent blurNode event
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
			delete dijit._clearActiveWidgetsTimer;
		}

		// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
		var newStack=[];
		try{
			while(node){
				var popupParent = dojo.attr(node, "dijitPopupParent");
				if(popupParent){
					node=dijit.byId(popupParent).domNode;
				}else if(node.tagName && node.tagName.toLowerCase() == "body"){
					// is this the root of the document or just the root of an iframe?
					if(node === dojo.body()){
						// node is the root of the main document
						break;
					}
					// otherwise, find the iframe this node refers to (can't access it via parentNode,
					// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
					node=dojo.window.get(node.ownerDocument).frameElement;
				}else{
					// if this node is the root node of a widget, then add widget id to stack,
					// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
					// to support MenuItem)
					var id = node.getAttribute && node.getAttribute("widgetId"),
						widget = id && dijit.byId(id);
					if(widget && !(by == "mouse" && widget.get("disabled"))){
						newStack.unshift(id);
					}
					node=node.parentNode;
				}
			}
		}catch(e){ /* squelch */ }

		dijit._setStack(newStack, by);
	},

	_onFocusNode: function(/*DomNode*/ node){
		// summary:
		//		Callback when node is focused

		if(!node){
			return;
		}

		if(node.nodeType == 9){
			// Ignore focus events on the document itself.  This is here so that
			// (for example) clicking the up/down arrows of a spinner
			// (which don't get focus) won't cause that widget to blur. (FF issue)
			return;
		}

		dijit._onTouchNode(node);

		if(node == dijit._curFocus){ return; }
		if(dijit._curFocus){
			dijit._prevFocus = dijit._curFocus;
		}
		dijit._curFocus = node;
		dojo.publish("focusNode", [node]);
	},

	_setStack: function(/*String[]*/ newStack, /*String*/ by){
		// summary:
		//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
		// newStack:
		//		array of widget id's, starting from the top (outermost) widget
		// by:
		//		"mouse" if the focus/touch was caused by a mouse down event

		var oldStack = dijit._activeStack;
		dijit._activeStack = newStack;

		// compare old stack to new stack to see how many elements they have in common
		for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
			if(oldStack[nCommon] != newStack[nCommon]){
				break;
			}
		}

		var widget;
		// for all elements that have gone out of focus, send blur event
		for(var i=oldStack.length-1; i>=nCommon; i--){
			widget = dijit.byId(oldStack[i]);
			if(widget){
				widget._focused = false;
				widget.set("focused", false);
				widget._hasBeenBlurred = true;
				if(widget._onBlur){
					widget._onBlur(by);
				}
				dojo.publish("widgetBlur", [widget, by]);
			}
		}

		// for all element that have come into focus, send focus event
		for(i=nCommon; i<newStack.length; i++){
			widget = dijit.byId(newStack[i]);
			if(widget){
				widget._focused = true;
				widget.set("focused", true);
				if(widget._onFocus){
					widget._onFocus(by);
				}
				dojo.publish("widgetFocus", [widget, by]);
			}
		}
	}
});

// register top window and all the iframes it contains
dojo.addOnLoad(function(){
	var handle = dijit.registerWin(window);
	if(dojo.isIE){
		dojo.addOnWindowUnload(function(){
			dijit.unregisterWin(handle);
			handle = null;
		})
	}
});

}

if(!dojo._hasResource["dojo.AdapterRegistry"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.AdapterRegistry"] = true;
dojo.provide("dojo.AdapterRegistry");


dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	//	summary:
	//		A registry to make contextual calling/searching easier.
	//	description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	//	example:
	//	|	// create a new registry
	//	|	var reg = new dojo.AdapterRegistry();
	//	|	reg.register("handleString",
	//	|		dojo.isString,
	//	|		function(str){
	//	|			// do something with the string here
	//	|		}
	//	|	);
	//	|	reg.register("handleArr",
	//	|		dojo.isArray,
	//	|		function(arr){
	//	|			// do something with the array here
	//	|		}
	//	|	);
	//	|
	//	|	// now we can pass reg.match() *either* an array or a string and
	//	|	// the value we pass will get handled by the right function
	//	|	reg.match("someValue"); // will call the first function
	//	|	reg.match(["someValue"]); // will call the second

	this.pairs = [];
	this.returnWrappers = returnWrappers || false; // Boolean
};

dojo.extend(dojo.AdapterRegistry, {
	register: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){
		//	summary:
		//		register a check function to determine if the wrap function or
		//		object gets selected
		//	name:
		//		a way to identify this matcher.
		//	check:
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		//	directReturn:
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		//	override:
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.
		this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
		// summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
	},

	unregister: function(name){
		// summary: Remove a named adapter from the registry

		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

}

if(!dojo._hasResource["dijit._base.place"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.place"] = true;
dojo.provide("dijit._base.place");




dijit.getViewport = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	return dojo.window.getBox();
};

/*=====
dijit.__Position = function(){
	// x: Integer
	//		horizontal coordinate in pixels, relative to document body
	// y: Integer
	//		vertical coordinate in pixels, relative to document body

	thix.x = x;
	this.y = y;
}
=====*/


dijit.placeOnScreen = function(
	/* DomNode */			node,
	/* dijit.__Position */	pos,
	/* String[] */			corners,
	/* dijit.__Position? */	padding){
	// summary:
	//		Positions one of the node's corners at specified position
	//		such that node is fully visible in viewport.
	// description:
	//		NOTE: node is assumed to be absolutely or relatively positioned.
	//	pos:
	//		Object like {x: 10, y: 20}
	//	corners:
	//		Array of Strings representing order to try corners in, like ["TR", "BL"].
	//		Possible values are:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//	padding:
	//		set padding to put some buffer around the element you want to position.
	// example:
	//		Try to place node's top right corner at (10,20).
	//		If that makes node go (partially) off screen, then try placing
	//		bottom left corner at (10,20).
	//	|	placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])

	var choices = dojo.map(corners, function(corner){
		var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
		if(padding){
			c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
			c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
		}
		return c;
	});

	return dijit._place(node, choices);
}

dijit._place = function(/*DomNode*/ node, choices, layoutNode, /*Object*/ aroundNodeCoords){
	// summary:
	//		Given a list of spots to put node, put it at the first spot where it fits,
	//		of if it doesn't fit anywhere then the place with the least overflow
	// choices: Array
	//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	//		Above example says to put the top-left corner of the node at (10,20)
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
	//		for things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//		It also passes in the available size for the popup, which is useful for tooltips to
	//		tell them that their width is limited to a certain amount.   layoutNode() may return a value expressing
	//		how much the popup had to be modified to fit into the available space.   This is used to determine
	//		what the best placement is.
	// aroundNodeCoords: Object
	//		Size of aroundNode, ex: {w: 200, h: 50}

	// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
	// viewport over document
	var view = dojo.window.getBox();

	// This won't work if the node is inside a <div style="position: relative">,
	// so reattach it to dojo.doc.body.   (Otherwise, the positioning will be wrong
	// and also it might get cutoff)
	if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
		dojo.body().appendChild(node);
	}

	var best = null;
	dojo.some(choices, function(choice){
		var corner = choice.corner;
		var pos = choice.pos;
		var overflow = 0;

		// calculate amount of space available given specified position of node
		var spaceAvailable = {
			w: corner.charAt(1) == 'L' ? (view.l + view.w) - pos.x : pos.x - view.l,
			h: corner.charAt(1) == 'T' ? (view.t + view.h) - pos.y : pos.y - view.t
		};

		// configure node to be displayed in given position relative to button
		// (need to do this in order to get an accurate size for the node, because
		// a tooltip's size changes based on position, due to triangle)
		if(layoutNode){
			var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
			overflow = typeof res == "undefined" ? 0 : res;
		}

		// get node's size
		var style = node.style;
		var oldDisplay = style.display;
		var oldVis = style.visibility;
		style.visibility = "hidden";
		style.display = "";
		var mb = dojo.marginBox(node);
		style.display = oldDisplay;
		style.visibility = oldVis;

		// coordinates and size of node with specified corner placed at pos,
		// and clipped by viewport
		var startX = Math.max(view.l, corner.charAt(1) == 'L' ? pos.x : (pos.x - mb.w)),
			startY = Math.max(view.t, corner.charAt(0) == 'T' ? pos.y : (pos.y - mb.h)),
			endX = Math.min(view.l + view.w, corner.charAt(1) == 'L' ? (startX + mb.w) : pos.x),
			endY = Math.min(view.t + view.h, corner.charAt(0) == 'T' ? (startY + mb.h) : pos.y),
			width = endX - startX,
			height = endY - startY;

		overflow += (mb.w - width) + (mb.h - height);

		if(best == null || overflow < best.overflow){
			best = {
				corner: corner,
				aroundCorner: choice.aroundCorner,
				x: startX,
				y: startY,
				w: width,
				h: height,
				overflow: overflow,
				spaceAvailable: spaceAvailable
			};
		}
		
		return !overflow;
	});

	// In case the best position is not the last one we checked, need to call
	// layoutNode() again.
	if(best.overflow && layoutNode){
		layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
	}

	// And then position the node.   Do this last, after the layoutNode() above
	// has sized the node, due to browser quirks when the viewport is scrolled
	// (specifically that a Tooltip will shrink to fit as though the window was
	// scrolled to the left).
	//
	// In RTL mode, set style.right rather than style.left so in the common case,
	// window resizes move the popup along with the aroundNode.
	var l = dojo._isBodyLtr(),
		s = node.style;
	s.top = best.y + "px";
	s[l ? "left" : "right"] = (l ? best.x : view.w - best.x - best.w) + "px";
	
	return best;
}

dijit.placeOnScreenAroundNode = function(
	/* DomNode */		node,
	/* DomNode */		aroundNode,
	/* Object */		aroundCorners,
	/* Function? */		layoutNode){

	// summary:
	//		Position node adjacent or kitty-corner to aroundNode
	//		such that it's fully visible in viewport.
	//
	// description:
	//		Place node such that corner of node touches a corner of
	//		aroundNode, and that node is fully visible.
	//
	// aroundCorners:
	//		Ordered list of pairs of corners to try matching up.
	//		Each pair of corners is represented as a key/value in the hash,
	//		where the key corresponds to the aroundNode's corner, and
	//		the value corresponds to the node's corner:
	//
	//	|	{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2, ...}
	//
	//		The following strings are used to represent the four corners:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		For things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//
	// example:
	//	|	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	//		This will try to position node such that node's top-left corner is at the same position
	//		as the bottom left corner of the aroundNode (ie, put node below
	//		aroundNode, with left edges aligned).  If that fails it will try to put
	// 		the bottom-right corner of node where the top right corner of aroundNode is
	//		(ie, put node above aroundNode, with right edges aligned)
	//

	// get coordinates of aroundNode
	aroundNode = dojo.byId(aroundNode);
	var aroundNodePos = dojo.position(aroundNode, true);

	// place the node around the calculated rectangle
	return dijit._placeOnScreenAroundRect(node,
		aroundNodePos.x, aroundNodePos.y, aroundNodePos.w, aroundNodePos.h,	// rectangle
		aroundCorners, layoutNode);
};

/*=====
dijit.__Rectangle = function(){
	// x: Integer
	//		horizontal offset in pixels, relative to document body
	// y: Integer
	//		vertical offset in pixels, relative to document body
	// width: Integer
	//		width in pixels
	// height: Integer
	//		height in pixels

	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
}
=====*/


dijit.placeOnScreenAroundRectangle = function(
	/* DomNode */			node,
	/* dijit.__Rectangle */	aroundRect,
	/* Object */			aroundCorners,
	/* Function */			layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except that the "around"
	//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
	//		instead of a dom node.

	return dijit._placeOnScreenAroundRect(node,
		aroundRect.x, aroundRect.y, aroundRect.width, aroundRect.height,	// rectangle
		aroundCorners, layoutNode);
};

dijit._placeOnScreenAroundRect = function(
	/* DomNode */		node,
	/* Number */		x,
	/* Number */		y,
	/* Number */		width,
	/* Number */		height,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts coordinates
	//		of a rectangle to place node adjacent to.

	// TODO: combine with placeOnScreenAroundRectangle()

	// Generate list of possible positions for node
	var choices = [];
	for(var nodeCorner in aroundCorners){
		choices.push( {
			aroundCorner: nodeCorner,
			corner: aroundCorners[nodeCorner],
			pos: {
				x: x + (nodeCorner.charAt(1) == 'L' ? 0 : width),
				y: y + (nodeCorner.charAt(0) == 'T' ? 0 : height)
			}
		});
	}

	return dijit._place(node, choices, layoutNode, {w: width, h: height});
};

dijit.placementRegistry= new dojo.AdapterRegistry();
dijit.placementRegistry.register("node",
	function(n, x){
		return typeof x == "object" &&
			typeof x.offsetWidth != "undefined" && typeof x.offsetHeight != "undefined";
	},
	dijit.placeOnScreenAroundNode);
dijit.placementRegistry.register("rect",
	function(n, x){
		return typeof x == "object" &&
			"x" in x && "y" in x && "width" in x && "height" in x;
	},
	dijit.placeOnScreenAroundRectangle);

dijit.placeOnScreenAroundElement = function(
	/* DomNode */		node,
	/* Object */		aroundElement,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
	//		for the "around" argument and finds a proper processor to place a node.

	return dijit.placementRegistry.match.apply(dijit.placementRegistry, arguments);
};

dijit.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
	// summary:
	//		Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
	//
	// position: String[]
	//		This variable controls the position of the drop down.
	//		It's an array of strings with the following values:
	//
	//			* before: places drop down to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places drop down to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: drop down goes above target node
	//			* below: drop down goes below target node
	//
	//		The list is positions is tried, in order, until a position is found where the drop down fits
	//		within the viewport.
	//
	// leftToRight: Boolean
	//		Whether the popup will be displaying in leftToRight mode.
	//
	var align = {};
	dojo.forEach(position, function(pos){
		switch(pos){
			case "after":
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
				break;
			case "before":
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
				break;
			case "below-alt":
				leftToRight = !leftToRight;
				// fall through
			case "below":
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "BL" : "BR"] = leftToRight ? "TL" : "TR";
				align[leftToRight ? "BR" : "BL"] = leftToRight ? "TR" : "TL";
				break;
			case "above-alt":
				leftToRight = !leftToRight;
				// fall through
			case "above":
			default:
				// first try to align left borders, next try to align right borders (or reverse for RTL mode)
				align[leftToRight ? "TL" : "TR"] = leftToRight ? "BL" : "BR";
				align[leftToRight ? "TR" : "TL"] = leftToRight ? "BR" : "BL";
				break;
		}
	});
	return align;
};

}

if(!dojo._hasResource["dijit._base.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.window"] = true;
dojo.provide("dijit._base.window");



dijit.getDocumentWindow = function(doc){
	return dojo.window.get(doc);
};

}

if(!dojo._hasResource["dijit._base.popup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.popup"] = true;
dojo.provide("dijit._base.popup");





/*=====
dijit.popup.__OpenArgs = function(){
	// popup: Widget
	//		widget to display
	// parent: Widget
	//		the button etc. that is displaying this popup
	// around: DomNode
	//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
	// x: Integer
	//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// y: Integer
	//		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// orient: Object|String
	//		When the around parameter is specified, orient should be an
	//		ordered list of tuples of the form (around-node-corner, popup-node-corner).
	//		dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	//		until the popup appears fully within the viewport.
	//
	//		The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	//			1. (BL, TL)
	//			2. (TL, BL)
	//		where BL means "bottom left" and "TL" means "top left".
	//		So by default, it first tries putting the popup below the around node, left-aligning them,
	//		and then tries to put it above the around node, still left-aligning them.   Note that the
	//		default is horizontally reversed when in RTL mode.
	//
	//		When an (x,y) position is specified rather than an around node, orient is either
	//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
	//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	//		and the top-right corner.
	// onCancel: Function
	//		callback when user has canceled the popup by
	//			1. hitting ESC or
	//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
	// onClose: Function
	//		callback whenever this popup is closed
	// onExecute: Function
	//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
	// padding: dijit.__Position
	//		adding a buffer around the opening position. This is only useful when around is not set.
	this.popup = popup;
	this.parent = parent;
	this.around = around;
	this.x = x;
	this.y = y;
	this.orient = orient;
	this.onCancel = onCancel;
	this.onClose = onClose;
	this.onExecute = onExecute;
	this.padding = padding;
}
=====*/

dijit.popup = {
	// summary:
	//		This singleton is used to show/hide widgets as popups.

	// _stack: dijit._Widget[]
	//		Stack of currently popped up widgets.
	//		(someone opened _stack[0], and then it opened _stack[1], etc.)
	_stack: [],
	
	// _beginZIndex: Number
	//		Z-index of the first popup.   (If first popup opens other
	//		popups they get a higher z-index.)
	_beginZIndex: 1000,

	_idGen: 1,

	_createWrapper: function(/*Widget || DomNode*/ widget){
		// summary:
		//		Initialization for widgets that will be used as popups.
		//		Puts widget inside a wrapper DIV (if not already in one),
		//		and returns pointer to that wrapper DIV.

		var wrapper = widget.declaredClass ? widget._popupWrapper : (widget.parentNode && dojo.hasClass(widget.parentNode, "dijitPopup")),
			node = widget.domNode || widget;

		if(!wrapper){
			// Create wrapper <div> for when this widget [in the future] will be used as a popup.
			// This is done early because of IE bugs where creating/moving DOM nodes causes focus
			// to go wonky, see tests/robot/Toolbar.html to reproduce
			wrapper = dojo.create("div",{
				"class":"dijitPopup",
				style:{ display: "none"},
				role: "presentation"
			}, dojo.body());
			wrapper.appendChild(node);

			var s = node.style;
			s.display = "";
			s.visibility = "";
			s.position = "";
			s.top = "0px";

			if(widget.declaredClass){		// TODO: in 2.0 change signature to always take widget, then remove if()
				widget._popupWrapper = wrapper;
				dojo.connect(widget, "destroy", function(){
					dojo.destroy(wrapper);
					delete widget._popupWrapper;
				});
			}
		}
		
		return wrapper;
	},

	moveOffScreen: function(/*Widget || DomNode*/ widget){
		// summary:
		//		Moves the popup widget off-screen.
		//		Do not use this method to hide popups when not in use, because
		//		that will create an accessibility issue: the offscreen popup is
		//		still in the tabbing order.

		// Create wrapper if not already there
		var wrapper = this._createWrapper(widget);

		dojo.style(wrapper, {
			visibility: "hidden",
			top: "-9999px",		// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
			display: ""
		});
	},

	hide: function(/*dijit._Widget*/ widget){
		// summary:
		//		Hide this popup widget (until it is ready to be shown).
		//		Initialization for widgets that will be used as popups
		//
		// 		Also puts widget inside a wrapper DIV (if not already in one)
		//
		//		If popup widget needs to layout it should
		//		do so when it is made visible, and popup._onShow() is called.

		// Create wrapper if not already there
		var wrapper = this._createWrapper(widget);

		dojo.style(wrapper, "display", "none");
	},
		
	getTopPopup: function(){
		// summary:
		//		Compute the closest ancestor popup that's *not* a child of another popup.
		//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
		var stack = this._stack;
		for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
			/* do nothing, just trying to get right value for pi */
		}
		return stack[pi];
	},

	open: function(/*dijit.popup.__OpenArgs*/ args){
		// summary:
		//		Popup the widget at the specified position
		//
		// example:
		//		opening at the mouse position
		//		|		dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
		//
		// example:
		//		opening the widget as a dropdown
		//		|		dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
		//
		//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
		//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

		var stack = this._stack,
			widget = args.popup,
			orient = args.orient || (
				(args.parent ? args.parent.isLeftToRight() : dojo._isBodyLtr()) ?
				{'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'} :
				{'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'}
			),
			around = args.around,
			id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+this._idGen++);

		// If we are opening a new popup that isn't a child of a currently opened popup, then
		// close currently opened popup(s).   This should happen automatically when the old popups
		// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
		while(stack.length && (!args.parent || !dojo.isDescendant(args.parent.domNode, stack[stack.length-1].widget.domNode))){
			dijit.popup.close(stack[stack.length-1].widget);
		}

		// Get pointer to popup wrapper, and create wrapper if it doesn't exist
		var wrapper = this._createWrapper(widget);


		dojo.attr(wrapper, {
			id: id,
			style: {
				zIndex: this._beginZIndex + stack.length
			},
			"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] +"Popup",
			dijitPopupParent: args.parent ? args.parent.id : ""
		});

		if(dojo.isIE || dojo.isMoz){
			if(!widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _Widget.destroy()
				widget.bgIframe = new dijit.BackgroundIframe(wrapper);
			}
		}

		// position the wrapper node and make it visible
		var best = around ?
			dijit.placeOnScreenAroundElement(wrapper, around, orient, widget.orient ? dojo.hitch(widget, "orient") : null) :
			dijit.placeOnScreen(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

		wrapper.style.display = "";
		wrapper.style.visibility = "visible";
		widget.domNode.style.visibility = "visible";	// counteract effects from _HasDropDown

		var handlers = [];

		// provide default escape and tab key handling
		// (this will work for any widget, not just menu)
		handlers.push(dojo.connect(wrapper, "onkeypress", this, function(evt){
			if(evt.charOrCode == dojo.keys.ESCAPE && args.onCancel){
				dojo.stopEvent(evt);
				args.onCancel();
			}else if(evt.charOrCode === dojo.keys.TAB){
				dojo.stopEvent(evt);
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onCancel){
					topPopup.onCancel();
				}
			}
		}));

		// watch for cancel/execute events on the popup and notify the caller
		// (for a menu, "execute" means clicking an item)
		if(widget.onCancel){
			handlers.push(dojo.connect(widget, "onCancel", args.onCancel));
		}

		handlers.push(dojo.connect(widget, widget.onExecute ? "onExecute" : "onChange", this, function(){
			var topPopup = this.getTopPopup();
			if(topPopup && topPopup.onExecute){
				topPopup.onExecute();
			}
		}));

		stack.push({
			widget: widget,
			parent: args.parent,
			onExecute: args.onExecute,
			onCancel: args.onCancel,
 			onClose: args.onClose,
			handlers: handlers
		});

		if(widget.onOpen){
			// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
			widget.onOpen(best);
		}

		return best;
	},

	close: function(/*dijit._Widget?*/ popup){
		// summary:
		//		Close specified popup and any popups that it parented.
		//		If no popup is specified, closes all popups.

		var stack = this._stack;

		// Basically work backwards from the top of the stack closing popups
		// until we hit the specified popup, but IIRC there was some issue where closing
		// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
		// closing C might close B indirectly and then the while() condition will run where stack==[A]...
		// so the while condition is constructed defensively.
		while((popup && dojo.some(stack, function(elem){return elem.widget == popup;})) ||
			(!popup && stack.length)){
			var top = stack.pop(),
				widget = top.widget,
				onClose = top.onClose;

			if(widget.onClose){
				// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
				widget.onClose();
			}
			dojo.forEach(top.handlers, dojo.disconnect);

			// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
			if(widget && widget.domNode){
				this.hide(widget);
			}
                        
			if(onClose){
				onClose();
			}
		}
	}
};

// TODO: remove dijit._frames, it isn't being used much, since popups never release their
// iframes (see [22236])
dijit._frames = new function(){
	// summary:
	//		cache of iframes

	var queue = [];

	this.pop = function(){
		var iframe;
		if(queue.length){
			iframe = queue.pop();
			iframe.style.display="";
		}else{
			if(dojo.isIE < 9){
				var burl = dojo.config["dojoBlankHtmlUrl"] || (dojo.moduleUrl("dojo", "resources/blank.html")+"") || "javascript:\"\"";
				var html="<iframe src='" + burl + "'"
					+ " style='position: absolute; left: 0px; top: 0px;"
					+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
				iframe = dojo.doc.createElement(html);
			}else{
			 	iframe = dojo.create("iframe");
				iframe.src = 'javascript:""';
				iframe.className = "dijitBackgroundIframe";
				dojo.style(iframe, "opacity", 0.1);
			}
			iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			dijit.setWaiRole(iframe,"presentation");
		}
		return iframe;
	};

	this.push = function(iframe){
		iframe.style.display="none";
		queue.push(iframe);
	}
}();


dijit.BackgroundIframe = function(/*DomNode*/ node){
	// summary:
	//		For IE/FF z-index schenanigans. id attribute is required.
	//
	// description:
	//		new dijit.BackgroundIframe(node)
	//			Makes a background iframe as a child of node, that fills
	//			area (and position) of node

	if(!node.id){ throw new Error("no id"); }
	if(dojo.isIE || dojo.isMoz){
		var iframe = (this.iframe = dijit._frames.pop());
		node.appendChild(iframe);
		if(dojo.isIE<7 || dojo.isQuirks){
			this.resize(node);
			this._conn = dojo.connect(node, 'onresize', this, function(){
				this.resize(node);
			});
		}else{
			dojo.style(iframe, {
				width: '100%',
				height: '100%'
			});
		}
	}
};

dojo.extend(dijit.BackgroundIframe, {
	resize: function(node){
		// summary:
		// 		Resize the iframe so it's the same size as node.
		//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
		if(this.iframe){
			dojo.style(this.iframe, {
				width: node.offsetWidth + 'px',
				height: node.offsetHeight + 'px'
			});
		}
	},
	destroy: function(){
		// summary:
		//		destroy the iframe
		if(this._conn){
			dojo.disconnect(this._conn);
			this._conn = null;
		}
		if(this.iframe){
			dijit._frames.push(this.iframe);
			delete this.iframe;
		}
	}
});

}

if(!dojo._hasResource["dijit._base.scroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.scroll"] = true;
dojo.provide("dijit._base.scroll");



dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.
	//		Deprecated, use `dojo.window.scrollIntoView` instead.
	
	dojo.window.scrollIntoView(node, pos);
};

}

if(!dojo._hasResource["dojo.uacss"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.uacss"] = true;
dojo.provide("dojo.uacss");


(function(){
	// summary:
	//		Applies pre-set CSS classes to the top-level HTML node, based on:
	// 			- browser (ex: dj_ie)
	//			- browser version (ex: dj_ie6)
	//			- box model (ex: dj_contentBox)
	//			- text direction (ex: dijitRtl)
	//
	//		In addition, browser, browser version, and box model are
	//		combined with an RTL flag when browser text is RTL.  ex: dj_ie-rtl.

	var d = dojo,
		html = d.doc.documentElement,
		ie = d.isIE,
		opera = d.isOpera,
		maj = Math.floor,
		ff = d.isFF,
		boxModel = d.boxModel.replace(/-/,''),

		classes = {
			dj_ie: ie,
			dj_ie6: maj(ie) == 6,
			dj_ie7: maj(ie) == 7,
			dj_ie8: maj(ie) == 8,
			dj_ie9: maj(ie) == 9,
			dj_quirks: d.isQuirks,
			dj_iequirks: ie && d.isQuirks,

			// NOTE: Opera not supported by dijit
			dj_opera: opera,

			dj_khtml: d.isKhtml,

			dj_webkit: d.isWebKit,
			dj_safari: d.isSafari,
			dj_chrome: d.isChrome,

			dj_gecko: d.isMozilla,
			dj_ff3: maj(ff) == 3
		}; // no dojo unsupported browsers

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = d.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	// Unshift() is to run sniff code before the parser.
	dojo._loaders.unshift(function(){
		if(!dojo._isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ")
			html.className = d.trim(html.className + " " + rtlClassStr);
		}
	});
})();

}

if(!dojo._hasResource["dijit._base.sniff"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.sniff"] = true;
dojo.provide("dijit._base.sniff");



// summary:
//		Applies pre-set CSS classes to the top-level HTML node, see
//		`dojo.uacss` for details.
//
//		Simply doing a require on this module will
//		establish this CSS.  Modified version of Morris' CSS hack.

}

if(!dojo._hasResource["dijit._base.typematic"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.typematic"] = true;
dojo.provide("dijit._base.typematic");


dijit.typematic = {
	// summary:
	//		These functions are used to repetitively call a user specified callback
	//		method when a specific key or mouse click over a specific DOM node is
	//		held down for a specific amount of time.
	//		Only 1 such event is allowed to occur on the browser page at 1 time.

	_fireEventAndReload: function(){
		this._timer = null;
		this._callback(++this._count, this._node, this._evt);
		
		// Schedule next event, timer is at most minDelay (default 10ms) to avoid
		// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
		this._currentTimeout = Math.max(
			this._currentTimeout < 0 ? this._initialDelay :
				(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
			this._minDelay);
		this._timer = setTimeout(dojo.hitch(this, "_fireEventAndReload"), this._currentTimeout);
	},

	trigger: function(/*Event*/ evt, /*Object*/ _this, /*DOMNode*/ node, /*Function*/ callback, /*Object*/ obj, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start a timed, repeating callback sequence.
		//		If already started, the function call is ignored.
		//		This method is not normally called by the user but can be
		//		when the normal listener code is insufficient.
		// evt:
		//		key or mouse event object to pass to the user callback
		// _this:
		//		pointer to the user's widget space.
		// node:
		//		the DOM node object to pass the the callback function
		// callback:
		//		function to call until the sequence is stopped called with 3 parameters:
		// count:
		//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
		// node:
		//		the DOM node object passed in
		// evt:
		//		key or mouse event object
		// obj:
		//		user space object used to uniquely identify each typematic sequence
		// subsequentDelay (optional):
		//		if > 1, the number of milliseconds until the 3->n events occur
		//		or else the fractional time multiplier for the next event's delay, default=0.9
		// initialDelay (optional):
		//		the number of milliseconds until the 2nd event occurs, default=500ms
		// minDelay (optional):
		//		the maximum delay in milliseconds for event to fire, default=10ms
		if(obj != this._obj){
			this.stop();
			this._initialDelay = initialDelay || 500;
			this._subsequentDelay = subsequentDelay || 0.90;
			this._minDelay = minDelay || 10;
			this._obj = obj;
			this._evt = evt;
			this._node = node;
			this._currentTimeout = -1;
			this._count = -1;
			this._callback = dojo.hitch(_this, callback);
			this._fireEventAndReload();
			this._evt = dojo.mixin({faux: true}, evt);
		}
	},

	stop: function(){
		// summary:
		//		Stop an ongoing timed, repeating callback sequence.
		if(this._timer){
			clearTimeout(this._timer);
			this._timer = null;
		}
		if(this._obj){
			this._callback(-1, this._node, this._evt);
			this._obj = null;
		}
	},

	addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key.
		//		See also the trigger method for other parameters.
		// keyObject:
		//		an object defining the key to listen for:
		// 		charOrCode:
		//			the printable character (string) or keyCode (number) to listen for.
		// 		keyCode:
		//			(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
		// 		charCode:
		//			(deprecated - use charOrCode) the charCode (number) to listen for.
		// 		ctrlKey:
		//			desired ctrl key state to initiate the callback sequence:
		//			- pressed (true)
		//			- released (false)
		//			- either (unspecified)
		// 		altKey:
		//			same as ctrlKey but for the alt key
		// 		shiftKey:
		//			same as ctrlKey but for the shift key
		// returns:
		//		an array of dojo.connect handles
		if(keyObject.keyCode){
			keyObject.charOrCode = keyObject.keyCode;
			dojo.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}else if(keyObject.charCode){
			keyObject.charOrCode = String.fromCharCode(keyObject.charCode);
			dojo.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}
		return [
			dojo.connect(node, "onkeypress", this, function(evt){
				if(evt.charOrCode == keyObject.charOrCode &&
				(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
				(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
				(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
				(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
					dojo.stopEvent(evt);
					dijit.typematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);
				}else if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			}),
			dojo.connect(node, "onkeyup", this, function(evt){
				if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			})
		];
	},

	addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a typematic mouse click.
		//		See the trigger method for other parameters.
		// returns:
		//		an array of dojo.connect handles
		var dc = dojo.connect;
		return [
			dc(node, "mousedown", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
			}),
			dc(node, "mouseup", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mouseout", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mousemove", this, function(evt){
				evt.preventDefault();
			}),
			dc(node, "dblclick", this, function(evt){
				dojo.stopEvent(evt);
				if(dojo.isIE){
					dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
					setTimeout(dojo.hitch(this, dijit.typematic.stop), 50);
				}
			})
		];
	},

	addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
		// summary:
		//		Start listening for a specific typematic key and mouseclick.
		//		This is a thin wrapper to addKeyListener and addMouseListener.
		//		See the addMouseListener and addKeyListener methods for other parameters.
		// mouseNode:
		//		the DOM node object to listen on for mouse events.
		// keyNode:
		//		the DOM node object to listen on for key events.
		// returns:
		//		an array of dojo.connect handles
		return this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay).concat(
			this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay));
	}
};

}

if(!dojo._hasResource["dijit._base.wai"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.wai"] = true;
dojo.provide("dijit._base.wai");


dijit.wai = {
	onload: function(){
		// summary:
		//		Detects if we are in high-contrast mode or not

		// This must be a named function and not an anonymous
		// function, so that the widget parsing code can make sure it
		// registers its onload function after this function.
		// DO NOT USE "this" within this function.

		// create div for testing if high contrast mode is on or images are turned off
		var div = dojo.create("div",{
			id: "a11yTestNode",
			style:{
				cssText:'border: 1px solid;'
					+ 'border-color:red green;'
					+ 'position: absolute;'
					+ 'height: 5px;'
					+ 'top: -999px;'
					+ 'background-image: url("' + (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")) + '");'
			}
		}, dojo.body());

		// test it
		var cs = dojo.getComputedStyle(div);
		if(cs){
			var bkImg = cs.backgroundImage;
			var needsA11y = (cs.borderTopColor == cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
			dojo[needsA11y ? "addClass" : "removeClass"](dojo.body(), "dijit_a11y");
			if(dojo.isIE){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				dojo.body().removeChild(div);
			}
		}
	}
};

// Test if computer is in high contrast mode.
// Make sure the a11y test runs first, before widgets are instantiated.
if(dojo.isIE || dojo.isMoz){	// NOTE: checking in Safari messes things up
	dojo._loaders.unshift(dijit.wai.onload);
}

dojo.mixin(dijit, {
	hasWaiRole: function(/*Element*/ elem, /*String?*/ role){
		// summary:
		//		Determines if an element has a particular role.
		// returns:
		//		True if elem has the specific role attribute and false if not.
		// 		For backwards compatibility if role parameter not provided,
		// 		returns true if has a role
		var waiRole = this.getWaiRole(elem);
		return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
	},

	getWaiRole: function(/*Element*/ elem){
		// summary:
		//		Gets the role for an element (which should be a wai role).
		// returns:
		//		The role of elem or an empty string if elem
		//		does not have a role.
		 return dojo.trim((dojo.attr(elem, "role") || "").replace("wairole:",""));
	},

	setWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Sets the role on an element.
		// description:
		//		Replace existing role attribute with new role.

			dojo.attr(elem, "role", role);
	},

	removeWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Removes the specified role from an element.
		// 		Removes role attribute if no specific role provided (for backwards compat.)

		var roleValue = dojo.attr(elem, "role");
		if(!roleValue){ return; }
		if(role){
			var t = dojo.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
			dojo.attr(elem, "role", t);
		}else{
			elem.removeAttribute("role");
		}
	},

	hasWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Determines if an element has a given state.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		true if elem has a value for the given state and
		//		false if it does not.

		return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
	},

	getWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Gets the value of a state on an element.
		// description:
		//		Checks for an attribute called "aria-"+state.
		// returns:
		//		The value of the requested state on elem
		//		or an empty string if elem has no value for state.

		return elem.getAttribute("aria-"+state) || "";
	},

	setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
		// summary:
		//		Sets a state on an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.setAttribute("aria-"+state, value);
	},

	removeWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Removes a state from an element.
		// description:
		//		Sets an attribute called "aria-"+state.

		elem.removeAttribute("aria-"+state);
	}
});

}

if(!dojo._hasResource["dijit._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base"] = true;
dojo.provide("dijit._base");












}

if(!dojo._hasResource["dijit._Widget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Widget"] = true;
dojo.provide("dijit._Widget");





////////////////// DEFERRED CONNECTS ///////////////////

// This code is to assist deferring dojo.connect() calls in widgets (connecting to events on the widgets'
// DOM nodes) until someone actually needs to monitor that event.
dojo.connect(dojo, "_connect",
	function(/*dijit._Widget*/ widget, /*String*/ event){
		if(widget && dojo.isFunction(widget._onConnect)){
			widget._onConnect(event);
		}
	});

dijit._connectOnUseEventHandler = function(/*Event*/ event){};

////////////////// ONDIJITCLICK SUPPORT ///////////////////

// Keep track of where the last keydown event was, to help avoid generating
// spurious ondijitclick events when:
// 1. focus is on a <button> or <a>
// 2. user presses then releases the ENTER key
// 3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
// 4. onkeyup event fires, causing the ondijitclick handler to fire
dijit._lastKeyDownNode = null;
if(dojo.isIE){
	(function(){
		var keydownCallback = function(evt){
			dijit._lastKeyDownNode = evt.srcElement;
		};
		dojo.doc.attachEvent('onkeydown', keydownCallback);
		dojo.addOnWindowUnload(function(){
			dojo.doc.detachEvent('onkeydown', keydownCallback);
		});
	})();
}else{
	dojo.doc.addEventListener('keydown', function(evt){
		dijit._lastKeyDownNode = evt.target;
	}, true);
}

(function(){

dojo.declare("dijit._Widget", dijit._WidgetBase, {
	// summary:
	//		Base class for all Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//			- deferred connections
	//				A call like dojo.connect(myWidget, "onMouseMove", func)
	//				will essentially do a dojo.connect(myWidget.domNode, "onMouseMove", func)
	//			- ondijitclick
	//				Support new dojoAttachEvent="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//			- focus related functions
	//				In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//				dijit/_base/focus.js.
	//			- deprecated methods
	//			- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//			- browser sniffing (putting browser id like .dj_ie on <html> node)
	//			- high contrast mode sniffing (add .dijit_a11y class to <body> if machine is in high contrast mode)
	

	////////////////// DEFERRED CONNECTS ///////////////////

	// _deferredConnects: [protected] Object
	//		attributeMap addendum for event handlers that should be connected only on first use
	_deferredConnects: {
		onClick: "",
		onDblClick: "",
		onKeyDown: "",
		onKeyPress: "",
		onKeyUp: "",
		onMouseMove: "",
		onMouseDown: "",
		onMouseOut: "",
		onMouseOver: "",
		onMouseLeave: "",
		onMouseEnter: "",
		onMouseUp: ""
	},

	onClick: dijit._connectOnUseEventHandler,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: dijit._connectOnUseEventHandler,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: dijit._connectOnUseEventHandler,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: dijit._connectOnUseEventHandler,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: dijit._connectOnUseEventHandler,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: dijit._connectOnUseEventHandler,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: dijit._connectOnUseEventHandler,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: dijit._connectOnUseEventHandler,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: dijit._connectOnUseEventHandler,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: dijit._connectOnUseEventHandler,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// To avoid double-connects, remove entries from _deferredConnects
		// that have been setup manually by a subclass (ex, by dojoAttachEvent).
		// If a subclass has redefined a callback (ex: onClick) then assume it's being
		// connected to manually.
		this._deferredConnects = dojo.clone(this._deferredConnects);
		for(var attr in this.attributeMap){
			delete this._deferredConnects[attr]; // can't be in both attributeMap and _deferredConnects
		}
		for(attr in this._deferredConnects){
			if(this[attr] !== dijit._connectOnUseEventHandler){
				delete this._deferredConnects[attr];	// redefined, probably dojoAttachEvent exists
			}
		}

		this.inherited(arguments);

		if(this.domNode){
			// If the developer has specified a handler as a widget parameter
			// (ex: new Button({onClick: ...})
			// then naturally need to connect from DOM node to that handler immediately,
			for(attr in this.params){
				this._onConnect(attr);
			}
		}
	},

	_onConnect: function(/*String*/ event){
		// summary:
		//		Called when someone connects to one of my handlers.
		//		"Turn on" that handler if it isn't active yet.
		//
		//		This is also called for every single initialization parameter
		//		so need to do nothing for parameters like "id".
		// tags:
		//		private
		if(event in this._deferredConnects){
			var mapNode = this[this._deferredConnects[event] || 'domNode'];
			this.connect(mapNode, event.toLowerCase(), event);
			delete this._deferredConnects[event];
		}
	},

	////////////////// FOCUS RELATED ///////////////////
	// _onFocus() and _onBlur() are called by the focus manager

	// focused: [readonly] Boolean
	//		This widget or a widget it contains has focus, or is "active" because
	//		it was recently clicked.
	focused: false,

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (dojo.style(this.domNode, "display") != "none");
	},

	onFocus: function(){
		// summary:
		//		Called when the widget becomes "active" because
		//		it or a widget inside of it either has focus, or has recently
		//		been clicked.
		// tags:
		//		callback
	},

	onBlur: function(){
		// summary:
		//		Called when the widget stops being "active" because
		//		focus moved to something outside of it, or the user
		//		clicked somewhere outside of it, or the widget was
		//		hidden.
		// tags:
		//		callback
	},

	_onFocus: function(e){
		// summary:
		//		This is where widgets do processing for when they are active,
		//		such as changing CSS classes.  See onFocus() for more details.
		// tags:
		//		protected
		this.onFocus();
	},

	_onBlur: function(){
		// summary:
		//		This is where widgets do processing for when they stop being active,
		//		such as changing CSS classes.  See onBlur() for more details.
		// tags:
		//		protected
		this.onBlur();
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		dojo.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// description:
		//		This method is deprecated, use get() or set() directly.

		// Print deprecation warning but only once per calling function
		if(dojo.config.isDebug){
			var alreadyCalledHash = arguments.callee._ach || (arguments.callee._ach = {}),
				caller = (arguments.callee.caller || "unknown caller").toString();
			if(!alreadyCalledHash[caller]){
				dojo.deprecated(this.declaredClass + "::attr() is deprecated. Use get() or set() instead, called from " +
				caller, "", "2.0");
				alreadyCalledHash[caller] = true;
			}
		}

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},
	
	////////////////// ONDIJITCLICK SUPPORT ///////////////////

	// nodesWithKeyClick: [private] String[]
	//		List of nodes that correctly handle click events via native browser support,
	//		and don't need dijit's help
	nodesWithKeyClick: ["input", "button"],

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		This version of connect also provides a special "ondijitclick"
		//		event which triggers on a click or space or enter keyup.
		//		Events connected with `this.connect` are disconnected upon
		//		destruction.
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var d = dojo,
			dc = d._connect,
			handles = this.inherited(arguments, [obj, event == "ondijitclick" ? "onclick" : event, method]);

		if(event == "ondijitclick"){
			// add key based click activation for unsupported nodes.
			// do all processing onkey up to prevent spurious clicks
			// for details see comments at top of this file where _lastKeyDownNode is defined
			if(d.indexOf(this.nodesWithKeyClick, obj.nodeName.toLowerCase()) == -1){ // is NOT input or button
				var m = d.hitch(this, method);
				handles.push(
					dc(obj, "onkeydown", this, function(e){
						//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if((e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
							// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
							dijit._lastKeyDownNode = e.target;
							
							// Stop event to prevent scrolling on space key in IE.
							// But don't do this for _HasDropDown because it surpresses the onkeypress
							// event needed to open the drop down when the user presses the SPACE key.
							if(!("openDropDown" in this && obj == this._buttonNode)){
								e.preventDefault();
							}
						}
			 		}),
					dc(obj, "onkeyup", this, function(e){
						//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if( (e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							e.target == dijit._lastKeyDownNode &&	// === breaks greasemonkey
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
								//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
								dijit._lastKeyDownNode = null;
								return m(e);
						}
					})
				);
			}
		}

		return handles;		// _Widget.Handle
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
		//		`dijit.layout.AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
			//		`dijit.layout.AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit.layout.StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

})();

}

if(!dojo._hasResource["dojo.cache"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cache"] = true;
dojo.provide("dojo.cache");


/*=====
dojo.cache = {
	// summary:
	// 		A way to cache string content that is fetchable via `dojo.moduleUrl`.
};
=====*/

	var cache = {};
	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		// 		A getter and setter for storing the string content associated with the
		// 		module and url arguments.
		// description:
		// 		module and url are used to call `dojo.moduleUrl()` to generate a module URL.
		// 		If value is specified, the cache value for the moduleUrl will be set to
		// 		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		// 		in its internal cache and return that cached value for the URL. To clear
		// 		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		// 		the URL contents, only modules on the same domain of the page can use this capability.
		// 		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		// 		If a String, the module name to use for the base part of the URL, similar to module argument
		// 		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		// 		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		// 		The rest of the path to append to the path derived from the module argument. If
		// 		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		// 		If a String, the value to use in the cache for the module/url combination.
		// 		If an Object, it can have two properties: value and sanitize. The value property
		// 		should be the value to use in the cache, and sanitize can be set to true or false,
		// 		to indicate if XML declarations should be removed from the value and if the HTML
		// 		inside a body tag in the value should be extracted as the real value. The value argument
		// 		or the value property on the value argument are usually only used by the build system
		// 		as it inlines cache content.
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		// 		of call is used to avoid an issue with the build system erroneously trying to intern
		// 		this example. To get the build system to intern your dojo.cache calls, use the
		// 		"dojo.cache" style of call):
		// 		|	//If template.html contains "<h1>Hello</h1>" that will be
		// 		|	//the value for the text variable.
		//		|	var text = dojo["cache"]("my.module", "template.html");
		//	example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		// 		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		// 		erroneously trying to intern this example. To get the build system to intern your
		// 		dojo.cache calls, use the "dojo.cache" style of call):
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		//	example:
		//		Same example as previous, but demostrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		// 		|	//If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		// 		|	//text variable will contain just "<h1>Hello</h1>".
		//		|	var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//Module could be a string, or an object that has a toString() method
		//that will return a useful path. If it is an object, then the "url" argument
		//will actually be the value argument.
		if(typeof module == "string"){
			var pathObj = dojo.moduleUrl(module, url);
		}else{
			pathObj = module;
			value = url;
		}
		var key = pathObj.toString();

		var val = value;
		if(value != undefined && !dojo.isString(value)){
			val = ("value" in value ? value.value : undefined);
		}

		var sanitize = value && value.sanitize ? true : false;

		if(typeof val == "string"){
			//We have a string, set cache value
			val = cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
		}else if(val === null){
			//Remove cached value
			delete cache[key];
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in cache)){
				val = dojo._getText(key);
				cache[key] = sanitize ? dojo.cache._sanitize(val) : val;
			}
			val = cache[key];
		}
		return val; //String
	};

	dojo.cache._sanitize = function(/*String*/val){
		// summary:
		//		Strips <?xml ...?> declarations so that external SVG and XML
		// 		documents can be added to a document without worry. Also, if the string
		//		is an HTML document, only the part inside the body tag is returned.
		// description:
		// 		Copied from dijit._Templated._sanitizeTemplateString.
		if(val){
			val = val.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
			var matches = val.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
			if(matches){
				val = matches[1];
			}
		}else{
			val = "";
		}
		return val; //String
	};

}

if(!dojo._hasResource["dijit._Templated"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Templated"] = true;
dojo.provide("dijit._Templated");






dojo.declare("dijit._Templated",
	null,
	{
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template. Pre-empts the
		//		templatePath. In builds that have their strings "interned", the
		//		templatePath is converted to an inline templateString, thereby
		//		preventing a synchronous network call.
		//
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with dojo.cache() instead.
		templatePath: null,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template node poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with dojoAttachPoint=... in the
		//		template, ex: ["containerNode", "labelNode"]
 		_attachPoints: [],
 =====*/

/*=====
		// _attachEvents: [private] Handle[]
		//		List of connections associated with dojoAttachEvent=... in the
		//		template
 		_attachEvents: [],
 =====*/

		constructor: function(){
			this._attachPoints = [];
			this._attachEvents = [];
		},

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return dojo.string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = dojo.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = dijit._Templated.getCachedTemplate(this.templatePath, this.templateString, this._skipNodeCache);

			var node;
			if(dojo.isString(cached)){
				node = dojo._toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// Call down to _Widget.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to attributeMap
			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node);

			if(this.widgetsInTemplate){
				// Store widgets that we need to start at a later point in time
				var cw = (this._startupWidgets = dojo.parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}));

				this._supportingWidgets = dijit.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}

			this._fillContent(this.srcNodeRef);
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.
			//		Alternately, if rootNode is an array of widgets, then will process dojoAttachPoint
			//		etc. for those widgets.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint
			//			* dojoAttachEvent
			//			* waiRole
			//			* waiState
			// rootNode: DomNode|Array[Widgets]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function?
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			getAttrFunc = getAttrFunc || function(n,p){ return n.getAttribute(p); };

			var nodes = dojo.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = dojo.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && (getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type"))){
					continue;
				}
				// Process dojoAttachPoint
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(dojo.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
						this._attachPoints.push(point);
					}
				}

				// Process dojoAttachEvent
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");;
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = dojo.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							this._attachEvents.push(this.connect(baseNode, event, thisFunc));
						}
					}
				}

				// waiRole, waiState
				// TODO: remove this in 2.0, templates are now using role=... and aria-XXX=... attributes directicly
				var role = getAttrFunc(baseNode, "waiRole");
				if(role){
					dijit.setWaiRole(baseNode, role);
				}
				var values = getAttrFunc(baseNode, "waiState");
				if(values){
					dojo.forEach(values.split(/\s*,\s*/), function(stateValue){
						if(stateValue.indexOf('-') != -1){
							var pair = stateValue.split('-');
							dijit.setWaiState(baseNode, pair[0], pair[1]);
						}
					});
				}
			}
		},

		startup: function(){
			dojo.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this.inherited(arguments);
		},

		destroyRendering: function(){
			// Delete all attach points to prevent IE6 memory leaks.
			dojo.forEach(this._attachPoints, function(point){
				delete this[point];
			}, this);
			this._attachPoints = [];

			// And same for event handlers
			dojo.forEach(this._attachEvents, this.disconnect, this);
			this._attachEvents = [];
			
			this.inherited(arguments);
		}
	}
);

// key is either templatePath or templateString; object is either string or DOM tree
dijit._Templated._templateCache = {};

dijit._Templated.getCachedTemplate = function(templatePath, templateString, alwaysUseString){
	// summary:
	//		Static method to get a template based on the templatePath or
	//		templateString key
	// templatePath: String||dojo.uri.Uri
	//		The URL to get the template from.
	// templateString: String?
	//		a string to use in lieu of fetching the template from a URL. Takes precedence
	//		over templatePath
	// returns: Mixed
	//		Either string (if there are ${} variables that need to be replaced) or just
	//		a DOM tree (if the node can be cloned directly)

	// is it already cached?
	var tmplts = dijit._Templated._templateCache;
	var key = templateString || templatePath;
	var cached = tmplts[key];
	if(cached){
		try{
			// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the current document, then use the current cached value
			if(!cached.ownerDocument || cached.ownerDocument == dojo.doc){
				// string or node of the same document
				return cached;
			}
		}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
		dojo.destroy(cached);
	}

	// If necessary, load template string from template path
	if(!templateString){
		templateString = dojo.cache(templatePath, {sanitize: true});
	}
	templateString = dojo.string.trim(templateString);

	if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
		// there are variables in the template so all we can do is cache the string
		return (tmplts[key] = templateString); //String
	}else{
		// there are no variables in the template so we can cache the DOM tree
		var node = dojo._toDom(templateString);
		if(node.nodeType != 1){
			throw new Error("Invalid template: " + templateString);
		}
		return (tmplts[key] = node); //Node
	}
};

if(dojo.isIE){
	dojo.addOnWindowUnload(function(){
		var cache = dijit._Templated._templateCache;
		for(var key in cache){
			var value = cache[key];
			if(typeof value == "object"){ // value is either a string or a DOM node template
				dojo.destroy(value);
			}
			delete cache[key];
		}
	});
}

// These arguments can be specified for widgets which are used in templates.
// Since any widget can be specified as sub widgets in template, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget,{
	dojoAttachEvent: "",
	dojoAttachPoint: "",
	waiRole: "",
	waiState:""
});

}

if(!dojo._hasResource['bfree.widget.document.DraggableGridItem']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.DraggableGridItem'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 29/11/11
 * Time: 10:40 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.DraggableGridItem');





dojo.declare('bfree.widget.document.DraggableGridItem', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree/widget/document", "template/DraggableGridItem.html", "<div style=\"height:100%;width:100%\">\n    <div dojoAttachPoint=\"source\" style=\"width:100%;height:100%\">\n    </div>\n</div>\n"),
	widgetsInTemplate: true,
    dnd: null,

    document: null,
    data: null,
    grid: null,

    selectedItems: null,

    constructor: function(args){
        this.data = args.data;
        this.document = args.document;
        this.grid = args.grid;
    },

    postCreate: function(){
		this.inherited('postCreate', arguments);

        this.dnd = new dojo.dnd.Source(this.source,{
            accept:[],
            creator: dojo.hitch(this, this.creator)
        });

        this.dnd.insertNodes(true, [this.document]);
	},

    creator: function(item, hint){
        var node = null;

        if(hint == 'avatar'){

            //Created a "dragging" item
            this.selectedItems = this.grid.selection.getSelected();

            node = dojo.create('tr');
            var tableNode = dojo.create('table', {
                style: {borderCollapse: 'collapse'}
            }, node);

             dojo.forEach(this.selectedItems, function(item, idx){
                var rowNode = dojo.create('tr', null, tableNode);

                var imgCellNode = dojo.create('td', null, rowNode);
                var imgSrc = bfree.api.Document.getIconUrl(item.binary_content_type, 16);
                dojo.create('img', {
                    src: imgSrc,
                    width: 16, height: 16
                }, imgCellNode);

                dojo.create('td', {innerHTML: item.name}, rowNode);
            }, this);

            this.dnd.itemCount = this.selectedItems.length;
        }
        else{
            //Just a normal grid item; just display normally.
            node = dojo.create('div', {innerHTML: this.data})
            this.selectedItems = [item];
        }

        return {node: node, data: this.selectedItems};
    }

});

}

if(!dojo._hasResource['bfree.api.CellDefinition']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.CellDefinition'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.CellDefinition');




dojo.declare('bfree.api.CellDefinition', [bfree.api._Object],{
constructor: function(/* Object */args){
        dojo.safeMixin(this, ((!args) ? { } : args));
	}

});

bfree.api.CellDefinition.clone = function(source){
    return new bfree.api.CellDefinition({
        column_order: source.column_order,
        table_name: source.table_name,
        column_name: source.column_name,
        label: source.label,
        name: source.name,
        noresize: source.noresize,
        style: source.style,
        width: source.width,
        formatter: source.formatter,
        date_format: source.date_format
    });
};

bfree.api.CellDefinition.compare = function(cellA, cellB){
    return cellA.column_order-cellB.column_order;
}

bfree.api.CellDefinition.getDbName = function(cell_definition){
    return dojo.replace("{table_name}.{column_name}", cell_definition);
}


bfree.api.CellDefinition.formats = {'none': 0, 'icon': 1, 'size': 2, 'status': 4, 'datetime': 8, 'date': 16, 'time': 32};
bfree.api.CellDefinition.formatStatus = function(data, rowIndex){
    var item = this.grid.getItem(rowIndex);

    var icon = 'none.16.png';

    try{

        if((item) && (item.getState(bfree.api.Document.states.CHECKED_OUT))){
            icon = 'cko.16.png';
        }

    }
    catch(e){
    }

    return dojo.replace('<img name="statusIcon" src="/images/icons/states/{0}" width="16" height="16" style="position:relative;top:1px;left:1px"/>', [icon]);
}

//bfree.api.CellDefinition.formatIcon = function(data, rowIndex){
//    var imgSrc =  bfree.api.Document.getIconUrl(data, 16);
//    return dojo.replace('<img src="{0}" width="16" height="16"/>', [imgSrc]);
//}
//
//bfree.api.CellDefinition.formatSize = function(data, rowIndex){
//
//	var sizeBytes = data;
//
//	return bfree.api.Utilities.readablizeBytes({
//		bytes: sizeBytes
//	});
//}

bfree.api.CellDefinition.formatIcon = function(data, rowIndex){

    if(!data)
        return '';

    var item = this.grid.getItem(rowIndex);
	var imgSrc =  bfree.api.Document.getIconUrl(data, 16);

    var wrapper = dojo.create('div');
    var node = dojo.create('div', { style: {width: 16, height:16, position: 'relative' }}, wrapper);
    dojo.create('img', {src: imgSrc, width: 16, height: 16}, node);

    if(item.isShare()){
        imgSrc = '/images/icons/states/shared.16.png';
        dojo.create('img', {src: imgSrc, width: 16, height: 16, style: {position: 'absolute', top:'2px', left:'2px'}}, node);
    }

    return wrapper.innerHTML;


    /*
    if(data.reference_type == 1)
        dojo.create('img', {src: '/images/icons/states/reference.16.png', style: {position: 'absolute', top: 0, left: 0}}, node);
    */

    //var img = dojo.replace('<img src="{0}" width="16" height="16"/>', [imgSrc]);

    /*
    var gridNode = new bfree.widget.document.DraggableGridItem({
        data: wrapper.innerHTML,
        document: item,
        grid: this.grid
    });

    return gridNode;
    */
};

bfree.api.CellDefinition.formatSize = function(data, rowIndex){

	var sizeBytes = data;

	var bytes = bfree.api.Utilities.readablizeBytes({
		bytes: sizeBytes
	});
    return bytes;

    /*
    var item = this.grid.getItem(rowIndex);

    var gridNode=new bfree.widget.document.DraggableGridItem({
        data: bytes,
        document: item,
        grid: this.grid
    });

    return gridNode;
    */
};

bfree.api.CellDefinition.formatData = function(data, rowIndex){

    return data || '';

    /*
    var item = this.grid.getItem(rowIndex);

    var gridNode=new bfree.widget.document.DraggableGridItem({
        data: data==null?'':data,
        document: item,
        grid: this.grid
    });

    return gridNode;
    */
};

bfree.api.CellDefinition.schema = {
	type: 'object',
	properties: {
		'id': {
			type: 'integer'
		},
		'view_definition_id':{
			type: 'integer'
		},
		'table_name': {
			type: 'string'
		},
		'column_name': {
			type: 'string'
		},
		'name': {
			type: 'string'
		},
		'label': {
			type: 'string'
		},
		'formatter': {
			type: 'integer',
			'default': bfree.api.CellDefinition.formats.none
		},
		'noresize': {
			type: 'boolean',
			'default': false
		},
		'width': {
			type: 'string',
			'default': '128px'
		},
		'style': {
			type: 'string',
			'default': ''
		},
		'column_order': {
			type: 'integer',
			'default': 1
		},
		'date_format': {
			type: 'string',
			'default': ''
		}
	},
    prototype: new bfree.api.CellDefinition()
};

}

if(!dojo._hasResource['bfree.IconManager']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.IconManager'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.IconManager');


dojo.declare('bfree.IconManager', null,{
});

bfree.IconManager.generateImage = function(args){
	var name = 'default';
	var type = args.content_type;
	
	if ((type) && (type.length > 0)) {
		
		if(type[0] == '.')
			type = type.substr(1);
		
		switch (type) {
			case 'doc':
			case 'application/msword':
				name = 'application_msword';
				break;
			case '.docx':
			case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
				name = 'application_msword';
				break;
			case 'gif':
			case 'image/gif':
				name = 'image_gif';
				break;
			case 'image/jpeg':
			case 'jpg':
			case 'jpeg':
				name = 'image_jpeg';
				break;
			case 'pdf':
			case 'application/pdf':
				name = 'application_pdf';
				break;
			case 'zip':
			case 'application/zip':
				name = 'application_zip'
				break;
		}	
	}
	
	return dojo.string.substitute('/images/mimetypes/${0}/${1}.png', [args.size, name]);
}

bfree.IconManager.generateStatusImage = function(args){
	var state = args.state;	
	var size = args.size;
	var name = 'blank'; 
	
	if(bfree.api.Documents.isCheckedOut({state: state}))
		name = 'status-cko';
	if(bfree.api.Documents.isBusy({state: state}))
		name = 'status-busy';
	
	return dojo.string.substitute('/images/icons/${0}/${1}.png', [size, name]);		
};

bfree.IconManager.generateStatusIcon = function(args){
	var img =  bfree.IconManager.generateStatusImage(args);
	return dojo.string.substitute('<img src="${0}" height="${1}" width="${1}">', [img, size]);
};

bfree.IconManager.generateIcon = function(args){
	var content_type = args.content_type;
	var size = args.size;
	
	var imgSrc = bfree.IconManager.generateImage({
		content_type: content_type,
		size: size
	}); 
		
	return dojo.string.substitute('<img src="${0}" height="${1}" width="${1}">', [imgSrc, size]);		
}

}

if(!dojo._hasResource['bfree.widget.StatusIcon']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.StatusIcon'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.StatusIcon');





dojo.declare('bfree.widget.StatusIcon', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree/widget", "template/StatusIcon.html", "<div style=\"height:100%;position:relative;width:100%\">\n\t\n\t<img dojoAttachPoint=\"imgIcon\" src=\"/images/icons/16/blank.png\" height=\"16\" width=\"16\"></img>\n\t\n</div>\n"),
	widgetsInTemplate: false,
	
	busy: false,
	state: 0,
	
	_setBusyAttr: function(value){
		this.busy = value;
		
		if(this.busy){
			this.imgIcon.src = '/images/loading/loading16-b.gif'
		}
		else{
			this.attr('state', this.state);
		}
		
	},
	
	_setStateAttr: function(value){
		this.state = value;
		
		this.imgIcon.src = bfree.IconManager.generateStatusImage({
			state: this.state,
			size: 16
		});
		
	},
	
	postCreate: function(){
		this.inherited('postCreate', arguments);
		
	}
	
});

bfree.widget.StatusIcon.generateId = function(documentItem){
	return dojo.string.substitute('__stsicon_${0}', [documentItem.id]);
}

}

if(!dojo._hasResource['bfree.api.CellDefinitions']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.CellDefinitions'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.CellDefinitions');






dojo.declare('bfree.api.CellDefinitions', [bfree.api._Collection],{

	constructor: function(/* Object */args){
        this.zone=args.zone;
        this.library=args.library;
		this.target = dojo.replace(bfree.api.CellDefinitions.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.CellDefinition.schema;
        this.cache=true;

        this._initialize();
	},
	
	isValidItem: function(args){
		var isValid = this.inherited(arguments);
		var item = args.item;
		
		if(!isValid) return;
	
		if((!item.width) || (item.width.length < 1))
			throw new Error('Cell Definition \'Width\' property is empty or invalid');
				
		return true;
	}
	
});

bfree.api.CellDefinitions.getDefaultWidth = function(data_type_id){
    var w = 128

    switch(data_type_id){
        case bfree.api.DataTypes.types.VOID:
            w = 18;
            break;
        case bfree.api.DataTypes.types.BOOLEAN:
            w = 18;
            break;
        case bfree.api.DataTypes.types.INTEGER:
            w = 64;
            break;
        case bfree.api.DataTypes.types.FLOAT:
            w = 64;
            break;
        case bfree.api.DataTypes.types.DATETIME:
            w = 128;
            break;
        case bfree.api.DataTypes.types.STRING:
            w = 128;
            break;
        case bfree.api.DataTypes.types.TEXT:
            w = 128;
            break;
    }

    return w;
};
bfree.api.CellDefinitions.TRGT="/zones/{0}/libraries/{1}/cell_definitions"


}

if(!dojo._hasResource['bfree.api.ViewDefinitions']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ViewDefinitions'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.ViewDefinitions');






dojo.declare('bfree.api.ViewDefinitions', [bfree.api._Collection],{

    _system: null,

	documentTypes: null,


    _matchesQuery: function(item,request){

        //query returns array of cell definitions,
        //exclude them.
        if(dojo.isArray(item) || (item.hasOwnProperty('column_order')))
            return false;

        var query = request.query;
        var ignoreCase = request.queryOptions && request.queryOptions.ignoreCase;
        for(var i in query){
            // if anything doesn't match, than this should be in the query
            var match = query[i];
            var value = this.getValue(item,i);
            if((typeof match == 'string' && (match.match(/[\*\.]/) || ignoreCase)) ?
                !dojo.data.util.filter.patternToRegExp(match, ignoreCase).test(value) :
                value != match){
                return false;
            }
        }
        return true;
    },

    copyFromTemplate: function(viewDef, user){
        var cell_definitions=viewDef.cell_definitions;
        var toReturn=this.create({
            cell_definitions: [],
            created_by: user.name,
            is_system: false,
            is_template: false,
            library_id: viewDef.library_id,
            name: viewDef.name,
            scope: viewDef.scope,
            sort_by: viewDef.sort_by,
            updated_by: user.name
        });

        dojo.forEach(cell_definitions, function(cell){
            toReturn.cell_definitions.push({
                column_name: cell.column_name,
                column_order: cell.column_order,
                date_format: cell.date_format,
                formatter: cell.formatter,
                label: cell.label,
                name: cell.name,
                noresize: cell.noresize,
                style: cell.style,
                table_name: cell.table_name,
                width: cell.width
            })
        }, this);

        return toReturn;
    },

    /*
    generateView: function(viewDef, cellDefinitions){
		var view = {
			name: viewDef.name,
			view_definition_id: viewDef.id,
			sort_column: 1,			
			cells: []
		}
		
		var cellDefs = cellDefinitions.query({
			query: { view_definition_id: viewDef.id }
		});

        cellDefs=cellDefs.sort(bfree.api.CellDefinition.compare);
		
		var idx = 1;
		dojo.forEach(cellDefs, function(cellDef){
			var cell = {
				field: cellDef.table_name + '.' + cellDef.column_name,
				name: cellDef.label,
				width: cellDef.width,
				noresize: cellDef.noresize,
				style: cellDef.style,
				date_format: cellDef.date_format
			};
			
			if((cell.name == null) || (cell.name.length < 1))
				cell.name = ' ';
			
			cell.get = viewDef._generateGetFn(cellDef, this.library);
			cell.formatter = viewDef._generateFormatterFn(cellDef);
		
			view.cells.push(cell);	
			
			if(cell.field == viewDef.sort_by){
				view.sort_column = idx;
			}
			
			idx++;
		}, this);
								
		return view;		
	},
	*/

	_getDocumentAttr: function(rowIndex, item){
		var value = '';
		var viewDef = this[0];
		var cellDef = this[1];
		
		if(!item)
			return value;
		
		var column = cellDef.column_name
		
		switch(column){		
			case 'created_at':
			case 'updated_at':
				value = viewDef._formatDateTime(cellDef, item[column]);
				break;
			default:
				if (/prp_dtt/.test(column) && item[column]) {
					value = dojo.date.stamp.fromISOString(item[column]);
					if(value){
						value = viewDef._formatDateTime(cellDef, value);
					}
				}
				else {
					value = item[column];
				}
				break;
		}
		
		return value;
	},

	_getDocumentTypeAttr: function(rowIndex, item){
		var value = '';
		var viewDef = this[0];
		var cellDef = this[1];
		
		if(!item)
			return value;
				
		if(!item.document_type_id)		
			return '';
				
		var docType = viewDef.documentTypes.fetchById({
			id: item.document_type_id
		});

		switch(cellDef.column_name){
			case 'name':
				value = docType.name;
				break;
		}
	
		return value;
	},
	
	_getVersionAttr: function(rowIndex, item){
		var value = '';
		var viewDef = this[0];
		var cellDef = this[1];
		
		if(!item)
			return value;
		
		switch(cellDef.column_name){
			case 'content_type':
				value = (item.current_version) ? item.current_version.content_type : '';
				break;
			case 'version_number':
				value = (item.current_version) ? item.current_version.version_number : 0;
				break;
			case 'size':
				value = (item.current_version) ? item.current_version.size : 0;
				break;			
		}

		return value;
	},
	
	constructor: function(/* Object */args){
        this.zone=args.zone;
        this.library=args.library;
		this.target = dojo.replace(bfree.api.ViewDefinitions.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.ViewDefinition.schema;
        this.cache = true;
        this.cellDefinitions = args.cellDefinitions;

        this._initialize();
        //this.store.matchesQuery  = dojo.hitch(this, this._matchesQuery);
	},

    cloneItem: function(source){
        var clone = this.create({
            name: source.name,
            is_system: false,
            description: source.description,
            is_template: false,
            scope: source.scope,
            sort_by: source.sort_by
        });

        dojo.forEach(source.cell_definitions, function(cell_definition, idx){
            clone.cell_definitions.push(bfree.api.CellDefinition.clone(cell_definition));
        });

        return clone;
    },

    getSystem: function(){

        if(!this._system){
            this._system = new Array();
            this.forEach(function(item){
                if(item.is_system){
                    this._system.push(item);
                }
            }, this);
        }

        return this._system;
    },

	isValidItem: function(args){
		var isValid = this.inherited(arguments);
		var item = args.item;
		
		if(!isValid) return;
		
		if (item.name.length < 1) {
			throw new Error('View Definition \'Name\' is empty or invalid');
		}
		
		if ((!item.sort_by) || (item.sort_by.length < 1)){
			throw new Error('View Definition must have a \'Sort By\' value');
		}
				
		return true;
	}
	
});

bfree.api.ViewDefinitions.TRGT="/zones/{0}/libraries/{1}/view_definitions"

}

if(!dojo._hasResource['bfree.api.SharedItem']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.SharedItem'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/04/12
 * Time: 12:06 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.SharedItem');





dojo.declare('bfree.api.SharedItem', bfree.api._Object, {
    zone: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));

    },

    copyLocal: function(args){
        var zone = args.zone;
        var share = args.share;
        var form = args.form;

        var url = dojo.replace(bfree.api.SharedItem.CP_TRGT, [zone.subdomain, share.fingerprint, this.getId()]);

        form.set('action', url);
        form.set('target', '_self');
        form.set('method', 'post');
        form.submit();

	},

    view: function(args){
        var zone = args.zone;
        var share = args.share;
        var form = args.form;

        var url = dojo.replace(bfree.api.SharedItem.VW_TRGT, [zone.subdomain, share.fingerprint, this.getId()]);

        bfree.api.Utilities.viewUrl({
            windowBox: args.windowBox,
            url: '',
            window_name: 'versa_viewer'
        });

        form.set('action', url);
        form.set('target', 'versa_viewer');
        form.set('method', 'post');
        form.submit();
	}


});

bfree.api.SharedItem.VW_TRGT = '/zones/{0}/shares/{1}/download/?item_id={2}&disposition=inline';
bfree.api.SharedItem.CP_TRGT = '/zones/{0}/shares/{1}/download/?item_id={2}&disposition=attachment';

bfree.api.SharedItem.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		}
 	},

	prototype: new bfree.api.SharedItem()
 };

}

if(!dojo._hasResource['bfree.api.SharedItems']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.SharedItems'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/04/12
 * Time: 9:49 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.SharedItems');



dojo.declare('bfree.api.SharedItems', bfree.api._Collection,{
    zone: null,
    share: null,

    constructor: function(args){
        this.zone = args.zone;
        this.share = args.share;
        this.target = dojo.replace(bfree.api.SharedItems.TRGT, [this.zone.subdomain, this.share.fingerprint]);
	    this.schema = bfree.api.SharedItem.schema;
		this.cache = true;

		this._initialize();
    }

});

bfree.api.SharedItems.TRGT = '/zones/{0}/shares/{1}/shared_items';

}

if(!dojo._hasResource['bfree.api.Share']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Share'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/04/12
 * Time: 9:31 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Share');





dojo.declare('bfree.api.Share', bfree.api._Object, {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    authorize: function(zone){
        var url = dojo.replace(bfree.api.Share.AUTH_URL, [zone.id, this.fingerprint]);

        var postData = {
            password: this.password
        };

        var results = bfree.api.XhrHelper.doPostAction({
            target: url,
            postData: postData
        });

        return true;
    },

    getSharedItems: function(args){
        return new bfree.api.SharedItems({zone: args.zone, share: this});
    }

});

bfree.api.Share.AUTH_URL = '/zones/{0}/shares/{1}/authorize.json';

bfree.api.Share.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		}
 	},
	prototype: new bfree.api.Share()
 };

}

if(!dojo._hasResource['bfree.api.Shares']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Shares'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 24/10/11
 * Time: 9:58 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Shares');



dojo.declare('bfree.api.Shares', bfree.api._Collection,{

    constructor: function(args){

        this.zone = args.zone;
        this.target = dojo.replace(bfree.api.Shares.TRGT, [this.zone.subdomain]);
		this.schema = bfree.api.Share.schema;
		this.cache = true;

        this._initialize();
    }

});

bfree.api.Shares.TRGT = '/zones/{0}/shares';

}

if(!dojo._hasResource["dojo.data.util.sorter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.sorter"] = true;
dojo.provide("dojo.data.util.sorter");

dojo.getObject("data.util.sorter", true, dojo);

dojo.data.util.sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	//	summary:
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.
	
	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

dojo.data.util.sorter.createSortFunction = function(	/* attributes array */sortSpec,
														/*dojo.data.core.Read*/ store){
	//	summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = dojo.data.util.sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

}

if(!dojo._hasResource["dojo.data.util.simpleFetch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.simpleFetch"] = true;
dojo.provide("dojo.data.util.simpleFetch");


dojo.getObject("data.util.simpleFetch", true, dojo);

dojo.data.util.simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems()
	//		method takes three arguments, the keywordArgs object that was passed
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters
	//		(such as includeChildren).  The _fetchItems() method should create an array of
	//		result items and pass it to the fetchHandler along with the original request object
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object
	//		with other specifics about the request that are specific to the datastore and pass
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || dojo.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || dojo.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if(!requestObject.onItem){
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

}

if(!dojo._hasResource["dojo.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileReadStore"] = true;
dojo.provide("dojo.data.ItemFileReadStore");





dojo.declare("dojo.data.ItemFileReadStore", null,{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
		if("failOk" in keywordParameters){
			this.failOk = keywordParameters.failOk?true:false;
		}
	},
	
	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.
	
	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,
	
	//Parameter for specifying that it is OK for the xhrGet call to fail silently.
	failOk: false,

	//Parameter to indicate to process data from the url as hierarchical
	//(data items can contain other data items in js form).  Default is true
	//for backwards compatibility.  False means only root items are processed
	//as items, all child objects outside of type-mapped objects and those in
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute:
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		//	summary:
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item,
						/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		// Clone it before returning.  refs: #10474
		return (item[attribute] || []).slice(0); // Array
	},

	getAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		//	summary:
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item,
								/* attribute-name-string */ attribute,
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary:
		//		Internal function for looking at the values contained by the item.
		//	description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary:
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		//	summary:
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this,
		    filter = function(requestArgs, arrayOfItems){
			var items = [],
			    i, key;
			if(requestArgs.query){
				var value,
				    ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}else if(value instanceof RegExp){
						regexpList[key] = value;
					}
				}
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query){
							value = requestArgs.query[key];
							if(!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array.
				// We shouldn't allow resort of the internal list, so that multiple callers
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary:
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i],
				    delayedQuery = fData.args,
				    delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions));
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary:
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems;
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary:
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose &&
			this._loadFinished &&
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) &&
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojo.data.ItemFileReadStore: WARNING!  Data reload " +
					" information has not been provided." +
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		var addingArrays = false,
		    self = this;
		
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'1802-05-14'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue) || addingArrays) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object || dojo.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") &&
				(typeof aValue._type === "undefined") &&
				(typeof aValue._value === "undefined") &&
				self.hierarchical
			);
			return isItem;
		}
		
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i,
		    item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(dojo.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items,
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		//
		// We also store the attribute names so we can validate our store
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {},
		    key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is
		// the name of an attribute that holds the identity of each item.
		// If this data file specified an identifier attribute, then build a
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] }
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'1918-07-18'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date(1918, 6, 18)) }
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._getItemByIdentity(referenceDescription);
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k],
									    found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){
											found = false;
										}
									}
									if(found){
										arrayOfValues[j] = candidateItem;
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item,
		    scope;
		if(!this._loadFinished){
			var self = this;
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			}
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity &&
		   Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
			item = this._itemsByIdentity[identity];
		}else if (Object.hasOwnProperty.call(this._arrayOfAllItems, identity)){
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentityAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed
			// of attributes
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary:
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.
		var self = this;
		//Do a check on the JsonFileUrl and crosscheck it.
		//If it doesn't match the cross-check, it needs to be updated
		//This allows for either url or _jsonFileUrl to he changed to
		//reset the store load location.  Done this way for backwards
		//compatibility.  People use _jsonFileUrl (even though officially
		//private.
		if(this._jsonFileUrl !== this._ccUrl){
			dojo.deprecated("dojo.data.ItemFileReadStore: ",
				"To change the url, set the url property of the store," +
				" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}

		//See if there was any forced reset of data.
		if(this.data != null){
			this._jsonData = this.data;
			this.data = null;
		}

		if(this._jsonFileUrl){
				var getArgs = {
					url: this._jsonFileUrl,
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					failOk: this.failOk,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress.");
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		}
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojo.data.ItemFileReadStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource['bfree.api.Preference']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Preference'] = true;
/**
 * @author mattk
 */
dojo.provide('bfree.api.Preference');



dojo.declare('bfree.api.Preference', [bfree.api._Object],{
	constructor: function(/* Object */args){
        dojo.safeMixin(this, ((!args) ? { } : args));
	}
});

bfree.api.Preference.dateEntryFormats = {_date: 1, _time: 2, _datetime: 3};

bfree.api.Preference.schema = {
	type: 'object',
	properties: {
		'id': {
			type: 'integer'
		},
		'name': {
			type: 'string'
		},
		'value': {
			type: 'string'
		},
		'created_at': {
			type: 'date',
			format: 'date-time'
		},
		'created_by': {
			type: 'string',
			'default': ''
		},
		'updated_at': {
			type: 'date',
			format: 'date-time'
		},
		'updated_by': {
			type: 'string',
			'default': ''
		}
	}
};


}

if(!dojo._hasResource['bfree.api.Preferences']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Preferences'] = true;
/**
 * @author mattk
 */
dojo.provide('bfree.api.Preferences');






dojo.declare('bfree.api.Preferences', [bfree.api._Collection],{
	constructor: function(/* Object */args){
		this.zone = args.zone;
        this.library=args.library;
        this.target = dojo.replace(bfree.api.Preferences.TRGT, [this.zone.subdomain, this.library.id]);
		this.schema = bfree.api.Preference.schema;
		this.cache = true;

		this._dateEntryFormats = new dojo.data.ItemFileReadStore({
			data: {
				'identifier': 'id',
				'label': 'name',
				'items': [
					{id: bfree.api.Preference.dateEntryFormats._date, name: "Date only"},
					{id: bfree.api.Preference.dateEntryFormats._time, name: "Time only"},
					{id: bfree.api.Preference.dateEntryFormats._datetime, name: "Date and Time"}
				]
			},
			clearOnClose: true
		});

        this._initialize();
	},
	
	getDateEntryFormat: function(){
		var item = this.store.fetch({query: {name:"Date entry format"}}).results[0];
		return (item) ? parseInt(this.getValue(item, 'value')) : 1;
	}
});

bfree.api.Preferences.TRGT='/zones{0}/libraries/${1}/preferences'

}

if(!dojo._hasResource['bfree.api.Zone']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Zone'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:03 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Zone');


















dojo.declare('bfree.api.Zone', [bfree.api._Object,bfree.api._Configurable], {
    subdomain: null,

    _groups: null,
    _libraries: null,
    _roles: null,
    _shares: null,
    _users: null,
    _documentTypes: new Array(),
    _propertyDefinitions: new Array(),
    _propertyMappings: new Array(),
    _choiceLists: new Array(),
    _choiceValues: new Array(),
    _cellDefinitions: new Array(),
    _viewDefinitions: new Array(),

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    getGroups: function(){
        if(!this._groups){
            this._groups = new bfree.api.Groups({
                zone: this
            });
        }

        return this._groups;
    },

    getLibraries: function(){

        if(!this._libraries){
            this._libraries = new bfree.api.Libraries({
                zone: this
            });
        }

        return this._libraries;
    },

    getMetrics: function(args){

        var url = dojo.replace(bfree.api.Zone.MT_TRGT,  [this.subdomain]);
        var result = bfree.api.XhrHelper.doGetAction({
            target: url
        });

        return result;
    },

    getRoles: function(){

        if(!this._roles){
            this._roles = new bfree.api.Roles({
                zone: this
            });
        }

        return this._roles;
    },

    getShares: function(){
        if(!this._shares){
            this._shares = new bfree.api.Shares({
                zone: this
            });
        }

        return this._shares;
    },

    getUsers: function(){

        if(!this._users){
            this._users = new bfree.api.Users({
                zone: this
            });
        }

        return this._users;
    },

    getPropertyDefinitions: function(library){
        if(!this._propertyDefinitions[library.id]){
            this._propertyDefinitions[library.id]=new bfree.api.PropertyDefinitions({
                zone: this,
                library: library
            });
        }
        return this._propertyDefinitions[library.id];
    },

    getDocumentTypes: function(library){
        if(!this._documentTypes[library.id]){
            this._documentTypes[library.id]=new bfree.api.DocumentTypes({
                zone: this,
                library: library
            });
        }
        return this._documentTypes[library.id];
    },

    getChoiceLists: function(library){
        if(!this._choiceLists[library.id]){
            this._choiceLists[library.id]=new bfree.api.ChoiceLists({
                zone: this,
                library: library
            });
        }
        return this._choiceLists[library.id];
    },

    getChoiceValues: function(library){
        if(!this._choiceValues[library.id]){
            this._choiceValues[library.id]=new bfree.api.ChoiceValues({
                zone: this,
                library: library
            });
        }
        return this._choiceValues[library.id];
    },

    getPropertyMappings: function(library){
        if(!this._propertyMappings[library.id]){
            this._propertyMappings[library.id]=new bfree.api.PropertyMappings({
                zone: this,
                library: library
            })
        }
        return this._propertyMappings[library.id];
    },

    getCellDefinitions: function(library){
        if(!this._cellDefinitions[library.id]){
            this._cellDefinitions[library.id]=new bfree.api.CellDefinitions({
                zone: this,
                library: library
            })
        }
        return this._cellDefinitions[library.id];
    },

    getViewDefinitions: function(library){
        if(!this._viewDefinitions[library.id]){
            this._viewDefinitions[library.id]=new bfree.api.ViewDefinitions({
                zone: this,
                library: library,
                cellDefinitions: this.getCellDefinitions(library)
            })
        }
        return this._viewDefinitions[library.id];
    },

    isAlive: function(){
        var url = dojo.replace(bfree.api.Zone.ISALIVE_URL, this);

        var postData = {
        };

        var results = bfree.api.XhrHelper.doPostAction({
            target: url,
            postData: postData
        });

        return true;
    },

    logon: function(username, password){
        var url = dojo.replace(bfree.api.Zone.LOGIN_URL, this);

        var postData = {
            username: username,
            password: password
        };

        var results = bfree.api.XhrHelper.doPostAction({
            target: url,
            postData: postData
        });

        return new bfree.api.User(results);
    },

    logoff: function(){
        var url = dojo.replace(bfree.api.Zone.LOGOUT_URL, this);

        var postData = {
        };

        var results = bfree.api.XhrHelper.doPostAction({
            target: url,
            postData: postData
        });

        return results;
    },

    resetPassword: function(username, email){
        var url = dojo.replace(bfree.api.Zone.RESET_URL, this)

        var postData = {
            username: username,
            email: email
        }

        var results = bfree.api.XhrHelper.doPostAction({
            target: url,
            postData: postData
        });

        return results;
    }

});

bfree.api.Zone.TrialStates = {
    'EXPIRED':      0x0000,
    'NO_TRIAL':    -0x0001,
    'INFINITE':     0xFFFF
}


bfree.api.Zone.LOGIN_URL = '/zones/{subdomain}/logon.json';
bfree.api.Zone.LOGOUT_URL = '/zones/{subdomain}/logoff.json';
bfree.api.Zone.ISALIVE_URL = '/zones/{subdomain}/alive.json';
bfree.api.Zone.MT_TRGT = '/zones/{0}/metrics.json';
bfree.api.Zone.RESET_URL = '/zones/{subdomain}/reset.json';

bfree.api.Zone.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'subdomain': {
            type: 'string'
        },
        'active_permissions': {
            type: 'integer',
            'default': 0
        },
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        }
 	},
	prototype: new bfree.api.Zone()
 };



}

if(!dojo._hasResource['bfree.api.Zones']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Zones'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:08 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.Zones');



dojo.declare('bfree.api.Zones', [bfree.api._Collection],{

	/**
	 * Creates a new instance of bfree.api.Libraries
 	 * @constructor
	 */
	constructor: function(args){
		this.target = bfree.api.Zones.TRGT;
		this.schema = bfree.api.Zone.schema;
		this.cache = true;

		this._initialize();
	}

});

bfree.api.Zones.TRGT = '/zones';

}

if(!dojo._hasResource['bfree.api.ZoneNode']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ZoneNode'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:03 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.ZoneNode');



dojo.declare('bfree.api.ZoneNode', [bfree.api._Object], {

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    isValid: function(){

        var valid=true;

        if(String.isBlank(this.name)){
            valid=false;
        }

        if(String.isBlank(this.subdomain)){
            valid=false;
        }

        if(String.isBlank(this.max_users)){
            valid=false;
        }

        if(String.isBlank(this.max_disk_space)){
            valid=false;
        }

        return valid;

    }
});

bfree.api.ZoneNode.schema = {
 	type: 'object',
 	properties: {
 		'id': {
 			type: 'integer'
 		},
 		'name': {
 			type: 'string',
 			'default': ''
 		},
        'subdomain': {
 			type: 'string',
 			'default': ''
 		},
        'fingerprint': {
 			type: 'string',
 			'default': ''
 		},
        'status': {
 			type: 'integer',
 			'default': ''
 		},
        'current_users': {
 			type: 'integer',
 			'default': ''
 		},
        'max_users': {
 			type: 'integer',
 			'default': ''
 		},
        'current_disk_space': {
 			type: 'long',
 			'default': ''
 		},
        'max_disk_space': {
 			type: 'long',
 			'default': ''
 		},
        'created_at': {
            type: 'date',
            format: 'date-time'
        },
        'updated_at': {
            type: 'date',
            format: 'date-time'
        },
        'account_id':{
            type: 'integer',
            'default': 1
        },
        'server_id':{
            type: 'integer',
            'default': 1
        },
        'status':{
            type: 'integer',
            'default': 0
        }
 	},
	prototype: new bfree.api.ZoneNode()
 };



}

if(!dojo._hasResource['bfree.api.ZoneNodes']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ZoneNodes'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/09/11
 * Time: 4:08 PM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.api.ZoneNodes');



dojo.declare('bfree.api.ZoneNodes', [bfree.api._Collection],{

	/**
	 * Creates a new instance of bfree.api.Libraries
 	 * @constructor
	 */
	constructor: function(args){
		this.target = bfree.api.ZoneNodes.TRGT;
		this.schema = bfree.api.ZoneNode.schema;
		this.cache = true;

		this._initialize();
	},

    updateUsage: function(zone){
        var results = bfree.api.XhrHelper.doPostAction({
            target: dojo.replace('/zone_nodes/{0}/update_current_usage.json', [zone.id]),
            postData: []
        });

        zone.current_disk_space=results.current_disk_space;
        zone.current_users=results.current_users;

        this.loadItem({item: zone});

        return zone;
    },

    deploy: function(zone){
        var results = bfree.api.XhrHelper.doPostAction({
            target: dojo.replace('/zone_nodes/{0}/deploy.json', [zone.id]),
            postData: []
        });

        zone.deployed=results.deployed;
        this.loadItem({item: zone});

        return zone;
    }
});

bfree.api.ZoneNodes.TRGT = '/zone_nodes';

}

if(!dojo._hasResource['bfree.widget.BrowserSniffer']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.BrowserSniffer'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 06/10/11
 * Time: 4:43 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.BrowserSniffer');




dojo.declare('bfree.widget.BrowserSniffer', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree.widget", "template/BrowserSniffer.html", "<div style=\"height:32px;width:160px\">\n\n    <div id=\"nodeChrome\" class=\"browserIcon browserChrome\"></div>\n    <div id=\"nodeFF\" class=\"browserIcon browserFF\"></div>\n    <div id=\"nodeOpera\" class=\"browserIcon browserOpera\"></div>\n    <div id=\"nodeSafari\" class=\"browserIcon browserSafari\"></div>\n    <div id=\"nodeIE\" class=\"browserIcon browserIE\"></div>\n\n</div>\n"),

    _browsers: null,
    delay: 250,

    _sniff: function(){
        var p = this.delay;

        if((this._browsers == null) || (this._browsers.length < 1))
            return;

        var b = this._browsers.pop();
        if(!dojo['is' + b]){
            dojo.fadeOut({node: dojo.byId('node' + b), end: 0.15}).play();
        }
        else{
            p = 0;
        }

        setTimeout(bfree.widget.BrowserSniffer.Browsers._buildSniffFnRef(this), p);
    },

    constructor: function(args){
    },

    postCreate: function(){
		this.inherited('postCreate', arguments)

        this._browsers = bfree.widget.BrowserSniffer.Browsers.slice(0);
        this._browsers.shuffle();
    },

    sniff: function(){
        setTimeout(bfree.widget.BrowserSniffer.Browsers._buildSniffFnRef(this), this.duration);
    }

});

bfree.widget.BrowserSniffer.Browsers = ['Chrome', 'FF', 'Opera', 'Safari','IE'];

bfree.widget.BrowserSniffer.Browsers._buildSniffFnRef = function(that){
    return ( function() {
       that._sniff();
    });
}

}

if(!dojo._hasResource["dijit._Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Container"] = true;
dojo.provide("dijit._Container");


dojo.declare("dijit._Container",
	null,
	{
		// summary:
		//		Mixin for widgets that contain a set of widget children.
		// description:
		//		Use this mixin for widgets that needs to know about and
		//		keep track of their widget children. Suitable for widgets like BorderContainer
		//		and TabContainer which contain (only) a set of child widgets.
		//
		//		It's not suitable for widgets like ContentPane
		//		which contains mixed HTML (plain DOM nodes in addition to widgets),
		//		and where contained widgets are not necessarily directly below
		//		this.containerNode.   In that case calls like addChild(node, position)
		//		wouldn't make sense.

		// isContainer: [protected] Boolean
		//		Indicates that this widget acts as a "parent" to the descendant widgets.
		//		When the parent is started it will call startup() on the child widgets.
		//		See also `isLayoutContainer`.
		isContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// all widgets with descendants must set containerNode
	 				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			var refNode = this.containerNode;
			if(insertIndex && typeof insertIndex == "number"){
				var children = this.getChildren();
				if(children && children.length >= insertIndex){
					refNode = children[insertIndex-1].domNode;
					insertIndex = "after";
				}
			}
			dojo.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget or int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has children, i.e. if this.containerNode contains something.
			return this.getChildren().length > 0;	// Boolean
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//      Destroys all the widgets inside this.containerNode,
			//      but not this widget itself
			dojo.forEach(this.getChildren(), function(child){ child.destroyRecursive(preserveDom); });
		},

		_getSiblingOfChild: function(/*dijit._Widget*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//      private
			var node = child.domNode,
				which = (dir>0 ? "nextSibling" : "previousSibling");
			do{
				node = node[which];
			}while(node && (node.nodeType != 1 || !dijit.byNode(node)));
			return node && dijit.byNode(node);	// dijit._Widget
		},

		getIndexOfChild: function(/*dijit._Widget*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return dojo.indexOf(this.getChildren(), child);	// int
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Startup all children of this widget
			dojo.forEach(this.getChildren(), function(child){ child.startup(); });

			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit._Contained"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Contained"] = true;
dojo.provide("dijit._Contained");


dojo.declare("dijit._Contained",
		null,
		{
			// summary:
			//		Mixin for widgets that are children of a container widget
			//
			// example:
			// | 	// make a basic custom widget that knows about it's parents
			// |	dojo.declare("my.customClass",[dijit._Widget,dijit._Contained],{});

			getParent: function(){
				// summary:
				//		Returns the parent widget of this widget, assuming the parent
				//		specifies isContainer
				var parent = dijit.getEnclosingWidget(this.domNode.parentNode);
				return parent && parent.isContainer ? parent : null;
			},

			_getSibling: function(/*String*/ which){
				// summary:
				//      Returns next or previous sibling
				// which:
				//      Either "next" or "previous"
				// tags:
				//      private
				var node = this.domNode;
				do{
					node = node[which+"Sibling"];
				}while(node && node.nodeType != 1);
				return node && dijit.byNode(node);	// dijit._Widget
			},

			getPreviousSibling: function(){
				// summary:
				//		Returns null if this is the first child of the parent,
				//		otherwise returns the next element sibling to the "left".

				return this._getSibling("previous"); // dijit._Widget
			},

			getNextSibling: function(){
				// summary:
				//		Returns null if this is the last child of the parent,
				//		otherwise returns the next element sibling to the "right".

				return this._getSibling("next"); // dijit._Widget
			},

			getIndexInParent: function(){
				// summary:
				//		Returns the index of this widget within its container parent.
				//		It returns -1 if the parent does not exist, or if the parent
				//		is not a dijit._Container

				var p = this.getParent();
				if(!p || !p.getIndexOfChild){
					return -1; // int
				}
				return p.getIndexOfChild(this); // int
			}
		}
	);

}

if(!dojo._hasResource["dijit.layout._LayoutWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._LayoutWidget"] = true;
dojo.provide("dijit.layout._LayoutWidget");





dojo.declare("dijit.layout._LayoutWidget",
	[dijit._Widget, dijit._Container, dijit._Contained],
	{
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			dojo.addClass(this.domNode, "dijitContainer");
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent()
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when my size changes so that I can re-layout.
				// For browsers where I can't directly monitor when my size changes,
				// monitor when the viewport changes size, which *may* indicate a size change for me.
				this.connect(dojo.isIE ? this.domNode : dojo.global, 'onresize', function(){
					// Using function(){} closure to ensure no arguments to resize.
					this.resize();
				});
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		Change size mode:
			//			When changeSize is specified, changes the marginBox of this widget
			//			and forces it to relayout its contents accordingly.
			//			changeSize may specify height, width, or both.
			//
			//			If resultSize is specified it indicates the size the widget will
			//			become after changeSize has been applied.
			//
			//		Notification mode:
			//			When changeSize is null, indicates that the caller has already changed
			//			the size of the widget, or perhaps it changed because the browser
			//			window was resized.  Tells widget to relayout its contents accordingly.
			//
			//			If resultSize is also specified it indicates the size the widget has
			//			become.
			//
			//		In either mode, this method also:
			//			1. Sets this._borderBox and this._contentBox to the new size of
			//				the widget.  Queries the current domNode size if necessary.
			//			2. Calls layout() to resize contents (and maybe adjust child widgets).
			//
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			//
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				dojo.marginBox(node, changeSize);

				// set offset of the node
				if(changeSize.t){ node.style.top = changeSize.t + "px"; }
				if(changeSize.l){ node.style.left = changeSize.l + "px"; }
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = dojo.mixin(dojo.marginBox(node), mb);	// just use dojo.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling dojo.contentBox() since that may fail if size was recently set)
			var cs = dojo.getComputedStyle(node);
			var me = dojo._getMarginExtents(node, cs);
			var be = dojo._getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = dojo._getPadExtents(node, cs);
			this._contentBox = {
				l: dojo._toPixelValue(node, cs.paddingLeft),
				t: dojo._toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit._Widget*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			var cls = this.baseClass + "-child "
				+ (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
			dojo.addClass(child.domNode, cls);
		},

		addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit._Widget*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			var cls = this.baseClass + "-child"
					+ (child.baseClass ?
						" " + this.baseClass + "-" + child.baseClass : "");
			dojo.removeClass(child.domNode, cls);
			
			this.inherited(arguments);
		}
	}
);

dijit.layout.marginBox2contentBox = function(/*DomNode*/ node, /*Object*/ mb){
	// summary:
	//		Given the margin-box size of a node, return its content box size.
	//		Functions like dojo.contentBox() but is more reliable since it doesn't have
	//		to wait for the browser to compute sizes.
	var cs = dojo.getComputedStyle(node);
	var me = dojo._getMarginExtents(node, cs);
	var pb = dojo._getPadBorderExtents(node, cs);
	return {
		l: dojo._toPixelValue(node, cs.paddingLeft),
		t: dojo._toPixelValue(node, cs.paddingTop),
		w: mb.w - (me.w + pb.w),
		h: mb.h - (me.h + pb.h)
	};
};

(function(){
	var capitalize = function(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	};

	var size = function(widget, dim){
		// size the child
		var newSize = widget.resize ? widget.resize(dim) : dojo.marginBox(widget.domNode, dim);

		// record child's size
		if(newSize){
			// if the child returned it's new size then use that
			dojo.mixin(widget, newSize);
		}else{
			// otherwise, call marginBox(), but favor our own numbers when we have them.
			// the browser lies sometimes
			dojo.mixin(widget, dojo.marginBox(widget.domNode));
			dojo.mixin(widget, dim);
		}
	};

	dijit.layout.layoutChildren = function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
			/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
		// summary
		//		Layout a bunch of child dom nodes within a parent dom node
		// container:
		//		parent node
		// dim:
		//		{l, t, w, h} object specifying dimensions of container into which to place children
		// children:
		//		an array of Widgets or at least objects containing:
		//			* domNode: pointer to DOM node to position
		//			* region or layoutAlign: position to place DOM node
		//			* resize(): (optional) method to set size of node
		//			* id: (optional) Id of widgets, referenced from resize object, below.
		// changedRegionId:
		//		If specified, the slider for the region with the specified id has been dragged, and thus
		//		the region's height or width should be adjusted according to changedRegionSize
		// changedRegionSize:
		//		See changedRegionId.

		// copy dim because we are going to modify it
		dim = dojo.mixin({}, dim);

		dojo.addClass(container, "dijitLayoutContainer");

		// Move "client" elements to the end of the array for layout.  a11y dictates that the author
		// needs to be able to put them in the document in tab-order, but this algorithm requires that
		// client be last.    TODO: move these lines to LayoutContainer?   Unneeded other places I think.
		children = dojo.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
			.concat(dojo.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

		// set positions/sizes
		dojo.forEach(children, function(child){
			var elm = child.domNode,
				pos = (child.region || child.layoutAlign);

			// set elem to upper left corner of unused space; may move it later
			var elmStyle = elm.style;
			elmStyle.left = dim.l+"px";
			elmStyle.top = dim.t+"px";
			elmStyle.position = "absolute";

			dojo.addClass(elm, "dijitAlign" + capitalize(pos));

			// Size adjustments to make to this child widget
			var sizeSetting = {};

			// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
			// panes and width adjustment for left/right align panes.
			if(changedRegionId && changedRegionId == child.id){
				sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
			}

			// set size && adjust record of remaining space.
			// note that setting the width of a <div> may affect its height.
			if(pos == "top" || pos == "bottom"){
				sizeSetting.w = dim.w;
				size(child, sizeSetting);
				dim.h -= child.h;
				if(pos == "top"){
					dim.t += child.h;
				}else{
					elmStyle.top = dim.t + dim.h + "px";
				}
			}else if(pos == "left" || pos == "right"){
				sizeSetting.h = dim.h;
				size(child, sizeSetting);
				dim.w -= child.w;
				if(pos == "left"){
					dim.l += child.w;
				}else{
					elmStyle.left = dim.l + dim.w + "px";
				}
			}else if(pos == "client" || pos == "center"){
				size(child, dim);
			}
		});
	};

})();

}

if(!dojo._hasResource["dojo.cookie"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cookie"] = true;
dojo.provide("dojo.cookie");



/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes. << FIXME: 0 seems to disappear right away? FF3.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary:
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props:
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + dojo.regexp.escapeString(name) + "=([^;]*)"));
		return matches ? decodeURIComponent(matches[1]) : undefined; // String or undefined
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

}

if(!dojo._hasResource["dijit.layout.BorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.BorderContainer"] = true;
dojo.provide("dijit.layout.BorderContainer");





dojo.declare(
	"dijit.layout.BorderContainer",
	dijit.layout._LayoutWidget,
{
	// summary:
	//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.
	//
	// description:
	//		A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	//		that contains a child widget marked region="center" and optionally children widgets marked
	//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	//		Children along the edges will be laid out according to width or height dimensions and may
	//		include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	//		space is designated for the center region.
	//
	//		The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	//		"left" and "right" except that they will be reversed in right-to-left environments.
	//
	//		For complex layouts, multiple children can be specified for a single region.   In this case, the
	//		layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	//		and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	//		instead of the design attribute to conrol layout precedence of horizontal vs. vertical panes.
	// example:
	// |	<div dojoType="dijit.layout.BorderContainer" design="sidebar" gutters="false"
	// |            style="width: 400px; height: 300px;">
	// |		<div dojoType="dijit.layout.ContentPane" region="top">header text</div>
	// |		<div dojoType="dijit.layout.ContentPane" region="right" splitter="true" style="width: 200px;">table of contents</div>
	// |		<div dojoType="dijit.layout.ContentPane" region="center">client area</div>
	// |	</div>

	// design: String
	//		Which design is used for the layout:
	//			- "headline" (default) where the top and bottom extend
	//				the full width of the container
	//			- "sidebar" where the left and right sides extend from top to bottom.
	design: "headline",

	// gutters: [const] Boolean
	//		Give each pane a border and margin.
	//		Margin determined by domNode.paddingLeft.
	//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
	gutters: true,

	// liveSplitters: [const] Boolean
	//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
	liveSplitters: true,

	// persist: Boolean
	//		Save splitter positions in a cookie.
	persist: false,

	baseClass: "dijitBorderContainer",

	// _splitterClass: String
	// 		Optional hook to override the default Splitter widget used by BorderContainer
	_splitterClass: "dijit.layout._Splitter",

	postMixInProperties: function(){
		// change class name to indicate that BorderContainer is being used purely for
		// layout (like LayoutContainer) rather than for pretty formatting.
		if(!this.gutters){
			this.baseClass += "NoGutter";
		}
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }
		dojo.forEach(this.getChildren(), this._setupChild, this);
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget._setupChild().

		var region = child.region;
		if(region){
			this.inherited(arguments);

			dojo.addClass(child.domNode, this.baseClass+"Pane");

			var ltr = this.isLeftToRight();
			if(region == "leading"){ region = ltr ? "left" : "right"; }
			if(region == "trailing"){ region = ltr ? "right" : "left"; }

			// Create draggable splitter for resizing pane,
			// or alternately if splitter=false but BorderContainer.gutters=true then
			// insert dummy div just for spacing
			if(region != "center" && (child.splitter || this.gutters) && !child._splitterWidget){
				var _Splitter = dojo.getObject(child.splitter ? this._splitterClass : "dijit.layout._Gutter");
				var splitter = new _Splitter({
					id: child.id + "_splitter",
					container: this,
					child: child,
					region: region,
					live: this.liveSplitters
				});
				splitter.isSplitter = true;
				child._splitterWidget = splitter;

				dojo.place(splitter.domNode, child.domNode, "after");

				// Splitters aren't added as Contained children, so we need to call startup explicitly
				splitter.startup();
			}
			child.region = region;	// TODO: technically wrong since it overwrites "trailing" with "left" etc.
		}
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		this._layoutChildren();
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Override _LayoutWidget.addChild().
		this.inherited(arguments);
		if(this._started){
			this.layout(); //OPT
		}
	},

	removeChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget.removeChild().

		var region = child.region;
		var splitter = child._splitterWidget
		if(splitter){
			splitter.destroy();
			delete child._splitterWidget;
		}
		this.inherited(arguments);
		
		if(this._started){
			this._layoutChildren();
		}
		// Clean up whatever style changes we made to the child pane.
		// Unclear how height and width should be handled.
		dojo.removeClass(child.domNode, this.baseClass+"Pane");
		dojo.style(child.domNode, {
			top: "auto",
			bottom: "auto",
			left: "auto",
			right: "auto",
			position: "static"
		});
		dojo.style(child.domNode, region == "top" || region == "bottom" ? "width" : "height", "auto");
	},

	getChildren: function(){
		// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
		return dojo.filter(this.inherited(arguments), function(widget){
			return !widget.isSplitter;
		});
	},

	// TODO: remove in 2.0
	getSplitter: function(/*String*/region){
		// summary:
		//		Returns the widget responsible for rendering the splitter associated with region
		// tags:
		//		deprecated
		return dojo.filter(this.getChildren(), function(child){
			return child.region == region;
		})[0]._splitterWidget;
	},

	resize: function(newSize, currentSize){
		// Overrides _LayoutWidget.resize().

		// resetting potential padding to 0px to provide support for 100% width/height + padding
		// TODO: this hack doesn't respect the box model and is a temporary fix
		if(!this.cs || !this.pe){
			var node = this.domNode;
			this.cs = dojo.getComputedStyle(node);
			this.pe = dojo._getPadExtents(node, this.cs);
			this.pe.r = dojo._toPixelValue(node, this.cs.paddingRight);
			this.pe.b = dojo._toPixelValue(node, this.cs.paddingBottom);

			dojo.style(node, "padding", "0px");
		}

		this.inherited(arguments);
	},

	_layoutChildren: function(/*String?*/ changedChildId, /*Number?*/ changedChildSize){
		// summary:
		//		This is the main routine for setting size/position of each child.
		// description:
		//		With no arguments, measures the height of top/bottom panes, the width
		//		of left/right panes, and then sizes all panes accordingly.
		//
		//		With changedRegion specified (as "left", "top", "bottom", or "right"),
		//		it changes that region's width/height to changedRegionSize and
		//		then resizes other regions that were affected.
		// changedChildId:
		//		Id of the child which should be resized because splitter was dragged.
		// changedChildSize:
		//		The new width/height (in pixels) to make specified child

		if(!this._borderBox || !this._borderBox.h){
			// We are currently hidden, or we haven't been sized by our parent yet.
			// Abort.   Someone will resize us later.
			return;
		}

		// Generate list of wrappers of my children in the order that I want layoutChildren()
		// to process them (i.e. from the outside to the inside)
		var wrappers = dojo.map(this.getChildren(), function(child, idx){
			return {
				pane: child,
				weight: [
					child.region == "center" ? Infinity : 0,
					child.layoutPriority,
					(this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1),
					idx
				]
			};
		}, this);
		wrappers.sort(function(a, b){
			var aw = a.weight, bw = b.weight;
			for(var i=0; i<aw.length; i++){
				if(aw[i] != bw[i]){
					return aw[i] - bw[i];
				}
			}
			return 0;
		});

		// Make new list, combining the externally specified children with splitters and gutters
		var childrenAndSplitters = [];
		dojo.forEach(wrappers, function(wrapper){
			var pane = wrapper.pane;
			childrenAndSplitters.push(pane);
			if(pane._splitterWidget){
				childrenAndSplitters.push(pane._splitterWidget);
			}
		});

		// Compute the box in which to lay out my children
		var dim = {
			l: this.pe.l,
			t: this.pe.t,
			w: this._borderBox.w - this.pe.w,
			h: this._borderBox.h - this.pe.h
		};

		// Layout the children, possibly changing size due to a splitter drag
		dijit.layout.layoutChildren(this.domNode, dim, childrenAndSplitters,
			changedChildId, changedChildSize);
	},

	destroyRecursive: function(){
		// Destroy splitters first, while getChildren() still works
		dojo.forEach(this.getChildren(), function(child){
			var splitter = child._splitterWidget;
			if(splitter){
				splitter.destroy();
			}
			delete child._splitterWidget;
		});

		// Then destroy the real children, and myself
		this.inherited(arguments);
	}
});

// This argument can be specified for the children of a BorderContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// region: [const] String
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
	//		See the `dijit.layout.BorderContainer` description for details.
	region: '',

	// layoutPriority: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Children with a higher layoutPriority will be placed closer to the BorderContainer center,
	//		between children with a lower layoutPriority.
	layoutPriority: 0,

	// splitter: [const] Boolean
	//		Parameter for child of `dijit.layout.BorderContainer` where region != "center".
	//		If true, enables user to resize the widget by putting a draggable splitter between
	//		this widget and the region=center widget.
	splitter: false,

	// minSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
	minSize: 0,

	// maxSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
	maxSize: Infinity
});

dojo.declare("dijit.layout._Splitter", [ dijit._Widget, dijit._Templated ],
{
	// summary:
	//		A draggable spacer between two items in a `dijit.layout.BorderContainer`.
	// description:
	//		This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create it directly.
	// tags:
	//		private

/*=====
 	// container: [const] dijit.layout.BorderContainer
 	//		Pointer to the parent BorderContainer
	container: null,

	// child: [const] dijit.layout._LayoutWidget
	//		Pointer to the pane associated with this splitter
	child: null,

	// region: [const] String
	//		Region of pane associated with this splitter.
	//		"top", "bottom", "left", "right".
	region: null,
=====*/

	// live: [const] Boolean
	//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
	live: true,

	templateString: '<div class="dijitSplitter" dojoAttachEvent="onkeypress:_onKeyPress,onmousedown:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0" role="separator"><div class="dijitSplitterThumb"></div></div>',

	postMixInProperties: function(){
		this.inherited(arguments);

		this.horizontal = /top|bottom/.test(this.region);
		this._factor = /top|left/.test(this.region) ? 1 : -1;
		this._cookieName = this.container.id + "_" + this.region;
	},

	buildRendering: function(){
		this.inherited(arguments);

		dojo.addClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));

		if(this.container.persist){
			// restore old size
			var persistSize = dojo.cookie(this._cookieName);
			if(persistSize){
				this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
			}
		}
	},

	_computeMaxSize: function(){
		// summary:
		//		Return the maximum size that my corresponding pane can be set to

		var dim = this.horizontal ? 'h' : 'w',
			childSize = dojo.marginBox(this.child.domNode)[dim],
			center = dojo.filter(this.container.getChildren(), function(child){ return child.region == "center";})[0],
			spaceAvailable = dojo.marginBox(center.domNode)[dim];	// can expand until center is crushed to 0

		return Math.min(this.child.maxSize, childSize + spaceAvailable);
	},

	_startDrag: function(e){
		if(!this.cover){
			this.cover = dojo.doc.createElement('div');
			dojo.addClass(this.cover, "dijitSplitterCover");
			dojo.place(this.cover, this.child.domNode, "after");
		}
		dojo.addClass(this.cover, "dijitSplitterCoverActive");

		// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
		if(this.fake){ dojo.destroy(this.fake); }
		if(!(this._resize = this.live)){ //TODO: disable live for IE6?
			// create fake splitter to display at old position while we drag
			(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
			dojo.addClass(this.domNode, "dijitSplitterShadow");
			dojo.place(this.fake, this.domNode, "after");
		}
		dojo.addClass(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
		if(this.fake){
			dojo.removeClass(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
		}

		//Performance: load data info local vars for onmousevent function closure
		var factor = this._factor,
			isHorizontal = this.horizontal,
			axis = isHorizontal ? "pageY" : "pageX",
			pageStart = e[axis],
			splitterStyle = this.domNode.style,
			dim = isHorizontal ? 'h' : 'w',
			childStart = dojo.marginBox(this.child.domNode)[dim],
			max = this._computeMaxSize(),
			min = this.child.minSize || 20,
			region = this.region,
			splitterAttr = region == "top" || region == "bottom" ? "top" : "left",	// style attribute of splitter to adjust
			splitterStart = parseInt(splitterStyle[splitterAttr], 10),
			resize = this._resize,
			layoutFunc = dojo.hitch(this.container, "_layoutChildren", this.child.id),
			de = dojo.doc;

		this._handlers = (this._handlers || []).concat([
			dojo.connect(de, "onmousemove", this._drag = function(e, forceResize){
				var delta = e[axis] - pageStart,
					childSize = factor * delta + childStart,
					boundChildSize = Math.max(Math.min(childSize, max), min);

				if(resize || forceResize){
					layoutFunc(boundChildSize);
				}
				// TODO: setting style directly (usually) sets content box size, need to set margin box size
				splitterStyle[splitterAttr] = delta + splitterStart + factor*(boundChildSize - childSize) + "px";
			}),
			dojo.connect(de, "ondragstart", dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent),
			dojo.connect(de, "onmouseup", this, "_stopDrag")
		]);
		dojo.stopEvent(e);
	},

	_onMouse: function(e){
		var o = (e.type == "mouseover" || e.type == "mouseenter");
		dojo.toggleClass(this.domNode, "dijitSplitterHover", o);
		dojo.toggleClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
	},

	_stopDrag: function(e){
		try{
			if(this.cover){
				dojo.removeClass(this.cover, "dijitSplitterCoverActive");
			}
			if(this.fake){ dojo.destroy(this.fake); }
			dojo.removeClass(this.domNode, "dijitSplitterActive dijitSplitter"
				+ (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
			this._drag(e); //TODO: redundant with onmousemove?
			this._drag(e, true);
		}finally{
			this._cleanupHandlers();
			delete this._drag;
		}

		if(this.container.persist){
			dojo.cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires:365});
		}
	},

	_cleanupHandlers: function(){
		dojo.forEach(this._handlers, dojo.disconnect);
		delete this._handlers;
	},

	_onKeyPress: function(/*Event*/ e){
		// should we apply typematic to this?
		this._resize = true;
		var horizontal = this.horizontal;
		var tick = 1;
		var dk = dojo.keys;
		switch(e.charOrCode){
			case horizontal ? dk.UP_ARROW : dk.LEFT_ARROW:
				tick *= -1;
//				break;
			case horizontal ? dk.DOWN_ARROW : dk.RIGHT_ARROW:
				break;
			default:
//				this.inherited(arguments);
				return;
		}
		var childSize = dojo._getMarginSize(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
		this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
		dojo.stopEvent(e);
	},

	destroy: function(){
		this._cleanupHandlers();
		delete this.child;
		delete this.container;
		delete this.cover;
		delete this.fake;
		this.inherited(arguments);
	}
});

dojo.declare("dijit.layout._Gutter", [dijit._Widget, dijit._Templated],
{
	// summary:
	// 		Just a spacer div to separate side pane from center pane.
	//		Basically a trick to lookup the gutter/splitter width from the theme.
	// description:
	//		Instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create directly.
	// tags:
	//		private

	templateString: '<div class="dijitGutter" role="presentation"></div>',

	postMixInProperties: function(){
		this.inherited(arguments);
		this.horizontal = /top|bottom/.test(this.region);
	},

	buildRendering: function(){
		this.inherited(arguments);
		dojo.addClass(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
	}
});

}

if(!dojo._hasResource["dijit.layout._ContentPaneResizeMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._ContentPaneResizeMixin"] = true;
dojo.provide("dijit.layout._ContentPaneResizeMixin");




dojo.declare("dijit.layout._ContentPaneResizeMixin", null, {
	// summary:
	//		Resize() functionality of ContentPane.   If there's a single layout widget
	//		child then it will call resize() with the same dimensions as the ContentPane.
	//		Otherwise just calls resize on each child.
	//
	//		Also implements basic startup() functionality, where starting the parent
	//		will start the children

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// isContainer: [protected] Boolean
	//		Indicates that this widget acts as a "parent" to the descendant widgets.
	//		When the parent is started it will call startup() on the child widgets.
	//		See also `isLayoutContainer`.
	isContainer: true,

	// isLayoutContainer: [protected] Boolean
	//		Indicates that this widget will call resize() on it's child widgets
	//		when they become visible.
	isLayoutContainer: true,

	_startChildren: function(){
		// summary:
		//		Call startup() on all children including non _Widget ones like dojo.dnd.Source objects

		// This starts all the widgets
		dojo.forEach(this.getChildren(), function(child){
			child.startup();
			child._started = true;
		});
	},

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		if(this._started){ return; }

		var parent = dijit._Contained.prototype.getParent.call(this);
		this._childOfLayoutWidget = parent && parent.isLayoutContainer;

		// I need to call resize() on my child/children (when I become visible), unless
		// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
		this._needLayout = !this._childOfLayoutWidget;

		this.inherited(arguments);

		this._startChildren();

		if(this._isShown()){
			this._onShow();
		}

		if(!this._childOfLayoutWidget){
			// If my parent isn't a layout container, since my style *may be* width=height=100%
			// or something similar (either set directly or via a CSS class),
			// monitor when my size changes so that I can re-layout.
			// For browsers where I can't directly monitor when my size changes,
			// monitor when the viewport changes size, which *may* indicate a size change for me.
			this.connect(dojo.isIE ? this.domNode : dojo.global, 'onresize', function(){
				// Using function(){} closure to ensure no arguments to resize.
				this._needLayout = !this._childOfLayoutWidget;
				this.resize();
			});
		}
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propagate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = dojo.query("> *", this.containerNode).filter(function(node){
				return node.tagName !== "SCRIPT"; // or a regexp for hidden elements like script|area|map|etc..
			}),
			childWidgetNodes = childNodes.filter(function(node){
				return dojo.hasAttr(node, "data-dojo-type") || dojo.hasAttr(node, "dojoType") || dojo.hasAttr(node, "widgetId");
			}),
			candidateWidgets = dojo.filter(childWidgetNodes.map(dijit.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}

		// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
		dojo.toggleClass(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
	},

	resize: function(changeSize, resultSize){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
		// never called, so resize() is our trigger to do the initial href download (see [20099]).
		// However, don't load href for closed TitlePanes.
		if(!this._wasShown && this.open !== false){
			this._onShow();
		}

		this._resizeCalled = true;

		this._scheduleLayout(changeSize, resultSize);
	},

	_scheduleLayout: function(changeSize, resultSize){
		// summary:
		//		Resize myself, and call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layout(changeSize, resultSize);
		}else{
			this._needLayout = true;
			this._changeSize = changeSize;
			this._resultSize = resultSize;
		}
	},

	_layout: function(changeSize, resultSize){
		// summary:
		//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
		//		Also, since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		//
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from set('content', ...))... but deferred until
		//		the ContentPane is visible

		// Set margin box size, unless it wasn't specified, in which case use current size.
		if(changeSize){
			dojo.marginBox(this.domNode, changeSize);
		}

		// Compute content box size of containerNode in case we [later] need to size our single child.
		var cn = this.containerNode;
		if(cn === this.domNode){
			// If changeSize or resultSize was passed to this method and this.containerNode ==
			// this.domNode then we can compute the content-box size without querying the node,
			// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {}); // changeSize overrides resultSize
			if(!("h" in mb) || !("w" in mb)){
				mb = dojo.mixin(dojo.marginBox(cn), mb); // just use dojo.marginBox() to fill in missing values
			}
			this._contentBox = dijit.layout.marginBox2contentBox(cn, mb);
		}else{
			this._contentBox = dojo.contentBox(cn);
		}

		this._layoutChildren();

		delete this._needLayout;
	},
	
	_layoutChildren: function(){
		// Call _checkIfSingleChild() again in case app has manually mucked w/the content
		// of the ContentPane (rather than changing it through the set("content", ...) API.
		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || dojo.contentBox(this.containerNode);

			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			dojo.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown.
		// description:
		//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
		//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
		//		tree every call, and at least solves the performance problem on page load by deferring loading
		//		hidden ContentPanes until they are first shown

		if(this._childOfLayoutWidget){
			// If we are TitlePane, etc - we return that only *IF* we've been resized
			if(this._resizeCalled && "open" in this){
				return this.open;
			}
			return this._resizeCalled;
		}else if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			var node = this.domNode, parent = this.domNode.parentNode;
			return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !dojo.hasClass(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does layout/resize of child widget(s)

		if(this._needLayout){
			// If a layout has been scheduled for when we become visible, do it now
			this._layout(this._changeSize, this._resultSize);
		}

		this.inherited(arguments);

		// Need to keep track of whether ContentPane has been shown (which is different than
		// whether or not it's currently visible).
		this._wasShown = true;
	}
});

}

if(!dojo._hasResource["dojo.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.html"] = true;
dojo.provide("dojo.html");


dojo.getObject("html", true, dojo);

// the parser might be needed..
(function(){ // private scope, sort of a namespace

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0,
		d = dojo;
	
	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		//
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = dojo.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont){
		// summary:
		//		inserts the given content into the given node
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element.
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
		
		// always empty
		d.empty(node);

		if(cont) {
			if(typeof cont == "string") {
				cont = d._toDom(cont, node.ownerDocument);
			}
			if(!cont.nodeType && d.isArrayLike(cont)) {
				// handle as enumerable, but it may shrink as we enumerate it
				for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0) {
					d.place( cont[i], node, "last");
				}
			} else {
				// pass nodes, documentFragments and unknowns through to dojo.place
				d.place(cont, node, "last");
			}
		}

		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	dojo.declare("dojo.html._ContentSetter", null,
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",
			
			// id: String?
			//		Usually only used internally, and auto-generated with each instance
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,
			
			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,

			// parserScope: String
			//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
			//		will search for data-dojo-type (or dojoType).  For backwards compatibility
			//		reasons defaults to dojo._scopeName (which is "dojo" except when
			//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			parserScope: dojo._scopeName,

			// startup: Boolean
			//		Start the child widgets after parsing them.   Only obeyed if parseContent is true.
			startup: true,
			
			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..
 
				// the original params are mixed directly into the instance "this"
				dojo.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dojo.byId( this.node || node );
	
				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "",
						idCounter++
					].join("_");
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node

				var node = this.node;
				if(!node) {
				    // can't proceed
					throw new Error(this.declaredClass + ": setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
	
					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e);
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},
			
			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					dojo.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},
	
			onBegin: function(){
				// summary
				//		Called after instantiation, but before set();
				//		It allows modification of any of the object properties
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to
				//		optionally pre-process html string content
				var cont = this.content;
	
				if(dojo.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}
  
					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();
				
				this.content = cont;
				return this.node; /* DomNode */
			},
	
			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},
	
			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically.
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults;
				delete this.node;
				delete this.content;
			},
  
			onContentError: function(err){
				return "Error occured setting content: " + err;
			},
			
			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key];
				}
			},
			_parse: function(){
				// summary:
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					var inherited = {};
					dojo.forEach(["dir", "lang", "textDir"], function(name){
						if(this[name]){
							inherited[name] = this[name];
						}
					}, this);
					this.parseResults = dojo.parser.parse({
						rootNode: rootNode,
						noStart: !this.startup,
						inherited: inherited,
						scope: this.parserScope
					});
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},
  
			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//		dojo.html.set(node, "some string");
			//		dojo.html.set(node, contentNode, {options});
			//		dojo.html.set(node, myNode.childNodes, {options});
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(dojo.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};
})();

}

if(!dojo._hasResource["dijit.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ContentPane"] = true;
dojo.provide("dijit.layout.ContentPane");







dojo.declare(
	"dijit.layout.ContentPane", [dijit._Widget, dijit.layout._ContentPaneResizeMixin],
{
	// summary:
	//		A widget containing an HTML fragment, specified inline
	//		or by uri.  Fragment may include widgets.
	//
	// description:
	//		This widget embeds a document fragment in the page, specified
	//		either by uri, javascript generated markup or DOM reference.
	//		Any widgets within this content are instantiated and managed,
	//		but laid out according to the HTML structure.  Unlike IFRAME,
	//		ContentPane embeds a document fragment as would be found
	//		inside the BODY tag of a full HTML document.  It should not
	//		contain the HTML, HEAD, or BODY tags.
	//		For more advanced functionality with scripts and
	//		stylesheets, see dojox.layout.ContentPane.  This widget may be
	//		used stand alone or as a base class for other widgets.
	//		ContentPane is useful as a child of other layout containers
	//		such as BorderContainer or TabContainer, but note that those
	//		widgets can contain any widget as a child.
	//
	// example:
	//		Some quick samples:
	//		To change the innerHTML: cp.set('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList: cp.set('content', dojo.query('div [class=selected]', userSelection))
	//
	//		To do an ajax update: cp.set('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.  (Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; Use set('href', ...);
	href: "",

/*=====
	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to set("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",
=====*/

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad: true,

	// parserScope: String
	//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
	//		will search for data-dojo-type (or dojoType).  For backwards compatibility
	//		reasons defaults to dojo._scopeName (which is "dojo" except when
	//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
	parserScope: dojo._scopeName,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache: false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'>${loadingState}</span>",

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'>${errorState}</span>",

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via set('content', ...) / set('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div dojoType="dijit.layout.ContentPane" href="./bar" ioArgs="{timeout: 500}">
	ioArgs: {},

	// onLoadDeferred: [readonly] dojo.Deferred
	//		This is the `dojo.Deferred` returned by set('href', ...) and refresh().
	//		Calling onLoadDeferred.addCallback() or addErrback() registers your
	//		callback to be called only once, when the prior set('href', ...) call or
	//		the initial href parameter to the constructor finishes loading.
	//
	//		This is different than an onLoad() handler which gets called any time any href
	//		or content is loaded.
	onLoadDeferred: null,

	// Override _Widget's attributeMap because we don't want the title attribute (used to specify
	// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
	// entire pane.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		title: []
	}),

	// Flag to parser that I'll parse my contents, so it shouldn't.
	stopParser: true,

	// template: [private] Boolean
	//		Flag from the parser that this ContentPane is inside a template
	//		so the contents are pre-parsed.
	// (TODO: this declaration can be commented out in 2.0)
	template: false,

	create: function(params, srcNodeRef){
		// Convert a srcNodeRef argument into a content parameter, so that the original contents are
		// processed in the same way as contents set via set("content", ...), calling the parser etc.
		// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.
		if((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)){
			var df = dojo.doc.createDocumentFragment();
			srcNodeRef = dojo.byId(srcNodeRef)
			while(srcNodeRef.firstChild){
				df.appendChild(srcNodeRef.firstChild);
			}
			params = dojo.delegate(params, {content: df});
		}
		this.inherited(arguments, [params, srcNodeRef]);
	},

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
		this.errorMessage = dojo.string.substitute(this.errorMessage, messages);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.
		// For subclasses of ContentPane that do have a template, does nothing.
		if(!this.containerNode){
			this.containerNode = this.domNode;
		}

		// remove the title attribute so it doesn't show up when hovering
		// over a node  (TODO: remove in 2.0, no longer needed after #11490)
		this.domNode.title = "";

		if(!dojo.attr(this.domNode,"role")){
			dijit.setWaiRole(this.domNode, "group");
		}
	},

	_startChildren: function(){
		// summary:
		//		Call startup() on all children including non _Widget ones like dojo.dnd.Source objects

		// This starts all the widgets
		this.inherited(arguments);

		// And this catches stuff like dojo.dnd.Source
		if(this._contentSetter){
			dojo.forEach(this._contentSetter.parseResults, function(obj){
				if(!obj._started && !obj._destroyed && dojo.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			}, this);
		}
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use set('href', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
		return this.set("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so set("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(dojo.hitch(this, "onLoad"));

		this._set("href", href);

		// _setHrefAttr() is called during creation and by the user, after creation.
		// Assuming preload == false, only in the second case do we actually load the URL;
		// otherwise it's done in startup(), and only if this widget is shown.
		if(this.preload || (this._created && this._isShown())){
			this._load();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}

		return this.onLoadDeferred;		// dojo.Deferred
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use set('content', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
		this.set("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make set("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this._set("href", "");

		// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		// Even though user is just setting content directly, still need to define an onLoadDeferred
		// because the _onLoadHandler() handler is still getting called from setContent()
		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		if(this._created){
			// For back-compat reasons, call onLoad() for set('content', ...)
			// calls but not for content specified in srcNodeRef (ie: <div dojoType=ContentPane>...</div>)
			// or as initialization parameter (ie: new ContentPane({content: ...})
			this.onLoadDeferred.addCallback(dojo.hitch(this, "onLoad"));
		}

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a set('content') not a set('href')

		return this.onLoadDeferred; 	// dojo.Deferred
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make get("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect

		this.onLoadDeferred = null;
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
		this.inherited(arguments);
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this.inherited(arguments);
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does necessary processing, including href download and layout/resize of
		//		child widget(s)

		this.inherited(arguments);

		if(this.href){
			if(!this._xhrDfd && // if there's an href that isn't already being loaded
				(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
			){
				return this.refresh();	// If child has an href, promise that fires when the load is complete
			}
		}
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// Cancel possible prior in-flight request
		this.cancel();

		this.onLoadDeferred = new dojo.Deferred(dojo.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(dojo.hitch(this, "onLoad"));
		this._load();
		return this.onLoadDeferred;		// If child has an href, promise that fires when refresh is complete
	},

	_load: function(){
		// summary:
		//		Load/reload the href specified in this.href

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(dojo.isObject(this.ioArgs)){
			dojo.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || dojo.xhrGet)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});

		// Remove flag saying that a load is needed
		delete this._hrefChanged;
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this._set("isLoaded", true);
		try{
			this.onLoadDeferred.callback(data);
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this._set("isLoaded", false);
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			dojo.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == dojo.body()){
					widget.destroyRecursive();
				}
			});
			delete setter.parseResults;
		}

		// And then clear away all the DOM nodes
		dojo.html._emptyNode(this.containerNode);

		// Delete any state information we have about current contents
		delete this._singleChild;
	},

	_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){
		// summary:
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// dojo.html.set will take care of the rest of the details
		// we provide an override for the error handling to ensure the widget gets the errors
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property,
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter;
		if(! (setter && setter instanceof dojo.html._ContentSetter)){
			setter = this._contentSetter = new dojo.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		var setterParams = dojo.mixin({
			cleanContent: this.cleanContent,
			extractContent: this.extractContent,
			parseContent: this.parseOnLoad,
			parserScope: this.parserScope,
			startup: false,
			dir: this.dir,
			lang: this.lang
		}, this._contentSetterParams || {});

		setter.set( (dojo.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(!isFakeContent){
			if(this._started){
				// Startup each top level child widget (and they will start their children, recursively)
				this._startChildren();
	
				// Call resize() on each of my child layout widgets,
				// or resize() on my single child layout widget...
				// either now (if I'm currently visible) or when I become visible
				this._scheduleLayout();
			}

			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		this.onLoadDeferred.errback(err);

		// shows user the string that is returned by on[type]Error
		// override on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},

	// EVENT's, should be overide-able
	onLoad: function(data){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ error){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ error){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

}

if(!dojo._hasResource["dijit._KeyNavContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._KeyNavContainer"] = true;
dojo.provide("dijit._KeyNavContainer");



dojo.declare("dijit._KeyNavContainer",
	dijit._Container,
	{

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate() and call startupKeyNavChildren() in startup().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.
/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		_keyNavCodes: {},

		connectKeyNavHandlers: function(/*dojo.keys[]*/ prevKeyCodes, /*dojo.keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: dojo.keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: dojo.keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			var keyCodes = (this._keyNavCodes = {});
			var prev = dojo.hitch(this, this.focusPrev);
			var next = dojo.hitch(this, this.focusNext);
			dojo.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			dojo.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			keyCodes[dojo.keys.HOME] = dojo.hitch(this, "focusFirstChild");
			keyCodes[dojo.keys.END] = dojo.hitch(this, "focusLastChild");
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			// summary:
			//		Call in startup() to set child tabindexes to -1
			// tags:
			//		protected
			dojo.forEach(this.getChildren(), dojo.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Add a child to our _Container
			dijit._KeyNavContainer.superclass.addChild.apply(this, arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			var child = this._getFirstFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected
			var child = this._getLastFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			this.focusChild(child);
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			this.focusChild(child, true);
		},

		focusChild: function(/*dijit._Widget*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected
			
			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focs
			widget.focus(last ? "end" : "start");
			this._set("focusedChild", widget);
		},

		_startupChild: function(/*dijit._Widget*/ widget){
			// summary:
			//		Setup for each child widget
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			// tags:
			//		private
			
			widget.set("tabIndex", "-1");
			
			this.connect(widget, "_onFocus", function(){
				// Set valid tabIndex so tabbing away from widget goes to right place, see #10272
				widget.set("tabIndex", this.tabIndex);
			});
			this.connect(widget, "_onBlur", function(){
				widget.set("tabIndex", "-1");
			});
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)

			// focus bubbles on Firefox,
			// so just make sure that focus has really gone to the container
			if(evt.target !== this.domNode){ return; }

			this.focusFirstChild();

			// and then set the container's tabIndex to -1,
			// (don't remove as that breaks Safari 4)
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			dojo.attr(this.domNode, "tabIndex", "-1");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				dojo.attr(this.domNode, "tabIndex", this.tabIndex);
			}
			this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				dojo.stopEvent(evt);
			}
		},

		_onChildBlur: function(/*dijit._Widget*/ widget){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);	// dijit._Widget
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused
			return this._getNextFocusableChild(null, -1);	// dijit._Widget
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;	// dijit._Widget
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;	// dijit._Widget
		}
	}
);

}

if(!dojo._hasResource["dijit._CssStateMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._CssStateMixin"] = true;
dojo.provide("dijit._CssStateMixin");


dojo.declare("dijit._CssStateMixin", [], {
	// summary:
	//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
	//		state changes, and also higher-level state changes such becoming disabled or selected.
	//
	// description:
	//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
	//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	//
	//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
	//
	//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	//		within the widget).

	// cssStateNodes: [protected] Object
	//		List of sub-nodes within the widget that need CSS classes applied on mouse hover/press and focus
	//.
	//		Each entry in the hash is a an attachpoint names (like "upArrowButton") mapped to a CSS class names
	//		(like "dijitUpArrowButton"). Example:
	//	|		{
	//	|			"upArrowButton": "dijitUpArrowButton",
	//	|			"downArrowButton": "dijitDownArrowButton"
	//	|		}
	//		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
	//		is hovered, etc.
	cssStateNodes: {},

	// hovering: [readonly] Boolean
	//		True if cursor is over this widget
	hovering: false,
	
	// active: [readonly] Boolean
	//		True if mouse was pressed while over this widget, and hasn't been released yet
	active: false,

	_applyAttributes: function(){
		// This code would typically be in postCreate(), but putting in _applyAttributes() for
		// performance: so the class changes happen before DOM is inserted into the document.
		// Change back to postCreate() in 2.0.  See #11635.

		this.inherited(arguments);

		// Automatically monitor mouse events (essentially :hover and :active) on this.domNode
		dojo.forEach(["onmouseenter", "onmouseleave", "onmousedown"], function(e){
			this.connect(this.domNode, e, "_cssMouseEvent");
		}, this);
		
		// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
		dojo.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active"], function(attr){
			this.watch(attr, dojo.hitch(this, "_setStateClass"));
		}, this);

		// Events on sub nodes within the widget
		for(var ap in this.cssStateNodes){
			this._trackMouseState(this[ap], this.cssStateNodes[ap]);
		}
		// Set state initially; there's probably no hover/active/focus state but widget might be
		// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
		this._setStateClass();
	},

	_cssMouseEvent: function(/*Event*/ event){
		// summary:
		//	Sets hovering and active properties depending on mouse state,
		//	which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":	// generated on non-IE browsers even though we connected to mouseenter
					this._set("hovering", true);
					this._set("active", this._mouseDown);
					break;

				case "mouseleave":
				case "mouseout":	// generated on non-IE browsers even though we connected to mouseleave
					this._set("hovering", false);
					this._set("active", false);
					break;

				case "mousedown" :
					this._set("active", true);
					this._mouseDown = true;
					// Set a global event to handle mouseup, so it fires properly
					// even if the cursor leaves this.domNode before the mouse up event.
					// Alternately could set active=false on mouseout.
					var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
						this._mouseDown = false;
						this._set("active", false);
						this.disconnect(mouseUpConnector);
					});
					break;
			}
		}
	},

	_setStateClass: function(){
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(dojo.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(!this.isLeftToRight()){
			// For RTL mode we need to set an addition class like dijitTextBoxRtl.
			multiply("Rtl");
		}

		if(this.checked){
			multiply("Checked");
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else{
			if(this.active){
				multiply("Active");
			}else if(this.hovering){
				multiply("Hover");
			}
		}

		if(this._focused){
			multiply("Focused");
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		dojo.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			dojo.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		tn.className = newClasses.join(" ");

		this._stateClasses = newStateClasses;
	},

	_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
		// summary:
		//		Track mouse/focus events on specified node and set CSS class on that node to indicate
		//		current state.   Usually not called directly, but via cssStateNodes attribute.
		// description:
		//		Given class=foo, will set the following CSS class on the node
		//			- fooActive: if the user is currently pressing down the mouse button while over the node
		//			- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
		//			- fooFocus: if the node is focused
		//
		//		Note that it won't set any classes if the widget is disabled.
		// node: DomNode
		//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
		//		is handled specially and automatically just by mixing in this class.
		// clazz: String
		//		CSS class name (ex: dijitSliderUpArrow).

		// Current state of node (initially false)
		// NB: setting specifically to false because dojo.toggleClass() needs true boolean as third arg
		var hovering=false, active=false, focused=false;

		var self = this,
			cn = dojo.hitch(this, "connect", node);

		function setClass(){
			var disabled = ("disabled" in self && self.disabled) || ("readonly" in self && self.readonly);
			dojo.toggleClass(node, clazz+"Hover", hovering && !active && !disabled);
			dojo.toggleClass(node, clazz+"Active", active && !disabled);
			dojo.toggleClass(node, clazz+"Focused", focused && !disabled);
		}

		// Mouse
		cn("onmouseenter", function(){
			hovering = true;
			setClass();
		});
		cn("onmouseleave", function(){
			hovering = false;
			active = false;
			setClass();
		});
		cn("onmousedown", function(){
			active = true;
			setClass();
		});
		cn("onmouseup", function(){
			active = false;
			setClass();
		});

		// Focus
		cn("onfocus", function(){
			focused = true;
			setClass();
		});
		cn("onblur", function(){
			focused = false;
			setClass();
		});

		// Just in case widget is enabled/disabled while it has focus/hover/active state.
		// Maybe this is overkill.
		this.watch("disabled", setClass);
		this.watch("readOnly", setClass);
	}
});

}

if(!dojo._hasResource["dijit.MenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuItem"] = true;
dojo.provide("dijit.MenuItem");






dojo.declare("dijit.MenuItem",
		[dijit._Widget, dijit._Templated, dijit._Contained, dijit._CssStateMixin],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: dojo.cache("dijit", "templates/MenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\"/>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\"/>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n"),

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			label: { node: "containerNode", type: "innerHTML" },
			iconClass: { node: "iconNode", type: "class" }
		}),

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text
		label: '',

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "",

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id+"_text";
			dojo.attr(this.containerNode, "id", label);
			if(this.accelKeyNode){
				dojo.attr(this.accelKeyNode, "id", this.id + "_accel");
				label += " " + this.id + "_accel";
			}
			dijit.setWaiState(this.domNode, "labelledby", label);
			dojo.setSelectable(this.domNode, false);
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			this.getParent().onItemUnhover(this);

			// When menu is hidden (collapsed) due to clicking a MenuItem and having it execute,
			// FF and IE don't generate an onmouseout event for the MenuItem.
			// So, help out _CssStateMixin in this case.
			this._set("hovering", false);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			dojo.stopEvent(evt);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(dojo.isIE == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				dijit.focus(this.focusNode);
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);
			this.getParent()._onItemFocus(this);

			this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */

			dojo.toggleClass(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			dojo.attr(this.containerNode,'colSpan',value?"1":"2");
			
			this._set("accelKey", value);
		}
	});

}

if(!dojo._hasResource["dijit.PopupMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuItem"] = true;
dojo.provide("dijit.PopupMenuItem");



dojo.declare("dijit.PopupMenuItem",
		dijit.MenuItem,
		{
		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div dojoType="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = dojo.query("*", this.srcNodeRef);
				dijit.PopupMenuItem.superclass._fillContent.call(this, nodes[0]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to dojo.doc.body.
			if(!this.popup){
				var node = dojo.query("[widgetId]", this.dropDownContainer)[0];
				this.popup = dijit.byNode(node);
			}
			dojo.body().appendChild(this.popup.domNode);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				dojo.style(this.arrowWrapper, "visibility", "");
			}
			dijit.setWaiState(this.focusNode, "haspopup", "true");
		},

		destroyDescendants: function(){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive();
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.CheckedMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.CheckedMenuItem"] = true;
dojo.provide("dijit.CheckedMenuItem");



dojo.declare("dijit.CheckedMenuItem",
		dijit.MenuItem,
		{
		// summary:
		//		A checkbox-like menu item for toggling on and off

		templateString: dojo.cache("dijit", "templates/CheckedMenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" dojoAttachPoint=\"iconNode\"/>\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&nbsp;</td>\n</tr>\n"),

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			dojo.toggleClass(this.domNode, "dijitCheckedMenuItemChecked", checked);
			dijit.setWaiState(this.domNode, "checked", checked);
			this._set("checked", checked);
		},

		onChange: function(/*Boolean*/ checked){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.MenuSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuSeparator"] = true;
dojo.provide("dijit.MenuSeparator");





dojo.declare("dijit.MenuSeparator",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line between two menu items

		templateString: dojo.cache("dijit", "templates/MenuSeparator.html", "<tr class=\"dijitMenuSeparator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n"),

		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});

}

if(!dojo._hasResource["dijit.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Menu"] = true;
dojo.provide("dijit.Menu");










// "dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator" for Back-compat (TODO: remove in 2.0)

dojo.declare("dijit._MenuBase",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){ child.startup(); });
		this.startupKeyNavChildren();

		this.inherited(arguments);
	},

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.   In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ closeAll){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	_onPopupHover: function(/*Event*/ evt){
		// summary:
		//		This handler is called when the mouse moves over the popup.
		// tags:
		//		private

		// if the mouse hovers over a menu popup that is in pending-close state,
		// then stop the close operation.
		// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)
		if(this.currentPopup && this.currentPopup._pendingClose_timer){
			var parentMenu = this.currentPopup.parentMenu;
			// highlight the parent menu item pointing to this popup
			if(parentMenu.focusedChild){
				parentMenu.focusedChild._setSelected(false);
			}
			parentMenu.focusedChild = this.currentPopup.from_item;
			parentMenu.focusedChild._setSelected(true);
			// cancel the pending close
			this._stopPendingCloseTimer(this.currentPopup);
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(dojo.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
		// if the user is mixing mouse and keyboard navigation,
		// then the menu may not be active but a menu item has focus,
		// but it's not the item that the mouse just hovered over.
		// To avoid both keyboard and mouse selections, use the latest.
		if(this.focusedChild){
			this.focusChild(item);
		}
		this._hoveredChild = item;
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private
		this._stopPopupTimer();
		item._setSelected(false);
		// Close all popups that are open and descendants of this menu
		var itemPopup = item.popup;
		if(itemPopup){
			this._stopPendingCloseTimer(itemPopup);
			itemPopup._pendingClose_timer = setTimeout(function(){
				itemPopup._pendingClose_timer = null;
				if(itemPopup.parentMenu){
					itemPopup.parentMenu.currentPopup = null;
				}
				dijit.popup.close(itemPopup); // this calls onClose
			}, this.popupDelay);
		}
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected

		if(this.isActive){
			this._stopPopupTimer();
		}
		if(this._hoveredChild == item){ this._hoveredChild = null; }
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_stopPendingCloseTimer: function(/*dijit._Widget*/ popup){
		// summary:
		//		Cancels the pending-close timer because the close has been preempted
		// tags:
		//		private
		if(popup._pendingClose_timer){
			clearTimeout(popup._pendingClose_timer);
			popup._pendingClose_timer = null;
		}
	},

	_stopFocusTimer: function(){
		// summary:
		//		Cancels the pending-focus timer because the menu was closed before focus occured
		// tags:
		//		private
		if(this._focus_timer){
			clearTimeout(this._focus_timer);
			this._focus_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private

		// this can't be done in _onFocus since the _onFocus events occurs asynchronously
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
			this._markActive();
		}

		this.focusChild(item);

		if(item.disabled){ return false; }

		if(item.popup){
			this._openPopup();
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		if(!from_item){ return; } // the focused child lost focus since the timer was started
		var popup = from_item.popup;
		if(popup.isShowingNow){ return; }
		if(this.currentPopup){
			this._stopPendingCloseTimer(this.currentPopup);
			dijit.popup.close(this.currentPopup);
		}
		popup.parentMenu = this;
		popup.from_item = from_item; // helps finding the parent item that should be focused for this popup
		var self = this;
		dijit.popup.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || (this.isLeftToRight() ?
									{'TR': 'TL', 'TL': 'TR', 'BR': 'BL', 'BL': 'BR'} :
									{'TL': 'TR', 'TR': 'TL', 'BL': 'BR', 'BR': 'BL'}),
			onCancel: function(){ // called when the child menu is canceled
				// set isActive=false (_closeChild vs _cleanUp) so that subsequent hovering will NOT open child menus
				// which seems aligned with the UX of most applications (e.g. notepad, wordpad, paint shop pro)
				self.focusChild(from_item);	// put focus back on my node
				self._cleanUp();			// close the submenu (be sure this is done _after_ focus is moved)
				from_item._setSelected(true); // oops, _cleanUp() deselected the item
				self.focusedChild = from_item;	// and unset focusedChild
			},
			onExecute: dojo.hitch(this, "_cleanUp")
		});

		this.currentPopup = popup;
		// detect mouseovers to handle lazy mouse movements that temporarily focus other menu items
		popup.connect(popup.domNode, "onmouseenter", dojo.hitch(self, "_onPopupHover")); // cleaned up when the popped-up widget is destroyed on close

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.   Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			popup._focus_timer = setTimeout(dojo.hitch(popup, function(){
				this._focus_timer = null;
				this.focus();
			}), 0);
		}
	},

	_markActive: function(){
		// summary:
		//              Mark this menu's state as active.
		//		Called when this Menu gets focus from:
		//			1) clicking it (mouse or via space/arrow key)
		//			2) being opened by a parent menu.
		//		This is not called just from mouse hover.
		//		Focusing a menu via TAB does NOT automatically set isActive
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar
		//		menus (similar to TAB navigation) but the menu is not active
		//		(ie no dropdown) until an item is clicked.
		this.isActive = true;
		dojo.replaceClass(this.domNode, "dijitMenuActive", "dijitMenuPassive");
	},

	onOpen: function(/*Event*/ e){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
		this._markActive();
	},

	_markInactive: function(){
		// summary:
		//		Mark this menu's state as inactive.
		this.isActive = false; // don't do this in _onBlur since the state is pending-close until we get here
		dojo.replaceClass(this.domNode, "dijitMenuPassive", "dijitMenuActive");
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopFocusTimer();
		this._markInactive();
		this.isShowingNow = false;
		this.parentMenu = null;
	},

	_closeChild: function(){
		// summary:
		//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
		// tags:
		//		private
		this._stopPopupTimer();

		var fromItem = this.focusedChild && this.focusedChild.from_item;

		if(this.currentPopup){
			// If focus is on my child menu then move focus to me,
			// because IE doesn't like it when you display:none a node with focus
			if(dijit._curFocus && dojo.isDescendant(dijit._curFocus, this.currentPopup.domNode)){
				this.focusedChild.focusNode.focus();
			}
			// Close all popups that are open and descendants of this menu
			dijit.popup.close(this.currentPopup);
			this.currentPopup = null;
		}

		if(this.focusedChild){ // unhighlight the focused item
			this.focusedChild._setSelected(false);
			this.focusedChild._onUnhover();
			this.focusedChild = null;
		}
	},

	_onItemFocus: function(/*MenuItem*/ item){
		// summary:
		//		Called when child of this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		if(this._hoveredChild && this._hoveredChild != item){
			this._hoveredChild._onUnhover(); // any previous mouse movement is trumped by focus selection
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this._cleanUp();
		this.inherited(arguments);
	},

	_cleanUp: function(){
		// summary:
		//		Called when the user is done with this menu.  Closes hierarchy of menus.
		// tags:
		//		private

		this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
			this._markInactive();
		}
	}
});

dojo.declare("dijit.Menu",
	dijit._MenuBase,
	{
	// summary
	//		A context menu you can assign to multiple elements

	// TODO: most of the code in here is just for context menu (right-click menu)
	// support.  In retrospect that should have been a separate class (dijit.ContextMenu).
	// Split them for 2.0

	constructor: function(){
		this._bindings = [];
	},

	templateString: dojo.cache("dijit", "templates/Menu.html", "<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" dojoAttachPoint=\"containerNode\"></tbody>\n</table>\n"),

	baseClass: "dijitMenu",

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similiar to a file menu.
	leftClickToOpen: false,

	// refocus: Boolean
	// 		When this menu closes, re-focus the element which had focus before it was opened.
	refocus: true,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(dojo.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later set('targetNodeIds', ...) call.   There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			dojo.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		var k = dojo.keys, l = this.isLeftToRight();
		this._openSubMenuKey = l ? k.RIGHT_ARROW : k.LEFT_ARROW;
		this._closeSubMenuKey = l ? k.LEFT_ARROW : k.RIGHT_ARROW;
		this.connectKeyNavHandlers([k.UP_ARROW], [k.DOWN_ARROW]);
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case this._openSubMenuKey:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
				break;
			case this._closeSubMenuKey:
				if(this.parentMenu){
					if(this.parentMenu._isMenuBar){
						this.parentMenu.focusPrev();
					}else{
						this.onCancel(false);
					}
				}else{
					dojo.stopEvent(evt);
				}
				break;
		}
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		var win = dojo.window.get(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && dojo.doc.frames[iframe_el.name]) || null;
		return win;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		var doc = iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && dojo.doc.frames[iframe_el.name] && dojo.doc.frames[iframe_el.name].document)
			|| null;
		return doc;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dojo.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.   Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				win = this._iframeContentWindow(iframe);
			cn = dojo.withGlobal(win, dojo.body);
		}else{
			
			// To capture these events at the top level, attach to <html>, not <body>.
			// Otherwise right-click context menu just doesn't work.
			cn = (node == dojo.body() ? dojo.doc.documentElement : node);
		}


		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: node,
			iframe: iframe
		};

		// Save info about binding in _bindings[], and make node itself record index(+1) into
		// _bindings[] array.   Prefix w/_dijitMenu to avoid setting an attribute that may
		// start with a number, which fails on FF/safari.
		dojo.attr(node, "_dijitMenu" + this.id, this._bindings.push(binding));

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
		// we need to monitor keyboard events in addition to the oncontextmenu event.
		var doConnects = dojo.hitch(this, function(cn){
			return [
				// TODO: when leftClickToOpen is true then shouldn't space/enter key trigger the menu,
				// rather than shift-F10?
				dojo.connect(cn, this.leftClickToOpen ? "onclick" : "oncontextmenu", this, function(evt){
					// Schedule context menu to be opened unless it's already been scheduled from onkeydown handler
					dojo.stopEvent(evt);
					this._scheduleOpen(evt.target, iframe, {x: evt.pageX, y: evt.pageY});
				}),
				dojo.connect(cn, "onkeydown", this, function(evt){
					if(evt.shiftKey && evt.keyCode == dojo.keys.F10){
						dojo.stopEvent(evt);
						this._scheduleOpen(evt.target, iframe);	// no coords - open near target node
					}
				})
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use dojo.connect(), see #9609.

			binding.onloadHandler = dojo.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var win = this._iframeContentWindow(iframe);
					cn = dojo.withGlobal(win, dojo.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try{
			node = dojo.byId(nodeName);
		}catch(e){
			// On IE the dojo.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
		var attrName = "_dijitMenu" + this.id;
		if(node && dojo.hasAttr(node, attrName)){
			var bid = dojo.attr(node, attrName)-1, b = this._bindings[bid];
			dojo.forEach(b.connects, dojo.disconnect);

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			dojo.removeAttr(node, attrName);
			delete this._bindings[bid];
		}
	},

	_scheduleOpen: function(/*DomNode?*/ target, /*DomNode?*/ iframe, /*Object?*/ coords){
		// summary:
		//		Set timer to display myself.  Using a timer rather than displaying immediately solves
		//		two problems:
		//
		//		1. IE: without the delay, focus work in "open" causes the system
		//		context menu to appear in spite of stopEvent.
		//
		//		2. Avoid double-shows on linux, where shift-F10 generates an oncontextmenu event
		//		even after a dojo.stopEvent(e).  (Shift-F10 on windows doesn't generate the
		//		oncontextmenu event.)

		if(!this._openTimer){
			this._openTimer = setTimeout(dojo.hitch(this, function(){
				delete this._openTimer;
				this._openMyself({
					target: target,
					iframe: iframe,
					coords: coords
				});
			}), 1);
		}
	},

	_openMyself: function(args){
		// summary:
		//		Internal function for opening myself when the user does a right-click or something similar.
		// args:
		//		This is an Object containing:
		//		* target:
		//			The node that is being clicked
		//		* iframe:
		//			If an <iframe> is being clicked, iframe points to that iframe
		//		* coords:
		//			Put menu at specified x/y position in viewport, or if iframe is
		//			specified, then relative to iframe.
		//
		//		_openMyself() formerly took the event object, and since various code references
		//		evt.target (after connecting to _openMyself()), using an Object for parameters
		//		(so that old code still works).

		var target = args.target,
			iframe = args.iframe,
			coords = args.coords;

		// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
		// then near the node the menu is assigned to.
		if(coords){
			if(iframe){
				// Specified coordinates are on <body> node of an <iframe>, convert to match main document
				var od = target.ownerDocument,
					ifc = dojo.position(iframe, true),
					win = this._iframeContentWindow(iframe),
					scroll = dojo.withGlobal(win, "_docScroll", dojo);
	
				var cs = dojo.getComputedStyle(iframe),
					tp = dojo._toPixelValue,
					left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0),
					top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0);

				coords.x += ifc.x + left - scroll.x;
				coords.y += ifc.y + top - scroll.y;
			}
		}else{
			coords = dojo.position(target, true);
			coords.x += 10;
			coords.y += 10;
		}

		var self=this;
		var savedFocus = dijit.getFocus(this);
		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			if(self.refocus){
				dijit.focus(savedFocus);
			}
			dijit.popup.close(self);
		}
		dijit.popup.open({
			popup: this,
			x: coords.x,
			y: coords.y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			dijit.popup.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		dojo.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
}
);

}

if(!dojo._hasResource['bfree.widget.admin.AdminMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.admin.AdminMenu'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/09/11
 * Time: 10:42 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.admin.AdminMenu');




dojo.declare('bfree.widget.admin.AdminMenu', [dijit.Menu], {
    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    constructor: function(args){

    },

    onCommand: function(cmdId){

    },

    postCreate: function(){
        this.addChild(
            new dijit.MenuItem({
                label: 'Users',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconUser',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.USERS)
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Servers',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconAdmin',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.SERVERS)
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Accounts',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconLock',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.ACCOUNTS)
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Zones',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconEdit',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.ZONES)
            })
        );
    }

});


/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 07/12/11
 * Time: 9:10 AM
 * To change this template use File | Settings | File Templates.
 */

}

if(!dojo._hasResource["dijit.ToolbarSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ToolbarSeparator"] = true;
dojo.provide("dijit.ToolbarSeparator");




dojo.declare("dijit.ToolbarSeparator",
		[ dijit._Widget, dijit._Templated ],
		{
		// summary:
		//		A spacer between two `dijit.Toolbar` items
		templateString: '<div class="dijitToolbarSeparator dijitInline" role="presentation"></div>',
		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);
		},
		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}

	});

}

if(!dojo._hasResource["dijit.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Toolbar"] = true;
dojo.provide("dijit.Toolbar");






// Note: require of ToolbarSeparator is for back-compat, remove for 2.0

dojo.declare("dijit.Toolbar",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
	{
	// summary:
	//		A Toolbar widget, used to hold things like `dijit.Editor` buttons

	templateString:
		'<div class="dijit" role="toolbar" tabIndex="${tabIndex}" dojoAttachPoint="containerNode">' +
		//	'<table style="table-layout: fixed" class="dijitReset dijitToolbarTable">' + // factor out style
		//		'<tr class="dijitReset" dojoAttachPoint="containerNode"></tr>'+
		//	'</table>' +
		'</div>',

	baseClass: "dijitToolbar",

	postCreate: function(){
		this.inherited(arguments);

		this.connectKeyNavHandlers(
			this.isLeftToRight() ? [dojo.keys.LEFT_ARROW] : [dojo.keys.RIGHT_ARROW],
			this.isLeftToRight() ? [dojo.keys.RIGHT_ARROW] : [dojo.keys.LEFT_ARROW]
		);
	},

	startup: function(){
		if(this._started){ return; }

		this.startupKeyNavChildren();

		this.inherited(arguments);
	}
}
);

}

if(!dojo._hasResource["dijit.form._FormWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormWidget"] = true;
dojo.provide("dijit.form._FormWidget");






dojo.declare("dijit.form._FormWidget", [dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	// name: [const] String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// These mixins assume that the focus node is an INPUT, as many but not all _FormWidgets are.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		value: "focusNode",
		id: "focusNode",
		tabIndex: "focusNode",
		alt: "focusNode",
		title: "focusNode"
	}),

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
		// Regarding escaping, see heading "Attribute values" in
		// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
		this.nameAttrSetting = this.name ? ('name="' + this.name.replace(/'/g, "&quot;") + '"') : '';
		this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onmousedown", "_onMouseDown");
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this._set("disabled", value);
		dojo.attr(this.focusNode, 'disabled', value);
		if(this.valueNode){
			dojo.attr(this.valueNode, 'disabled', value);
		}
		dijit.setWaiState(this.focusNode, "disabled", value);

		if(value){
			// reset these, because after the domNode is disabled, we can no longer receive
			// mouse related events, see #4200
			this._set("hovering", false);
			this._set("active", false);

			// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
			var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex : "focusNode";
			dojo.forEach(dojo.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
				var node = this[attachPointName];
				// complex code because tabIndex=-1 on a <div> doesn't work on FF
				if(dojo.isWebKit || dijit.hasDefaultTabStop(node)){	// see #11064 about webkit bug
					node.setAttribute('tabIndex', "-1");
				}else{
					node.removeAttribute('tabIndex');
				}
			}, this);
		}else{
			if(this.tabIndex != ""){
				this.focusNode.setAttribute('tabIndex', this.tabIndex);
			}
		}
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.  Use set('disabled', ...) instead.
		dojo.deprecated("setDisabled("+disabled+") is deprecated. Use set('disabled',"+disabled+") instead.", "", "2.0");
		this.set('disabled', disabled);
	},

	_onFocus: function(e){
		if(this.scrollOnFocus){
			dojo.window.scrollIntoView(this.domNode);
		}
		this.inherited(arguments);
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.  Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && this.focusNode && (dojo.style(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		if(!this.disabled){
			dijit.focus(this.focusNode);
		}
	},

	compare: function(/*anything*/ val1, /*anything*/ val2){
		// summary:
		//		Compare 2 values (as returned by get('value') for this widget).
		// tags:
		//		protected
		if(typeof val1 == "number" && typeof val2 == "number"){
			return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
		}else if(val1 > val2){
			return 1;
		}else if(val1 < val2){
			return -1;
		}else{
			return 0;
		}
	},

	onChange: function(newValue){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private
		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		this._pendingOnChange = this._pendingOnChange
			|| (typeof newValue != typeof this._lastValueReported)
			|| (this.compare(newValue, this._lastValueReported) != 0);
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
			this._lastValueReported = newValue;
			this._pendingOnChange = false;
			if(this._onChangeActive){
				if(this._onChangeHandle){
					clearTimeout(this._onChangeHandle);
				}
				// setTimout allows hidden value processing to run and
				// also the onChange handler can safely adjust focus, etc
				this._onChangeHandle = setTimeout(dojo.hitch(this,
					function(){
						this._onChangeHandle = null;
						this.onChange(newValue);
					}), 0); // try to collapse multiple onChange's fired faster than can be processed
			}
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
	},

	destroy: function(){
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			clearTimeout(this._onChangeHandle);
			this.onChange(this._lastValueReported);
		}
		this.inherited(arguments);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.  Use set('value', ...) instead.
		dojo.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use set('value',"+value+") instead.", "", "2.0");
		this.set('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.  Use get('value') instead.
		dojo.deprecated(this.declaredClass+"::getValue() is deprecated. Use get('value') instead.", "", "2.0");
		return this.get('value');
	},
	
	_onMouseDown: function(e){
		// If user clicks on the button, even if the mouse is released outside of it,
		// this button should get focus (to mimics native browser buttons).
		// This is also needed on chrome because otherwise buttons won't get focus at all,
		// which leads to bizarre focus restore on Dialog close etc.
		if(!e.ctrlKey && dojo.mouseButtons.isLeft(e) && this.isFocusable()){ // !e.ctrlKey to ignore right-click on mac
			// Set a global event to handle mouseup, so it fires properly
			// even if the cursor leaves this.domNode before the mouse up event.
			var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
				if (this.isFocusable()) {
					this.focus();
				}
				this.disconnect(mouseUpConnector);
			});
		}
	}
});

dojo.declare("dijit.form._FormValueWidget", dijit.form._FormWidget,
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.  See #8484, #8660.
	// TODO: unclear what that {value: ""} is for; FormWidget.attributeMap copies value to focusNode,
	// so maybe {value: ""} is so the value *doesn't* get copied to focusNode?
	// Seems like we really want value removed from attributeMap altogether
	// (although there's no easy way to do that now)

	// readOnly: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "readOnly".
	//		Similar to disabled except readOnly form values are submitted.
	readOnly: false,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		value: "",
		readOnly: "focusNode"
	}),

	_setReadOnlyAttr: function(/*Boolean*/ value){
		dojo.attr(this.focusNode, 'readOnly', value);
		dijit.setWaiState(this.focusNode, "readonly", value);
		this._set("readOnly", value);
	},

	postCreate: function(){
		this.inherited(arguments);

		if(dojo.isIE < 9 || (dojo.isIE && dojo.isQuirks)){ // IE won't stop the event with keypress
			this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
		}
		// Update our reset value if it hasn't yet been set (because this.set()
		// is only called when there *is* a value)
		if(this._resetValue === undefined){
			this._lastValueReported = this._resetValue = this.value;
		}
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Hook so set('value', value) works.
		// description:
		//		Sets the value of the widget.
		//		If the value has changed, then fire onChange event, unless priorityChange
		//		is specified as null (or false?)
		this._handleOnChange(newValue, priorityChange);
	},

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget has changed.  Saves the new value in this.value,
		//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
		this._set("value", newValue);
		this.inherited(arguments);
	},

	undo: function(){
		// summary:
		//		Restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	_onKeyDown: function(e){
		if(e.keyCode == dojo.keys.ESCAPE && !(e.ctrlKey || e.altKey || e.metaKey)){
			var te;
			if(dojo.isIE){
				e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
				te = document.createEventObject();
				te.keyCode = dojo.keys.ESCAPE;
				te.shiftKey = e.shiftKey;
				e.srcElement.fireEvent('onkeypress', te);
			}
		}
	},

	_layoutHackIE7: function(){
		// summary:
		//		Work around table sizing bugs on IE7 by forcing redraw

		if(dojo.isIE == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
			var domNode = this.domNode;
			var parent = domNode.parentNode;
			var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
			var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
			var _this = this;
			while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
				(function ping(){
					var disconnectHandle = _this.connect(parent, "onscroll",
						function(e){
							_this.disconnect(disconnectHandle); // only call once
							pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
							setTimeout(function(){ pingNode.style.filter = origFilter }, 0); // restore custom filter, if any
						}
					);
				})();
				parent = parent.parentNode;
			}
		}
	}
});

}

if(!dojo._hasResource["dijit._HasDropDown"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._HasDropDown"] = true;
dojo.provide("dijit._HasDropDown");



dojo.declare("dijit._HasDropDown",
	null,
	{
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the popupActive class on.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a dojoAttachPoint assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: 0,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below","above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subwidget
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown's on the arrow icon

			if(this.disabled || this.readOnly){ return; }

			dojo.stopEvent(e);

			this._docHandler = this.connect(dojo.doc, "onmouseup", "_onDropDownMouseUp");

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback when the user lifts their mouse after mouse down on the arrow icon.
			//		If the drop is a simple menu and the mouse is over the menu, we execute it, otherwise, we focus our
			//		dropDown node.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser <select> nodes:
			//			1. mouse down on the select node (probably on the arrow)
			//			2. move mouse to a menu item while holding down the mouse button
			//			3. mouse up.  this selects the menu item as though the user had clicked it.
			if(e && this._docHandler){
				this.disconnect(this._docHandler);
			}
			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = dojo.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) ||
					!(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(dojo.hasClass(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = dijit.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened && dropDown.focus && dropDown.autoFocus !== false){
				// Focus the dropdown widget - do it on a delay so that we
				// don't steal our own focus.
				window.setTimeout(dojo.hitch(dropDown, "focus"), 1);
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			// the drop down was already opened on mousedown/keydown; just need to call stopEvent()
			if(this._stopClickEvents){
				dojo.stopEvent(e);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
					"after" : this.isLeftToRight() ? "Right" : "Left",
					"before" : this.isLeftToRight() ? "Left" : "Right",
					"above" : "Up",
					"below" : "Down",
					"left" : "Left",
					"right" : "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			dojo.addClass(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keypress events

			this.inherited(arguments);

			this.connect(this._buttonNode, "onmousedown", "_onDropDownMouseDown");
			this.connect(this._buttonNode, "onclick", "_onDropDownClick");
			this.connect(this.focusNode, "onkeypress", "_onKey");
			this.connect(this.focusNode, "onkeyup", "_onKeyUp");
		},

		destroy: function(){
			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){ return; }

			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					dojo.stopEvent(e);
					return;
				}
			}
			if(d && this._opened && e.charOrCode == dojo.keys.ESCAPE){
				this.closeDropDown();
				dojo.stopEvent(e);
			}else if(!this._opened &&
					(e.charOrCode == dojo.keys.DOWN_ARROW ||
						( (e.charOrCode == dojo.keys.ENTER || e.charOrCode == " ") &&
						  //ignore enter and space if the event is for a text input
						  ((target.tagName || "").toLowerCase() !== 'input' ||
						     (target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				dojo.stopEvent(e);
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					setTimeout(dojo.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Don't focus on button if the user has explicitly focused on something else (happens
			// when user clicks another control causing the current popup to close)..
			// But if focus is inside of the drop down then reset focus to me, because IE doesn't like
			// it when you display:none a node with focus.
			var focusMe = dijit._curFocus && this.dropDown && dojo.isDescendant(dijit._curFocus, this.dropDown.domNode);

			this.closeDropDown(focusMe);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns whether or not the dropdown is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/* Function */ loadCallback){
			// summary:
			//		Loads the data for the dropdown, and at some point, calls
			//		the given callback.   This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// tags:
			//		protected

			loadCallback();
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){ return; }
			if(!this._opened){
				// If we aren't loaded, load it first so there isn't a flicker
				if(!this.isLoaded()){
					this.loadDropDown(dojo.hitch(this, "openDropDown"));
					return;
				}else{
					this.openDropDown();
				}
			}else{
				this.closeDropDown();
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit.popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			// Prepare our popup's height and honor maxHeight if it exists.

			// TODO: isn't maxHeight dependent on the return value from dijit.popup.open(),
			// ie, dependent on how much space is available (BK)

			if(!this._preparedNode){
				this._preparedNode = true;
				// Check if we have explicitly set width and height on the dropdown widget dom node
				if(ddNode.style.width){
					this._explicitDDWidth = true;
				}
				if(ddNode.style.height){
					this._explicitDDHeight = true;
				}
			}

			// Code for resizing dropdown (height limitation, or increasing width to match my width)
			if(this.maxHeight || this.forceWidth || this.autoWidth){
				var myStyle = {
					display: "",
					visibility: "hidden"
				};
				if(!this._explicitDDWidth){
					myStyle.width = "";
				}
				if(!this._explicitDDHeight){
					myStyle.height = "";
				}
				dojo.style(ddNode, myStyle);
				
				// Figure out maximum height allowed (if there is a height restriction)
				var maxHeight = this.maxHeight;
				if(maxHeight == -1){
					// limit height to space available in viewport either above or below my domNode
					// (whichever side has more room)
					var viewport = dojo.window.getBox(),
						position = dojo.position(aroundNode, false);
					maxHeight = Math.floor(Math.max(position.y, viewport.h - (position.y + position.h)));
				}

				// Attach dropDown to DOM and make make visibility:hidden rather than display:none
				// so we call startup() and also get the size
				if(dropDown.startup && !dropDown._started){
					dropDown.startup();
				}

				dijit.popup.moveOffScreen(dropDown);
				// Get size of drop down, and determine if vertical scroll bar needed
				var mb = dojo._getMarginSize(ddNode);
				var overHeight = (maxHeight && mb.h > maxHeight);
				dojo.style(ddNode, {
					overflowX: "hidden",
					overflowY: overHeight ? "auto" : "hidden"
				});
				if(overHeight){
					mb.h = maxHeight;
					if("w" in mb){
						mb.w += 16;	// room for vertical scrollbar
					}
				}else{
					delete mb.h;
				}

				// Adjust dropdown width to match or be larger than my width
				if(this.forceWidth){
					mb.w = aroundNode.offsetWidth;
				}else if(this.autoWidth){
					mb.w = Math.max(mb.w, aroundNode.offsetWidth);
				}else{
					delete mb.w;
				}
				
				// And finally, resize the dropdown to calculated height and width
				if(dojo.isFunction(dropDown.resize)){
					dropDown.resize(mb);
				}else{
					dojo.marginBox(ddNode, mb);
				}
			}

			var retVal = dijit.popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: dijit.getPopupAroundAlignment((this.dropDownPosition && this.dropDownPosition.length) ? this.dropDownPosition : ["below"],this.isLeftToRight()),
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					dojo.attr(self._popupStateNode, "popupActive", false);
					dojo.removeClass(self._popupStateNode, "dijitHasDropDownOpen");
					self._opened = false;
				}
			});
			dojo.attr(this._popupStateNode, "popupActive", "true");
			dojo.addClass(self._popupStateNode, "dijitHasDropDownOpen");
			this._opened=true;

			// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._opened){
				if(focus){ this.focus(); }
				dijit.popup.close(this.dropDown);
				this._opened = false;
			}
		}

	}
);

}

if(!dojo._hasResource["dijit.form.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Button"] = true;
dojo.provide("dijit.form.Button");





dojo.declare("dijit.form.Button",
	dijit.form._FormWidget,
	{
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button dojoType="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Text to display in button.
	//		If the label is hidden (showLabel=false) then and no title has
	//		been specified, then label is also set as title attribute of icon.
	label: "",

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to DOMNode in button to make it display an icon
	iconClass: "",

	// type: String
	//		Defines the type of button.  "button", "submit", or "reset".
	type: "button",

	baseClass: "dijitButton",

	templateString: dojo.cache("dijit.form", "templates/Button.html", "<span class=\"dijit dijitReset dijitInline\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdojoAttachEvent=\"ondijitclick:_onButtonClick\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdojoAttachPoint=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" dojoAttachPoint=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdojoAttachPoint=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdojoAttachPoint=\"valueNode\"\n/></span>\n"),

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		value: "valueNode"
	}),

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled){
			return false;
		}
		this._clicked(); // widget click actions
		return this.onClick(e); // user click actions
	},

	_onButtonClick: function(/*Event*/ e){
		// summary:
		//		Handler when the user activates the button portion.
		if(this._onClick(e) === false){ // returning nothing is same as true
			e.preventDefault(); // needed for checkbox
		}else if(this.type == "submit" && !(this.valueNode||this.focusNode).form){ // see if a nonform widget needs to be signalled
			for(var node=this.domNode; node.parentNode/*#5935*/; node=node.parentNode){
				var widget=dijit.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					break;
				}
			}
		}else if(this.valueNode){
			this.valueNode.click();
			e.preventDefault(); // cancel BUTTON click and continue with hidden INPUT click
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		dojo.setSelectable(this.focusNode, false);
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		// TODO: remove the method in 2.0, parser will do it all for me
		if(source && (!this.params || !("label" in this.params))){
			this.set('label', source.innerHTML);
		}
	},

	_setShowLabelAttr: function(val){
		if(this.containerNode){
			dojo.toggleClass(this.containerNode, "dijitDisplayNone", !val);
		}
		this._set("showLabel", val);
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_clicked: function(/*Event*/ e){
		// summary:
		//		Internal overridable function for when the button is clicked
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use set('label', ...) instead.
		dojo.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
		this.set("label", content);
	},

	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this._set("label", content);
		this.containerNode.innerHTML = content;
		if(this.showLabel == false && !this.params.title){
			this.titleNode.title = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	},

	_setIconClassAttr: function(/*String*/ val){
		// Custom method so that icon node is hidden when not in use, to avoid excess padding/margin
		// appearing around it (even if it's a 0x0 sized <img> node)

		var oldVal = this.iconClass || "dijitNoIcon",
			newVal = val || "dijitNoIcon";
		dojo.replaceClass(this.iconNode, newVal, oldVal);
		this._set("iconClass", val);
	}
});


dojo.declare("dijit.form.DropDownButton", [dijit.form.Button, dijit._Container, dijit._HasDropDown], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button dojoType="dijit.form.DropDownButton" label="Hello world">
	// |		<div dojotype="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	dojo.body().appendChild(button1);
	//

	baseClass : "dijitDropDownButton",

	templateString: dojo.cache("dijit.form", "templates/DropDownButton.html", "<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdojoAttachEvent=\"ondijitclick:_onButtonClick\" dojoAttachPoint=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdojoAttachPoint=\"focusNode,titleNode,_arrowWrapperNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdojoAttachPoint=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdojoAttachPoint=\"containerNode,_popupStateNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdojoAttachPoint=\"valueNode\"\n/></span>\n"),

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = dojo.query("*", this.srcNodeRef);
			dijit.form.DropDownButton.superclass._fillContent.call(this, nodes[0]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown && this.dropDownContainer){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		if(this.dropDown){
			dijit.popup.hide(this.dropDown);
		}

		this.inherited(arguments);
	},

	isLoaded: function(){
		// Returns whether or not we are loaded - if our dropdown has an href,
		// then we want to check that.
		var dropDown = this.dropDown;
		return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
	},

	loadDropDown: function(){
		// Loads our dropdown
		var dropDown = this.dropDown;
		if(!dropDown){ return; }
		if(!this.isLoaded()){
			var handler = dojo.connect(dropDown, "onLoad", this, function(){
				dojo.disconnect(handler);
				this.openDropDown();
			});
			dropDown.refresh();
		}else{
			this.openDropDown();
		}
	},

	isFocusable: function(){
		// Overridden so that focus is handled by the _HasDropDown mixin, not by
		// the _FormWidget mixin.
		return this.inherited(arguments) && !this._mouseDown;
	}
});

dojo.declare("dijit.form.ComboButton", dijit.form.DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button dojoType="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div dojoType="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	//

	templateString: dojo.cache("dijit.form", "templates/ComboButton.html", "<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" dojoAttachPoint=\"buttonNode\" dojoAttachEvent=\"ondijitclick:_onButtonClick,onkeypress:_onButtonKeyPress\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdojoAttachPoint=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" dojoAttachPoint=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdojoAttachPoint=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdojoAttachEvent=\"onkeypress:_onArrowKeyPress\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" dojoAttachPoint=\"valueNode\"\n\t\t/></td></tr></tbody\n></table>\n"),

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		id: "",
		tabIndex: ["focusNode", "titleNode"],
		title: "titleNode"
	}),

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	// Set classes like dijitButtonContentsHover or dijitArrowButtonActive depending on
	// mouse action over specified node
	cssStateNodes: {
		"buttonNode": "dijitButtonNode",
		"titleNode": "dijitButtonContents",
		"_popupStateNode": "dijitDownArrowButton"
	},

	_focusedNode: null,

	_onButtonKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for right arrow key when focus is on left part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
			dijit.focus(this._popupStateNode);
			dojo.stopEvent(evt);
		}
	},

	_onArrowKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for left arrow key when focus is on right part of button
		if(evt.charOrCode == dojo.keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
			dijit.focus(this.titleNode);
			dojo.stopEvent(evt);
		}
	},
	
	focus: function(/*String*/ position){
		// summary:
		//		Focuses this widget to according to position, if specified,
		//		otherwise on arrow node
		// position:
		//		"start" or "end"
		if(!this.disabled){
			dijit.focus(position == "start" ? this.titleNode : this._popupStateNode);
		}
	}
});

dojo.declare("dijit.form.ToggleButton", dijit.form.Button, {
	// summary:
	//		A button that can be in two states (checked or not).
	//		Can be base class for things like tabs or checkbox or radio buttons

	baseClass: "dijitToggleButton",

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		checked:"focusNode"
	}),

	_clicked: function(/*Event*/ evt){
		this.set('checked', !this.checked);
	},

	_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
		this._set("checked", value);
		dojo.attr(this.focusNode || this.domNode, "checked", value);
		dijit.setWaiState(this.focusNode || this.domNode, "pressed", value);
		this._handleOnChange(value, priorityChange);
	},

	setChecked: function(/*Boolean*/ checked){
		// summary:
		//		Deprecated.  Use set('checked', true/false) instead.
		dojo.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
		this.set('checked', checked);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.set('checked', this.params.checked || false);
	}
});

}

if(!dojo._hasResource['bfree.widget.admin.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.admin.CommandBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/09/11
 * Time: 10:42 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.admin.CommandBar');





dojo.declare('bfree.widget.admin.CommandBar', [dijit.Toolbar], {

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    constructor: function(args){

    },

    onCommand: function(cmdId){

    },

    changesMade: function(changed){
        if(changed){
//            this._btnSaveUser.set('iconClass', 'commandIcon32 bfreeIconSave32');
            this._btnSaveUser.set('disabled', false);
//            this._btnUndoUser.set('iconClass', 'commandIcon32 bfreeIconUndo32');
            this._btnUndoUser.set('disabled', false);
        }else{
//            this._btnSaveUser.set('iconClass', 'commandIcon32 bfreeIconSaveD32');
            this._btnSaveUser.set('disabled', true);
//            this._btnUndoUser.set('iconClass', 'commandIcon32 bfreeIconUndoD32');
            this._btnUndoUser.set('disabled', true);
        }
    },

    itemEditable: function(editable){
        if(editable){
//            this._btnEditUser.set('iconClass', 'commandIcon32 bfreeIconEdit32');
            this._btnEditUser.set('disabled', false);
//            this._btnDeleteUser.set('iconClass', 'commandIcon32 bfreeIconDelete32');
            this._btnDeleteUser.set('disabled', false);
        }else{
//            this._btnEditUser.set('iconClass', 'commandIcon32 bfreeIconEditD32');
            this._btnEditUser.set('disabled', true);
//            this._btnDeleteUser.set('iconClass', 'commandIcon32 bfreeIconDeleteD32');
            this._btnDeleteUser.set('disabled', false);
        }
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this.addChild(
            new dijit.form.DropDownButton({
                label: 'Administration',
                showLabel: false,
                scrollOnFocus: false,
                dropDown:   new bfree.widget.admin.AdminMenu({
                                onCommand: dojo.hitch(this, this._onCommand)
                            }),
                iconClass: 'commandIcon32 bfreeIconAdmin32'
            })
        );

        this.addChild(new dijit.ToolbarSeparator());


        this._btnSaveUser = new dijit.form.Button({
			label: 'Save Changes...',
			showLabel: false,
			disabled: true,
			iconClass: 'commandIcon32 bfreeIconSave32',
			onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.USER_SAVE)
		});
		this.addChild(this._btnSaveUser);

		this._btnUndoUser = new dijit.form.Button({
			label: 'Undo Unsaved Changes...',
			showLabel: false,
			disabled: true,
			iconClass: 'commandIcon32 bfreeIconUndo32',
			onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.USER_UNDO)
		});
		this.addChild(this._btnUndoUser);

		this.addChild(new dijit.ToolbarSeparator({}));

		this._btnNewUser = new dijit.form.Button({
			label: 'New...',
			showLabel: false,
			iconClass: 'commandIcon32 bfreeIconUser32',
			onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.USER_NEW)
		});
		this.addChild(this._btnNewUser);

		this._btnEditUser = new dijit.form.Button({
			label: 'Edit Selected...',
			showLabel: false,
            disabled: true,
			iconClass: 'commandIcon32 bfreeIconEdit32',
			onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.USER_EDIT)
		});
		this.addChild(this._btnEditUser);

		this._btnDeleteUser = new dijit.form.Button({
			label: 'Delete Selected...',
			showLabel: false,
            disabled: true,
			iconClass: 'commandIcon32 bfreeIconDelete32',
			onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.USER_DELETE)
		});
		this.addChild(this._btnDeleteUser);

//        this.addChild(new dijit.ToolbarSeparator());
//
//        this._btnLogout =new dijit.form.Button({
//            label: 'Logout',
//            showLabel: false,
//            iconClass: 'commandIcon32 bfreeIconLogout32',
//            onClick: dojo.hitch(this, this._onCommand, bfree.widget.admin.CommandBar.COMMANDS.LOGOUT)
//        })
//        this.addChild(this._btnLogout);

        this.containerNode.className='';
	},

	refresh: function(args){

		this._setState();

	}
});

bfree.widget.admin.CommandBar.COMMANDS={
    NONE:          0x0000,
    USERS:         0x0001,
    SERVERS:       0x0002,
    ACCOUNTS:      0x0003,
    ZONES:         0x0004,
    LOGOUT:        0x0005,

    USER_SAVE:     0x0100,
    USER_UNDO:     0x0101,
    USER_NEW:      0x0102,
    USER_EDIT:     0x0103,
    USER_DELETE:   0x0104
};



}

if(!dojo._hasResource['bfree.widget._DialogWidget']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget._DialogWidget'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/09/11
 * Time: 4:06 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget._DialogWidget');

dojo.declare('bfree.widget._DialogWidget', null,{

    dialog: null,
	dialogResult: 0x00,
    isLoaded: false,
    returnValue: null,

	isDirty: false,

	_closeDialog: function(args){
		this.onDialogClose(this.dialogResult, this.returnValue);
	},

    _loadComplete: function(){
        this.isLoaded = true;
        this.onWidgetLoaded();
    },

	_setIsDirtyAttr: function(value){
		var isChanged = (this.isDirty != value);

		if(!isChanged)
			return;

		this.isDirty = value;
		this.onDirtyChanged(this.isDirty);
	},

	_workEnd: function(args){
		this.onWorkEnd();
	},
	_workStart: function(args){
		this.onWorkStart();
	},

	canClose: function(){
		return true;
	},

	constructor: function(/* Object */args){
	},


	focus: function(){
	},

	isValid: function(){
		return true;
	},

	onDialogClose: function(dlgResult, retValue){
	},

    onDirtyChanged: function(is_dirty){
    },

	onValueChange: function(){
	},

	//called before dialog is closed
	//returning false will abort the dialog close
	onDialogClosing: function(dlgResult){
		return true;
	},

    onWidgetLoaded: function(){
    },

	onWorkEnd: function(args){
	},
	onWorkStart: function(args){
	},

	resize: function(){
	}


});

}

if(!dojo._hasResource["dijit.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tooltip"] = true;
dojo.provide("dijit.Tooltip");




dojo.declare(
	"dijit._MasterTooltip",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: dijit.defaultDuration,

		templateString: dojo.cache("dijit", "templates/Tooltip.html", "<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"containerNode\" role='alert'></div\n\t><div class=\"dijitTooltipConnector\" dojoAttachPoint=\"connectorNode\"></div\n></div>\n"),

		postCreate: function(){
			dojo.body().appendChild(this.domNode);

			this.bgIframe = new dijit.BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = dojo.fadeIn({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onShow") });
			this.fadeOut = dojo.fadeOut({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onHide") });
		},

		show: function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position, /*Boolean*/ rtl){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)

			if(this.aroundNode && this.aroundNode === aroundNode){
				return;
			}

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.width = "auto";

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			var pos = dijit.placeOnScreenAroundElement(this.domNode, aroundNode, dijit.getPopupAroundAlignment((position && position.length) ? position : dijit.Tooltip.defaultPosition, !rtl), dojo.hitch(this, "orient"));

			// show it
			dojo.style(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected
			this.connectorNode.style.top = ""; //reset to default
			
			//Adjust the spaceAvailable width, without changing the spaceAvailable object
			var tooltipSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;

			node.className = "dijitTooltip " +
				{
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];
				
			// reduce tooltip's width to the amount of width available, so that it doesn't overflow screen
			this.domNode.style.width = "auto";
			var size = dojo.contentBox(this.domNode);
			
			var width = Math.min((Math.max(tooltipSpaceAvaliableWidth,1)), size.w);
			var widthWasReduced = width < size.w;
			
			this.domNode.style.width = width+"px";
						
			//Adjust width for tooltips that have a really long word or a nowrap setting
			if(widthWasReduced){
				this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our tooltip needs to be wider to support the content
				var scrollWidth = this.containerNode.scrollWidth;
				this.containerNode.style.overflow = "visible"; //change it back
				if(scrollWidth > width){
					scrollWidth = scrollWidth + dojo.style(this.domNode,"paddingLeft") + dojo.style(this.domNode,"paddingRight");
					this.domNode.style.width = scrollWidth + "px";
				}
			}
			
			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var mb = dojo.marginBox(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(mb.h > spaceAvailable.h){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = spaceAvailable.h - (aroundNodeCoords.h / 2) - (tooltipConnectorHeight / 2);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						mb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}
			
			return Math.max(0, size.w - tooltipSpaceAvaliableWidth);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(dojo.isIE){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}

	}
);

dijit.showTooltip = function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position, /*Boolean*/ rtl){
	// summary:
	//		Display tooltip w/specified contents in specified position.
	//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
	//		If position is not specified then dijit.Tooltip.defaultPosition is used.
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.show(innerHTML, aroundNode, position, rtl);
};

dijit.hideTooltip = function(aroundNode){
	// summary:
	//		Hide the tooltip
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.hide(aroundNode);
};

dojo.declare(
	"dijit.Tooltip",
	dijit._Widget,
	{
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: String|String[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node, the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		_setConnectIdAttr: function(/*String*/ newId){
			// summary:
			//		Connect to node(s) (specified by id)

			// Remove connections to old nodes (if there are any)
			dojo.forEach(this._connections || [], function(nested){
				dojo.forEach(nested, dojo.hitch(this, "disconnect"));
			}, this);

			// Make connections to nodes in newIds.
			var ary = dojo.isArrayLike(newId) ? newId : (newId ? [newId] : []);
			this._connections = dojo.map(ary, function(id){
				var node = dojo.byId(id);
				return node ? [
					this.connect(node, "onmouseenter", "_onTargetMouseEnter"),
					this.connect(node, "onmouseleave", "_onTargetMouseLeave"),
					this.connect(node, "onfocus", "_onTargetFocus"),
					this.connect(node, "onblur", "_onTargetBlur")
				] : [];
			}, this);
	
			this._set("connectId", newId);

			this._connectIds = ary;	// save as array
		},

		addTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(dojo.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface
			
			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = dojo.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			dojo.addClass(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			dojo.forEach(dojo.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		_onTargetMouseEnter: function(/*Event*/ e){
			// summary:
			//		Handler for mouseenter event on the target node
			// tags:
			//		private
			this._onHover(e);
		},

		_onTargetMouseLeave: function(/*Event*/ e){
			// summary:
			//		Handler for mouseleave event on the target node
			// tags:
			//		private
			this._onUnHover(e);
		},

		_onTargetFocus: function(/*Event*/ e){
			// summary:
			//		Handler for focus event on the target node
			// tags:
			//		private

			this._focus = true;
			this._onHover(e);
		},

		_onTargetBlur: function(/*Event*/ e){
			// summary:
			//		Handler for blur event on the target node
			// tags:
			//		private

			this._focus = false;
			this._onUnHover(e);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(dojo.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			dijit.showTooltip(this.label || this.domNode.innerHTML, target, this.position, !this.isLeftToRight());

			this._connectNode = target;
			this.onShow(target, this.position);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				dijit.hideTooltip(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		onShow: function(target, position){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		uninitialize: function(){
			this.close();
			this.inherited(arguments);
		}
	}
);

// dijit.Tooltip.defaultPosition: String[]
//		This variable controls the position of tooltips, if the position is not specified to
//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
//
//			* before: places tooltip to the left of the target node/widget, or to the right in
//			  the case of RTL scripts like Hebrew and Arabic
//			* after: places tooltip to the right of the target node/widget, or to the left in
//			  the case of RTL scripts like Hebrew and Arabic
//			* above: tooltip goes above target node
//			* below: tooltip goes below target node
//
//		The list is positions is tried, in order, until a position is found where the tooltip fits
//		within the viewport.
//
//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
//		the screen so that there's no room above the target node.   Nodes with drop downs, like
//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
//		is only room below (or above) the target node, but not both.
dijit.Tooltip.defaultPosition = ["after", "before"];

}

if(!dojo._hasResource["dijit.form.ToggleButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ToggleButton"] = true;
dojo.provide("dijit.form.ToggleButton");




}

if(!dojo._hasResource["dijit.form.CheckBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CheckBox"] = true;
dojo.provide("dijit.form.CheckBox");



dojo.declare(
	"dijit.form.CheckBox",
	dijit.form.ToggleButton,
	{
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//
		//		There are two modes:
		//			1. High contrast mode
		//			2. Normal mode
		//
		//		In case 1, the regular html inputs are shown and used by the user.
		//		In case 2, the regular html inputs are invisible but still used by
		//		the user. They are turned quasi-invisible and overlay the background-image.

		templateString: dojo.cache("dijit.form", "templates/CheckBox.html", "<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdojoAttachPoint=\"focusNode\"\n\t \tdojoAttachEvent=\"onclick:_onClick\"\n/></div>\n"),

		baseClass: "dijitCheckBox",

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.  Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		//
		//		However, get('value') will return either the string or false depending on
		//		whether or not the checkbox is checked.
		//
		//		set('value', string) will check the checkbox and change the value to the
		//		specified string
		//
		//		set('value', boolean) will change the checked state.
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,
		
		// the attributeMap should inherit from dijit.form._FormWidget.prototype.attributeMap
		// instead of ToggleButton as the icon mapping has no meaning for a CheckBox
		attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
			readOnly: "focusNode"
		}),

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this._set("readOnly", value);
			dojo.attr(this.focusNode, 'readOnly', value);
			dijit.setWaiState(this.focusNode, "readonly", value);
		},

		_setValueAttr: function(/*String|Boolean*/ newValue, /*Boolean*/ priorityChange){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		set('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		dojoType="dijit.CheckBox" value="chicken">)
			if(typeof newValue == "string"){
				this._set("value", newValue);
				dojo.attr(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.set('checked', newValue, priorityChange);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		// Override dijit.form.Button._setLabelAttr() since we don't even have a containerNode.
		// Normally users won't try to set label, except when CheckBox or RadioButton is the child of a dojox.layout.TabContainer
		_setLabelAttr: undefined,

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}

			// Need to set initial checked state as part of template, so that form submit works.
			// dojo.attr(node, "checked", bool) doesn't work on IEuntil node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";

			this.inherited(arguments);
		},

		 _fillContent: function(/*DomNode*/ source){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		reset: function(){
			// Override ToggleButton.reset()

			this._hasBeenBlurred = false;

			this.set('checked', this.params.checked || false);

			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this._set("value", this.params.value || "on");
			dojo.attr(this.focusNode, 'value', this.value);
		},

		_onFocus: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onBlur: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				dojo.stopEvent(e);
				return false;
			}
			return this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.RadioButton",
	dijit.form.CheckBox,
	{
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		type: "radio",
		baseClass: "dijitRadio",

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				var _this = this;
				// search for radio buttons with the same name that need to be unchecked
				dojo.query("INPUT[type=radio]", this.focusNode.form || dojo.doc).forEach( // can't use name= since dojo.query doesn't support [] in the name
					function(inputNode){
						if(inputNode.name == _this.name && inputNode != _this.focusNode && inputNode.form == _this.focusNode.form){
							var widget = dijit.getEnclosingWidget(inputNode);
							if(widget && widget.checked){
								widget.set('checked', false);
							}
						}
					}
				);
			}
		},

		_clicked: function(/*Event*/ e){
			if(!this.checked){
				this.set('checked', true);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.TextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TextBox"] = true;
dojo.provide("dijit.form.TextBox");



dojo.declare(
	"dijit.form.TextBox",
	dijit.form._FormValueWidget,
	{
		// summary:
		//		A base class for textbox form inputs

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",
		
		templateString: dojo.cache("dijit.form", "templates/TextBox.html", "<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"),
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" dojoAttachPoint="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: dojo.isIE ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
			maxLength: "focusNode"
		}),
		
		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == dijit.form.TextBox.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				/* dijitInputField class gives placeHolder same padding as the input field
				 * parent node already has dijitInputField class but it doesn't affect this <span>
				 * since it's position: absolute.
				 */
				this._phspan = dojo.create('span',{className:'dijitPlaceHolder dijitInputField'},this.textbox,'after');
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(document.createTextNode(v));
			
			this._updatePlaceHolder();
		},
		
		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display=(this.placeHolder&&!this._focused&&!this.textbox.value)?"":"none";
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit.form.TextBox` this basically returns the value of the <input>.
			//
			//		For `dijit.form.MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{ formattedValue = ''; }
				}
			}
			if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this._updatePlaceHolder();

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use set('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			// 		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see dijit.form.ValidationTextBox.serialize)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value === null || value === undefined){ value = '' }
			else if(typeof value != "string"){ value = String(value) }

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			//		Replacable function to convert a value to a properly formatted string.
			// tags:
			//		protected extension
			return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
		},

		parse: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a value
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit.form.TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		_onInput: function(e){
			if(e && e.type && /key/i.test(e.type) && e.keyCode){
				switch(e.keyCode){
					case dojo.keys.SHIFT:
					case dojo.keys.ALT:
					case dojo.keys.CTRL:
					case dojo.keys.TAB:
						return;
				}
			}
			if(this.intermediateChanges){
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.get('value'), false); }, 0);
			}
			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			if(dojo.isIE){ // IE INPUT tag fontFamily has to be set directly using STYLE
				// the setTimeout gives IE a chance to render the TextBox and to deal with font inheritance
				setTimeout(dojo.hitch(this, function(){
				var s = dojo.getComputedStyle(this.domNode);
				if(s){
					var ff = s.fontFamily;
					if(ff){
						var inputs = this.domNode.getElementsByTagName("INPUT");
						if(inputs){
							for(var i=0; i < inputs.length; i++){
								inputs[i].style.fontFamily = ff;
							}
						}
					}
				}
				}), 0);
			}

			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			if(dojo.isMoz || dojo.isOpera){
				this.connect(this.textbox, "oninput", "_onInput");
			}else{
				this.connect(this.textbox, "onkeydown", "_onInput");
				this.connect(this.textbox, "onkeyup", "_onInput");
				this.connect(this.textbox, "onpaste", "_onInput");
				this.connect(this.textbox, "oncut", "_onInput");
			}
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			// 			- once with the display value
			//			- once the value as set/returned by set('value', ...)
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){ return this._blankValue; }
			if(typeof val != "string"){ return val; }
			if(this.trim){
				val = dojo.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0,1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this._setBlurValue();
			this.inherited(arguments);

			if(this._selectOnClickHandle){
				this.disconnect(this._selectOnClickHandle);
			}
			if(this.selectOnClick && dojo.isMoz){
				this.textbox.selectionStart = this.textbox.selectionEnd = undefined; // clear selection so that the next mouse click doesn't reselect
			}
			
			this._updatePlaceHolder();
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				this._selectOnClickHandle = this.connect(this.domNode, "onmouseup", function(){
					// Only select all text on first click; otherwise users would have no way to clear
					// the selection.
					this.disconnect(this._selectOnClickHandle);

					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					var textIsNotSelected;
					if(dojo.isIE){
						var range = dojo.doc.selection.createRange();
						var parent = range.parentElement();
						textIsNotSelected = parent == this.textbox && range.text.length == 0;
					}else{
						textIsNotSelected = this.textbox.selectionStart == this.textbox.selectionEnd;
					}
					if(textIsNotSelected){
						dijit.selectInputText(this.textbox);
					}
				});
			}

			this._updatePlaceHolder();
			
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

			this._refreshState();
		},

		reset: function(){
			// Overrides dijit._FormWidget.reset().
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	}
);

dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	var _window = dojo.global;
	var _document = dojo.doc;
	element = dojo.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	dijit.focus(element);
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		if(element.createTextRange){
			var r = element.createTextRange();
			r.collapse(true);
			r.moveStart("character", -99999); // move to 0
			r.moveStart("character", start); // delta from 0 is the correct position
			r.moveEnd("character", stop-start);
			r.select();
		}
	}else if(_window["getSelection"]){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	}
};

}

if(!dojo._hasResource["dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ValidationTextBox"] = true;
dojo.provide("dijit.form.ValidationTextBox");






/*=====
	dijit.form.ValidationTextBox.__Constraints = function(){
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to regExpGen function
		this.locale = "";
		this._flags_ = "";
	}
=====*/

dojo.declare(
	"dijit.form.ValidationTextBox",
	dijit.form.TextBox,
	{
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString: dojo.cache("dijit.form", "templates/ValidationTextBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"),
		baseClass: "dijitTextBox dijitValidationTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		// 		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp; // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this.validate(this._focused);
		},

		validator: function(/*anything*/ value, /*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.constraints);
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return (this.required && this._isEmpty(this.textbox.value)) ? this.missingMessage : this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && this._maskValidSubsetError) ? "Incomplete" : "Error"));
			dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			dijit.hideTooltip(this.domNode);
			if(message && this._focused){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this._focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._computePartialRE();
		},

		_computePartialRE: function(){
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function (re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(':
							partialre += re;
							break;
						case ")":
							partialre += "|$)";
							break;
						 default:
							partialre += "(?:"+re+"|$)";
							break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			if(!this.invalidMessage){ this.invalidMessage = this.promptMessage; }
			if(this.missingMessage == "$_unset_$"){ this.missingMessage = this.messages.missingMessage; }
			if(!this.missingMessage){ this.missingMessage = this.invalidMessage; }
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			dijit.setWaiState(this.focusNode, "required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.MappedTextBox",
	dijit.form.ValidationTextBox,
	{
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		serialize: function(/*anything*/ val, /*Object?*/ options){
			// summary:
			//		Overridable function used to convert the get('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._Templated.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than calling dojo.create() with an attrs argument
			// to make dojo.query(input[name=...]) work on IE. (see #8660)
			this.valueNode = dojo.place("<input type='hidden'" + (this.name ? " name='" + this.name.replace(/'/g, "&quot;") + "'" : "") + "/>", this.textbox, "after");
		},

		reset: function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	}
);

/*=====
	dijit.form.RangeBoundTextBox.__Constraints = function(){
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
		this.min = min;
		this.max = max;
	}
=====*/

dojo.declare(
	"dijit.form.RangeBoundTextBox",
	dijit.form.MappedTextBox,
	{
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
				("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
		},

		isInRange: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.get('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.get('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				min = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0) ? 0 : min);
				isTooLittle = (typeof min == "number") && min < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				max = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0);
				isTooMuch = (typeof max == "number") && max > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			var v = this.get('value');
			if(v !== null && v !== '' && v !== undefined && (typeof v != "number" || !isNaN(v)) && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
				return this.rangeMessage; // String
			}
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			this.inherited(arguments);
			if(this.focusNode){ // not set when called from postMixInProperties
				if(this.constraints.min !== undefined){
					dijit.setWaiState(this.focusNode, "valuemin", this.constraints.min);
				}else{
					dijit.removeWaiState(this.focusNode, "valuemin");
				}
				if(this.constraints.max !== undefined){
					dijit.setWaiState(this.focusNode, "valuemax", this.constraints.max);
				}else{
					dijit.removeWaiState(this.focusNode, "valuemax");
				}
			}
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', ...) works.

			dijit.setWaiState(this.focusNode, "valuenow", value);
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ComboBox"] = true;
dojo.provide("dijit.form.ComboBox");











dojo.declare(
	"dijit.form.ComboBoxMixin",
	dijit._HasDropDown,
	{
		// summary:
		//		Implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`
		// description:
		//		All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo.data.store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies number of search results per page (before hitting "next" button)
		pageSize: Infinity,

		// store: [const] Object
		//		Reference to data provider object used by this ComboBox
		store: null,

		// fetchProperties: Object
		//		Mixin to the dojo.data store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: [{attribute:"name",descending: true}] }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to 'store' to initially filter the items,
		//		before doing further filtering based on `searchAttr` and the key.
		//		Any reference to the `searchAttr` is ignored.
		query: {},

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		// 		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 100,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// queryExpr: String
		//		This specifies what query ComboBox/FilteringSelect sends to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the drop down shows only exact matches, a "starting with" match,
		//		etc.  Use it in conjunction with highlightMatch.
		//		dojo.data query expression pattern.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the ComboBox/FilteringSelect should ignore case when matching possible items
		ignoreCase: true,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: dojo.cache("dijit.form", "templates/DropDownBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"\n\t/></div\n></div>\n"),

		baseClass: "dijitTextBox dijitComboBox",

		// dropDownClass: [protected extension] String
		//		Name of the dropdown widget class used to select a date/time.
		//		Subclasses should specify this.
		dropDownClass: "dijit.form._ComboBoxMenu",

		// Set classes like dijitDownArrowButtonHover depending on
		// mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
		maxHeight: -1,

		// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
		_stopClickEvents: false,

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(dojo.isIE){
				// in the case of a mouse click in a popup being handled,
				// then the dojo.doc.selection is not the textarea, but the popup
				// var r = dojo.doc.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = dojo.doc.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character",0);
				ntr.move("character",0);
				try{
					// If control doesn't have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g,"").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			dijit.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			dijit.setWaiState(this.domNode, "disabled", value);
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				clearTimeout(this.searchTimer);
				this.searchTimer = null;
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){ this._fetchHandle.abort(); }
				this._fetchHandle = null;
			}
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Handles paste events
			if(!this.searchTimer && (evt.type == 'paste'/*IE|WebKit*/ || evt.type == 'input'/*Firefox*/) && this._lastInput != this.textbox.value){
				this.searchTimer = setTimeout(dojo.hitch(this, function(){
					this._onKey({charOrCode: 229}); // fake IME key to cause a search
				}), 100); // long delay that will probably be preempted by keyboard input
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			var key = evt.charOrCode;

			// except for cutting/pasting case - ctrl + x/v
			if(evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == dojo.keys.SHIFT){
				return; // throw out weird key combinations and spurious events
			}
			
			var doSearch = false;
			var pw = this.dropDown;
			var dk = dojo.keys;
			var highlighted = null;
			this._prev_key_backspace = false;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//		1. when drop down is not yet shown:
			//			- if user presses the down arrow key, call loadDropDown()
			//		2. when drop down is already displayed:
			//			- on ESC key, call closeDropDown()
			//			- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case dk.PAGE_DOWN:
				case dk.DOWN_ARROW:
				case dk.PAGE_UP:
				case dk.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					dojo.stopEvent(evt);
					break;

				case dk.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							dojo.stopEvent(evt);
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							dojo.stopEvent(evt);
							break;
						}
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
					// default case:
					// if enter pressed while drop down is open, or for FilteringSelect,
					// if we are in the middle of a query to convert a directly typed in value to an item,
					// prevent submit, but allow event to bubble
					if(this._opened || this._fetchHandle){
					evt.preventDefault();
					}
					// fall through

				case dk.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (
						newvalue == pw._messages["previousMessage"] ||
						newvalue == pw._messages["nextMessage"])
					){
						break;
					}
					if(highlighted){
						this._selectOption();
					}
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;

				case ' ':
					if(highlighted){
						// user is effectively clicking a choice in the drop down menu
						dojo.stopEvent(evt);
						this._selectOption();
						this.closeDropDown();
					}else{
						// user typed a space into the input box, treat as normal character
						doSearch = true;
					}
					break;

				case dk.DELETE:
				case dk.BACKSPACE:
					this._prev_key_backspace = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..)  shouldn't open list.
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					//IME input produces keycode == 229.
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				this.item = undefined; // undefined means item needs to be set
				this.searchTimer = setTimeout(dojo.hitch(this, "_startSearchFromInput"),1);
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			// 		Fill in the textbox with the first item from the drop down
			// 		list, and highlight the characters that were
			// 		auto-completed. For example, if user typed "CA" and the
			// 		drop down list appeared, the textbox would be changed to
			// 		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			dijit.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this._getCaretPos(fn);
				// only try to extend if we added the last character at the end of the input
				if((cpos+1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					dijit.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				dijit.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// summary:
			//		Callback when a search completes.
			// description:
			//		1. generates drop-down list and calls _showResultList() to display it
			//		2. if this result list is from user pressing "more choices"/"previous choices"
			//			then tell screen reader to announce new option
			this._fetchHandle = null;
			if(	this.disabled ||
				this.readOnly ||
				(dataObject.query[this.searchAttr] != this._lastQuery)
			){
				return;
			}
			var wasSelected = this.dropDown._highlighted_option && dojo.hasClass(this.dropDown._highlighted_option, "dijitMenuItemSelected");
			this.dropDown.clearResultList();
			if(!results.length && !this._maxOptions){ // if no results and not just the previous choices button
				this.closeDropDown();
				return;
			}

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			dataObject._maxOptions = this._maxOptions;
			var nodes = this.dropDown.createOptions(
				results,
				dataObject,
				dojo.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if(dataObject.direction){
				if(1 == dataObject.direction){
					this.dropDown.highlightFirstOption();
				}else if(-1 == dataObject.direction){
					this.dropDown.highlightLastOption();
				}
				if(wasSelected){
					this._announceOption(this.dropDown.getHighlightedOption());
				}
			}else if(this.autoComplete && !this._prev_key_backspace
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(dataObject.query[this.searchAttr])){
					this._announceOption(nodes[1]); // 1st real item
			}
		},

		_showResultList: function(){
			// summary:
			//		Display the drop down if not already displayed, or if it is displayed, then
			//		reposition it if necessary (reposition may be necessary if drop down's height changed).

			this.closeDropDown(true);

			// hide the tooltip
			this.displayMessage("");

			this.openDropDown();

			dijit.setWaiState(this.domNode, "expanded", "true");
		},

		loadDropDown: function(/*Function*/ callback){
			// Overrides _HasDropDown.loadDropDown().
			// This is called when user has pressed button icon or pressed the down arrow key
			// to open the drop down.
			
			this._startSearchAll();
		},

		isLoaded: function(){
			// signal to _HasDropDown that it needs to call loadDropDown() to load the
			// drop down asynchronously before displaying it
			return false;
		},

		closeDropDown: function(){
			// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
			// This method is the callback when the user types ESC or clicking
			// the button icon while the drop down is open.  It's also called by other code.
			this._abortQuery();
			if(this._opened){
				this.inherited(arguments);
				dijit.setWaiState(this.domNode, "expanded", "false");
				dijit.removeWaiState(this.focusNode,"activedescendant");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue = this.get('displayedValue');
			var pw = this.dropDown;
			if(pw && (
				newvalue == pw._messages["previousMessage"] ||
				newvalue == pw._messages["nextMessage"]
				)
			){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.set('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true);
				}
				this._refreshState();
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's drop down
			this.closeDropDown();
			this.inherited(arguments);
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			if(!displayedValue){
				displayedValue = this.store.getValue(item, this.searchAttr);
			}
			var value = this._getValueField() != this.searchAttr? this.store.getIdentity(item) : displayedValue;
			this._set("item", item);
			dijit.form.ComboBox.superclass._setValueAttr.call(this, value, priorityChange, displayedValue);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if(node == this.dropDown.nextButton ||
				node == this.dropDown.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				newValue = this.store.getValue(node.item, this.searchAttr).toString();
				this.set('item', node.item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			dijit.setWaiState(this.focusNode, "activedescendant", dojo.attr(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*Event*/ evt){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			if(evt){
				this._announceOption(evt.target);
			}
			this.closeDropDown();
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true); // set this.value and fire onChange
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value.replace(/([\\\*\?])/g, "\\$1"));
		},

		_getQueryString: function(/*String*/ text){
			return dojo.string.substitute(this.queryExpr, [text]);
		},

		_startSearch: function(/*String*/ key){
			// summary:
			//		Starts a search for elements matching key (key=="" means to return all items),
			//		and calls _openResultList() when the search completes, to display the results.
			if(!this.dropDown){
				var popupId = this.id + "_popup",
				dropDownConstructor = dojo.getObject(this.dropDownClass, false);
				this.dropDown = new dropDownConstructor({
					onChange: dojo.hitch(this, this._selectOption),
					id: popupId,
					dir: this.dir
				});
				dijit.removeWaiState(this.focusNode,"activedescendant");
				dijit.setWaiState(this.textbox,"owns",popupId); // associate popup with textbox
			}
			// create a new query to prevent accidentally querying for a hidden
			// value from FilteringSelect's keyField
			var query = dojo.clone(this.query); // #5970
			this._lastInput = key; // Store exactly what was entered by the user.
			this._lastQuery = query[this.searchAttr] = this._getQueryString(key);
			// #5970: set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this.searchTimer=setTimeout(dojo.hitch(this, function(query, _this){
				this.searchTimer = null;
				var fetch = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					query: query,
					onBegin: dojo.hitch(this, "_setMaxOptions"),
					onComplete: dojo.hitch(this, "_openResultList"),
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.ComboBox: ' + errText);
						_this.closeDropDown();
					},
					start: 0,
					count: this.pageSize
				};
				dojo.mixin(fetch, _this.fetchProperties);
				this._fetchHandle = _this.store.fetch(fetch);

				var nextSearch = function(dataObject, direction){
					dataObject.start += dataObject.count*direction;
					// #4091:
					//		tell callback the direction of the paging so the screen
					//		reader knows which menu option to shout
					dataObject.direction = direction;
					this._fetchHandle = this.store.fetch(dataObject);
					this.focus();
				};
				this._nextSearch = this.dropDown.onPage = dojo.hitch(this, nextSearch, this._fetchHandle);
			}, query, this), this.searchDelay);
		},

		_setMaxOptions: function(size, request){
			 this._maxOptions = size;
		},

		_getValueField: function(){
			// summary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit.form._ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.store){
				var srcNodeRef = this.srcNodeRef;

				// if user didn't specify store, then assume there are option tags
				this.store = new dijit.form._ComboBoxDataStore(srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native
				// Select

				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(!("value" in this.params)){
					var item = (this.item = this.store.fetchSelectedItem());
					if(item){
						var valueField = this._getValueField();
						this.value = this.store.getValue(item, valueField);
					}
				}
			}

			this.inherited(arguments);
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label=dojo.query('label[for="'+this.id+'"]');
			if(label.length){
				label[0].id = (this.id+"_label");
				dijit.setWaiState(this.domNode, "labelledby", label[0].id);

			}
			this.inherited(arguments);
		},

		_setHasDownArrowAttr: function(val){
			this.hasDownArrow = val;
			this._buttonNode.style.display = val ? "" : "none";
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelFunc(item, this.store),
				labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._escapeHtml(this._lastInput));
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/ label, /*String*/ find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurrence found. Override this method
			//		to implement your custom highlighting.
			// tags:
			//		protected

			var
				// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
				modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
				i = this.queryExpr.indexOf("${0}");
			find = dojo.regexp.escapeString(find); // escape regexp special chars
			return this._escapeHtml(label).replace(
				// prepend ^ when this.queryExpr == "${0}*" and append $ when this.queryExpr == "*${0}"
				new RegExp((i == 0 ? "^" : "") + "("+ find +")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
				'<span class="dijitComboBoxHighlightMatch">$1</span>'
			); // returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*String*/ str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: &<>"'
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
			return str; // string
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(/*item*/ item, /*dojo.data.store*/ store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354)
			return store.getValue(item, this.labelAttr || this.searchAttr).toString(); // String
		}
	}
);

dojo.declare(
	"dijit.form._ComboBoxMenu",
	[dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
		// summary:
		//		Focus-less menu for internal use in `dijit.form.ComboBox`
		// tags:
		//		private

		templateString: "<ul class='dijitReset dijitMenu' dojoAttachEvent='onmousedown:_onMouseDown,onmouseup:_onMouseUp,onmouseover:_onMouseOver,onmouseout:_onMouseOut' style='overflow: \"auto\"; overflow-x: \"hidden\";'>"
				+"<li class='dijitMenuItem dijitMenuPreviousButton' dojoAttachPoint='previousButton' role='option'></li>"
				+"<li class='dijitMenuItem dijitMenuNextButton' dojoAttachPoint='nextButton' role='option'></li>"
			+"</ul>",

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,
		
		baseClass: "dijitComboBoxMenu",

		postMixInProperties: function(){
			this.inherited(arguments);
			this._messages = dojo.i18n.getLocalization("dijit.form", "ComboBox", this.lang);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
		},

		_setValueAttr: function(/*Object*/ value){
			this.value = value;
			this.onChange(value);
		},

		// stubs
		onChange: function(/*Object*/ value){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked an option in the drop down menu.
			//		Probably should be called onSelect.
			// tags:
			//		callback
		},
		onPage: function(/*Number*/ direction){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._blurOptionNode();
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit.form.FilteringSelect`.

			var menuitem = dojo.create("li", {
				"class": "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl"),
				role: "option"
			});
			var labelObject = labelFunc(item);
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					dojo.doc.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&nbsp;";
			}
			menuitem.item=item;
			return menuitem;
		},

		createOptions: function(results, dataObject, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of dojo.data items
			// dataObject:
			//		dojo.data store
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			//this._dataObject=dataObject;
			//this._dataObject.onComplete=dojo.hitch(comboBox, comboBox._openResultList);
			// display "Previous . . ." button
			this.previousButton.style.display = (dataObject.start == 0) ? "none" : "";
			dojo.attr(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			dojo.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				dojo.attr(menuitem, "id", this.id + i);
				this.domNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			//Try to determine if we should show 'more'...
			if(dataObject._maxOptions && dataObject._maxOptions != -1){
				if((dataObject.start + dataObject.count) < dataObject._maxOptions){
					displayMore = true;
				}else if((dataObject.start + dataObject.count) > dataObject._maxOptions && dataObject.count == results.length){
					//Weird return from a datastore, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					//And more or less assume more if count == results.length
					displayMore = true;
				}
			}else if(dataObject.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			dojo.attr(this.nextButton,"id", this.id + "_next");
			return this.domNode.childNodes;
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			while(this.domNode.childNodes.length>2){
				this.domNode.removeChild(this.domNode.childNodes[this.domNode.childNodes.length-2]);
			}
			this._blurOptionNode();
		},

		_onMouseDown: function(/*Event*/ evt){
			dojo.stopEvent(evt);
		},

		_onMouseUp: function(/*Event*/ evt){
			if(evt.target === this.domNode || !this._highlighted_option){
				// !this._highlighted_option check to prevent immediate selection when menu appears on top
				// of <input>, see #9898.  Note that _HasDropDown also has code to prevent this.
				return;
			}else if(evt.target == this.previousButton){
				this._blurOptionNode();
				this.onPage(-1);
			}else if(evt.target == this.nextButton){
				this._blurOptionNode();
				this.onPage(1);
			}else{
				var tgt = evt.target;
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
				this._setValueAttr({ target: tgt }, true);
			}
		},

		_onMouseOver: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			var tgt = evt.target;
			if(!(tgt == this.previousButton || tgt == this.nextButton)){
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
			}
			this._focusOptionNode(tgt);
		},

		_onMouseOut: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			this._blurOptionNode();
		},

		_focusOptionNode: function(/*DomNode*/ node){
			// summary:
			//		Does the actual highlight.
			if(this._highlighted_option != node){
				this._blurOptionNode();
				this._highlighted_option = node;
				dojo.addClass(this._highlighted_option, "dijitMenuItemSelected");
			}
		},

		_blurOptionNode: function(){
			// summary:
			//		Removes highlight on highlighted option.
			if(this._highlighted_option){
				dojo.removeClass(this._highlighted_option, "dijitMenuItemSelected");
				this._highlighted_option = null;
			}
		},

		_highlightNextOption: function(){
			// summary:
			// 		Highlight the item just below the current selection.
			// 		If nothing selected, highlight first option.

			// because each press of a button clears the menu,
			// the highlighted option sometimes becomes detached from the menu!
			// test to see if the option has a parent to see if this is the case.
			if(!this.getHighlightedOption()){
				var fc = this.domNode.firstChild;
				this._focusOptionNode(fc.style.display == "none" ? fc.nextSibling : fc);
			}else{
				var ns = this._highlighted_option.nextSibling;
				if(ns && ns.style.display != "none"){
					this._focusOptionNode(ns);
				}else{
					this.highlightFirstOption();
				}
			}
			// scrollIntoView is called outside of _focusOptionNode because in IE putting it inside causes the menu to scroll up on mouseover
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		highlightFirstOption: function(){
			// summary:
			// 		Highlight the first real item in the list (not Previous Choices).
			var first = this.domNode.firstChild;
			var second = first.nextSibling;
			this._focusOptionNode(second.style.display == "none" ? first : second); // remotely possible that Previous Choices is the only thing in the list
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		highlightLastOption: function(){
			// summary:
			// 		Highlight the last real item in the list (not More Choices).
			this._focusOptionNode(this.domNode.lastChild.previousSibling);
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		_highlightPrevOption: function(){
			// summary:
			// 		Highlight the item just above the current selection.
			// 		If nothing selected, highlight last option (if
			// 		you select Previous and try to keep scrolling up the list).
			if(!this.getHighlightedOption()){
				var lc = this.domNode.lastChild;
				this._focusOptionNode(lc.style.display == "none" ? lc.previousSibling : lc);
			}else{
				var ps = this._highlighted_option.previousSibling;
				if(ps && ps.style.display != "none"){
					this._focusOptionNode(ps);
				}else{
					this.highlightLastOption();
				}
			}
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = dojo.style(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this._highlightNextOption();
			}
			while(scrollamount<height){
				if(up){
					// stop at option 1
					if(!this.getHighlightedOption().previousSibling ||
						this._highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this._highlightPrevOption();
				}else{
					// stop at last option
					if(!this.getHighlightedOption().nextSibling ||
						this._highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this._highlightNextOption();
				}
				// going backwards
				var newscroll=this.domNode.scrollTop;
				scrollamount+=(newscroll-oldscroll)*(up ? -1:1);
				oldscroll=newscroll;
			}
		},

		pageUp: function(){
			// summary:
			//		Handles pageup keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(true);
		},

		pageDown: function(){
			// summary:
			//		Handles pagedown keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(false);
		},

		getHighlightedOption: function(){
			// summary:
			//		Returns the highlighted option.
			var ho = this._highlighted_option;
			return (ho && ho.parentNode) ? ho : null;
		},

		handleKey: function(evt){
			// summary:
			//		Handle keystroke event forwarded from ComboBox, returning false if it's
			//		a keystroke I recognize and process, true otherwise.
			switch(evt.charOrCode){
				case dojo.keys.DOWN_ARROW:
					this._highlightNextOption();
					return false;
				case dojo.keys.PAGE_DOWN:
					this.pageDown();
					return false;
				case dojo.keys.UP_ARROW:
					this._highlightPrevOption();
					return false;
				case dojo.keys.PAGE_UP:
					this.pageUp();
					return false;
				default:
					return true;
			}
		}
	}
);

dojo.declare(
	"dijit.form.ComboBox",
	[dijit.form.ValidationTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		Auto-completing text box, and base class for dijit.form.FilteringSelect.
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			this._set("item", null); // value not looked up in store
			if(!value){ value = ''; } // null translates to blank
			dijit.form.ValidationTextBox.prototype._setValueAttr.call(this, value, priorityChange, displayedValue);
		}
	}
);

dojo.declare("dijit.form._ComboBoxDataStore", null, {
	// summary:
	//		Inefficient but small data store specialized for inlined `dijit.form.ComboBox` data
	//
	// description:
	//		Provides a store for inlined data like:
	//
	//	|	<select>
	//	|		<option value="AL">Alabama</option>
	//	|		...
	//
	//		Actually. just implements the subset of dojo.data.Read/Notification
	//		needed for ComboBox and FilteringSelect to work.
	//
	//		Note that an item is just a pointer to the <option> DomNode.

	constructor: function( /*DomNode*/ root){
		this.root = root;
		if(root.tagName != "SELECT" && root.firstChild){
			root = dojo.query("select", root);
			if(root.length > 0){ // SELECT is a child of srcNodeRef
				root = root[0];
			}else{ // no select, so create 1 to parent the option tags to define selectedIndex
				this.root.innerHTML = "<SELECT>"+this.root.innerHTML+"</SELECT>";
				root = this.root.firstChild;
			}
			this.root = root;
		}
		dojo.query("> option", root).forEach(function(node){
			//	TODO: this was added in #3858 but unclear why/if it's needed;  doesn't seem to be.
			//	If it is needed then can we just hide the select itself instead?
			//node.style.display="none";
			node.innerHTML = dojo.trim(node.innerHTML);
		});

	},

	getValue: function(	/*item*/ item,
						/*attribute-name-string*/ attribute,
						/*value?*/ defaultValue){
		return (attribute == "value") ? item.value : (item.innerText || item.textContent || '');
	},

	isItemLoaded: function(/*anything*/ something){
		return true;
	},

	getFeatures: function(){
		return {"dojo.data.api.Read": true, "dojo.data.api.Identity": true};
	},

	_fetchItems: function(	/*Object*/ args,
							/*Function*/ findCallback,
							/*Function*/ errorCallback){
		// summary:
		//		See dojo.data.util.simpleFetch.fetch()
		if(!args.query){ args.query = {}; }
		if(!args.query.name){ args.query.name = ""; }
		if(!args.queryOptions){ args.queryOptions = {}; }
		var matcher = dojo.data.util.filter.patternToRegExp(args.query.name, args.queryOptions.ignoreCase),
			items = dojo.query("> option", this.root).filter(function(option){
				return (option.innerText || option.textContent || '').match(matcher);
			} );
		if(args.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(args.sort, this));
		}
		findCallback(items, args);
	},

	close: function(/*dojo.data.api.Request || args || null*/ request){
		return;
	},

	getLabel: function(/*item*/ item){
		return item.innerHTML;
	},

	getIdentity: function(/*item*/ item){
		return dojo.attr(item, "value");
	},

	fetchItemByIdentity: function(/*Object*/ args){
		// summary:
		//		Given the identity of an item, this method returns the item that has
		//		that identity through the onItem callback.
		//		Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.
		//
		// description:
		//		Given arguments like:
		//
		//	|		{identity: "CA", onItem: function(item){...}
		//
		//		Call `onItem()` with the DOM node `<option value="CA">California</option>`
		var item = dojo.query("> option[value='" + args.identity + "']", this.root)[0];
		args.onItem(item);
	},

	fetchSelectedItem: function(){
		// summary:
		//		Get the option marked as selected, like `<option selected>`.
		//		Not part of dojo.data API.
		var root = this.root,
			si = root.selectedIndex;
		return typeof si == "number"
			? dojo.query("> option:nth-child(" + (si != -1 ? si+1 : 1) + ")", root)[0]
			: null;	// dojo.data.Item
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dijit.form._ComboBoxDataStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dijit.form.FilteringSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.FilteringSelect"] = true;
dojo.provide("dijit.form.FilteringSelect");



dojo.declare(
	"dijit.form.FilteringSelect",
	[dijit.form.MappedTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//			- There is a drop down list of possible values.
		//			- You can only enter a value from the drop down list.  (You can't
		//				enter an arbitrary value.)
		//			- The value submitted with the form is the hidden value (ex: CA),
		//				not the displayed value a.k.a. label (ex: California)
		//
		//		Enhancements over plain HTML version:
		//			- If you type in some text then it will filter down the list of
		//				possible values in the drop down list.
		//			- List can be specified either as a static list or via a javascript
		//				function (that can get the list from a server)

		// required: Boolean
		//		True (default) if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		_isValidSubset: function(){
			return this._opened;
		},

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return this.item || (!this.required && this.get('displayedValue') == ""); // #5974
		},

		_refreshState: function(){
			if(!this.searchTimer){ // state will be refreshed after results are returned
				this.inherited(arguments);
			}
		},

		_callbackSetLabel: function(
						/*Array*/ result,
						/*Object*/ dataObject,
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback from dojo.data after lookup of user entered value finishes

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((dataObject && dataObject.query[this.searchAttr] != this._lastQuery) || (!dataObject && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: don't modify display value on bad input
				//#3285: change CSS to indicate error
				this.valueNode.value = "";
				dijit.form.TextBox.superclass._setValueAttr.call(this, "", priorityChange || (priorityChange === undefined && !this._focused));
				this._set("item", null);
				this.validate(this._focused);
			}else{
				this.set('item', result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// Callback when a data store query completes.
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(dataObject.query[this.searchAttr] != this._lastQuery){
				return;
			}
			dijit.form.ComboBoxMixin.prototype._openResultList.apply(this, arguments);

			if(this.item === undefined){ // item == undefined for keyboard search
				// If the search returned no items that means that the user typed
				// in something invalid (and they can't make it valid by typing more characters),
				// so flag the FilteringSelect as being in an invalid state
				this.validate(true);
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for get('value') to work.

			// don't get the textbox value but rather the previously set hidden value.
			// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }
			this._lastQuery = value;

			if(value === null || value === ''){
				this._setDisplayedValueAttr('', priorityChange);
				return;
			}

			//#3347: fetchItemByIdentity if no keyAttr specified
			var self = this;
			this.store.fetchItemByIdentity({
				identity: value,
				onItem: function(item){
					self._callbackSetLabel(item? [item] : [], undefined, priorityChange);
				}
			});
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			this.inherited(arguments);
			this.valueNode.value = this.value;
			this._lastDisplayedValue = this.textbox.value;
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.  label should corresponding to item.searchAttr.

			if(label == null){ label = ''; }

			// This is called at initialization along with every custom setter.
			// Usually (or always?) the call can be ignored.   If it needs to be
			// processed then at least make sure that the XHR request doesn't trigger an onChange()
			// event, even if it returns after creation has finished
			if(!this._created){
				if(!("displayedValue" in this.params)){
					return;
				}
				priorityChange = false;
			}

			// Do a reverse lookup to map the specified displayedValue to the hidden value.
			// Note that if there's a custom labelFunc() this code
			if(this.store){
				this.closeDropDown();
				var query = dojo.clone(this.query); // #6196: populate query with user-specifics
				// escape meta characters of dojo.data.util.filter.patternToRegExp().
				this._lastQuery = query[this.searchAttr] = this._getDisplayQueryString(label);
				// If the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox.   Set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				this._set("displayedValue", label);	// for watch("displayedValue") notification
				var _this = this;
				var fetch = {
					query: query,
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					onComplete: function(result, dataObject){
						_this._fetchHandle = null;
						dojo.hitch(_this, "_callbackSetLabel")(result, dataObject, priorityChange);
					},
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.FilteringSelect: ' + errText);
						dojo.hitch(_this, "_callbackSetLabel")([], undefined, false);
					}
				};
				dojo.mixin(fetch, this.fetchProperties);
				this._fetchHandle = this.store.fetch(fetch);
			}
		},

		undo: function(){
			this.set('displayedValue', this._lastDisplayedValue);
		}
	}
);

}

if(!dojo._hasResource["dijit.dijit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.dijit"] = true;
dojo.provide("dijit.dijit");









/*=====
dijit.dijit = {
	// summary:
	//		A roll-up for common dijit methods
	// description:
	//	A rollup file for the build system including the core and common
	//	dijit files.
	//
	// example:
	// | <script type="text/javascript" src="js/dojo/dijit/dijit.js"></script>
	//
};
=====*/

// All the stuff in _base (these are the function that are guaranteed available without an explicit dojo.require)

// And some other stuff that we tend to pull in all the time anyway

}

if(!dojo._hasResource["dojox.html.metrics"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html.metrics"] = true;
dojo.provide("dojox.html.metrics");

(function(){
	var dhm = dojox.html.metrics;

	//	derived from Morris John's emResized measurer
	dhm.getFontMeasurements = function(){
		//	summary
		//	Returns an object that has pixel equivilents of standard font size values.
		var heights = {
			'1em':0, '1ex':0, '100%':0, '12pt':0, '16px':0, 'xx-small':0, 'x-small':0,
			'small':0, 'medium':0, 'large':0, 'x-large':0, 'xx-large':0
		};
	
		if(dojo.isIE){
			//	we do a font-size fix if and only if one isn't applied already.
			//	NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			dojo.doc.documentElement.style.fontSize="100%";
		}
	
		//	set up the measuring node.
		var div=dojo.doc.createElement("div");
		var ds = div.style;
		ds.position="absolute";
		ds.left="-100px";
		ds.top="0";
		ds.width="30px";
		ds.height="1000em";
		ds.borderWidth="0";
		ds.margin="0";
		ds.padding="0";
		ds.outline="0";
		ds.lineHeight="1";
		ds.overflow="hidden";
		dojo.body().appendChild(div);
	
		//	do the measurements.
		for(var p in heights){
			ds.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}
		
		dojo.body().removeChild(div);
		div = null;
		return heights; 	//	object
	};

	var fontMeasurements = null;
	
	dhm.getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = dhm.getFontMeasurements();
		}
		return fontMeasurements;
	};

	var measuringNode = null, empty = {};
	dhm.getTextBox = function(/* String */ text, /* Object */ style, /* String? */ className){
		var m, s;
		if(!measuringNode){
			m = measuringNode = dojo.doc.createElement("div");
			// Container that we can set contraints on so that it doesn't
			// trigger a scrollbar.
			var c = dojo.doc.createElement("div");
			c.appendChild(m);
			s = c.style;
			s.overflow='scroll';
			s.position = "absolute";
			s.left = "0px";
			s.top = "-10000px";
			s.width = "1px";
			s.height = "1px";
			s.visibility = "hidden";
			s.borderWidth = "0";
			s.margin = "0";
			s.padding = "0";
			s.outline = "0";
			dojo.body().appendChild(c);
		}else{
			m = measuringNode;
		}
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(arguments.length > 1 && style){
			for(var i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(arguments.length > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;
		var box = dojo.position(m);
		// position doesn't report right (reports 1, since parent is 1)
		// So we have to look at the scrollWidth to get the real width
		// Height is right.
		box.w = m.parentNode.scrollWidth;
		return box;
	};

	//	determine the scrollbar sizes on load.
	var scroll={ w:16, h:16 };
	dhm.getScrollbar=function(){ return { w:scroll.w, h:scroll.h }; };

	dhm._fontResizeNode = null;

	dhm.initOnFontResize = function(interval){
		var f = dhm._fontResizeNode = dojo.doc.createElement("iframe");
		var fs = f.style;
		fs.position = "absolute";
		fs.width = "5em";
		fs.height = "10em";
		fs.top = "-10000px";
		if(dojo.isIE){
			f.onreadystatechange = function(){
				if(f.contentWindow.document.readyState == "complete"){
					f.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
				}
			};
		}else{
			f.onload = function(){
				f.contentWindow.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
			};
		}
		//The script tag is to work around a known firebug race condition.  See comments in bug #9046
		f.setAttribute("src", "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'");
		dojo.body().appendChild(f);
		dhm.initOnFontResize = function(){};
	};

	dhm.onFontResize = function(){};
	dhm._fontresize = function(){
		dhm.onFontResize();
	}

	dojo.addOnUnload(function(){
		// destroy our font resize iframe if we have one
		var f = dhm._fontResizeNode;
		if(f){
			if(dojo.isIE && f.onresize){
				f.onresize = null;
			}else if(f.contentWindow && f.contentWindow.onresize){
				f.contentWindow.onresize = null;
			}
			dhm._fontResizeNode = null;
		}
	});

	dojo.addOnLoad(function(){
		// getScrollbar metrics node
		try{
			var n=dojo.doc.createElement("div");
			n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
			dojo.body().appendChild(n);
			scroll.w = n.offsetWidth - n.clientWidth;
			scroll.h = n.offsetHeight - n.clientHeight;
			dojo.body().removeChild(n);
			//console.log("Scroll bar dimensions: ", scroll);
			delete n;
		}catch(e){}

		// text size poll setup
		if("fontSizeWatch" in dojo.config && !!dojo.config.fontSizeWatch){
			dhm.initOnFontResize();
		}
	});
})();

}

if(!dojo._hasResource["dojox.grid.util"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.util"] = true;
dojo.provide("dojox.grid.util");

// summary: grid utility library
(function(){
	var dgu = dojox.grid.util;

	dgu.na = '...';
	dgu.rowIndexTag = "gridRowIndex";
	dgu.gridViewTag = "gridView";


	dgu.fire = function(ob, ev, args){
		var fn = ob && ev && ob[ev];
		return fn && (args ? fn.apply(ob, args) : ob[ev]());
	};
	
	dgu.setStyleHeightPx = function(inElement, inHeight){
		if(inHeight >= 0){
			var s = inElement.style;
			var v = inHeight + 'px';
			if(inElement && s['height'] != v){
				s['height'] = v;
			}
		}
	};
	
	dgu.mouseEvents = [ 'mouseover', 'mouseout', /*'mousemove',*/ 'mousedown', 'mouseup', 'click', 'dblclick', 'contextmenu' ];

	dgu.keyEvents = [ 'keyup', 'keydown', 'keypress' ];

	dgu.funnelEvents = function(inNode, inObject, inMethod, inEvents){
		var evts = (inEvents ? inEvents : dgu.mouseEvents.concat(dgu.keyEvents));
		for (var i=0, l=evts.length; i<l; i++){
			inObject.connect(inNode, 'on' + evts[i], inMethod);
		}
	};

	dgu.removeNode = function(inNode){
		inNode = dojo.byId(inNode);
		inNode && inNode.parentNode && inNode.parentNode.removeChild(inNode);
		return inNode;
	};
	
	dgu.arrayCompare = function(inA, inB){
		for(var i=0,l=inA.length; i<l; i++){
			if(inA[i] != inB[i]){return false;}
		}
		return (inA.length == inB.length);
	};
	
	dgu.arrayInsert = function(inArray, inIndex, inValue){
		if(inArray.length <= inIndex){
			inArray[inIndex] = inValue;
		}else{
			inArray.splice(inIndex, 0, inValue);
		}
	};
	
	dgu.arrayRemove = function(inArray, inIndex){
		inArray.splice(inIndex, 1);
	};
	
	dgu.arraySwap = function(inArray, inI, inJ){
		var cache = inArray[inI];
		inArray[inI] = inArray[inJ];
		inArray[inJ] = cache;
	};
})();

}

if(!dojo._hasResource["dojox.grid._Scroller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Scroller"] = true;
dojo.provide("dojox.grid._Scroller");

(function(){
	var indexInParent = function(inNode){
		var i=0, n, p=inNode.parentNode;
		while((n = p.childNodes[i++])){
			if(n == inNode){
				return i - 1;
			}
		}
		return -1;
	};
	
	var cleanNode = function(inNode){
		if(!inNode){
			return;
		}
		var filter = function(inW){
			return inW.domNode && dojo.isDescendant(inW.domNode, inNode, true);
		};
		var ws = dijit.registry.filter(filter);
		for(var i=0, w; (w=ws[i]); i++){
			w.destroy();
		}
		delete ws;
	};

	var getTagName = function(inNodeOrId){
		var node = dojo.byId(inNodeOrId);
		return (node && node.tagName ? node.tagName.toLowerCase() : '');
	};
	
	var nodeKids = function(inNode, inTag){
		var result = [];
		var i=0, n;
		while((n = inNode.childNodes[i])){
			i++;
			if(getTagName(n) == inTag){
				result.push(n);
			}
		}
		return result;
	};
	
	var divkids = function(inNode){
		return nodeKids(inNode, 'div');
	};

	dojo.declare("dojox.grid._Scroller", null, {
		constructor: function(inContentNodes){
			this.setContentNodes(inContentNodes);
			this.pageHeights = [];
			this.pageNodes = [];
			this.stack = [];
		},
		// specified
		rowCount: 0, // total number of rows to manage
		defaultRowHeight: 32, // default height of a row
		keepRows: 100, // maximum number of rows that should exist at one time
		contentNode: null, // node to contain pages
		scrollboxNode: null, // node that controls scrolling
		// calculated
		defaultPageHeight: 0, // default height of a page
		keepPages: 10, // maximum number of pages that should exists at one time
		pageCount: 0,
		windowHeight: 0,
		firstVisibleRow: 0,
		lastVisibleRow: 0,
		averageRowHeight: 0, // the average height of a row
		// private
		page: 0,
		pageTop: 0,
		// init
		init: function(inRowCount, inKeepRows, inRowsPerPage){
			switch(arguments.length){
				case 3: this.rowsPerPage = inRowsPerPage;
				case 2: this.keepRows = inKeepRows;
				case 1: this.rowCount = inRowCount;
				default: break;
			}
			this.defaultPageHeight = this.defaultRowHeight * this.rowsPerPage;
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			this.setKeepInfo(this.keepRows);
			this.invalidate();
			if(this.scrollboxNode){
				this.scrollboxNode.scrollTop = 0;
				this.scroll(0);
				this.scrollboxNode.onscroll = dojo.hitch(this, 'onscroll');
			}
		},
		_getPageCount: function(rowCount, rowsPerPage){
			return rowCount ? (Math.ceil(rowCount / rowsPerPage) || 1) : 0;
		},
		destroy: function(){
			this.invalidateNodes();
			delete this.contentNodes;
			delete this.contentNode;
			delete this.scrollboxNode;
		},
		setKeepInfo: function(inKeepRows){
			this.keepRows = inKeepRows;
			this.keepPages = !this.keepRows ? this.keepPages : Math.max(Math.ceil(this.keepRows / this.rowsPerPage), 2);
		},
		// nodes
		setContentNodes: function(inNodes){
			this.contentNodes = inNodes;
			this.colCount = (this.contentNodes ? this.contentNodes.length : 0);
			this.pageNodes = [];
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i] = [];
			}
		},
		getDefaultNodes: function(){
			return this.pageNodes[0] || [];
		},
		// updating
		invalidate: function(){
			this._invalidating = true;
			this.invalidateNodes();
			this.pageHeights = [];
			this.height = (this.pageCount ? (this.pageCount - 1)* this.defaultPageHeight + this.calcLastPageHeight() : 0);
			this.resize();
			this._invalidating = false;
		},
		updateRowCount: function(inRowCount){
			this.invalidateNodes();
			this.rowCount = inRowCount;
			// update page count, adjust document height
			var oldPageCount = this.pageCount;
			if(oldPageCount === 0){
				//We want to have at least 1px in height to keep scroller.  Otherwise with an
				//empty grid you can't scroll to see the header.
				this.height = 1;
			}
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			if(this.pageCount < oldPageCount){
				for(var i=oldPageCount-1; i>=this.pageCount; i--){
					this.height -= this.getPageHeight(i);
					delete this.pageHeights[i];
				}
			}else if(this.pageCount > oldPageCount){
				this.height += this.defaultPageHeight * (this.pageCount - oldPageCount - 1) + this.calcLastPageHeight();
			}
			this.resize();
		},
		// implementation for page manager
		pageExists: function(inPageIndex){
			return Boolean(this.getDefaultPageNode(inPageIndex));
		},
		measurePage: function(inPageIndex){
			if(this.grid.rowHeight){
				var height = this.grid.rowHeight + 1;
				return ((inPageIndex + 1) * this.rowsPerPage > this.rowCount ?
					this.rowCount - inPageIndex * this.rowsPerPage :
					this.rowsPerPage) * height;
					 
			}
			var n = this.getDefaultPageNode(inPageIndex);
			return (n && n.innerHTML) ? n.offsetHeight : undefined;
		},
		positionPage: function(inPageIndex, inPos){
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i][inPageIndex].style.top = inPos + 'px';
			}
		},
		repositionPages: function(inPageIndex){
			var nodes = this.getDefaultNodes();
			var last = 0;

			for(var i=0; i<this.stack.length; i++){
				last = Math.max(this.stack[i], last);
			}
			//
			var n = nodes[inPageIndex];
			var y = (n ? this.getPageNodePosition(n) + this.getPageHeight(inPageIndex) : 0);
			for(var p=inPageIndex+1; p<=last; p++){
				n = nodes[p];
				if(n){
					if(this.getPageNodePosition(n) == y){
						return;
					}
					this.positionPage(p, y);
				}
				y += this.getPageHeight(p);
			}
		},
		installPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				this.contentNodes[i].appendChild(this.pageNodes[i][inPageIndex]);
			}
		},
		preparePage: function(inPageIndex, inReuseNode){
			var p = (inReuseNode ? this.popPage() : null);
			for(var i=0; i<this.colCount; i++){
				var nodes = this.pageNodes[i];
				var new_p = (p === null ? this.createPageNode() : this.invalidatePageNode(p, nodes));
				new_p.pageIndex = inPageIndex;
				nodes[inPageIndex] = new_p;
			}
		},
		// rendering implementation
		renderPage: function(inPageIndex){
			var nodes = [];
			var i, j;
			for(i=0; i<this.colCount; i++){
				nodes[i] = this.pageNodes[i][inPageIndex];
			}
			for(i=0, j=inPageIndex*this.rowsPerPage; (i<this.rowsPerPage)&&(j<this.rowCount); i++, j++){
				this.renderRow(j, nodes);
			}
		},
		removePage: function(inPageIndex){
			for(var i=0, j=inPageIndex*this.rowsPerPage; i<this.rowsPerPage; i++, j++){
				this.removeRow(j);
			}
		},
		destroyPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				var n = this.invalidatePageNode(inPageIndex, this.pageNodes[i]);
				if(n){
					dojo.destroy(n);
				}
			}
		},
		pacify: function(inShouldPacify){
		},
		// pacification
		pacifying: false,
		pacifyTicks: 200,
		setPacifying: function(inPacifying){
			if(this.pacifying != inPacifying){
				this.pacifying = inPacifying;
				this.pacify(this.pacifying);
			}
		},
		startPacify: function(){
			this.startPacifyTicks = new Date().getTime();
		},
		doPacify: function(){
			var result = (new Date().getTime() - this.startPacifyTicks) > this.pacifyTicks;
			this.setPacifying(true);
			this.startPacify();
			return result;
		},
		endPacify: function(){
			this.setPacifying(false);
		},
		// default sizing implementation
		resize: function(){
			if(this.scrollboxNode){
				this.windowHeight = this.scrollboxNode.clientHeight;
			}
			for(var i=0; i<this.colCount; i++){
				//We want to have 1px in height min to keep scroller.  Otherwise can't scroll
				//and see header in empty grid.
				dojox.grid.util.setStyleHeightPx(this.contentNodes[i], Math.max(1,this.height));
			}
			
			// Calculate the average row height and update the defaults (row and page).
			var needPage = (!this._invalidating);
			if(!needPage){
				var ah = this.grid.get("autoHeight");
				if(typeof ah == "number" && ah <= Math.min(this.rowsPerPage, this.rowCount)){
					needPage = true;
				}
			}
			if(needPage){
				this.needPage(this.page, this.pageTop);
			}
			var rowsOnPage = (this.page < this.pageCount - 1) ? this.rowsPerPage : ((this.rowCount % this.rowsPerPage) || this.rowsPerPage);
			var pageHeight = this.getPageHeight(this.page);
			this.averageRowHeight = (pageHeight > 0 && rowsOnPage > 0) ? (pageHeight / rowsOnPage) : 0;
		},
		calcLastPageHeight: function(){
			if(!this.pageCount){
				return 0;
			}
			var lastPage = this.pageCount - 1;
			var lastPageHeight = ((this.rowCount % this.rowsPerPage)||(this.rowsPerPage)) * this.defaultRowHeight;
			this.pageHeights[lastPage] = lastPageHeight;
			return lastPageHeight;
		},
		updateContentHeight: function(inDh){
			this.height += inDh;
			this.resize();
		},
		updatePageHeight: function(inPageIndex, fromBuild, fromAsynRendering){
			if(this.pageExists(inPageIndex)){
				var oh = this.getPageHeight(inPageIndex);
				var h = (this.measurePage(inPageIndex));
				if(h === undefined){
					h = oh;
				}
				this.pageHeights[inPageIndex] = h;
				if(oh != h){
					this.updateContentHeight(h - oh);
					var ah = this.grid.get("autoHeight");
					if((typeof ah == "number" && ah > this.rowCount)||(ah === true && !fromBuild)){
						if(!fromAsynRendering){
							this.grid.sizeChange();
						}else{//fix #11101 by using fromAsynRendering to avoid deadlock
							var ns = this.grid.viewsNode.style;
							ns.height = parseInt(ns.height) + h - oh + 'px';
							this.repositionPages(inPageIndex);
						}
					}else{
						this.repositionPages(inPageIndex);
					}
				}
				return h;
			}
			return 0;
		},
		rowHeightChanged: function(inRowIndex, fromAsynRendering){
			this.updatePageHeight(Math.floor(inRowIndex / this.rowsPerPage), false, fromAsynRendering);
		},
		// scroller core
		invalidateNodes: function(){
			while(this.stack.length){
				this.destroyPage(this.popPage());
			}
		},
		createPageNode: function(){
			var p = document.createElement('div');
			dojo.attr(p,"role","presentation");
			p.style.position = 'absolute';
			//p.style.width = '100%';
			p.style[dojo._isBodyLtr() ? "left" : "right"] = '0';
			return p;
		},
		getPageHeight: function(inPageIndex){
			var ph = this.pageHeights[inPageIndex];
			return (ph !== undefined ? ph : this.defaultPageHeight);
		},
		// FIXME: this is not a stack, it's a FIFO list
		pushPage: function(inPageIndex){
			return this.stack.push(inPageIndex);
		},
		popPage: function(){
			return this.stack.shift();
		},
		findPage: function(inTop){
			var i = 0, h = 0;
			for(var ph = 0; i<this.pageCount; i++, h += ph){
				ph = this.getPageHeight(i);
				if(h + ph >= inTop){
					break;
				}
			}
			this.page = i;
			this.pageTop = h;
		},
		buildPage: function(inPageIndex, inReuseNode, inPos){
			this.preparePage(inPageIndex, inReuseNode);
			this.positionPage(inPageIndex, inPos);
			// order of operations is key below
			this.installPage(inPageIndex);
			this.renderPage(inPageIndex);
			// order of operations is key above
			this.pushPage(inPageIndex);
		},
		needPage: function(inPageIndex, inPos){
			var h = this.getPageHeight(inPageIndex), oh = h;
			if(!this.pageExists(inPageIndex)){
				this.buildPage(inPageIndex, (!this.grid._autoHeight/*fix #10543*/ && this.keepPages&&(this.stack.length >= this.keepPages)), inPos);
				h = this.updatePageHeight(inPageIndex, true);
			}else{
				this.positionPage(inPageIndex, inPos);
			}
			return h;
		},
		onscroll: function(){
			this.scroll(this.scrollboxNode.scrollTop);
		},
		scroll: function(inTop){
			this.grid.scrollTop = inTop;
			if(this.colCount){
				this.startPacify();
				this.findPage(inTop);
				var h = this.height;
				var b = this.getScrollBottom(inTop);
				for(var p=this.page, y=this.pageTop; (p<this.pageCount)&&((b<0)||(y<b)); p++){
					y += this.needPage(p, y);
				}
				this.firstVisibleRow = this.getFirstVisibleRow(this.page, this.pageTop, inTop);
				this.lastVisibleRow = this.getLastVisibleRow(p - 1, y, b);
				// indicates some page size has been updated
				if(h != this.height){
					this.repositionPages(p-1);
				}
				this.endPacify();
			}
		},
		getScrollBottom: function(inTop){
			return (this.windowHeight >= 0 ? inTop + this.windowHeight : -1);
		},
		// events
		processNodeEvent: function(e, inNode){
			var t = e.target;
			while(t && (t != inNode) && t.parentNode && (t.parentNode.parentNode != inNode)){
				t = t.parentNode;
			}
			if(!t || !t.parentNode || (t.parentNode.parentNode != inNode)){
				return false;
			}
			var page = t.parentNode;
			e.topRowIndex = page.pageIndex * this.rowsPerPage;
			e.rowIndex = e.topRowIndex + indexInParent(t);
			e.rowTarget = t;
			return true;
		},
		processEvent: function(e){
			return this.processNodeEvent(e, this.contentNode);
		},
		// virtual rendering interface
		renderRow: function(inRowIndex, inPageNode){
		},
		removeRow: function(inRowIndex){
		},
		// page node operations
		getDefaultPageNode: function(inPageIndex){
			return this.getDefaultNodes()[inPageIndex];
		},
		positionPageNode: function(inNode, inPos){
		},
		getPageNodePosition: function(inNode){
			return inNode.offsetTop;
		},
		invalidatePageNode: function(inPageIndex, inNodes){
			var p = inNodes[inPageIndex];
			if(p){
				delete inNodes[inPageIndex];
				this.removePage(inPageIndex, p);
				cleanNode(p);
				p.innerHTML = '';
			}
			return p;
		},
		// scroll control
		getPageRow: function(inPage){
			return inPage * this.rowsPerPage;
		},
		getLastPageRow: function(inPage){
			return Math.min(this.rowCount, this.getPageRow(inPage + 1)) - 1;
		},
		getFirstVisibleRow: function(inPage, inPageTop, inScrollTop){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var row = this.getPageRow(inPage);
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[inPage]);
			for(var i=0,l=rows.length; i<l && inPageTop<inScrollTop; i++, row++){
				inPageTop += rows[i].offsetHeight;
			}
			return (row ? row - 1 : row);
		},
		getLastVisibleRow: function(inPage, inBottom, inScrollBottom){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var nodes = this.getDefaultNodes();
			var row = this.getLastPageRow(inPage);
			var rows = divkids(nodes[inPage]);
			for(var i=rows.length-1; i>=0 && inBottom>inScrollBottom; i--, row--){
				inBottom -= rows[i].offsetHeight;
			}
			return row + 1;
		},
		findTopRow: function(inScrollTop){
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[this.page]);
			for(var i=0,l=rows.length,t=this.pageTop,h; i<l; i++){
				h = rows[i].offsetHeight;
				t += h;
				if(t >= inScrollTop){
					this.offset = h - (t - inScrollTop);
					return i + this.page * this.rowsPerPage;
				}
			}
			return -1;
		},
		findScrollTop: function(inRow){
			var rowPage = Math.floor(inRow / this.rowsPerPage);
			var t = 0;
			var i, l;
			for(i=0; i<rowPage; i++){
				t += this.getPageHeight(i);
			}
			this.pageTop = t;
			this.page = rowPage;//fix #10543
			this.needPage(rowPage, this.pageTop);

			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[rowPage]);
			var r = inRow - this.rowsPerPage * rowPage;
			for(i=0,l=rows.length; i<l && i<r; i++){
				t += rows[i].offsetHeight;
			}
			return t;
		},
		dummy: 0
	});
})();

}

if(!dojo._hasResource["dojox.grid.cells._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.cells._base"] = true;
dojo.provide("dojox.grid.cells._base");




dojo.declare("dojox.grid._DeferredTextWidget", dijit._Widget, {
	deferred: null,
	_destroyOnRemove: true,
	postCreate: function(){
		if(this.deferred){
			this.deferred.addBoth(dojo.hitch(this, function(text){
				if(this.domNode){
					this.domNode.innerHTML = text;
				}
			}));
		}
	}
});

(function(){
	var focusSelectNode = function(inNode){
		try{
			dojox.grid.util.fire(inNode, "focus");
			dojox.grid.util.fire(inNode, "select");
		}catch(e){// IE sux bad
		}
	};
	
	var whenIdle = function(/*inContext, inMethod, args ...*/){
		setTimeout(dojo.hitch.apply(dojo, arguments), 0);
	};

	var dgc = dojox.grid.cells;

	dojo.declare("dojox.grid.cells._Base", null, {
		// summary:
		//	Respresents a grid cell and contains information about column options and methods
		//	for retrieving cell related information.
		//	Each column in a grid layout has a cell object and most events and many methods
		//	provide access to these objects.
		styles: '',
		classes: '',
		editable: false,
		alwaysEditing: false,
		formatter: null,
		defaultValue: '...',
		value: null,
		hidden: false,
		noresize: false,
		draggable: true,
		//private
		_valueProp: "value",
		_formatPending: false,

		constructor: function(inProps){
			this._props = inProps || {};
			dojo.mixin(this, inProps);
			if(this.draggable === undefined){
				this.draggable = true;
			}
		},

		_defaultFormat: function(inValue, callArgs){
			var s = this.grid.formatterScope || this;
			var f = this.formatter;
			if(f && s && typeof f == "string"){
				f = this.formatter = s[f];
			}
			var v = (inValue != this.defaultValue && f) ? f.apply(s, callArgs) : inValue;
			if(typeof v == "undefined"){
				return this.defaultValue;
			}
			if(v && v.addBoth){
				// Check if it's a deferred
				v = new dojox.grid._DeferredTextWidget({deferred: v},
									dojo.create("span", {innerHTML: this.defaultValue}));
			}
			if(v && v.declaredClass && v.startup){
				return "<div class='dojoxGridStubNode' linkWidget='" +
						v.id +
						"' cellIdx='" +
						this.index +
						"'>" +
						this.defaultValue +
						"</div>";
			}
			return v;
		},
		
		// data source
		format: function(inRowIndex, inItem){
			// summary:
			//	provides the html for a given grid cell.
			// inRowIndex: int
			// grid row index
			// returns: html for a given grid cell
			var f, i=this.grid.edit.info, d=this.get ? this.get(inRowIndex, inItem) : (this.value || this.defaultValue);
			d = (d && d.replace && this.grid.escapeHTMLInData) ? d.replace(/&/g, '&amp;').replace(/</g, '&lt;') : d;
			if(this.editable && (this.alwaysEditing || (i.rowIndex==inRowIndex && i.cell==this))){
				return this.formatEditing(d, inRowIndex);
			}else{
				return this._defaultFormat(d, [d, inRowIndex, this]);
			}
		},
		formatEditing: function(inDatum, inRowIndex){
			// summary:
			//	formats the cell for editing
			// inDatum: anything
			//	cell data to edit
			// inRowIndex: int
			//	grid row index
			// returns: string of html to place in grid cell
		},
		// utility
		getNode: function(inRowIndex){
			// summary:
			//	gets the dom node for a given grid cell.
			// inRowIndex: int
			// grid row index
			// returns: dom node for a given grid cell
			return this.view.getCellNode(inRowIndex, this.index);
		},
		getHeaderNode: function(){
			return this.view.getHeaderCellNode(this.index);
		},
		getEditNode: function(inRowIndex){
			return (this.getNode(inRowIndex) || 0).firstChild || 0;
		},
		canResize: function(){
			var uw = this.unitWidth;
			return uw && (uw!=='auto');
		},
		isFlex: function(){
			var uw = this.unitWidth;
			return uw && dojo.isString(uw) && (uw=='auto' || uw.slice(-1)=='%');
		},
		// edit support
		applyEdit: function(inValue, inRowIndex){
			this.grid.edit.applyCellEdit(inValue, this, inRowIndex);
		},
		cancelEdit: function(inRowIndex){
			this.grid.doCancelEdit(inRowIndex);
		},
		_onEditBlur: function(inRowIndex){
			if(this.grid.edit.isEditCell(inRowIndex, this.index)){
				//console.log('editor onblur', e);
				this.grid.edit.apply();
			}
		},
		registerOnBlur: function(inNode, inRowIndex){
			if(this.commitOnBlur){
				dojo.connect(inNode, "onblur", function(e){
					// hack: if editor still thinks this editor is current some ms after it blurs, assume we've focused away from grid
					setTimeout(dojo.hitch(this, "_onEditBlur", inRowIndex), 250);
				});
			}
		},
		//protected
		needFormatNode: function(inDatum, inRowIndex){
			this._formatPending = true;
			whenIdle(this, "_formatNode", inDatum, inRowIndex);
		},
		cancelFormatNode: function(){
			this._formatPending = false;
		},
		//private
		_formatNode: function(inDatum, inRowIndex){
			if(this._formatPending){
				this._formatPending = false;
				// make cell selectable
				dojo.setSelectable(this.grid.domNode, true);
				this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
			}
		},
		//protected
		formatNode: function(inNode, inDatum, inRowIndex){
			// summary:
			//	format the editing dom node. Use when editor is a widget.
			// inNode: dom node
			// dom node for the editor
			// inDatum: anything
			//	cell data to edit
			// inRowIndex: int
			//	grid row index
			if(dojo.isIE){
				// IE sux bad
				whenIdle(this, "focus", inRowIndex, inNode);
			}else{
				this.focus(inRowIndex, inNode);
			}
		},
		dispatchEvent: function(m, e){
			if(m in this){
				return this[m](e);
			}
		},
		//public
		getValue: function(inRowIndex){
			// summary:
			//	returns value entered into editor
			// inRowIndex: int
			// grid row index
			// returns:
			//	value of editor
			return this.getEditNode(inRowIndex)[this._valueProp];
		},
		setValue: function(inRowIndex, inValue){
			// summary:
			//	set the value of the grid editor
			// inRowIndex: int
			// grid row index
			// inValue: anything
			//	value of editor
			var n = this.getEditNode(inRowIndex);
			if(n){
				n[this._valueProp] = inValue;
			}
		},
		focus: function(inRowIndex, inNode){
			// summary:
			//	focus the grid editor
			// inRowIndex: int
			// grid row index
			// inNode: dom node
			//	editor node
			focusSelectNode(inNode || this.getEditNode(inRowIndex));
		},
		save: function(inRowIndex){
			// summary:
			//	save editor state
			// inRowIndex: int
			// grid row index
			this.value = this.value || this.getValue(inRowIndex);
			//console.log("save", this.value, inCell.index, inRowIndex);
		},
		restore: function(inRowIndex){
			// summary:
			//	restore editor state
			// inRowIndex: int
			// grid row index
			this.setValue(inRowIndex, this.value);
			//console.log("restore", this.value, inCell.index, inRowIndex);
		},
		//protected
		_finish: function(inRowIndex){
			// summary:
			//	called when editing is completed to clean up editor
			// inRowIndex: int
			// grid row index
			dojo.setSelectable(this.grid.domNode, false);
			this.cancelFormatNode();
		},
		//public
		apply: function(inRowIndex){
			// summary:
			//	apply edit from cell editor
			// inRowIndex: int
			// grid row index
			this.applyEdit(this.getValue(inRowIndex), inRowIndex);
			this._finish(inRowIndex);
		},
		cancel: function(inRowIndex){
			// summary:
			//	cancel cell edit
			// inRowIndex: int
			// grid row index
			this.cancelEdit(inRowIndex);
			this._finish(inRowIndex);
		}
	});
	dgc._Base.markupFactory = function(node, cellDef){
		var d = dojo;
		var formatter = d.trim(d.attr(node, "formatter")||"");
		if(formatter){
			cellDef.formatter = dojo.getObject(formatter)||formatter;
		}
		var get = d.trim(d.attr(node, "get")||"");
		if(get){
			cellDef.get = dojo.getObject(get);
		}
		var getBoolAttr = function(attr, cell, cellAttr){
			var value = d.trim(d.attr(node, attr)||"");
			if(value){ cell[cellAttr||attr] = !(value.toLowerCase()=="false"); }
		};
		getBoolAttr("sortDesc", cellDef);
		getBoolAttr("editable", cellDef);
		getBoolAttr("alwaysEditing", cellDef);
		getBoolAttr("noresize", cellDef);
		getBoolAttr("draggable", cellDef);

		var value = d.trim(d.attr(node, "loadingText")||d.attr(node, "defaultValue")||"");
		if(value){
			cellDef.defaultValue = value;
		}

		var getStrAttr = function(attr, cell, cellAttr){
			var value = d.trim(d.attr(node, attr)||"")||undefined;
			if(value){ cell[cellAttr||attr] = value; }
		};
		getStrAttr("styles", cellDef);
		getStrAttr("headerStyles", cellDef);
		getStrAttr("cellStyles", cellDef);
		getStrAttr("classes", cellDef);
		getStrAttr("headerClasses", cellDef);
		getStrAttr("cellClasses", cellDef);
	};

	dojo.declare("dojox.grid.cells.Cell", dgc._Base, {
		// summary
		// grid cell that provides a standard text input box upon editing
		constructor: function(){
			this.keyFilter = this.keyFilter;
		},
		// keyFilter: RegExp
		//		optional regex for disallowing keypresses
		keyFilter: null,
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			return '<input class="dojoxGridInput" type="text" value="' + inDatum + '">';
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			this.inherited(arguments);
			// FIXME: feels too specific for this interface
			this.registerOnBlur(inNode, inRowIndex);
		},
		doKey: function(e){
			if(this.keyFilter){
				var key = String.fromCharCode(e.charCode);
				if(key.search(this.keyFilter) == -1){
					dojo.stopEvent(e);
				}
			}
		},
		_finish: function(inRowIndex){
			this.inherited(arguments);
			var n = this.getEditNode(inRowIndex);
			try{
				dojox.grid.util.fire(n, "blur");
			}catch(e){}
		}
	});
	dgc.Cell.markupFactory = function(node, cellDef){
		dgc._Base.markupFactory(node, cellDef);
		var d = dojo;
		var keyFilter = d.trim(d.attr(node, "keyFilter")||"");
		if(keyFilter){
			cellDef.keyFilter = new RegExp(keyFilter);
		}
	};

	dojo.declare("dojox.grid.cells.RowIndex", dgc.Cell, {
		name: 'Row',

		postscript: function(){
			this.editable = false;
		},
		get: function(inRowIndex){
			return inRowIndex + 1;
		}
	});
	dgc.RowIndex.markupFactory = function(node, cellDef){
		dgc.Cell.markupFactory(node, cellDef);
	};

	dojo.declare("dojox.grid.cells.Select", dgc.Cell, {
		// summary:
		// grid cell that provides a standard select for editing

		// options: Array
		// 		text of each item
		options: null,

		// values: Array
		//		value for each item
		values: null,

		// returnIndex: Integer
		// 		editor returns only the index of the selected option and not the value
		returnIndex: -1,

		constructor: function(inCell){
			this.values = this.values || this.options;
		},
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			var h = [ '<select class="dojoxGridSelect">' ];
			for (var i=0, o, v; ((o=this.options[i]) !== undefined)&&((v=this.values[i]) !== undefined); i++){
				h.push("<option", (inDatum==v ? ' selected' : ''), ' value="' + v + '"', ">", o, "</option>");
			}
			h.push('</select>');
			return h.join('');
		},
		getValue: function(inRowIndex){
			var n = this.getEditNode(inRowIndex);
			if(n){
				var i = n.selectedIndex, o = n.options[i];
				return this.returnIndex > -1 ? i : o.value || o.innerHTML;
			}
		}
	});
	dgc.Select.markupFactory = function(node, cell){
		dgc.Cell.markupFactory(node, cell);
		var d=dojo;
		var options = d.trim(d.attr(node, "options")||"");
		if(options){
			var o = options.split(',');
			if(o[0] != options){
				cell.options = o;
			}
		}
		var values = d.trim(d.attr(node, "values")||"");
		if(values){
			var v = values.split(',');
			if(v[0] != values){
				cell.values = v;
			}
		}
	};

	dojo.declare("dojox.grid.cells.AlwaysEdit", dgc.Cell, {
		// summary:
		// grid cell that is always in an editable state, regardless of grid editing state
		alwaysEditing: true,
		_formatNode: function(inDatum, inRowIndex){
			this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
		},
		applyStaticValue: function(inRowIndex){
			var e = this.grid.edit;
			e.applyCellEdit(this.getValue(inRowIndex), this, inRowIndex);
			e.start(this, inRowIndex, true);
		}
	});
	dgc.AlwaysEdit.markupFactory = function(node, cell){
		dgc.Cell.markupFactory(node, cell);
	};

	dojo.declare("dojox.grid.cells.Bool", dgc.AlwaysEdit, {
		// summary:
		// grid cell that provides a standard checkbox that is always on for editing
		_valueProp: "checked",
		formatEditing: function(inDatum, inRowIndex){
			return '<input class="dojoxGridInput" type="checkbox"' + (inDatum ? ' checked="checked"' : '') + ' style="width: auto" />';
		},
		doclick: function(e){
			if(e.target.tagName == 'INPUT'){
				this.applyStaticValue(e.rowIndex);
			}
		}
	});
	dgc.Bool.markupFactory = function(node, cell){
		dgc.AlwaysEdit.markupFactory(node, cell);
	};
})();

}

if(!dojo._hasResource["dojox.grid.cells"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.cells"] = true;
dojo.provide("dojox.grid.cells");


}

if(!dojo._hasResource["dojo.dnd.Mover"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Mover"] = true;
dojo.provide("dojo.dnd.Mover");




dojo.declare("dojo.dnd.Mover", null, {
	constructor: function(node, e, host){
		// summary:
		//		an object which makes a node follow the mouse, or touch-drag on touch devices.
		//		Used as a default mover, and as a base class for custom movers.
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		var pos = e.touches ? e.touches[0] : e;
		this.marginBox = {l: pos.pageX, t: pos.pageY};
		this.mouseButton = e.button;
		var h = (this.host = host), d = node.ownerDocument;
		this.events = [
			// At the start of a drag, onFirstMove is called, and then the following two
			// connects are disconnected
			dojo.connect(d, "onmousemove", this, "onFirstMove"),
			dojo.connect(d, "ontouchmove", this, "onFirstMove"),

			// These are called continually during the drag
			dojo.connect(d, "onmousemove", this, "onMouseMove"),
			dojo.connect(d, "ontouchmove", this, "onMouseMove"),

			// And these are called at the end of the drag
			dojo.connect(d, "onmouseup",   this, "onMouseUp"),
			dojo.connect(d, "ontouchend", this, "onMouseUp"),

			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent)
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove
		// e: Event
		//		mouse/touch event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox,
			pos = e.touches ? e.touches[0] : e;
		this.host.onMove(this, {l: m.l + pos.pageX, t: m.t + pos.pageY}, e);
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.isMac && this.mouseButton == 2 ?
				e.button == 0 : this.mouseButton == e.button){ // TODO Should condition be met for touch devices, too?
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(e){
		// summary:
		//		makes the node absolute; it is meant to be called only once.
		// 		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left)) || 0;
				t = Math.round(parseFloat(s.top)) || 0;
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style.
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this, e);
		}
		
		// Disconnect onmousemove and ontouchmove events that call this function
		dojo.disconnect(this.events.shift());
		dojo.disconnect(this.events.shift());
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

}

if(!dojo._hasResource["dojo.dnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Moveable"] = true;
dojo.provide("dojo.dnd.Moveable");



/*=====
dojo.declare("dojo.dnd.__MoveableArgs", [], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dojo.dnd.Mover
});
=====*/

dojo.declare("dojo.dnd.Moveable", null, {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,
	
	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.__MoveableArgs?
		//		optional parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.handle, "ontouchstart", this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.Moveable(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},
	
	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown/ontouchstart, creates a Mover for the node
		// e: Event
		//		mouse/touch event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, "onmousemove", this, "onMouseMove"),
				dojo.connect(this.handle, "ontouchmove", this, "onMouseMove"),
				dojo.connect(this.handle, "onmouseup", this, "onMouseUp"),
				dojo.connect(this.handle, "ontouchend", this, "onMouseUp")
			);
			var pos = e.touches ? e.touches[0] : e;
			this._lastX = pos.pageX;
			this._lastY = pos.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove, used only for delayed drags
		// e: Event
		//		mouse/touch event
		var pos = e.touches ? e.touches[0] : e;
		if(Math.abs(pos.pageX - this._lastX) > this.delay || Math.abs(pos.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// local events
	onDragDetected: function(/* Event */ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove");
		dojo.addClass(this.node, "dojoMoveItem");
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover, /* Event */ e){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		
		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop, /* Event */ e){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called before every incremental move; can be overwritten.
		
		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called after every incremental move; can be overwritten.
		
		// default implementation does nothing
	}
});

}

if(!dojo._hasResource["dojox.grid._Builder"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Builder"] = true;
dojo.provide("dojox.grid._Builder");




(function(){
	var dg = dojox.grid;

	var getTdIndex = function(td){
		return td.cellIndex >=0 ? td.cellIndex : dojo.indexOf(td.parentNode.cells, td);
	};
	
	var getTrIndex = function(tr){
		return tr.rowIndex >=0 ? tr.rowIndex : dojo.indexOf(tr.parentNode.childNodes, tr);
	};
	
	var getTr = function(rowOwner, index){
		return rowOwner && ((rowOwner.rows||0)[index] || rowOwner.childNodes[index]);
	};

	var findTable = function(node){
		for(var n=node; n && n.tagName!='TABLE'; n=n.parentNode){}
		return n;
	};
	
	var ascendDom = function(inNode, inWhile){
		for(var n=inNode; n && inWhile(n); n=n.parentNode){}
		return n;
	};
	
	var makeNotTagName = function(inTagName){
		var name = inTagName.toUpperCase();
		return function(node){ return node.tagName != name; };
	};

	var rowIndexTag = dojox.grid.util.rowIndexTag;
	var gridViewTag = dojox.grid.util.gridViewTag;

	// base class for generating markup for the views
	dg._Builder = dojo.extend(function(view){
		if(view){
			this.view = view;
			this.grid = view.grid;
		}
	},{
		view: null,
		// boilerplate HTML
		_table: '<table class="dojoxGridRowTable" border="0" cellspacing="0" cellpadding="0" role="presentation"',

		// Returns the table variable as an array - and with the view width, if specified
		getTableArray: function(){
			var html = [this._table];
			if(this.view.viewWidth){
				html.push([' style="width:', this.view.viewWidth, ';"'].join(''));
			}
			html.push('>');
			return html;
		},
		
		// generate starting tags for a cell
		generateCellMarkup: function(inCell, inMoreStyles, inMoreClasses, isHeader){
			var result = [], html;
			if(isHeader){
				var sortInfo = inCell.index != inCell.grid.getSortIndex() ? "" : inCell.grid.sortInfo > 0 ? 'aria-sort="ascending"' : 'aria-sort="descending"';
				if (!inCell.id){
					inCell.id = this.grid.id + "Hdr" + inCell.index;
				}
				// column headers are not editable, mark as aria-readonly=true
				html = ['<th tabIndex="-1" aria-readonly="true" role="columnheader"', sortInfo, 'id="', inCell.id, '"'];
			}else{
				// cells inherit grid aria-readonly property; default value for aria-readonly is false(grid is editable)
				// if grid is editable (had any editable cells), mark non editable cells as aria-readonly=true
				// if no editable cells, grid's aria-readonly value will have been set to true and cells will inherit
				var editInfo = this.grid.editable && !inCell.editable ? 'aria-readonly="true"' : "";
				html = ['<td tabIndex="-1" role="gridcell"', editInfo];
			}
			if(inCell.colSpan){
				html.push(' colspan="', inCell.colSpan, '"');
			}
			if(inCell.rowSpan){
				html.push(' rowspan="', inCell.rowSpan, '"');
			}
			html.push(' class="dojoxGridCell ');
			if(inCell.classes){
				html.push(inCell.classes, ' ');
			}
			if(inMoreClasses){
				html.push(inMoreClasses, ' ');
			}
			// result[0] => td opener, style
			result.push(html.join(''));
			// SLOT: result[1] => td classes
			result.push('');
			html = ['" idx="', inCell.index, '" style="'];
			if(inMoreStyles && inMoreStyles[inMoreStyles.length-1] != ';'){
				inMoreStyles += ';';
			}
			html.push(inCell.styles, inMoreStyles||'', inCell.hidden?'display:none;':'');
			if(inCell.unitWidth){
				html.push('width:', inCell.unitWidth, ';');
			}
			// result[2] => markup
			result.push(html.join(''));
			// SLOT: result[3] => td style
			result.push('');
			html = [ '"' ];
			if(inCell.attrs){
				html.push(" ", inCell.attrs);
			}
			html.push('>');
			// result[4] => td postfix
			result.push(html.join(''));
			// SLOT: result[5] => content
			result.push('');
			// result[6] => td closes
			result.push(isHeader?'</th>':'</td>');
			return result; // Array
		},

		// cell finding
		isCellNode: function(inNode){
			return Boolean(inNode && inNode!=dojo.doc && dojo.attr(inNode, "idx"));
		},
		
		getCellNodeIndex: function(inCellNode){
			return inCellNode ? Number(dojo.attr(inCellNode, "idx")) : -1;
		},
		
		getCellNode: function(inRowNode, inCellIndex){
			for(var i=0, row; ((row = getTr(inRowNode.firstChild, i)) && row.cells); i++){
				for(var j=0, cell; (cell = row.cells[j]); j++){
					if(this.getCellNodeIndex(cell) == inCellIndex){
						return cell;
					}
				}
			}
			return null;
		},
		
		findCellTarget: function(inSourceNode, inTopNode){
			var n = inSourceNode;
			while(n && (!this.isCellNode(n) || (n.offsetParent && gridViewTag in n.offsetParent.parentNode && n.offsetParent.parentNode[gridViewTag] != this.view.id)) && (n!=inTopNode)){
				n = n.parentNode;
			}
			return n!=inTopNode ? n : null;
		},
		
		// event decoration
		baseDecorateEvent: function(e){
			e.dispatch = 'do' + e.type;
			e.grid = this.grid;
			e.sourceView = this.view;
			e.cellNode = this.findCellTarget(e.target, e.rowNode);
			e.cellIndex = this.getCellNodeIndex(e.cellNode);
			e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		},
		
		// event dispatch
		findTarget: function(inSource, inTag){
			var n = inSource;
			while(n && (n!=this.domNode) && (!(inTag in n) || (gridViewTag in n && n[gridViewTag] != this.view.id))){
				n = n.parentNode;
			}
			return (n != this.domNode) ? n : null;
		},

		findRowTarget: function(inSource){
			return this.findTarget(inSource, rowIndexTag);
		},

		isIntraNodeEvent: function(e){
			try{
				return (e.cellNode && e.relatedTarget && dojo.isDescendant(e.relatedTarget, e.cellNode));
			}catch(x){
				// e.relatedTarget has permission problem in FF if it's an input: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		isIntraRowEvent: function(e){
			try{
				var row = e.relatedTarget && this.findRowTarget(e.relatedTarget);
				return !row && (e.rowIndex==-1) || row && (e.rowIndex==row.gridRowIndex);
			}catch(x){
				// e.relatedTarget on INPUT has permission problem in FF: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		dispatchEvent: function(e){
			if(e.dispatch in this){
				return this[e.dispatch](e);
			}
			return false;
		},

		// dispatched event handlers
		domouseover: function(e){
			if(e.cellNode && (e.cellNode!=this.lastOverCellNode)){
				this.lastOverCellNode = e.cellNode;
				this.grid.onMouseOver(e);
			}
			this.grid.onMouseOverRow(e);
		},

		domouseout: function(e){
			if(e.cellNode && (e.cellNode==this.lastOverCellNode) && !this.isIntraNodeEvent(e, this.lastOverCellNode)){
				this.lastOverCellNode = null;
				this.grid.onMouseOut(e);
				if(!this.isIntraRowEvent(e)){
					this.grid.onMouseOutRow(e);
				}
			}
		},
		
		domousedown: function(e){
			if (e.cellNode)
				this.grid.onMouseDown(e);
			this.grid.onMouseDownRow(e);
		}
	});

	// Produces html for grid data content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	dg._ContentBuilder = dojo.extend(function(view){
		dg._Builder.call(this, view);
	},dg._Builder.prototype,{
		update: function(){
			this.prepareHtml();
		},

		// cache html for rendering data rows
		prepareHtml: function(){
			var defaultGet=this.grid.get, cells=this.view.structure.cells;
			for(var j=0, row; (row=cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.get = cell.get || (cell.value == undefined) && defaultGet;
					cell.markup = this.generateCellMarkup(cell, cell.cellStyles, cell.cellClasses, false);
					if (!this.grid.editable && cell.editable){
						this.grid.editable = true;
					}
				}
			}
		},

		// time critical: generate html using cache and data source
		generateHtml: function(inDataIndex, inRowIndex){
			var
				html = this.getTableArray(),
				v = this.view,
				cells = v.structure.cells,
				item = this.grid.getItem(inRowIndex);

			dojox.grid.util.fire(this.view, "onBeforeRow", [inRowIndex, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden || row.header){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, m, cc, cs; (cell=row[i]); i++){
					m = cell.markup; cc = cell.customClasses = []; cs = cell.customStyles = [];
					// content (format can fill in cc and cs as side-effects)
					m[5] = cell.format(inRowIndex, item);
					// classes
					m[1] = cc.join(' ');
					// styles
					m[3] = cs.join(';');
					// in-place concat
					html.push.apply(html, m);
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join(''); // String
		},

		decorateEvent: function(e){
			e.rowNode = this.findRowTarget(e.target);
			if(!e.rowNode){return false;}
			e.rowIndex = e.rowNode[rowIndexTag];
			this.baseDecorateEvent(e);
			e.cell = this.grid.getCell(e.cellIndex);
			return true; // Boolean
		}
	});

	// Produces html for grid header content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	dg._HeaderBuilder = dojo.extend(function(view){
		this.moveable = null;
		dg._Builder.call(this, view);
	},dg._Builder.prototype,{
		_skipBogusClicks: false,
		overResizeWidth: 4,
		minColWidth: 1,
		
		update: function(){
			if(this.tableMap){
				this.tableMap.mapRows(this.view.structure.cells);
			}else{
				this.tableMap = new dg._TableMap(this.view.structure.cells);
			}
		},

		generateHtml: function(inGetValue, inValue){
			var html = this.getTableArray(), cells = this.view.structure.cells;
			
			dojox.grid.util.fire(this.view, "onBeforeRow", [-1, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, markup; (cell=row[i]); i++){
					cell.customClasses = [];
					cell.customStyles = [];
					if(this.view.simpleStructure){
						if(cell.draggable){
							if(cell.headerClasses){
								if(cell.headerClasses.indexOf('dojoDndItem') == -1){
									cell.headerClasses += ' dojoDndItem';
								}
							}else{
								cell.headerClasses = 'dojoDndItem';
							}
						}
						if(cell.attrs){
							if(cell.attrs.indexOf("dndType='gridColumn_") == -1){
								cell.attrs += " dndType='gridColumn_" + this.grid.id + "'";
							}
						}else{
							cell.attrs = "dndType='gridColumn_" + this.grid.id + "'";
						}
					}
					markup = this.generateCellMarkup(cell, cell.headerStyles, cell.headerClasses, true);
					// content
					markup[5] = (inValue != undefined ? inValue : inGetValue(cell));
					// styles
					markup[3] = cell.customStyles.join(';');
					// classes
					markup[1] = cell.customClasses.join(' '); //(cell.customClasses ? ' ' + cell.customClasses : '');
					html.push(markup.join(''));
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join('');
		},

		// event helpers
		getCellX: function(e){
			var n, x = e.layerX;
			if(dojo.isMoz || dojo.isIE >= 9){
				n = ascendDom(e.target, makeNotTagName("th"));
				x -= (n && n.offsetLeft) || 0;
				var t = e.sourceView.getScrollbarWidth();
				if(!dojo._isBodyLtr()/*&& e.sourceView.headerNode.scrollLeft < t*/){
					//fix #11253
					table = ascendDom(n,makeNotTagName("table"));
					x -= (table && table.offsetLeft) || 0;
				}
				//x -= getProp(ascendDom(e.target, mkNotTagName("td")), "offsetLeft") || 0;
			}
			n = ascendDom(e.target, function(){
				if(!n || n == e.cellNode){
					return false;
				}
				// Mozilla 1.8 (FF 1.5) has a bug that makes offsetLeft = -parent border width
				// when parent has border, overflow: hidden, and is positioned
				// handle this problem here ... not a general solution!
				x += (n.offsetLeft < 0 ? 0 : n.offsetLeft);
				return true;
			});
			return x;
		},

		// event decoration
		decorateEvent: function(e){
			this.baseDecorateEvent(e);
			e.rowIndex = -1;
			e.cellX = this.getCellX(e);
			return true;
		},

		// event handlers
		// resizing
		prepareResize: function(e, mod){
			do{
				var i = getTdIndex(e.cellNode);
				e.cellNode = (i ? e.cellNode.parentNode.cells[i+mod] : null);
				e.cellIndex = (e.cellNode ? this.getCellNodeIndex(e.cellNode) : -1);
			}while(e.cellNode && e.cellNode.style.display == "none");
			return Boolean(e.cellNode);
		},

		canResize: function(e){
			if(!e.cellNode || e.cellNode.colSpan > 1){
				return false;
			}
			var cell = this.grid.getCell(e.cellIndex);
			return !cell.noresize && cell.canResize();
		},

		overLeftResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(dojo.hasClass(dojo.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(dojo.isIE){
				var tN = e.target;
				if(dojo.hasClass(tN, "dojoxGridArrowButtonNode") ||
					dojo.hasClass(tN, "dojoxGridArrowButtonChar")){
					return false;
				}
			}

			if(dojo._isBodyLtr()){
				return (e.cellIndex>0) && (e.cellX > 0 && e.cellX < this.overResizeWidth) && this.prepareResize(e, -1);
			}
			var t = e.cellNode && (e.cellX > 0 && e.cellX < this.overResizeWidth);
			return t;
		},

		overRightResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(dojo.hasClass(dojo.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(dojo.isIE){
				var tN = e.target;
				if(dojo.hasClass(tN, "dojoxGridArrowButtonNode") ||
					dojo.hasClass(tN, "dojoxGridArrowButtonChar")){
					return false;
				}
			}

			if(dojo._isBodyLtr()){
				return e.cellNode && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth);
			}
			return (e.cellIndex>0) && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth) && this.prepareResize(e, -1);
		},

		domousemove: function(e){
			//console.log(e.cellIndex, e.cellX, e.cellNode.offsetWidth);
			if(!this.moveable){
				var c = (this.overRightResizeArea(e) ? 'dojoxGridColResize' : (this.overLeftResizeArea(e) ? 'dojoxGridColResize' : ''));
				if(c && !this.canResize(e)){
					c = 'dojoxGridColNoResize';
				}
				dojo.toggleClass(e.sourceView.headerNode, "dojoxGridColNoResize", (c == "dojoxGridColNoResize"));
				dojo.toggleClass(e.sourceView.headerNode, "dojoxGridColResize", (c == "dojoxGridColResize"));
				if(dojo.isIE){
					var t = e.sourceView.headerNode.scrollLeft;
					e.sourceView.headerNode.scrollLeft = t;
				}
				if(c){
					dojo.stopEvent(e);
				}
			}
		},

		domousedown: function(e){
			if(!this.moveable){
				if((this.overRightResizeArea(e) || this.overLeftResizeArea(e)) && this.canResize(e)){
					this.beginColumnResize(e);
				}else{
					this.grid.onMouseDown(e);
					this.grid.onMouseOverRow(e);
				}
				//else{
				//	this.beginMoveColumn(e);
				//}
			}
		},

		doclick: function(e) {
			if(this._skipBogusClicks){
				dojo.stopEvent(e);
				return true;
			}
			return false;
		},

		// column resizing
		colResizeSetup: function(/*Event Object*/e, /*boolean*/ isMouse ){
			//Set up the drag object for column resizing
			// Called with mouse event in case of drag and drop,
			// Also called from keyboard shift-arrow event when focus is on a header
			var headContentBox = dojo.contentBox(e.sourceView.headerNode);
			
			if(isMouse){  //IE draws line even with no mouse down so separate from keyboard
				this.lineDiv = document.createElement('div');

				// NOTE: this is for backwards compatibility with Dojo 1.3
				var vw = (dojo.position||dojo._abs)(e.sourceView.headerNode, true);
				var bodyContentBox = dojo.contentBox(e.sourceView.domNode);
				//fix #11340
				var l = e.pageX;
				if(!dojo._isBodyLtr() && dojo.isIE < 8){
					l -= dojox.html.metrics.getScrollbar().w;
				}
				dojo.style(this.lineDiv, {
					top: vw.y + "px",
					left: l + "px",
					height: (bodyContentBox.h + headContentBox.h) + "px"
				});
				dojo.addClass(this.lineDiv, "dojoxGridResizeColLine");
				this.lineDiv._origLeft = l;
				dojo.body().appendChild(this.lineDiv);
			}
			var spanners = [], nodes = this.tableMap.findOverlappingNodes(e.cellNode);
			for(var i=0, cell; (cell=nodes[i]); i++){
				spanners.push({ node: cell, index: this.getCellNodeIndex(cell), width: cell.offsetWidth });
				//console.log("spanner: " + this.getCellNodeIndex(cell));
			}

			var view = e.sourceView;
			var adj = dojo._isBodyLtr() ? 1 : -1;
			var views = e.grid.views.views;
			var followers = [];
			for(var j=view.idx+adj, cView; (cView=views[j]); j=j+adj){
				followers.push({ node: cView.headerNode, left: window.parseInt(cView.headerNode.style.left) });
			}
			var table = view.headerContentNode.firstChild;
			var drag = {
				scrollLeft: e.sourceView.headerNode.scrollLeft,
				view: view,
				node: e.cellNode,
				index: e.cellIndex,
				w: dojo.contentBox(e.cellNode).w,
				vw: headContentBox.w,
				table: table,
				tw: dojo.contentBox(table).w,
				spanners: spanners,
				followers: followers
			};
			return drag;
		},
		beginColumnResize: function(e){
			this.moverDiv = document.createElement("div");
			dojo.style(this.moverDiv,{position: "absolute", left:0}); // to make DnD work with dir=rtl
			dojo.body().appendChild(this.moverDiv);
			dojo.addClass(this.grid.domNode, "dojoxGridColumnResizing");
			var m = (this.moveable = new dojo.dnd.Moveable(this.moverDiv));

			var drag = this.colResizeSetup(e,true);

			m.onMove = dojo.hitch(this, "doResizeColumn", drag);

			dojo.connect(m, "onMoveStop", dojo.hitch(this, function(){
				this.endResizeColumn(drag);
				if(drag.node.releaseCapture){
					drag.node.releaseCapture();
				}
				this.moveable.destroy();
				delete this.moveable;
				this.moveable = null;
				dojo.removeClass(this.grid.domNode, "dojoxGridColumnResizing");
			}));

			if(e.cellNode.setCapture){
				e.cellNode.setCapture();
			}
			m.onMouseDown(e);
		},

		doResizeColumn: function(inDrag, mover, leftTop){
			var changeX = leftTop.l;
			var data = {
				deltaX: changeX,
				w: inDrag.w + (dojo._isBodyLtr() ? changeX : -changeX),//fix #11341
				vw: inDrag.vw + changeX,
				tw: inDrag.tw + changeX
			};
			
			this.dragRecord = {inDrag: inDrag, mover: mover, leftTop:leftTop};
			
			if(data.w >= this.minColWidth){
				if (!mover) { // we are using keyboard do immediate resize
					this.doResizeNow(inDrag, data);
				}
				else{
					dojo.style(this.lineDiv, "left", (this.lineDiv._origLeft + data.deltaX) + "px");
				}
			}
		},

		endResizeColumn: function(inDrag){
			if(this.dragRecord){
				var leftTop = this.dragRecord.leftTop;
				var changeX = dojo._isBodyLtr() ? leftTop.l : -leftTop.l;
				// Make sure we are not under our minimum
				// http://bugs.dojotoolkit.org/ticket/9390
				changeX += Math.max(inDrag.w + changeX, this.minColWidth) - (inDrag.w + changeX);
				if(dojo.isWebKit && inDrag.spanners.length){
					// Webkit needs the pad border extents back in
					changeX += dojo._getPadBorderExtents(inDrag.spanners[0].node).w;
				}
				var data = {
					deltaX: changeX,
					w: inDrag.w + changeX,
					vw: inDrag.vw + changeX,
					tw: inDrag.tw + changeX
				};
				// Only resize the columns when the drag has finished
				this.doResizeNow(inDrag, data);
				delete this.dragRecord;
			}
			
			dojo.destroy(this.lineDiv);
 			dojo.destroy(this.moverDiv);
			dojo.destroy(this.moverDiv);
			delete this.moverDiv;
			this._skipBogusClicks = true;
			inDrag.view.update();
			this._skipBogusClicks = false;
			this.grid.onResizeColumn(inDrag.index);
		},
		doResizeNow: function(inDrag, data){
			inDrag.view.convertColPctToFixed();
			if(inDrag.view.flexCells && !inDrag.view.testFlexCells()){
				var t = findTable(inDrag.node);
				if(t){
					(t.style.width = '');
				}
			}
			var i, s, sw, f, fl;
			for(i=0; (s=inDrag.spanners[i]); i++){
				sw = s.width + data.deltaX;
				if(sw > 0){
					s.node.style.width = sw + 'px';
					inDrag.view.setColWidth(s.index, sw);
				}
			}
			if(dojo._isBodyLtr() || !dojo.isIE){//fix #11339
				for(i=0; (f=inDrag.followers[i]); i++){
					fl = f.left + data.deltaX;
					f.node.style.left = fl + 'px';
				}
			}
			inDrag.node.style.width = data.w + 'px';
			inDrag.view.setColWidth(inDrag.index, data.w);
			inDrag.view.headerNode.style.width = data.vw + 'px';
			inDrag.view.setColumnsWidth(data.tw);
			if(!dojo._isBodyLtr()){
				inDrag.view.headerNode.scrollLeft = inDrag.scrollLeft + data.deltaX;
			}
		}
	});

	// Maps an html table into a structure parsable for information about cell row and col spanning.
	// Used by HeaderBuilder.
	dg._TableMap = dojo.extend(function(rows){
		this.mapRows(rows);
	},{
		map: null,

		mapRows: function(inRows){
			// summary: Map table topography

			//console.log('mapRows');
			// # of rows
			var rowCount = inRows.length;
			if(!rowCount){
				return;
			}
			// map which columns and rows fill which cells
			this.map = [];
			var row;
			for(var k=0; (row=inRows[k]); k++){
				this.map[k] = [];
			}
			for(var j=0; (row=inRows[j]); j++){
				for(var i=0, x=0, cell, colSpan, rowSpan; (cell=row[i]); i++){
					while(this.map[j][x]){x++;}
					this.map[j][x] = { c: i, r: j };
					rowSpan = cell.rowSpan || 1;
					colSpan = cell.colSpan || 1;
					for(var y=0; y<rowSpan; y++){
						for(var s=0; s<colSpan; s++){
							this.map[j+y][x+s] = this.map[j][x];
						}
					}
					x += colSpan;
				}
			}
			//this.dumMap();
		},

		dumpMap: function(){
			for(var j=0, row, h=''; (row=this.map[j]); j++,h=''){
				for(var i=0, cell; (cell=row[i]); i++){
					h += cell.r + ',' + cell.c + '   ';
				}
			}
		},

		getMapCoords: function(inRow, inCol){
			// summary: Find node's map coords by it's structure coords
			for(var j=0, row; (row=this.map[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					if(cell.c==inCol && cell.r == inRow){
						return { j: j, i: i };
					}
					//else{console.log(inRow, inCol, ' : ', i, j, " : ", cell.r, cell.c); };
				}
			}
			return { j: -1, i: -1 };
		},
		
		getNode: function(inTable, inRow, inCol){
			// summary: Find a node in inNode's table with the given structure coords
			var row = inTable && inTable.rows[inRow];
			return row && row.cells[inCol];
		},
		
		_findOverlappingNodes: function(inTable, inRow, inCol){
			var nodes = [];
			var m = this.getMapCoords(inRow, inCol);
			//console.log("node j: %d, i: %d", m.j, m.i);
			for(var j=0, row; (row=this.map[j]); j++){
				if(j == m.j){ continue; }
				var rw = row[m.i];
				//console.log("overlaps: r: %d, c: %d", rw.r, rw.c);
				var n = (rw?this.getNode(inTable, rw.r, rw.c):null);
				if(n){ nodes.push(n); }
			}
			//console.log(nodes);
			return nodes;
		},
		
		findOverlappingNodes: function(inNode){
			return this._findOverlappingNodes(findTable(inNode), getTrIndex(inNode.parentNode), getTdIndex(inNode));
		}
	});
})();

}

if(!dojo._hasResource["dojox.grid._View"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._View"] = true;
dojo.provide("dojox.grid._View");










(function(){
	// a private function
	var getStyleText = function(inNode, inStyleText){
		return inNode.style.cssText == undefined ? inNode.getAttribute("style") : inNode.style.cssText;
	};

	// some public functions
	dojo.declare('dojox.grid._View', [dijit._Widget, dijit._Templated], {
		// summary:
		//		A collection of grid columns. A grid is comprised of a set of views that stack horizontally.
		//		Grid creates views automatically based on grid's layout structure.
		//		Users should typically not need to access individual views directly.
		//
		// defaultWidth: String
		//		Default width of the view
		defaultWidth: "18em",

		// viewWidth: String
		// 		Width for the view, in valid css unit
		viewWidth: "",

		templateString:"<div class=\"dojoxGridView\" role=\"presentation\">\n\t<div class=\"dojoxGridHeader\" dojoAttachPoint=\"headerNode\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"headerNodeContainer\" style=\"width:9000em\" role=\"presentation\">\n\t\t\t<div dojoAttachPoint=\"headerContentNode\" role=\"row\"></div>\n\t\t</div>\n\t</div>\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" dojoAttachPoint=\"hiddenFocusNode\" role=\"presentation\" />\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" role=\"presentation\" />\n\t<div class=\"dojoxGridScrollbox\" dojoAttachPoint=\"scrollboxNode\" role=\"presentation\">\n\t\t<div class=\"dojoxGridContent\" dojoAttachPoint=\"contentNode\" hidefocus=\"hidefocus\" role=\"presentation\"></div>\n\t</div>\n</div>\n",
		
		themeable: false,
		classTag: 'dojoxGrid',
		marginBottom: 0,
		rowPad: 2,

		// _togglingColumn: int
		//		Width of the column being toggled (-1 for none)
		_togglingColumn: -1,
		
		// _headerBuilderClass: Object
		//		The class to use for our header builder
		_headerBuilderClass: dojox.grid._HeaderBuilder,
		
		// _contentBuilderClass: Object
		//		The class to use for our content builder
		_contentBuilderClass: dojox.grid._ContentBuilder,
		
		postMixInProperties: function(){
			this.rowNodes = {};
		},

		postCreate: function(){
			this.connect(this.scrollboxNode,"onscroll","doscroll");
			dojox.grid.util.funnelEvents(this.contentNode, this, "doContentEvent", [ 'mouseover', 'mouseout', 'click', 'dblclick', 'contextmenu', 'mousedown' ]);
			dojox.grid.util.funnelEvents(this.headerNode, this, "doHeaderEvent", [ 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'click', 'contextmenu' ]);
			this.content = new this._contentBuilderClass(this);
			this.header = new this._headerBuilderClass(this);
			//BiDi: in RTL case, style width='9000em' causes scrolling problem in head node
			if(!dojo._isBodyLtr()){
				this.headerNodeContainer.style.width = "";
			}
		},

		destroy: function(){
			dojo.destroy(this.headerNode);
			delete this.headerNode;
			for(var i in this.rowNodes){
				dojo.destroy(this.rowNodes[i]);
			}
			this.rowNodes = {};
			if(this.source){
				this.source.destroy();
			}
			this.inherited(arguments);
		},

		// focus
		focus: function(){
			if(dojo.isIE || dojo.isWebKit || dojo.isOpera){
				this.hiddenFocusNode.focus();
			}else{
				this.scrollboxNode.focus();
			}
		},

		setStructure: function(inStructure){
			var vs = (this.structure = inStructure);
			// FIXME: similar logic is duplicated in layout
			if(vs.width && !isNaN(vs.width)){
				this.viewWidth = vs.width + 'em';
			}else{
				this.viewWidth = vs.width || (vs.noscroll ? 'auto' : this.viewWidth); //|| this.defaultWidth;
			}
			this._onBeforeRow = vs.onBeforeRow||function(){};
			this._onAfterRow = vs.onAfterRow||function(){};
			this.noscroll = vs.noscroll;
			if(this.noscroll){
				this.scrollboxNode.style.overflow = "hidden";
			}
			this.simpleStructure = Boolean(vs.cells.length == 1);
			// bookkeeping
			this.testFlexCells();
			// accomodate new structure
			this.updateStructure();
		},
		
		_cleanupRowWidgets: function(inRowNode){
			// Summary:
			//		Cleans up the widgets for the given row node so that
			//		we can reattach them if needed
			if(inRowNode){
				dojo.forEach(dojo.query("[widgetId]", inRowNode).map(dijit.byNode), function(w){
					if(w._destroyOnRemove){
						w.destroy();
						delete w;
					}else if(w.domNode && w.domNode.parentNode){
						w.domNode.parentNode.removeChild(w.domNode);
					}
				});
			}
		},
		
		onBeforeRow: function(inRowIndex, cells){
			this._onBeforeRow(inRowIndex, cells);
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
		},
		
		onAfterRow: function(inRowIndex, cells, inRowNode){
			this._onAfterRow(inRowIndex, cells, inRowNode);
			var g = this.grid;
			dojo.forEach(dojo.query(".dojoxGridStubNode", inRowNode), function(n){
				if(n && n.parentNode){
					var lw = n.getAttribute("linkWidget");
					var cellIdx = window.parseInt(dojo.attr(n, "cellIdx"), 10);
					var cellDef = g.getCell(cellIdx);
					var w = dijit.byId(lw);
					if(w){
						n.parentNode.replaceChild(w.domNode, n);
						if(!w._started){
							w.startup();
						}
					}else{
						n.innerHTML = "";
					}
				}
			}, this);
		},

		testFlexCells: function(){
			// FIXME: cheater, this function does double duty as initializer and tester
			this.flexCells = false;
			for(var j=0, row; (row=this.structure.cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.view = this;
					this.flexCells = this.flexCells || cell.isFlex();
				}
			}
			return this.flexCells;
		},

		updateStructure: function(){
			// header builder needs to update table map
			this.header.update();
			// content builder needs to update markup cache
			this.content.update();
		},

		getScrollbarWidth: function(){
			var hasScrollSpace = this.hasVScrollbar();
			var overflow = dojo.style(this.scrollboxNode, "overflow");
			if(this.noscroll || !overflow || overflow == "hidden"){
				hasScrollSpace = false;
			}else if(overflow == "scroll"){
				hasScrollSpace = true;
			}
			return (hasScrollSpace ? dojox.html.metrics.getScrollbar().w : 0); // Integer
		},

		getColumnsWidth: function(){
			var h = this.headerContentNode;
			return h && h.firstChild ? h.firstChild.offsetWidth : 0; // Integer
		},

		setColumnsWidth: function(width){
			this.headerContentNode.firstChild.style.width = width + 'px';
			if(this.viewWidth){
				this.viewWidth = width + 'px';
			}
		},

		getWidth: function(){
			return this.viewWidth || (this.getColumnsWidth()+this.getScrollbarWidth()) +'px'; // String
		},

		getContentWidth: function(){
			return Math.max(0, dojo._getContentBox(this.domNode).w - this.getScrollbarWidth()) + 'px'; // String
		},

		render: function(){
			this.scrollboxNode.style.height = '';
			this.renderHeader();
			if(this._togglingColumn >= 0){
				this.setColumnsWidth(this.getColumnsWidth() - this._togglingColumn);
				this._togglingColumn = -1;
			}
			var cells = this.grid.layout.cells;
			var getSibling = dojo.hitch(this, function(node, before){
				!dojo._isBodyLtr() && (before = !before);
				var inc = before?-1:1;
				var idx = this.header.getCellNodeIndex(node) + inc;
				var cell = cells[idx];
				while(cell && cell.getHeaderNode() && cell.getHeaderNode().style.display == "none"){
					idx += inc;
					cell = cells[idx];
				}
				if(cell){
					return cell.getHeaderNode();
				}
				return null;
			});
			if(this.grid.columnReordering && this.simpleStructure){
				if(this.source){
					this.source.destroy();
				}
				
				// Create the top and bottom markers
				var bottomMarkerId = "dojoxGrid_bottomMarker";
				var topMarkerId = "dojoxGrid_topMarker";
				if(this.bottomMarker){
					dojo.destroy(this.bottomMarker);
				}
				this.bottomMarker = dojo.byId(bottomMarkerId);
				if(this.topMarker){
					dojo.destroy(this.topMarker);
				}
				this.topMarker = dojo.byId(topMarkerId);
				if (!this.bottomMarker) {
					this.bottomMarker = dojo.create("div", {
						"id": bottomMarkerId,
						"class": "dojoxGridColPlaceBottom"
					}, dojo.body());
					this._hide(this.bottomMarker);

					
					this.topMarker = dojo.create("div", {
						"id": topMarkerId,
						"class": "dojoxGridColPlaceTop"
					}, dojo.body());
					this._hide(this.topMarker);
				}
				this.arrowDim = dojo.contentBox(this.bottomMarker);

				var headerHeight = dojo.contentBox(this.headerContentNode.firstChild.rows[0]).h;
				
				this.source = new dojo.dnd.Source(this.headerContentNode.firstChild.rows[0], {
					horizontal: true,
					accept: [ "gridColumn_" + this.grid.id ],
					viewIndex: this.index,
					generateText: false,
					onMouseDown: dojo.hitch(this, function(e){
						this.header.decorateEvent(e);
						if((this.header.overRightResizeArea(e) || this.header.overLeftResizeArea(e)) &&
							this.header.canResize(e) && !this.header.moveable){
							this.header.beginColumnResize(e);
						}else{
							if(this.grid.headerMenu){
								this.grid.headerMenu.onCancel(true);
							}
							// IE reports a left click as 1, where everything else reports 0
							if(e.button === (dojo.isIE ? 1 : 0)){
								dojo.dnd.Source.prototype.onMouseDown.call(this.source, e);
							}
						}
					}),
					onMouseOver: dojo.hitch(this, function(e){
						var src = this.source;
						if(src._getChildByEvent(e)){
							dojo.dnd.Source.prototype.onMouseOver.apply(src, arguments);
						}
					}),
					_markTargetAnchor: dojo.hitch(this, function(before){
						var src = this.source;
						if(src.current == src.targetAnchor && src.before == before){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						dojo.dnd.Source.prototype._markTargetAnchor.call(src, before);
						
						var target = before ? src.targetAnchor : getSibling(src.targetAnchor, src.before);
						var endAdd = 0;

						if (!target) {
							target = src.targetAnchor;
							endAdd = dojo.contentBox(target).w + this.arrowDim.w/2 + 2;
						}

						// NOTE: this is for backwards compatibility with Dojo 1.3
						var pos = (dojo.position||dojo._abs)(target, true);
						var left = Math.floor(pos.x - this.arrowDim.w/2 + endAdd);

						dojo.style(this.bottomMarker, "visibility", "visible");
						dojo.style(this.topMarker, "visibility", "visible");
						dojo.style(this.bottomMarker, {
							"left": left + "px",
							"top" : (headerHeight + pos.y) + "px"
						});

						dojo.style(this.topMarker, {
							"left": left + "px",
							"top" : (pos.y - this.arrowDim.h) + "px"
						});

						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._addItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
					}),
					_unmarkTargetAnchor: dojo.hitch(this, function(){
						var src = this.source;
						if(!src.targetAnchor){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
						dojo.dnd.Source.prototype._unmarkTargetAnchor.call(src);
					}),
					destroy: dojo.hitch(this, function(){
						dojo.disconnect(this._source_conn);
						dojo.unsubscribe(this._source_sub);
						dojo.dnd.Source.prototype.destroy.call(this.source);
						if(this.bottomMarker){
							dojo.destroy(this.bottomMarker);
							delete this.bottomMarker;
						}
						if(this.topMarker){
							dojo.destroy(this.topMarker);
							delete this.topMarker;
						}
					}),
					onDndCancel: dojo.hitch(this, function(){
						dojo.dnd.Source.prototype.onDndCancel.call(this.source);
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
					})
				});

				this._source_conn = dojo.connect(this.source, "onDndDrop", this, "_onDndDrop");
				this._source_sub = dojo.subscribe("/dnd/drop/before", this, "_onDndDropBefore");
				this.source.startup();
			}
		},
		
		_hide: function(node){
			dojo.style(node, {
				left: "-10000px",
				top: "-10000px",
				"visibility": "hidden"
			});
		},

		_onDndDropBefore: function(source, nodes, copy){
			if(dojo.dnd.manager().target !== this.source){
				return;
			}
			this.source._targetNode = this.source.targetAnchor;
			this.source._beforeTarget = this.source.before;
			var views = this.grid.views.views;
			var srcView = views[source.viewIndex];
			var tgtView = views[this.index];
			if(tgtView != srcView){
				srcView.convertColPctToFixed();
				tgtView.convertColPctToFixed();
			}
		},

		_onDndDrop: function(source, nodes, copy){
			if(dojo.dnd.manager().target !== this.source){
				if(dojo.dnd.manager().source === this.source){
					this._removingColumn = true;
				}
				return;
			}
			this._hide(this.bottomMarker);
			this._hide(this.topMarker);

			var getIdx = function(n){
				return n ? dojo.attr(n, "idx") : null;
			};
			var w = dojo.marginBox(nodes[0]).w;
			if(source.viewIndex !== this.index){
				var views = this.grid.views.views;
				var srcView = views[source.viewIndex];
				var tgtView = views[this.index];
				if(srcView.viewWidth && srcView.viewWidth != "auto"){
					srcView.setColumnsWidth(srcView.getColumnsWidth() - w);
				}
				if(tgtView.viewWidth && tgtView.viewWidth != "auto"){
					tgtView.setColumnsWidth(tgtView.getColumnsWidth());
				}
			}
			var stn = this.source._targetNode;
			var stb = this.source._beforeTarget;
			!dojo._isBodyLtr() && (stb = !stb);
			var layout = this.grid.layout;
			var idx = this.index;
			delete this.source._targetNode;
			delete this.source._beforeTarget;
			
			layout.moveColumn(
				source.viewIndex,
				idx,
				getIdx(nodes[0]),
				getIdx(stn),
				stb);
		},

		renderHeader: function(){
			this.headerContentNode.innerHTML = this.header.generateHtml(this._getHeaderContent);
			if(this.flexCells){
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			dojox.grid.util.fire(this, "onAfterRow", [-1, this.structure.cells, this.headerContentNode]);
		},

		// note: not called in 'view' context
		_getHeaderContent: function(inCell){
			var n = inCell.name || inCell.grid.getCellName(inCell);
			var ret = [ '<div class="dojoxGridSortNode' ];
			
			if(inCell.index != inCell.grid.getSortIndex()){
				ret.push('">');
			}else{
				ret = ret.concat([ ' ',
							inCell.grid.sortInfo > 0 ? 'dojoxGridSortUp' : 'dojoxGridSortDown',
							'"><div class="dojoxGridArrowButtonChar">',
							inCell.grid.sortInfo > 0 ? '&#9650;' : '&#9660;',
							'</div><div class="dojoxGridArrowButtonNode" role="presentation"></div>',
							'<div class="dojoxGridColCaption">']);
			}
			ret = ret.concat([n, '</div></div>']);
			return ret.join('');
		},

		resize: function(){
			this.adaptHeight();
			this.adaptWidth();
		},

		hasHScrollbar: function(reset){
			var hadScroll = this._hasHScroll||false;
			if(this._hasHScroll == undefined || reset){
				if(this.noscroll){
					this._hasHScroll = false;
				}else{
					var style = dojo.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasHScroll = false;
					}else if(style == "scroll"){
						this._hasHScroll = true;
					}else{
						this._hasHScroll = (this.scrollboxNode.offsetWidth - this.getScrollbarWidth() < this.contentNode.offsetWidth );
					}
				}
			}
			if(hadScroll !== this._hasHScroll){
				this.grid.update();
			}
			return this._hasHScroll; // Boolean
		},

		hasVScrollbar: function(reset){
			var hadScroll = this._hasVScroll||false;
			if(this._hasVScroll == undefined || reset){
				if(this.noscroll){
					this._hasVScroll = false;
				}else{
					var style = dojo.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasVScroll = false;
					}else if(style == "scroll"){
						this._hasVScroll = true;
					}else{
						this._hasVScroll = (this.scrollboxNode.scrollHeight > this.scrollboxNode.clientHeight);
					}
				}
			}
			if(hadScroll !== this._hasVScroll){
				this.grid.update();
			}
			return this._hasVScroll; // Boolean
		},
		
		convertColPctToFixed: function(){
			// Fix any percentage widths to be pixel values
			var hasPct = false;
			this.grid.initialWidth = "";
			var cellNodes = dojo.query("th", this.headerContentNode);
			var fixedWidths = dojo.map(cellNodes, function(c, vIdx){
				var w = c.style.width;
				dojo.attr(c, "vIdx", vIdx);
				if(w && w.slice(-1) == "%"){
					hasPct = true;
				}else if(w && w.slice(-2) == "px"){
					return window.parseInt(w, 10);
				}
				return dojo.contentBox(c).w;
			});
			if(hasPct){
				dojo.forEach(this.grid.layout.cells, function(cell, idx){
					if(cell.view == this){
						var cellNode = cell.view.getHeaderCellNode(cell.index);
						if(cellNode && dojo.hasAttr(cellNode, "vIdx")){
							var vIdx = window.parseInt(dojo.attr(cellNode, "vIdx"));
							this.setColWidth(idx, fixedWidths[vIdx]);
							dojo.removeAttr(cellNode, "vIdx");
						}
					}
				}, this);
				return true;
			}
			return false;
		},

		adaptHeight: function(minusScroll){
			if(!this.grid._autoHeight){
				var h = (this.domNode.style.height && parseInt(this.domNode.style.height.replace(/px/,''), 10)) || this.domNode.clientHeight;
				var self = this;
				var checkOtherViewScrollers = function(){
					var v;
					for(var i in self.grid.views.views){
						v = self.grid.views.views[i];
						if(v !== self && v.hasHScrollbar()){
							return true;
						}
					}
					return false;
				};
				if(minusScroll || (this.noscroll && checkOtherViewScrollers())){
					h -= dojox.html.metrics.getScrollbar().h;
				}
				dojox.grid.util.setStyleHeightPx(this.scrollboxNode, h);
			}
			this.hasVScrollbar(true);
		},

		adaptWidth: function(){
			if(this.flexCells){
				// the view content width
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			// FIXME: it should be easier to get w from this.scrollboxNode.clientWidth,
			// but clientWidth seemingly does not include scrollbar width in some cases
			var w = this.scrollboxNode.offsetWidth - this.getScrollbarWidth();
			if(!this._removingColumn){
				w = Math.max(w, this.getColumnsWidth()) + 'px';
			}else{
				w = Math.min(w, this.getColumnsWidth()) + 'px';
				this._removingColumn = false;
			}
			var cn = this.contentNode;
			cn.style.width = w;
			this.hasHScrollbar(true);
		},

		setSize: function(w, h){
			var ds = this.domNode.style;
			var hs = this.headerNode.style;

			if(w){
				ds.width = w;
				hs.width = w;
			}
			ds.height = (h >= 0 ? h + 'px' : '');
		},

		renderRow: function(inRowIndex){
			var rowNode = this.createRowNode(inRowIndex);
			this.buildRow(inRowIndex, rowNode);
			this.grid.edit.restore(this, inRowIndex);
			return rowNode;
		},

		createRowNode: function(inRowIndex){
			var node = document.createElement("div");
			node.className = this.classTag + 'Row';
			if (this instanceof dojox.grid._RowSelector){
				dojo.attr(node,"role","presentation");
			}else{
				dojo.attr(node,"role","row");
				if (this.grid.selectionMode != "none") {
					dojo.attr(node, "aria-selected", "false"); //rows can be selected so add aria-selected prop
				}
			}
			node[dojox.grid.util.gridViewTag] = this.id;
			node[dojox.grid.util.rowIndexTag] = inRowIndex;
			this.rowNodes[inRowIndex] = node;
			return node;
		},

		buildRow: function(inRowIndex, inRowNode){
			
			this.buildRowContent(inRowIndex, inRowNode);
		  	
			this.styleRow(inRowIndex, inRowNode);
		  
		 
		},

		buildRowContent: function(inRowIndex, inRowNode){
			inRowNode.innerHTML = this.content.generateHtml(inRowIndex, inRowIndex);
			if(this.flexCells && this.contentWidth){
				// FIXME: accessing firstChild here breaks encapsulation
				inRowNode.firstChild.style.width = this.contentWidth;
			}
			dojox.grid.util.fire(this, "onAfterRow", [inRowIndex, this.structure.cells, inRowNode]);
		},

		rowRemoved:function(inRowIndex){
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
			this.grid.edit.save(this, inRowIndex);
			delete this.rowNodes[inRowIndex];
		},

		getRowNode: function(inRowIndex){
			return this.rowNodes[inRowIndex];
		},

		getCellNode: function(inRowIndex, inCellIndex){
			var row = this.getRowNode(inRowIndex);
			if(row){
				return this.content.getCellNode(row, inCellIndex);
			}
		},

		getHeaderCellNode: function(inCellIndex){
			if(this.headerContentNode){
				return this.header.getCellNode(this.headerContentNode, inCellIndex);
			}
		},

		// styling
		styleRow: function(inRowIndex, inRowNode){
			inRowNode._style = getStyleText(inRowNode);
			this.styleRowNode(inRowIndex, inRowNode);
		},

		styleRowNode: function(inRowIndex, inRowNode){
			if(inRowNode){
				this.doStyleRowNode(inRowIndex, inRowNode);
			}
		},

		doStyleRowNode: function(inRowIndex, inRowNode){
			this.grid.styleRowNode(inRowIndex, inRowNode);
		},

		// updating
		updateRow: function(inRowIndex){
			var rowNode = this.getRowNode(inRowIndex);
			if(rowNode){
				rowNode.style.height = '';
				this.buildRow(inRowIndex, rowNode);
			}
			return rowNode;
		},

		updateRowStyles: function(inRowIndex){
			this.styleRowNode(inRowIndex, this.getRowNode(inRowIndex));
		},

		// scrolling
		lastTop: 0,
		firstScroll:0,

		doscroll: function(inEvent){
			//var s = dojo.marginBox(this.headerContentNode.firstChild);
			var isLtr = dojo._isBodyLtr();
			if(this.firstScroll < 2){
				if((!isLtr && this.firstScroll == 1) || (isLtr && this.firstScroll === 0)){
					var s = dojo.marginBox(this.headerNodeContainer);
					if(dojo.isIE){
						this.headerNodeContainer.style.width = s.w + this.getScrollbarWidth() + 'px';
					}else if(dojo.isMoz){
						//TODO currently only for FF, not sure for safari and opera
						this.headerNodeContainer.style.width = s.w - this.getScrollbarWidth() + 'px';
						//this.headerNodeContainer.style.width = s.w + 'px';
						//set scroll to right in FF
						this.scrollboxNode.scrollLeft = isLtr ?
							this.scrollboxNode.clientWidth - this.scrollboxNode.scrollWidth :
							this.scrollboxNode.scrollWidth - this.scrollboxNode.clientWidth;
					}
				}
				this.firstScroll++;
			}
			this.headerNode.scrollLeft = this.scrollboxNode.scrollLeft;
			// 'lastTop' is a semaphore to prevent feedback-loop with setScrollTop below
			var top = this.scrollboxNode.scrollTop;
			if(top !== this.lastTop){
				this.grid.scrollTo(top);
			}
		},

		setScrollTop: function(inTop){
			// 'lastTop' is a semaphore to prevent feedback-loop with doScroll above
			this.lastTop = inTop;
			this.scrollboxNode.scrollTop = inTop;
			return this.scrollboxNode.scrollTop;
		},

		// event handlers (direct from DOM)
		doContentEvent: function(e){
			if(this.content.decorateEvent(e)){
				this.grid.onContentEvent(e);
			}
		},

		doHeaderEvent: function(e){
			if(this.header.decorateEvent(e)){
				this.grid.onHeaderEvent(e);
			}
		},

		// event dispatch(from Grid)
		dispatchContentEvent: function(e){
			return this.content.dispatchEvent(e);
		},

		dispatchHeaderEvent: function(e){
			return this.header.dispatchEvent(e);
		},

		// column resizing
		setColWidth: function(inIndex, inWidth){
			this.grid.setCellWidth(inIndex, inWidth + 'px');
		},

		update: function(){
			if(!this.domNode){
				return;
			}
			this.content.update();
			this.grid.update();
			//get scroll after update or scroll left setting goes wrong on IE.
			//See trac: #8040
			var left = this.scrollboxNode.scrollLeft;
			this.scrollboxNode.scrollLeft = left;
			this.headerNode.scrollLeft = left;
		}
	});

	dojo.declare("dojox.grid._GridAvatar", dojo.dnd.Avatar, {
		construct: function(){
			var dd = dojo.doc;

			var a = dd.createElement("table");
			a.cellPadding = a.cellSpacing = "0";
			a.className = "dojoxGridDndAvatar";
			a.style.position = "absolute";
			a.style.zIndex = 1999;
			a.style.margin = "0px"; // to avoid dojo.marginBox() problems with table's margins
			var b = dd.createElement("tbody");
			var tr = dd.createElement("tr");
			var td = dd.createElement("td");
			var img = dd.createElement("td");
			tr.className = "dojoxGridDndAvatarItem";
			img.className = "dojoxGridDndAvatarItemImage";
			img.style.width = "16px";
			var source = this.manager.source, node;
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[0].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[0].cloneNode(true);
				var table, tbody;
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					tbody.appendChild(node);
					table.appendChild(tbody);
					node = table;
				}else if(node.tagName.toLowerCase() == "th"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					var r = dd.createElement("tr");
					table.cellPadding = table.cellSpacing = "0";
					r.appendChild(node);
					tbody.appendChild(r);
					table.appendChild(tbody);
					node = table;
				}
			}
			node.id = "";
			td.appendChild(node);
			tr.appendChild(img);
			tr.appendChild(td);
			dojo.style(tr, "opacity", 0.9);
			b.appendChild(tr);

			a.appendChild(b);
			this.node = a;

			var m = dojo.dnd.manager();
			this.oldOffsetY = m.OFFSET_Y;
			m.OFFSET_Y = 1;
		},
		destroy: function(){
			dojo.dnd.manager().OFFSET_Y = this.oldOffsetY;
			this.inherited(arguments);
		}
	});

	var oldMakeAvatar = dojo.dnd.manager().makeAvatar;
	dojo.dnd.manager().makeAvatar = function(){
		var src = this.source;
		if(src.viewIndex !== undefined && !dojo.hasClass(dojo.body(),"dijit_a11y")){
			return new dojox.grid._GridAvatar(this);
		}
		return oldMakeAvatar.call(dojo.dnd.manager());
	};
})();

}

if(!dojo._hasResource["dojox.grid._RowSelector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._RowSelector"] = true;
dojo.provide("dojox.grid._RowSelector");


dojo.declare('dojox.grid._RowSelector', dojox.grid._View, {
	// summary:
	//	Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.
	defaultWidth: "2em",
	noscroll: true,
	padBorderWidth: 2,
	buildRendering: function(){
		this.inherited('buildRendering', arguments);
		this.scrollboxNode.style.overflow = "hidden";
		this.headerNode.style.visibility = "hidden";
	},
	getWidth: function(){
		return this.viewWidth || this.defaultWidth;
	},
	buildRowContent: function(inRowIndex, inRowNode){
		var w = this.contentWidth || 0;
		inRowNode.innerHTML = '<table class="dojoxGridRowbarTable" style="width:' + w + 'px;height:1px;" border="0" cellspacing="0" cellpadding="0" role="presentation"><tr><td class="dojoxGridRowbarInner">&nbsp;</td></tr></table>';
	},
	renderHeader: function(){
	},
	updateRow: function(){
	},
	resize: function(){
		this.adaptHeight();
	},
	adaptWidth: function(){
		// Only calculate this here - rather than every call to buildRowContent
		if(!("contentWidth" in this) && this.contentNode){
			this.contentWidth = this.contentNode.offsetWidth - this.padBorderWidth;
		}
	},
	// styling
	doStyleRowNode: function(inRowIndex, inRowNode){
		var n = [ "dojoxGridRowbar dojoxGridNonNormalizedCell" ];
		if(this.grid.rows.isOver(inRowIndex)){
			n.push("dojoxGridRowbarOver");
		}
		if(this.grid.selection.isSelected(inRowIndex)){
			n.push("dojoxGridRowbarSelected");
		}
		inRowNode.className = n.join(" ");
	},
	// event handlers
	domouseover: function(e){
		this.grid.onMouseOverRow(e);
	},
	domouseout: function(e){
		if(!this.isIntraRowEvent(e)){
			this.grid.onMouseOutRow(e);
		}
	}
});

}

if(!dojo._hasResource["dojox.grid._Layout"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Layout"] = true;
dojo.provide("dojox.grid._Layout");



dojo.declare("dojox.grid._Layout", null, {
	// summary:
	//	Controls grid cell layout. Owned by grid and used internally.
	constructor: function(inGrid){
		this.grid = inGrid;
	},
	// flat array of grid cells
	cells: [],
	// structured array of grid cells
	structure: null,
	// default cell width
	defaultWidth: '6em',

	// methods
	moveColumn: function(sourceViewIndex, destViewIndex, cellIndex, targetIndex, before){
		var source_cells = this.structure[sourceViewIndex].cells[0];
		var dest_cells = this.structure[destViewIndex].cells[0];

		var cell = null;
		var cell_ri = 0;
		var target_ri = 0;

		for(var i=0, c; c=source_cells[i]; i++){
			if(c.index == cellIndex){
				cell_ri = i;
				break;
			}
		}
		cell = source_cells.splice(cell_ri, 1)[0];
		cell.view = this.grid.views.views[destViewIndex];

		for(i=0, c=null; c=dest_cells[i]; i++){
			if(c.index == targetIndex){
				target_ri = i;
				break;
			}
		}
		if(!before){
			target_ri += 1;
		}
		dest_cells.splice(target_ri, 0, cell);

		var sortedCell = this.grid.getCell(this.grid.getSortIndex());
		if(sortedCell){
			sortedCell._currentlySorted = this.grid.getSortAsc();
		}

		this.cells = [];
		cellIndex = 0;
		var v;
		for(i=0; v=this.structure[i]; i++){
			for(var j=0, cs; cs=v.cells[j]; j++){
				for(var k=0; c=cs[k]; k++){
					c.index = cellIndex;
					this.cells.push(c);
					if("_currentlySorted" in c){
						var si = cellIndex + 1;
						si *= c._currentlySorted ? 1 : -1;
						this.grid.sortInfo = si;
						delete c._currentlySorted;
					}
					cellIndex++;
				}
			}
		}
		
		//Fix #9481 - reset idx in cell markup
		dojo.forEach(this.cells, function(c){
			var marks = c.markup[2].split(" ");
			var oldIdx = parseInt(marks[1].substring(5));//get old "idx"
			if(oldIdx != c.index){
				marks[1] = "idx=\"" + c.index + "\"";
				c.markup[2] = marks.join(" ");
			}
		});
		
		this.grid.setupHeaderMenu();
		//this.grid.renderOnIdle();
	},

	setColumnVisibility: function(columnIndex, visible){
		var cell = this.cells[columnIndex];
		if(cell.hidden == visible){
			cell.hidden = !visible;
			var v = cell.view, w = v.viewWidth;
			if(w && w != "auto"){
				v._togglingColumn = dojo.marginBox(cell.getHeaderNode()).w || 0;
			}
			v.update();
			return true;
		}else{
			return false;
		}
	},
	
	addCellDef: function(inRowIndex, inCellIndex, inDef){
		var self = this;
		var getCellWidth = function(inDef){
			var w = 0;
			if(inDef.colSpan > 1){
				w = 0;
			}else{
				w = inDef.width || self._defaultCellProps.width || self.defaultWidth;

				if(!isNaN(w)){
					w = w + "em";
				}
			}
			return w;
		};

		var props = {
			grid: this.grid,
			subrow: inRowIndex,
			layoutIndex: inCellIndex,
			index: this.cells.length
		};

		if(inDef && inDef instanceof dojox.grid.cells._Base){
			var new_cell = dojo.clone(inDef);
			props.unitWidth = getCellWidth(new_cell._props);
			new_cell = dojo.mixin(new_cell, this._defaultCellProps, inDef._props, props);
			return new_cell;
		}

		var cell_type = inDef.type || inDef.cellType || this._defaultCellProps.type || this._defaultCellProps.cellType || dojox.grid.cells.Cell;

		props.unitWidth = getCellWidth(inDef);
		return new cell_type(dojo.mixin({}, this._defaultCellProps, inDef, props));
	},
	
	addRowDef: function(inRowIndex, inDef){
		var result = [];
		var relSum = 0, pctSum = 0, doRel = true;
		for(var i=0, def, cell; (def=inDef[i]); i++){
			cell = this.addCellDef(inRowIndex, i, def);
			result.push(cell);
			this.cells.push(cell);
			// Check and calculate the sum of all relative widths
			if(doRel && cell.relWidth){
				relSum += cell.relWidth;
			}else if(cell.width){
				var w = cell.width;
				if(typeof w == "string" && w.slice(-1) == "%"){
					pctSum += window.parseInt(w, 10);
				}else if(w == "auto"){
					// relative widths doesn't play nice with auto - since we
					// don't have a way of knowing how much space the auto is
					// supposed to take up.
					doRel = false;
				}
			}
		}
		if(relSum && doRel){
			// We have some kind of relWidths specified - so change them to %
			dojo.forEach(result, function(cell){
				if(cell.relWidth){
					cell.width = cell.unitWidth = ((cell.relWidth / relSum) * (100 - pctSum)) + "%";
				}
			});
		}
		return result;
	
	},

	addRowsDef: function(inDef){
		var result = [];
		if(dojo.isArray(inDef)){
			if(dojo.isArray(inDef[0])){
				for(var i=0, row; inDef && (row=inDef[i]); i++){
					result.push(this.addRowDef(i, row));
				}
			}else{
				result.push(this.addRowDef(0, inDef));
			}
		}
		return result;
	},
	
	addViewDef: function(inDef){
		this._defaultCellProps = inDef.defaultCell || {};
		if(inDef.width && inDef.width == "auto"){
			delete inDef.width;
		}
		return dojo.mixin({}, inDef, {cells: this.addRowsDef(inDef.rows || inDef.cells)});
	},
	
	setStructure: function(inStructure){
		this.fieldIndex = 0;
		this.cells = [];
		var s = this.structure = [];

		if(this.grid.rowSelector){
			var sel = { type: dojox._scopeName + ".grid._RowSelector" };

			if(dojo.isString(this.grid.rowSelector)){
				var width = this.grid.rowSelector;

				if(width == "false"){
					sel = null;
				}else if(width != "true"){
					sel['width'] = width;
				}
			}else{
				if(!this.grid.rowSelector){
					sel = null;
				}
			}

			if(sel){
				s.push(this.addViewDef(sel));
			}
		}

		var isCell = function(def){
			return ("name" in def || "field" in def || "get" in def);
		};

		var isRowDef = function(def){
			if(dojo.isArray(def)){
				if(dojo.isArray(def[0]) || isCell(def[0])){
					return true;
				}
			}
			return false;
		};

		var isView = function(def){
			return (def !== null && dojo.isObject(def) &&
					("cells" in def || "rows" in def || ("type" in def && !isCell(def))));
		};

		if(dojo.isArray(inStructure)){
			var hasViews = false;
			for(var i=0, st; (st=inStructure[i]); i++){
				if(isView(st)){
					hasViews = true;
					break;
				}
			}
			if(!hasViews){
				s.push(this.addViewDef({ cells: inStructure }));
			}else{
				for(i=0; (st=inStructure[i]); i++){
					if(isRowDef(st)){
						s.push(this.addViewDef({ cells: st }));
					}else if(isView(st)){
						s.push(this.addViewDef(st));
					}
				}
			}
		}else if(isView(inStructure)){
			// it's a view object
			s.push(this.addViewDef(inStructure));
		}

		this.cellCount = this.cells.length;
		this.grid.setupHeaderMenu();
	}
});

}

if(!dojo._hasResource["dojox.grid._ViewManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._ViewManager"] = true;
dojo.provide("dojox.grid._ViewManager");

dojo.declare('dojox.grid._ViewManager', null, {
	// summary:
	//		A collection of grid views. Owned by grid and used internally for managing grid views.
	// description:
	//		Grid creates views automatically based on grid's layout structure.
	//		Users should typically not need to access individual views or the views collection directly.
	constructor: function(inGrid){
		this.grid = inGrid;
	},

	defaultWidth: 200,

	views: [],

	// operations
	resize: function(){
		this.onEach("resize");
	},

	render: function(){
		this.onEach("render");
	},

	// views
	addView: function(inView){
		inView.idx = this.views.length;
		this.views.push(inView);
	},

	destroyViews: function(){
		for(var i=0, v; v=this.views[i]; i++){
			v.destroy();
		}
		this.views = [];
	},

	getContentNodes: function(){
		var nodes = [];
		for(var i=0, v; v=this.views[i]; i++){
			nodes.push(v.contentNode);
		}
		return nodes;
	},

	forEach: function(inCallback){
		for(var i=0, v; v=this.views[i]; i++){
			inCallback(v, i);
		}
	},

	onEach: function(inMethod, inArgs){
		inArgs = inArgs || [];
		for(var i=0, v; v=this.views[i]; i++){
			if(inMethod in v){
				v[inMethod].apply(v, inArgs);
			}
		}
	},

	// layout
	normalizeHeaderNodeHeight: function(){
		var rowNodes = [];
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.headerContentNode.firstChild){
				rowNodes.push(v.headerContentNode);
			}
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	normalizeRowNodeHeights: function(inRowNodes){
		var h = 0;
		var currHeights = [];
		if(this.grid.rowHeight){
			h = this.grid.rowHeight;
		}else{
			if(inRowNodes.length <= 1){
				// no need to normalize if we are the only one...
				return;
			}
			for(var i=0, n; (n=inRowNodes[i]); i++){
				// We only care about the height - so don't use marginBox.  This
				// depends on the container not having any margin (which it shouldn't)
				// Also - we only look up the height if the cell doesn't have the
				// dojoxGridNonNormalizedCell class (like for row selectors)
				if(!dojo.hasClass(n, "dojoxGridNonNormalizedCell")){
					currHeights[i] = n.firstChild.offsetHeight;
					h =  Math.max(h, currHeights[i]);
				}
			}
			h = (h >= 0 ? h : 0);
	
			//Work around odd FF3 rendering bug: #8864.
			//A one px increase fixes FireFox 3's rounding bug for fractional font sizes.
			if(dojo.isMoz && h){h++;}
		}
		for(i=0; (n=inRowNodes[i]); i++){
			if(currHeights[i] != h){
				n.firstChild.style.height = h + "px";
			}
		}
	},
	
	resetHeaderNodeHeight: function(){
		for(var i=0, v, n; (v=this.views[i]); i++){
			n = v.headerContentNode.firstChild;
			if(n){
				n.style.height = "";
			}
		}
	},

	renormalizeRow: function(inRowIndex){
		var rowNodes = [];
		for(var i=0, v, n; (v=this.views[i])&&(n=v.getRowNode(inRowIndex)); i++){
			n.firstChild.style.height = '';
			rowNodes.push(n);
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	getViewWidth: function(inIndex){
		return this.views[inIndex].getWidth() || this.defaultWidth;
	},

	// must be called after view widths are properly set or height can be miscalculated
	// if there are flex columns
	measureHeader: function(){
		// need to reset view header heights so they are properly measured.
		this.resetHeaderNodeHeight();
		this.forEach(function(inView){
			inView.headerContentNode.style.height = '';
		});
		var h = 0;
		// calculate maximum view header height
		this.forEach(function(inView){
			h = Math.max(inView.headerNode.offsetHeight, h);
		});
		return h;
	},

	measureContent: function(){
		var h = 0;
		this.forEach(function(inView){
			h = Math.max(inView.domNode.offsetHeight, h);
		});
		return h;
	},

	findClient: function(inAutoWidth){
		// try to use user defined client
		var c = this.grid.elasticView || -1;
		// attempt to find implicit client
		if(c < 0){
			for(var i=1, v; (v=this.views[i]); i++){
				if(v.viewWidth){
					for(i=1; (v=this.views[i]); i++){
						if(!v.viewWidth){
							c = i;
							break;
						}
					}
					break;
				}
			}
		}
		// client is in the middle by default
		if(c < 0){
			c = Math.floor(this.views.length / 2);
		}
		return c;
	},

	arrange: function(l, w){
		var i, v, vw, len = this.views.length;
		// find the client
		var c = (w <= 0 ? len : this.findClient());
		// layout views
		var setPosition = function(v, l){
			var ds = v.domNode.style;
			var hs = v.headerNode.style;

			if(!dojo._isBodyLtr()){
				ds.right = l + 'px';
				// fixed rtl, the scrollbar is on the right side in FF
				if (dojo.isMoz) {
					hs.right = l + v.getScrollbarWidth() + 'px';
					hs.width = parseInt(hs.width, 10) - v.getScrollbarWidth() + 'px';
				}else{
					hs.right = l + 'px';
				}
			}else{
				ds.left = l + 'px';
				hs.left = l + 'px';
			}
			ds.top = 0 + 'px';
			hs.top = 0;
		};
		// for views left of the client
		//BiDi TODO: The left and right should not appear in BIDI environment. Should be replaced with
		//leading and tailing concept.
		for(i=0; (v=this.views[i])&&(i<c); i++){
			// get width
			vw = this.getViewWidth(i);
			// process boxes
			v.setSize(vw, 0);
			setPosition(v, l);
			if(v.headerContentNode && v.headerContentNode.firstChild){
				vw = v.getColumnsWidth()+v.getScrollbarWidth();
			}else{
				vw = v.domNode.offsetWidth;
			}
			// update position
			l += vw;
		}
		// next view (is the client, i++ == c)
		i++;
		// start from the right edge
		var r = w;
		// for views right of the client (iterated from the right)
		for(var j=len-1; (v=this.views[j])&&(i<=j); j--){
			// get width
			vw = this.getViewWidth(j);
			// set size
			v.setSize(vw, 0);
			// measure in pixels
			vw = v.domNode.offsetWidth;
			// update position
			r -= vw;
			// set position
			setPosition(v, r);
		}
		if(c<len){
			v = this.views[c];
			// position the client box between left and right boxes
			vw = Math.max(1, r-l);
			// set size
			v.setSize(vw + 'px', 0);
			setPosition(v, l);
		}
		return l;
	},

	// rendering
	renderRow: function(inRowIndex, inNodes, skipRenorm){
		var rowNodes = [];
		for(var i=0, v, n, rowNode; (v=this.views[i])&&(n=inNodes[i]); i++){
			rowNode = v.renderRow(inRowIndex);
			n.appendChild(rowNode);
			rowNodes.push(rowNode);
		}
		if(!skipRenorm){
			this.normalizeRowNodeHeights(rowNodes);
		}
	},
	
	rowRemoved: function(inRowIndex){
		this.onEach("rowRemoved", [ inRowIndex ]);
	},
	
	// updating
	updateRow: function(inRowIndex, skipRenorm){
		for(var i=0, v; v=this.views[i]; i++){
			v.updateRow(inRowIndex);
		}
		if(!skipRenorm){
			this.renormalizeRow(inRowIndex);
		}
	},
	
	updateRowStyles: function(inRowIndex){
		this.onEach("updateRowStyles", [ inRowIndex ]);
	},
	
	// scrolling
	setScrollTop: function(inTop){
		var top = inTop;
		for(var i=0, v; v=this.views[i]; i++){
			top = v.setScrollTop(inTop);
			// Work around IE not firing scroll events that cause header offset
			// issues to occur.
			if(dojo.isIE && v.headerNode && v.scrollboxNode){
				v.headerNode.scrollLeft = v.scrollboxNode.scrollLeft;
			}
		}
		return top;
		//this.onEach("setScrollTop", [ inTop ]);
	},
	
	getFirstScrollingView: function(){
		// summary: Returns the first grid view with a scroll bar
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.hasHScrollbar() || v.hasVScrollbar()){
				return v;
			}
		}
		return null;
	}
	
});

}

if(!dojo._hasResource["dojox.grid._RowManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._RowManager"] = true;
dojo.provide("dojox.grid._RowManager");

(function(){
	var setStyleText = function(inNode, inStyleText){
		if(inNode.style.cssText == undefined){
			inNode.setAttribute("style", inStyleText);
		}else{
			inNode.style.cssText = inStyleText;
		}
	};

	dojo.declare("dojox.grid._RowManager", null, {
		//	Stores information about grid rows. Owned by grid and used internally.
		constructor: function(inGrid){
			this.grid = inGrid;
		},
		linesToEms: 2,
		overRow: -2,
		// styles
		prepareStylingRow: function(inRowIndex, inRowNode){
			return {
				index: inRowIndex,
				node: inRowNode,
				odd: Boolean(inRowIndex&1),
				selected: !!this.grid.selection.isSelected(inRowIndex),
				over: this.isOver(inRowIndex),
				customStyles: "",
				customClasses: "dojoxGridRow"
			};
		},
		styleRowNode: function(inRowIndex, inRowNode){
			var row = this.prepareStylingRow(inRowIndex, inRowNode);
			this.grid.onStyleRow(row);
			this.applyStyles(row);
		},
		applyStyles: function(inRow){
			var i = inRow;

			i.node.className = i.customClasses;
			var h = i.node.style.height;
			setStyleText(i.node, i.customStyles + ';' + (i.node._style||''));
			i.node.style.height = h;
		},
		updateStyles: function(inRowIndex){
			this.grid.updateRowStyles(inRowIndex);
		},
		// states and events
		setOverRow: function(inRowIndex){
			var last = this.overRow;
			this.overRow = inRowIndex;
			if((last!=this.overRow)&&(dojo.isString(last) || last >= 0)){
				this.updateStyles(last);
			}
			this.updateStyles(this.overRow);
		},
		isOver: function(inRowIndex){
			return (this.overRow == inRowIndex && !dojo.hasClass(this.grid.domNode, "dojoxGridColumnResizing"));
		}
	});
})();

}

if(!dojo._hasResource["dojox.grid._FocusManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._FocusManager"] = true;
dojo.provide("dojox.grid._FocusManager");



// focus management
dojo.declare("dojox.grid._FocusManager", null, {
	// summary:
	//	Controls grid cell focus. Owned by grid and used internally for focusing.
	//	Note: grid cell actually receives keyboard input only when cell is being edited.
	constructor: function(inGrid){
		this.grid = inGrid;
		this.cell = null;
		this.rowIndex = -1;
		this._connects = [];
		this._headerConnects = [];
		this.headerMenu = this.grid.headerMenu;
		this._connects.push(dojo.connect(this.grid.domNode, "onfocus", this, "doFocus"));
		this._connects.push(dojo.connect(this.grid.domNode, "onblur", this, "doBlur"));
		this._connects.push(dojo.connect(this.grid.domNode, "oncontextmenu", this, "doContextMenu"));
		this._connects.push(dojo.connect(this.grid.lastFocusNode, "onfocus", this, "doLastNodeFocus"));
		this._connects.push(dojo.connect(this.grid.lastFocusNode, "onblur", this, "doLastNodeBlur"));
		this._connects.push(dojo.connect(this.grid,"_onFetchComplete", this, "_delayedCellFocus"));
		this._connects.push(dojo.connect(this.grid,"postrender", this, "_delayedHeaderFocus"));
	},
	destroy: function(){
		dojo.forEach(this._connects, dojo.disconnect);
		dojo.forEach(this._headerConnects, dojo.disconnect);
		delete this.grid;
		delete this.cell;
	},
	_colHeadNode: null,
	_colHeadFocusIdx: null,
	_contextMenuBindNode: null,
	tabbingOut: false,
	focusClass: "dojoxGridCellFocus",
	focusView: null,
	initFocusView: function(){
		this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
		this._initColumnHeaders();
	},
	isFocusCell: function(inCell, inRowIndex){
		// summary:
		//	states if the given cell is focused
		// inCell: object
		//	grid cell object
		// inRowIndex: int
		//	grid row index
		// returns:
		//	true of the given grid cell is focused
		return (this.cell == inCell) && (this.rowIndex == inRowIndex);
	},
	isLastFocusCell: function(){
		if(this.cell){
			return (this.rowIndex == this.grid.rowCount-1) && (this.cell.index == this.grid.layout.cellCount-1);
		}
		return false;
	},
	isFirstFocusCell: function(){
		if(this.cell){
			return (this.rowIndex === 0) && (this.cell.index === 0);
		}
		return false;
	},
	isNoFocusCell: function(){
		return (this.rowIndex < 0) || !this.cell;
	},
	isNavHeader: function(){
		// summary:
		//	states whether currently navigating among column headers.
		// returns:
		//	true if focus is on a column header; false otherwise.
		return (!!this._colHeadNode);
	},
	getHeaderIndex: function(){
		// summary:
		//	if one of the column headers currently has focus, return its index.
		// returns:
		//	index of the focused column header, or -1 if none have focus.
		if(this._colHeadNode){
			return dojo.indexOf(this._findHeaderCells(), this._colHeadNode);
		}else{
			return -1;
		}
	},
	_focusifyCellNode: function(inBork){
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			dojo.toggleClass(n, this.focusClass, inBork);
			if(inBork){
				var sl = this.scrollIntoView();
				try{
					if(!this.grid.edit.isEditing()){
						dojox.grid.util.fire(n, "focus");
						if(sl){ this.cell.view.scrollboxNode.scrollLeft = sl; }
					}
				}catch(e){}
			}
		}
	},
	_delayedCellFocus: function(){
		if(this.isNavHeader()||!this.grid._focused){
				return;
		}
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			try{
				if(!this.grid.edit.isEditing()){
					dojo.toggleClass(n, this.focusClass, true);
					this.blurHeader();
					dojox.grid.util.fire(n, "focus");
				}
			}
			catch(e){}
		}
	},
	_delayedHeaderFocus: function(){
		if(this.isNavHeader()){
			this.focusHeader();
			this.grid.domNode.focus();
		}
	},
	_initColumnHeaders: function(){
		dojo.forEach(this._headerConnects, dojo.disconnect);
		this._headerConnects = [];
		var headers = this._findHeaderCells();
		for(var i = 0; i < headers.length; i++){
			this._headerConnects.push(dojo.connect(headers[i], "onfocus", this, "doColHeaderFocus"));
			this._headerConnects.push(dojo.connect(headers[i], "onblur", this, "doColHeaderBlur"));
		}
	},
	_findHeaderCells: function(){
		// This should be a one liner:
		//	dojo.query("th[tabindex=-1]", this.grid.viewsHeaderNode);
		// But there is a bug in dojo.query() for IE -- see trac #7037.
		var allHeads = dojo.query("th", this.grid.viewsHeaderNode);
		var headers = [];
		for (var i = 0; i < allHeads.length; i++){
			var aHead = allHeads[i];
			var hasTabIdx = dojo.hasAttr(aHead, "tabIndex");
			var tabindex = dojo.attr(aHead, "tabIndex");
			if (hasTabIdx && tabindex < 0) {
				headers.push(aHead);
			}
		}
		return headers;
	},
	_setActiveColHeader: function(/*Node*/colHeaderNode, /*Integer*/colFocusIdx, /*Integer*/ prevColFocusIdx){
		//console.log("setActiveColHeader() - colHeaderNode:colFocusIdx:prevColFocusIdx = " + colHeaderNode + ":" + colFocusIdx + ":" + prevColFocusIdx);
		dojo.attr(this.grid.domNode, "aria-activedescendant",colHeaderNode.id);
		if (prevColFocusIdx != null && prevColFocusIdx >= 0 && prevColFocusIdx != colFocusIdx){
			dojo.toggleClass(this._findHeaderCells()[prevColFocusIdx],this.focusClass,false);
		}
		dojo.toggleClass(colHeaderNode,this.focusClass, true);
		this._colHeadNode = colHeaderNode;
		this._colHeadFocusIdx = colFocusIdx;
		this._scrollHeader(this._colHeadFocusIdx);
	},
	scrollIntoView: function(){
		var info = (this.cell ? this._scrollInfo(this.cell) : null);
		if(!info || !info.s){
			return null;
		}
		var rt = this.grid.scroller.findScrollTop(this.rowIndex);
		// place cell within horizontal view
		if(info.n && info.sr){
			if(info.n.offsetLeft + info.n.offsetWidth > info.sr.l + info.sr.w){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}
		}
		// place cell within vertical view
		if(info.r && info.sr){
			if(rt + info.r.offsetHeight > info.sr.t + info.sr.h){
				this.grid.setScrollTop(rt + info.r.offsetHeight - info.sr.h);
			}else if(rt < info.sr.t){
				this.grid.setScrollTop(rt);
			}
		}

		return info.s.scrollLeft;
	},
	_scrollInfo: function(cell, domNode){
		if(cell){
			var cl = cell,
				sbn = cl.view.scrollboxNode,
				sbnr = {
					w: sbn.clientWidth,
					l: sbn.scrollLeft,
					t: sbn.scrollTop,
					h: sbn.clientHeight
				},
				rn = cl.view.getRowNode(this.rowIndex);
			return {
				c: cl,
				s: sbn,
				sr: sbnr,
				n: (domNode ? domNode : cell.getNode(this.rowIndex)),
				r: rn
			};
		}
		return null;
	},
	_scrollHeader: function(currentIdx){
		var info = null;
		if(this._colHeadNode){
			var cell = this.grid.getCell(currentIdx);
			info = this._scrollInfo(cell, cell.getNode(0));
		}
		if(info && info.s && info.sr && info.n){
			// scroll horizontally as needed.
			var scroll = info.sr.l + info.sr.w;
			if(info.n.offsetLeft + info.n.offsetWidth > scroll){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}else if(dojo.isIE <= 7 && cell && cell.view.headerNode){
				// Trac 7158: scroll dojoxGridHeader for IE7 and lower
				cell.view.headerNode.scrollLeft = info.s.scrollLeft;
			}
		}
	},
	_isHeaderHidden: function(){
		// summary:
		//		determine if the grid headers are hidden
		//		relies on documented technique of setting .dojoxGridHeader { display:none; }
		// returns: Boolean
		//		true if headers are hidden
		//		false if headers are not hidden
		
		var curView = this.focusView;
		if (!curView){
			// find one so we can determine if headers are hidden
			// there is no focusView after adding items to empty grid (test_data_grid_empty.html)
			for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
				if(cView.headerNode ){
					curView=cView;
					break;
				}
			}
		}
		return (curView && dojo.getComputedStyle(curView.headerNode).display == "none");
	},
	colSizeAdjust: function (e, colIdx, delta){ // adjust the column specified by colIdx by the specified delta px
		var headers = this._findHeaderCells();
		var view = this.focusView;
		if (!view) {
			for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
				// find first view with a tableMap in order to work with empty grid
				if(cView.header.tableMap.map ){
					view=cView;
					break;
				}
			}
		}
		var curHeader = headers[colIdx];
		if (!view || (colIdx == headers.length-1 && colIdx === 0)){
			return; // can't adjust single col. grid
		}
		view.content.baseDecorateEvent(e);
		// need to adjust event with header cell info since focus is no longer on header cell
		e.cellNode = curHeader; //this.findCellTarget(e.target, e.rowNode);
		e.cellIndex = view.content.getCellNodeIndex(e.cellNode);
		e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		if (view.header.canResize(e)){
			var deltaObj = {
				l: delta
			};
			var drag = view.header.colResizeSetup(e,false);
			view.header.doResizeColumn(drag, null, deltaObj);
			view.update();
		}
	},
	styleRow: function(inRow){
		return;
	},
	setFocusIndex: function(inRowIndex, inCellIndex){
		// summary:
		//	focuses the given grid cell
		// inRowIndex: int
		//	grid row index
		// inCellIndex: int
		//	grid cell index
		this.setFocusCell(this.grid.getCell(inCellIndex), inRowIndex);
	},
	setFocusCell: function(inCell, inRowIndex){
		// summary:
		//	focuses the given grid cell
		// inCell: object
		//	grid cell object
		// inRowIndex: int
		//	grid row index
		if(inCell && !this.isFocusCell(inCell, inRowIndex)){
			this.tabbingOut = false;
			if (this._colHeadNode){
				this.blurHeader();
			}
			this._colHeadNode = this._colHeadFocusIdx = null;
			this.focusGridView();
			this._focusifyCellNode(false);
			this.cell = inCell;
			this.rowIndex = inRowIndex;
			this._focusifyCellNode(true);
		}
		// even if this cell isFocusCell, the document focus may need to be rejiggered
		// call opera on delay to prevent keypress from altering focus
		if(dojo.isOpera){
			setTimeout(dojo.hitch(this.grid, 'onCellFocus', this.cell, this.rowIndex), 1);
		}else{
			this.grid.onCellFocus(this.cell, this.rowIndex);
		}
	},
	next: function(){
		// summary:
		//	focus next grid cell
		if(this.cell){
			var row=this.rowIndex, col=this.cell.index+1, cc=this.grid.layout.cellCount-1, rc=this.grid.rowCount-1;
			if(col > cc){
				col = 0;
				row++;
			}
			if(row > rc){
				col = cc;
				row = rc;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var nextCell = this.grid.getCell(col);
				if (!this.isLastFocusCell() && (!nextCell.editable ||
					this.grid.canEdit && !this.grid.canEdit(nextCell, row))){
					this.cell=nextCell;
					this.rowIndex=row;
					this.next();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	previous: function(){
		// summary:
		//	focus previous grid cell
		if(this.cell){
			var row=(this.rowIndex || 0), col=(this.cell.index || 0) - 1;
			if(col < 0){
				col = this.grid.layout.cellCount-1;
				row--;
			}
			if(row < 0){
				row = 0;
				col = 0;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var prevCell = this.grid.getCell(col);
				if (!this.isFirstFocusCell() && !prevCell.editable){
					this.cell=prevCell;
					this.rowIndex=row;
					this.previous();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	move: function(inRowDelta, inColDelta) {
		// summary:
		//	focus grid cell or  simulate focus to column header based on position relative to current focus
		// inRowDelta: int
		// vertical distance from current focus
		// inColDelta: int
		// horizontal distance from current focus

		var colDir = inColDelta < 0 ? -1 : 1;
		// Handle column headers.
		if(this.isNavHeader()){
			var headers = this._findHeaderCells();
			var savedIdx = currentIdx = dojo.indexOf(headers, this._colHeadNode);
			currentIdx += inColDelta;
			while(currentIdx >=0 && currentIdx < headers.length && headers[currentIdx].style.display == "none"){
				// skip over hidden column headers
				currentIdx += colDir;
			}
			if((currentIdx >= 0) && (currentIdx < headers.length)){
				this._setActiveColHeader(headers[currentIdx],currentIdx, savedIdx);
			}
		}else{
			if(this.cell){
				// Handle grid proper.
				var sc = this.grid.scroller,
					r = this.rowIndex,
					rc = this.grid.rowCount-1,
					row = Math.min(rc, Math.max(0, r+inRowDelta));
				if(inRowDelta){
					if(inRowDelta>0){
						if(row > sc.getLastPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop+sc.findScrollTop(row)-sc.findScrollTop(r));
						}
					}else if(inRowDelta<0){
						if(row <= sc.getPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop-sc.findScrollTop(r)-sc.findScrollTop(row));
						}
					}
				}
				var cc = this.grid.layout.cellCount-1,
				i = this.cell.index,
				col = Math.min(cc, Math.max(0, i+inColDelta));
				var cell = this.grid.getCell(col);
				while(col>=0 && col < cc && cell && cell.hidden === true){
					// skip hidden cells
					col += colDir;
					cell = this.grid.getCell(col);
				}
				if (!cell || cell.hidden === true){
					// don't change col if would move to hidden
					col = i;
				}
				//skip hidden row|cell
				var n = cell.getNode(row);
				if(!n && inRowDelta){
					if((row + inRowDelta) >= 0 && (row + inRowDelta) <= rc){
						this.move(inRowDelta > 0 ? ++inRowDelta : --inRowDelta, inColDelta);
					}
					return;
				}else if((!n || dojo.style(n, "display") === "none") && inColDelta){
					if((col + inRowDelta) >= 0 && (col + inRowDelta) <= cc){
						this.move(inRowDelta, inColDelta > 0 ? ++inColDelta : --inColDelta);
					}
					return;
				}
				this.setFocusIndex(row, col);
				if(inRowDelta){
					this.grid.updateRow(r);
				}
			}
		}
	},
	previousKey: function(e){
		if(this.grid.edit.isEditing()){
			dojo.stopEvent(e);
			this.previous();
		}else if(!this.isNavHeader() && !this._isHeaderHidden()) {
			this.grid.domNode.focus(); // will call doFocus and set focus into header.
			dojo.stopEvent(e);
		}else{
			this.tabOut(this.grid.domNode);
			if (this._colHeadFocusIdx != null) { // clear grid header focus
				dojo.toggleClass(this._findHeaderCells()[this._colHeadFocusIdx], this.focusClass, false);
				this._colHeadFocusIdx = null;
			}
			this._focusifyCellNode(false);
		}
	},
	nextKey: function(e) {
		var isEmpty = (this.grid.rowCount === 0);
		if(e.target === this.grid.domNode && this._colHeadFocusIdx == null){
			this.focusHeader();
			dojo.stopEvent(e);
		}else if(this.isNavHeader()){
			// if tabbing from col header, then go to grid proper.
			this.blurHeader();
			if(!this.findAndFocusGridCell()){
				this.tabOut(this.grid.lastFocusNode);
			}
			this._colHeadNode = this._colHeadFocusIdx= null;
		}else if(this.grid.edit.isEditing()){
			dojo.stopEvent(e);
			this.next();
		}else{
			this.tabOut(this.grid.lastFocusNode);
		}
	},
	tabOut: function(inFocusNode){
		this.tabbingOut = true;
		inFocusNode.focus();
	},
	focusGridView: function(){
		dojox.grid.util.fire(this.focusView, "focus");
	},
	focusGrid: function(inSkipFocusCell){
		this.focusGridView();
		this._focusifyCellNode(true);
	},
	findAndFocusGridCell: function(){
		// summary:
		//		find the first focusable grid cell
		// returns: Boolean
		//		true if focus was set to a cell
		//		false if no cell found to set focus onto
		
		var didFocus = true;
		var isEmpty = (this.grid.rowCount === 0); // If grid is empty this.grid.rowCount == 0
		if (this.isNoFocusCell() && !isEmpty){
			var cellIdx = 0;
			var cell = this.grid.getCell(cellIdx);
			if (cell.hidden) {
				// if first cell isn't visible, use _colHeadFocusIdx
				// could also use a while loop to find first visible cell - not sure that is worth it
				cellIdx = this.isNavHeader() ? this._colHeadFocusIdx : 0;
			}
			this.setFocusIndex(0, cellIdx);
		}
		else if (this.cell && !isEmpty){
			if (this.focusView && !this.focusView.rowNodes[this.rowIndex]){
				// if rowNode for current index is undefined (likely as a result of a sort and because of #7304)
				// scroll to that row
				this.grid.scrollToRow(this.rowIndex);
			}
			this.focusGrid();
		}else {
			didFocus = false;
		}
		this._colHeadNode = this._colHeadFocusIdx= null;
		return didFocus;
	},
	focusHeader: function(){
		var headerNodes = this._findHeaderCells();
		var saveColHeadFocusIdx = this._colHeadFocusIdx;
		if (this._isHeaderHidden()){
			// grid header is hidden, focus a cell
			this.findAndFocusGridCell();
		}
		else if (!this._colHeadFocusIdx) {
			if (this.isNoFocusCell()) {
				this._colHeadFocusIdx = 0;
			}
			else {
				this._colHeadFocusIdx = this.cell.index;
			}
		}
		this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		while(this._colHeadNode && this._colHeadFocusIdx >=0 && this._colHeadFocusIdx < headerNodes.length &&
				this._colHeadNode.style.display == "none"){
			// skip over hidden column headers
			this._colHeadFocusIdx++;
			this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		}
		if(this._colHeadNode && this._colHeadNode.style.display != "none"){
			// Column header cells know longer receive actual focus.  So, for keyboard invocation of
			// contextMenu to work, the contextMenu must be bound to the grid.domNode rather than the viewsHeaderNode.
			// unbind the contextmenu from the viewsHeaderNode and to the grid when header cells are active.  Reset
			// the binding back to the viewsHeaderNode when header cells are no longer acive (in blurHeader) #10483
			if (this.headerMenu && this._contextMenuBindNode != this.grid.domNode){
				this.headerMenu.unBindDomNode(this.grid.viewsHeaderNode);
				this.headerMenu.bindDomNode(this.grid.domNode);
				this._contextMenuBindNode = this.grid.domNode;
			}
			this._setActiveColHeader(this._colHeadNode, this._colHeadFocusIdx, saveColHeadFocusIdx);
			this._scrollHeader(this._colHeadFocusIdx);
			this._focusifyCellNode(false);
		}else {
			// all col head nodes are hidden - focus the grid
			this.findAndFocusGridCell();
		}
	},
	blurHeader: function(){
		dojo.removeClass(this._colHeadNode, this.focusClass);
		dojo.removeAttr(this.grid.domNode,"aria-activedescendant");
		// reset contextMenu onto viewsHeaderNode so right mouse on header will invoke (see focusHeader)
		if (this.headerMenu && this._contextMenuBindNode == this.grid.domNode) {
			var viewsHeader = this.grid.viewsHeaderNode;
			this.headerMenu.unBindDomNode(this.grid.domNode);
			this.headerMenu.bindDomNode(viewsHeader);
			this._contextMenuBindNode = viewsHeader;
		}
	},
	doFocus: function(e){
		// trap focus only for grid dom node
		if(e && e.target != e.currentTarget){
			dojo.stopEvent(e);
			return;
		}
		// do not focus for scrolling if grid is about to blur
		if(!this.tabbingOut){
			this.focusHeader();
		}
		this.tabbingOut = false;
		dojo.stopEvent(e);
	},
	doBlur: function(e){
		dojo.stopEvent(e);	// FF2
	},
	doContextMenu: function(e){
	//stop contextMenu event if no header Menu to prevent default/browser contextMenu
		if (!this.headerMenu){
			dojo.stopEvent(e);
		}
	},
	doLastNodeFocus: function(e){
		if (this.tabbingOut){
			this._focusifyCellNode(false);
		}else if(this.grid.rowCount >0){
			if (this.isNoFocusCell()){
				this.setFocusIndex(0,0);
			}
			this._focusifyCellNode(true);
		}else {
			this.focusHeader();
		}
		this.tabbingOut = false;
		dojo.stopEvent(e);	 // FF2
	},
	doLastNodeBlur: function(e){
		dojo.stopEvent(e);	 // FF2
	},
	doColHeaderFocus: function(e){
		this._setActiveColHeader(e.target,dojo.attr(e.target, "idx"),this._colHeadFocusIdx);
		this._scrollHeader(this.getHeaderIndex());
		dojo.stopEvent(e);
	},
	doColHeaderBlur: function(e){
		dojo.toggleClass(e.target, this.focusClass, false);
	}
});

}

if(!dojo._hasResource["dojox.grid._EditManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._EditManager"] = true;
dojo.provide("dojox.grid._EditManager");



dojo.declare("dojox.grid._EditManager", null, {
	// summary:
	//		Controls grid cell editing process. Owned by grid and used internally for editing.
	constructor: function(inGrid){
		// inGrid: dojox.Grid
		//		The dojox.Grid this editor should be attached to
		this.grid = inGrid;
		if(dojo.isIE){
			this.connections = [dojo.connect(document.body, "onfocus", dojo.hitch(this, "_boomerangFocus"))];
		}else{
			this.connections = [dojo.connect(this.grid, 'onBlur', this, 'apply')];
		}
	},
	
	info: {},

	destroy: function(){
		dojo.forEach(this.connections,dojo.disconnect);
	},

	cellFocus: function(inCell, inRowIndex){
		// summary:
		//		Invoke editing when cell is focused
		// inCell: cell object
		//		Grid cell object
		// inRowIndex: Integer
		//		Grid row index
		if(this.grid.singleClickEdit || this.isEditRow(inRowIndex)){
			// if same row or quick editing, edit
			this.setEditCell(inCell, inRowIndex);
		}else{
			// otherwise, apply any pending row edits
			this.apply();
		}
		// if dynamic or static editing...
		if(this.isEditing() || (inCell && inCell.editable && inCell.alwaysEditing)){
			// let the editor focus itself as needed
			this._focusEditor(inCell, inRowIndex);
		}
	},

	rowClick: function(e){
		if(this.isEditing() && !this.isEditRow(e.rowIndex)){
			this.apply();
		}
	},

	styleRow: function(inRow){
		if(inRow.index == this.info.rowIndex){
			inRow.customClasses += ' dojoxGridRowEditing';
		}
	},

	dispatchEvent: function(e){
		var c = e.cell, ed = (c && c["editable"]) ? c : 0;
		return ed && ed.dispatchEvent(e.dispatch, e);
	},

	// Editing
	isEditing: function(){
		// summary:
		//		Indicates editing state of the grid.
		// returns: Boolean
		//	 	True if grid is actively editing
		return this.info.rowIndex !== undefined;
	},

	isEditCell: function(inRowIndex, inCellIndex){
		// summary:
		//		Indicates if the given cell is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// inCellIndex: Integer
		//		Grid cell index
		// returns: Boolean
		//	 	True if given cell is being edited
		return (this.info.rowIndex === inRowIndex) && (this.info.cell.index == inCellIndex);
	},

	isEditRow: function(inRowIndex){
		// summary:
		//		Indicates if the given row is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// returns: Boolean
		//	 	True if given row is being edited
		return this.info.rowIndex === inRowIndex;
	},

	setEditCell: function(inCell, inRowIndex){
		// summary:
		//		Set the given cell to be edited
		// inRowIndex: Integer
		//		Grid row index
		// inCell: Object
		//		Grid cell object
		if(!this.isEditCell(inRowIndex, inCell.index) && this.grid.canEdit && this.grid.canEdit(inCell, inRowIndex)){
			this.start(inCell, inRowIndex, this.isEditRow(inRowIndex) || inCell.editable);
		}
	},

	_focusEditor: function(inCell, inRowIndex){
		dojox.grid.util.fire(inCell, "focus", [inRowIndex]);
	},

	focusEditor: function(){
		if(this.isEditing()){
			this._focusEditor(this.info.cell, this.info.rowIndex);
		}
	},

	// implement fix for focus boomerang effect on IE
	_boomerangWindow: 500,
	_shouldCatchBoomerang: function(){
		return this._catchBoomerang > new Date().getTime();
	},
	_boomerangFocus: function(){
		//console.log("_boomerangFocus");
		if(this._shouldCatchBoomerang()){
			// make sure we don't utterly lose focus
			this.grid.focus.focusGrid();
			// let the editor focus itself as needed
			this.focusEditor();
			// only catch once
			this._catchBoomerang = 0;
		}
	},
	_doCatchBoomerang: function(){
		// give ourselves a few ms to boomerang IE focus effects
		if(dojo.isIE){this._catchBoomerang = new Date().getTime() + this._boomerangWindow;}
	},
	// end boomerang fix API

	start: function(inCell, inRowIndex, inEditing){
		this.grid.beginUpdate();
		this.editorApply();
		if(this.isEditing() && !this.isEditRow(inRowIndex)){
			this.applyRowEdit();
			this.grid.updateRow(inRowIndex);
		}
		if(inEditing){
			this.info = { cell: inCell, rowIndex: inRowIndex };
			this.grid.doStartEdit(inCell, inRowIndex);
			this.grid.updateRow(inRowIndex);
		}else{
			this.info = {};
		}
		this.grid.endUpdate();
		// make sure we don't utterly lose focus
		this.grid.focus.focusGrid();
		// let the editor focus itself as needed
		this._focusEditor(inCell, inRowIndex);
		// give ourselves a few ms to boomerang IE focus effects
		this._doCatchBoomerang();
	},

	_editorDo: function(inMethod){
		var c = this.info.cell;
		//c && c.editor && c.editor[inMethod](c, this.info.rowIndex);
		if(c && c.editable){
			c[inMethod](this.info.rowIndex);
		}
	},

	editorApply: function(){
		this._editorDo("apply");
	},

	editorCancel: function(){
		this._editorDo("cancel");
	},

	applyCellEdit: function(inValue, inCell, inRowIndex){
		if(this.grid.canEdit(inCell, inRowIndex)){
			this.grid.doApplyCellEdit(inValue, inRowIndex, inCell.field);
		}
	},

	applyRowEdit: function(){
		this.grid.doApplyEdit(this.info.rowIndex, this.info.cell.field);
	},

	apply: function(){
		// summary:
		//		Apply a grid edit
		if(this.isEditing()){
			this.grid.beginUpdate();
			this.editorApply();
			this.applyRowEdit();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	cancel: function(){
		// summary:
		//		Cancel a grid edit
		if(this.isEditing()){
			this.grid.beginUpdate();
			this.editorCancel();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	save: function(inRowIndex, inView){
		// summary:
		//		Save the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && (!inView || c.view==inView) && c.editable){
			c.save(c, this.info.rowIndex);
		}
	},

	restore: function(inView, inRowIndex){
		// summary:
		//		Restores the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && c.view == inView && c.editable){
			c.restore(c, this.info.rowIndex);
		}
	}
});

}

if(!dojo._hasResource['dojox.grid.Selection']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['dojox.grid.Selection'] = true;
dojo.provide('dojox.grid.Selection');

dojo.declare("dojox.grid.Selection", null, {
	// summary:
	//		Manages row selection for grid. Owned by grid and used internally
	//		for selection. Override to implement custom selection.

	constructor: function(inGrid){
		this.grid = inGrid;
		this.selected = [];

		this.setMode(inGrid.selectionMode);
	},

	mode: 'extended',

	selected: null,
	updating: 0,
	selectedIndex: -1,

	setMode: function(mode){
		if(this.selected.length){
			this.deselectAll();
		}
		if(mode != 'extended' && mode != 'multiple' && mode != 'single' && mode != 'none'){
			this.mode = 'extended';
		}else{
			this.mode = mode;
		}
	},

	onCanSelect: function(inIndex){
		return this.grid.onCanSelect(inIndex);
	},

	onCanDeselect: function(inIndex){
		return this.grid.onCanDeselect(inIndex);
	},

	onSelected: function(inIndex){
	},

	onDeselected: function(inIndex){
	},

	//onSetSelected: function(inIndex, inSelect) { };
	onChanging: function(){
	},

	onChanged: function(){
	},

	isSelected: function(inIndex){
		if(this.mode == 'none'){
			return false;
		}
		return this.selected[inIndex];
	},

	getFirstSelected: function(){
		if(!this.selected.length||this.mode == 'none'){ return -1; }
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getNextSelected: function(inPrev){
		if(this.mode == 'none'){ return -1; }
		for(var i=inPrev+1, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getSelected: function(){
		var result = [];
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				result.push(i);
			}
		}
		return result;
	},

	getSelectedCount: function(){
		var c = 0;
		for(var i=0; i<this.selected.length; i++){
			if(this.selected[i]){
				c++;
			}
		}
		return c;
	},

	_beginUpdate: function(){
		if(this.updating === 0){
			this.onChanging();
		}
		this.updating++;
	},

	_endUpdate: function(){
		this.updating--;
		if(this.updating === 0){
			this.onChanged();
		}
	},

	select: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(this.mode != 'multiple'){
			this.deselectAll(inIndex);
			this.addToSelection(inIndex);
		}else{
			this.toggleSelect(inIndex);
		}
	},

	addToSelection: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(dojo.isArray(inIndex)){
			dojo.forEach(inIndex, this.addToSelection, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selected[inIndex]){
			this.selectedIndex = inIndex;
		}else{
			if(this.onCanSelect(inIndex) !== false){
				this.selectedIndex = inIndex;
				var rowNode = this.grid.getRowNode(inIndex);
				if(rowNode){
					dojo.attr(rowNode,"aria-selected","true");
				}
				this._beginUpdate();
				this.selected[inIndex] = true;
				//this.grid.onSelected(inIndex);
				this.onSelected(inIndex);
				//this.onSetSelected(inIndex, true);
				this._endUpdate();
			}
		}
	},

	deselect: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(dojo.isArray(inIndex)){
			dojo.forEach(inIndex, this.deselect, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selectedIndex == inIndex){
			this.selectedIndex = -1;
		}
		if(this.selected[inIndex]){
			if(this.onCanDeselect(inIndex) === false){
				return;
			}
			var rowNode = this.grid.getRowNode(inIndex);
			if(rowNode){
				dojo.attr(rowNode,"aria-selected","false");
			}
			this._beginUpdate();
			delete this.selected[inIndex];
			//this.grid.onDeselected(inIndex);
			this.onDeselected(inIndex);
			//this.onSetSelected(inIndex, false);
			this._endUpdate();
		}
	},

	setSelected: function(inIndex, inSelect){
		this[(inSelect ? 'addToSelection' : 'deselect')](inIndex);
	},

	toggleSelect: function(inIndex){
		if(dojo.isArray(inIndex)){
			dojo.forEach(inIndex, this.toggleSelect, this);
			return;
		}
		this.setSelected(inIndex, !this.selected[inIndex]);
	},

	_range: function(inFrom, inTo, func){
		var s = (inFrom >= 0 ? inFrom : inTo), e = inTo;
		if(s > e){
			e = s;
			s = inTo;
		}
		for(var i=s; i<=e; i++){
			func(i);
		}
	},

	selectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, dojo.hitch(this, "addToSelection"));
	},

	deselectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, dojo.hitch(this, "deselect"));
	},

	insert: function(inIndex){
		this.selected.splice(inIndex, 0, false);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex++;
		}
	},

	remove: function(inIndex){
		this.selected.splice(inIndex, 1);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex--;
		}
	},

	deselectAll: function(inExcept){
		for(var i in this.selected){
			if((i!=inExcept)&&(this.selected[i]===true)){
				this.deselect(i);
			}
		}
	},

	clickSelect: function(inIndex, inCtrlKey, inShiftKey){
		if(this.mode == 'none'){ return; }
		this._beginUpdate();
		if(this.mode != 'extended'){
			this.select(inIndex);
		}else{
			var lastSelected = this.selectedIndex;
			if(!inCtrlKey){
				this.deselectAll(inIndex);
			}
			if(inShiftKey){
				this.selectRange(lastSelected, inIndex);
			}else if(inCtrlKey){
				this.toggleSelect(inIndex);
			}else{
				this.addToSelection(inIndex);
			}
		}
		this._endUpdate();
	},

	clickSelectEvent: function(e){
		this.clickSelect(e.rowIndex, dojo.isCopyKey(e), e.shiftKey);
	},

	clear: function(){
		this._beginUpdate();
		this.deselectAll();
		this._endUpdate();
	}
});

}

if(!dojo._hasResource["dojox.grid._Events"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Events"] = true;
dojo.provide("dojox.grid._Events");

dojo.declare("dojox.grid._Events", null, {
	// summary:
	//		_Grid mixin that provides default implementations for grid events.
	// description:
	//		Default synthetic events dispatched for _Grid. dojo.connect to events to
	//		retain default implementation or override them for custom handling.
	
	// cellOverClass: String
	// 		css class to apply to grid cells over which the cursor is placed.
	cellOverClass: "dojoxGridCellOver",
	
	onKeyEvent: function(e){
		// summary: top level handler for Key Events
		this.dispatchKeyEvent(e);
	},

	onContentEvent: function(e){
		// summary: Top level handler for Content events
		this.dispatchContentEvent(e);
	},

	onHeaderEvent: function(e){
		// summary: Top level handler for header events
		this.dispatchHeaderEvent(e);
	},

	onStyleRow: function(inRow){
		// summary:
		//		Perform row styling on a given row. Called whenever row styling is updated.
		//
		// inRow: Object
		// 		Object containing row state information: selected, true if the row is selcted; over:
		// 		true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
		// 		customStyles to control row css classes and styles; both properties are strings.
		//
		// example: onStyleRow({ selected: true, over:true, odd:false })
		var i = inRow;
		i.customClasses += (i.odd?" dojoxGridRowOdd":"") + (i.selected?" dojoxGridRowSelected":"") + (i.over?" dojoxGridRowOver":"");
		this.focus.styleRow(inRow);
		this.edit.styleRow(inRow);
	},
	
	onKeyDown: function(e){
		// summary:
		// 		Grid key event handler. By default enter begins editing and applies edits, escape cancels an edit,
		// 		tab, shift-tab, and arrow keys move grid cell focus.
		if(e.altKey || e.metaKey){
			return;
		}
		var dk = dojo.keys;
		var colIdx;
		switch(e.keyCode){
			case dk.ESCAPE:
				this.edit.cancel();
				break;
			case dk.ENTER:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					dojo.stopEvent(e);
				}
				if(!e.shiftKey){
					var isEditing = this.edit.isEditing();
					this.edit.apply();
					if(!isEditing){
						this.edit.setEditCell(this.focus.cell, this.focus.rowIndex);
					}
				}
				if (!this.edit.isEditing()){
					var curView = this.focus.focusView || this.views.views[0];  //if no focusView than only one view
					curView.content.decorateEvent(e);
					this.onRowClick(e);
					dojo.stopEvent(e);
				}
				break;
			case dk.SPACE:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					dojo.stopEvent(e);
				}
				break;
			case dk.TAB:
				this.focus[e.shiftKey ? 'previousKey' : 'nextKey'](e);
				break;
			case dk.LEFT_ARROW:
			case dk.RIGHT_ARROW:
				if(!this.edit.isEditing()){
					var keyCode = e.keyCode;  // IE seems to lose after stopEvent when modifier keys
					dojo.stopEvent(e);
					colIdx = this.focus.getHeaderIndex();
					if (colIdx >= 0 && (e.shiftKey && e.ctrlKey)){
						this.focus.colSizeAdjust(e, colIdx, (keyCode == dk.LEFT_ARROW ? -1 : 1)*5);
					}
					else{
						var offset = (keyCode == dk.LEFT_ARROW) ? 1 : -1;
						if(dojo._isBodyLtr()){ offset *= -1; }
						this.focus.move(0, offset);
					}
				}
				break;
			case dk.UP_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					dojo.stopEvent(e);
					this.focus.move(-1, 0);
				}
				break;
			case dk.DOWN_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					dojo.stopEvent(e);
					this.focus.move(1, 0);
				}
				break;
			case dk.PAGE_UP:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					dojo.stopEvent(e);
					if(this.focus.rowIndex != this.scroller.firstVisibleRow+1){
						this.focus.move(this.scroller.firstVisibleRow-this.focus.rowIndex, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex-1));
						this.focus.move(this.scroller.firstVisibleRow-this.scroller.lastVisibleRow+1, 0);
					}
				}
				break;
			case dk.PAGE_DOWN:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					dojo.stopEvent(e);
					if(this.focus.rowIndex != this.scroller.lastVisibleRow-1){
						this.focus.move(this.scroller.lastVisibleRow-this.focus.rowIndex-1, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex+1));
						this.focus.move(this.scroller.lastVisibleRow-this.scroller.firstVisibleRow-1, 0);
					}
				}
				break;
			default:
				break;
		}
	},
	
	onMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over the grid.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOver(e) : this.onCellMouseOver(e);
	},
	
	onMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOut(e) : this.onCellMouseOut(e);
	},
	
	onMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down inside grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseDown(e) : this.onCellMouseDown(e);
	},
	
	onMouseOverRow: function(e){
		// summary:
		//		Event fired when mouse is over any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(!this.rows.isOver(e.rowIndex)){
			this.rows.setOverRow(e.rowIndex);
			e.rowIndex == -1 ? this.onHeaderMouseOver(e) : this.onRowMouseOver(e);
		}
	},
	onMouseOutRow: function(e){
		// summary:
		//		Event fired when mouse moves out of any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(this.rows.isOver(-1)){
			this.onHeaderMouseOut(e);
		}else if(!this.rows.isOver(-2)){
			this.rows.setOverRow(-2);
			this.onRowMouseOut(e);
		}
	},
	
	onMouseDownRow: function(e){
		// summary:
		//		Event fired when mouse is down inside grid row
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		if(e.rowIndex != -1)
			this.onRowMouseDown(e);
	},

	// cell events
	onCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over a cell.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.addClass(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.removeClass(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onCellClick: function(e){
		// summary:
		//		Event fired when a cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this._click[0] = this._click[1];
		this._click[1] = e;
		if(!this.edit.isEditCell(e.rowIndex, e.cellIndex)){
			this.focus.setFocusCell(e.cell, e.rowIndex);
		}
		this.onRowClick(e);
	},

	onCellDblClick: function(e){
		// summary:
		//		Event fired when a cell is double-clicked.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(this._click.length > 1 && dojo.isIE){
			this.edit.setEditCell(this._click[1].cell, this._click[1].rowIndex);
		}else if(this._click.length > 1 && this._click[0].rowIndex != this._click[1].rowIndex){
			this.edit.setEditCell(this._click[0].cell, this._click[0].rowIndex);
		}else{
			this.edit.setEditCell(e.cell, e.rowIndex);
		}
		this.onRowDblClick(e);
	},

	onCellContextMenu: function(e){
		// summary:
		//		Event fired when a cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onRowContextMenu(e);
	},

	onCellFocus: function(inCell, inRowIndex){
		// summary:
		//		Event fired when a cell receives focus.
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
		this.edit.cellFocus(inCell, inRowIndex);
	},

	// row events
	onRowClick: function(e){
		// summary:
		//		Event fired when a row is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.edit.rowClick(e);
		this.selection.clickSelectEvent(e);
	},

	onRowDblClick: function(e){
		// summary:
		//		Event fired when a row is double clicked.
		// e: Event
		//		decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a data row.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a data row.
		// e: Event
		// 		Decorated event object contains reference to grid, cell, and rowIndex
	},
	
	onRowMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a row.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowContextMenu: function(e){
		// summary:
		//		Event fired when a row context menu is accessed via mouse right click.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		dojo.stopEvent(e);
	},

	// header events
	onHeaderMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over the grid header.
		// e: Event
		// 		Decorated event object contains reference to grid, cell, and rowIndex
	},

	onHeaderMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid header.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.addClass(e.cellNode, this.cellOverClass);
		}
	},

	onHeaderCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.removeClass(e.cellNode, this.cellOverClass);
		}
	},
	
	onHeaderCellMouseDown: function(e) {
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderClick: function(e){
		// summary:
		//		Event fired when the grid header is clicked.
		// e: Event
		// Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellClick: function(e){
		// summary:
		//		Event fired when a header cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.setSortIndex(e.cell.index);
		this.onHeaderClick(e);
	},

	onHeaderDblClick: function(e){
		// summary:
		//		Event fired when the grid header is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellDblClick: function(e){
		// summary:
		//		Event fired when a header cell is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderDblClick(e);
	},

	onHeaderCellContextMenu: function(e){
		// summary:
		//		Event fired when a header cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderContextMenu(e);
	},

	onHeaderContextMenu: function(e){
		// summary:
		//		Event fired when the grid header context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(!this.headerMenu){
			dojo.stopEvent(e);
		}
	},

	// editing
	onStartEdit: function(inCell, inRowIndex){
		// summary:
		//		Event fired when editing is started for a given grid cell
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
		// summary:
		//		Event fired when editing is applied for a given grid cell
		// inValue: String
		//		Value from cell editor
		// inRowIndex: Integer
		//		Index of the grid row
		// inFieldIndex: Integer
		//		Index in the grid's data store
	},

	onCancelEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is cancelled for a given grid cell
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is applied for a given grid row
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onCanSelect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be selected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be selected
		return true;
	},

	onCanDeselect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be deselected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be deselected
		return true;
	},

	onSelected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is selected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onDeselected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is deselected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onSelectionChanged: function(){
	}
});

}

if(!dojo._hasResource["dojox.grid._Grid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Grid"] = true;
dojo.provide("dojox.grid._Grid");




















(function(){
	// NOTE: this is for backwards compatibility with Dojo 1.3
	if(!dojo.isCopyKey){
		dojo.isCopyKey = dojo.dnd.getCopyKeyState;
	}
	/*=====
	dojox.grid.__CellDef = function(){
		//	name: String?
		//		The text to use in the header of the grid for this cell.
		//	get: Function?
		//		function(rowIndex){} rowIndex is of type Integer.  This
		//		function will be called when a cell	requests data.  Returns the
		//		unformatted data for the cell.
		//	value: String?
		//		If "get" is not specified, this is used as the data for the cell.
		//	defaultValue: String?
		//		If "get" and "value" aren't specified or if "get" returns an undefined
		//		value, this is used as the data for the cell.  "formatter" is not run
		//		on this if "get" returns an undefined value.
		//	formatter: Function?
		//		function(data, rowIndex){} data is of type anything, rowIndex
		//		is of type Integer.  This function will be called after the cell
		//		has its data but before it passes it back to the grid to render.
		//		Returns the formatted version of the cell's data.
		//	type: dojox.grid.cells._Base|Function?
		//		TODO
		//	editable: Boolean?
		//		Whether this cell should be editable or not.
		//	hidden: Boolean?
		//		If true, the cell will not be displayed.
		//	noresize: Boolean?
		//		If true, the cell will not be able to be resized.
		//	width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's.
		//	colSpan: Integer?
		//		How many columns to span this cell.  Will not work in the first
		//		sub-row of cells.
		//	rowSpan: Integer?
		//		How many sub-rows to span this cell.
		//	styles: String?
		//		A string of styles to apply to both the header cell and main
		//		grid cells.  Must end in a ';'.
		//	headerStyles: String?
		//		A string of styles to apply to just the header cell.  Must end
		//		in a ';'
		//	cellStyles: String?
		//		A string of styles to apply to just the main grid cells.  Must
		//		end in a ';'
		//	classes: String?
		//		A space separated list of classes to apply to both the header
		//		cell and the main grid cells.
		//	headerClasses: String?
		//		A space separated list of classes to apply to just the header
		//		cell.
		//	cellClasses: String?
		//		A space separated list of classes to apply to just the main
		//		grid cells.
		//	attrs: String?
		//		A space separated string of attribute='value' pairs to add to
		//		the header cell element and main grid cell elements.
		this.name = name;
		this.value = value;
		this.get = get;
		this.formatter = formatter;
		this.type = type;
		this.editable = editable;
		this.hidden = hidden;
		this.width = width;
		this.colSpan = colSpan;
		this.rowSpan = rowSpan;
		this.styles = styles;
		this.headerStyles = headerStyles;
		this.cellStyles = cellStyles;
		this.classes = classes;
		this.headerClasses = headerClasses;
		this.cellClasses = cellClasses;
		this.attrs = attrs;
	}
	=====*/

	/*=====
	dojox.grid.__ViewDef = function(){
		//	noscroll: Boolean?
		//		If true, no scrollbars will be rendered without scrollbars.
		//	width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's. If
		//		"noscroll" is true, this value is ignored.
		//	cells: dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]?
		//		The structure of the cells within this grid.
		//	type: String?
		//		A string containing the constructor of a subclass of
		//		dojox.grid._View.  If this is not specified, dojox.grid._View
		//		is used.
		//	defaultCell: dojox.grid.__CellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
		//	onBeforeRow: Function?
		//		function(rowIndex, cells){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]].  This function is called
		//		before each row of data is rendered.  Before the header is
		//		rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
		//	onAfterRow: Function?
		//		function(rowIndex, cells, rowNode){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]], rowNode is of type DOMNode.
		//		This function is called	after each row of data is rendered.  After the
		//		header is rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
		this.noscroll = noscroll;
		this.width = width;
		this.cells = cells;
		this.type = type;
		this.defaultCell = defaultCell;
		this.onBeforeRow = onBeforeRow;
		this.onAfterRow = onAfterRow;
	}
	=====*/

	dojo.declare('dojox.grid._Grid',
		[ dijit._Widget, dijit._Templated, dojox.grid._Events ],
		{
		// summary:
		// 		A grid widget with virtual scrolling, cell editing, complex rows,
		// 		sorting, fixed columns, sizeable columns, etc.
		//
		//	description:
		//		_Grid provides the full set of grid features without any
		//		direct connection to a data store.
		//
		//		The grid exposes a get function for the grid, or optionally
		//		individual columns, to populate cell contents.
		//
		//		The grid is rendered based on its structure, an object describing
		//		column and cell layout.
		//
		//	example:
		//		A quick sample:
		//
		//		define a get function
		//	|	function get(inRowIndex){ // called in cell context
		//	|		return [this.index, inRowIndex].join(', ');
		//	|	}
		//
		//		define the grid structure:
		//	|	var structure = [ // array of view objects
		//	|		{ cells: [// array of rows, a row is an array of cells
		//	|			[
		//	|				{ name: "Alpha", width: 6 },
		//	|				{ name: "Beta" },
		//	|				{ name: "Gamma", get: get }]
		//	|		]}
		//	|	];
		//
		//	|	<div id="grid"
		//	|		rowCount="100" get="get"
		//	|		structure="structure"
		//	|		dojoType="dojox.grid._Grid"></div>

		templateString:"<div hidefocus=\"hidefocus\" role=\"grid\" dojoAttachEvent=\"onmouseout:_mouseOut\">\n\t<div class=\"dojoxGridMasterHeader\" dojoAttachPoint=\"viewsHeaderNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterView\" dojoAttachPoint=\"viewsNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterMessages\" style=\"display: none;\" dojoAttachPoint=\"messagesNode\"></div>\n\t<span dojoAttachPoint=\"lastFocusNode\" tabindex=\"0\"></span>\n</div>\n",

		// classTag: String
		// 		CSS class applied to the grid's domNode
		classTag: 'dojoxGrid',

		// settings
		// rowCount: Integer
		//		Number of rows to display.
		rowCount: 5,

		// keepRows: Integer
		//		Number of rows to keep in the rendering cache.
		keepRows: 75,

		// rowsPerPage: Integer
		//		Number of rows to render at a time.
		rowsPerPage: 25,

		// autoWidth: Boolean
		//		If autoWidth is true, grid width is automatically set to fit the data.
		autoWidth: false,
		
		// initialWidth: String
		//		A css string to use to set our initial width (only used if autoWidth
		//		is true).  The first rendering of the grid will be this width, any
		//		resizing of columns, etc will result in the grid switching to
		//		autoWidth mode.  Note, this width will override any styling in a
		//		stylesheet or directly on the node.
		initialWidth: "",

		// autoHeight: Boolean|Integer
		//		If autoHeight is true, grid height is automatically set to fit the data.
		//		If it is an integer, the height will be automatically set to fit the data
		//		if there are fewer than that many rows - and the height will be set to show
		//		that many rows if there are more
		autoHeight: '',

		// rowHeight: Integer
		//		If rowHeight is set to a positive number, it will define the height of the rows
		//		in pixels. This can provide a significant performance advantage, since it
		//		eliminates the need to measure row sizes during rendering, which is one
		// 		the primary bottlenecks in the DataGrid's performance.
		rowHeight: 0,
		
		// autoRender: Boolean
		//		If autoRender is true, grid will render itself after initialization.
		autoRender: true,

		// defaultHeight: String
		//		default height of the grid, measured in any valid css unit.
		defaultHeight: '15em',
		
		// height: String
		//		explicit height of the grid, measured in any valid css unit.  This will be populated (and overridden)
		//		if the height: css attribute exists on the source node.
		height: '',

		// structure: dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]
		//		View layout defintion.
		structure: null,

		// elasticView: Integer
		//	Override defaults and make the indexed grid view elastic, thus filling available horizontal space.
		elasticView: -1,

		// singleClickEdit: boolean
		//		Single-click starts editing. Default is double-click
		singleClickEdit: false,

		// selectionMode: String
		//		Set the selection mode of grid's Selection.  Value must be 'single', 'multiple',
		//		or 'extended'.  Default is 'extended'.
		selectionMode: 'extended',

		// rowSelector: Boolean|String
		// 		If set to true, will add a row selector view to this grid.  If set to a CSS width, will add
		// 		a row selector of that width to this grid.
		rowSelector: '',

		// columnReordering: Boolean
		// 		If set to true, will add drag and drop reordering to views with one row of columns.
		columnReordering: false,

		// headerMenu: dijit.Menu
		// 		If set to a dijit.Menu, will use this as a context menu for the grid headers.
		headerMenu: null,

		// placeholderLabel: String
		// 		Label of placeholders to search for in the header menu to replace with column toggling
		// 		menu items.
		placeholderLabel: "GridColumns",
		
		// selectable: Boolean
		//		Set to true if you want to be able to select the text within the grid.
		selectable: false,
		
		// Used to store the last two clicks, to ensure double-clicking occurs based on the intended row
		_click: null,
		
		// loadingMessage: String
		//  Message that shows while the grid is loading
		loadingMessage: "<span class='dojoxGridLoading'>${loadingState}</span>",

		// errorMessage: String
		//  Message that shows when the grid encounters an error loading
		errorMessage: "<span class='dojoxGridError'>${errorState}</span>",

		// noDataMessage: String
		//  Message that shows if the grid has no data - wrap it in a
		//  span with class 'dojoxGridNoData' if you want it to be
		//  styled similar to the loading and error messages
		noDataMessage: "",
		
		// escapeHTMLInData: Boolean
		//		This will escape HTML brackets from the data to prevent HTML from
		// 		user-inputted data being rendered with may contain JavaScript and result in
		// 		XSS attacks. This is true by default, and it is recommended that it remain
		// 		true. Setting this to false will allow data to be displayed in the grid without
		// 		filtering, and should be only used if it is known that the data won't contain
		// 		malicious scripts. If HTML is needed in grid cells, it is recommended that
		// 		you use the formatter function to generate the HTML (the output of
		// 		formatter functions is not filtered, even with escapeHTMLInData set to true).
		escapeHTMLInData: true,
		
		// formatterScope: Object
		//		An object to execute format functions within.  If not set, the
		//		format functions will execute within the scope of the cell that
		//		has a format function.
		formatterScope: null,
		
		// editable: boolean
		// indicates if the grid contains editable cells, default is false
		// set to true if editable cell encountered during rendering
		editable: false,
		
		// private
		sortInfo: 0,
		themeable: true,
		_placeholders: null,

		// _layoutClass: Object
		//	The class to use for our layout - can be overridden by grid subclasses
		_layoutClass: dojox.grid._Layout,

		// initialization
		buildRendering: function(){
			this.inherited(arguments);
			if(!this.domNode.getAttribute('tabIndex')){
				this.domNode.tabIndex = "0";
			}
			this.createScroller();
			this.createLayout();
			this.createViews();
			this.createManagers();

			this.createSelection();

			this.connect(this.selection, "onSelected", "onSelected");
			this.connect(this.selection, "onDeselected", "onDeselected");
			this.connect(this.selection, "onChanged", "onSelectionChanged");

			dojox.html.metrics.initOnFontResize();
			this.connect(dojox.html.metrics, "onFontResize", "textSizeChanged");
			dojox.grid.util.funnelEvents(this.domNode, this, 'doKeyEvent', dojox.grid.util.keyEvents);
			if (this.selectionMode != "none") {
				dojo.attr(this.domNode, "aria-multiselectable", this.selectionMode == "single" ? "false" : "true");
			}

			dojo.addClass(this.domNode, this.classTag);
			if(!this.isLeftToRight()){
				dojo.addClass(this.domNode, this.classTag+"Rtl");
			}
		},
		
		postMixInProperties: function(){
			this.inherited(arguments);
			var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
			this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
			this.errorMessage = dojo.string.substitute(this.errorMessage, messages);
			if(this.srcNodeRef && this.srcNodeRef.style.height){
				this.height = this.srcNodeRef.style.height;
			}
			// Call this to update our autoheight to start out
			this._setAutoHeightAttr(this.autoHeight, true);
			this.lastScrollTop = this.scrollTop = 0;
		},
		
		postCreate: function(){
			this._placeholders = [];
			this._setHeaderMenuAttr(this.headerMenu);
			this._setStructureAttr(this.structure);
			this._click = [];
			this.inherited(arguments);
			if(this.domNode && this.autoWidth && this.initialWidth){
				this.domNode.style.width = this.initialWidth;
			}
			if (this.domNode && !this.editable){
				// default value for aria-readonly is false, set to true if grid is not editable
				dojo.attr(this.domNode,"aria-readonly", "true");
			}
		},

		destroy: function(){
			this.domNode.onReveal = null;
			this.domNode.onSizeChange = null;

			// Fixes IE domNode leak
			delete this._click;

			this.edit.destroy();
			delete this.edit;

			this.views.destroyViews();
			if(this.scroller){
				this.scroller.destroy();
				delete this.scroller;
			}
			if(this.focus){
				this.focus.destroy();
				delete this.focus;
			}
			if(this.headerMenu&&this._placeholders.length){
				dojo.forEach(this._placeholders, function(p){ p.unReplace(true); });
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.inherited(arguments);
		},

		_setAutoHeightAttr: function(ah, skipRender){
			// Calculate our autoheight - turn it into a boolean or an integer
			if(typeof ah == "string"){
				if(!ah || ah == "false"){
					ah = false;
				}else if (ah == "true"){
					ah = true;
				}else{
					ah = window.parseInt(ah, 10);
				}
			}
			if(typeof ah == "number"){
				if(isNaN(ah)){
					ah = false;
				}
				// Autoheight must be at least 1, if it's a number.  If it's
				// less than 0, we'll take that to mean "all" rows (same as
				// autoHeight=true - if it is equal to zero, we'll take that
				// to mean autoHeight=false
				if(ah < 0){
					ah = true;
				}else if (ah === 0){
					ah = false;
				}
			}
			this.autoHeight = ah;
			if(typeof ah == "boolean"){
				this._autoHeight = ah;
			}else if(typeof ah == "number"){
				this._autoHeight = (ah >= this.get('rowCount'));
			}else{
				this._autoHeight = false;
			}
			if(this._started && !skipRender){
				this.render();
			}
		},

		_getRowCountAttr: function(){
			return this.updating && this.invalidated && this.invalidated.rowCount != undefined ?
				this.invalidated.rowCount : this.rowCount;
		},
		
		textSizeChanged: function(){
			this.render();
		},

		sizeChange: function(){
			this.update();
		},

		createManagers: function(){
			// summary:
			//		create grid managers for various tasks including rows, focus, selection, editing

			// row manager
			this.rows = new dojox.grid._RowManager(this);
			// focus manager
			this.focus = new dojox.grid._FocusManager(this);
			// edit manager
			this.edit = new dojox.grid._EditManager(this);
		},

		createSelection: function(){
			// summary:	Creates a new Grid selection manager.

			// selection manager
			this.selection = new dojox.grid.Selection(this);
		},

		createScroller: function(){
			// summary: Creates a new virtual scroller
			this.scroller = new dojox.grid._Scroller();
			this.scroller.grid = this;
			this.scroller.renderRow = dojo.hitch(this, "renderRow");
			this.scroller.removeRow = dojo.hitch(this, "rowRemoved");
		},

		createLayout: function(){
			// summary: Creates a new Grid layout
			this.layout = new this._layoutClass(this);
			this.connect(this.layout, "moveColumn", "onMoveColumn");
		},

		onMoveColumn: function(){
			this.render();
		},
		
		onResizeColumn: function(/*int*/ cellIdx){
			// Called when a column is resized.
		},

		// views
		createViews: function(){
			this.views = new dojox.grid._ViewManager(this);
			this.views.createView = dojo.hitch(this, "createView");
		},

		createView: function(inClass, idx){
			var c = dojo.getObject(inClass);
			var view = new c({ grid: this, index: idx });
			this.viewsNode.appendChild(view.domNode);
			this.viewsHeaderNode.appendChild(view.headerNode);
			this.views.addView(view);
			dojo.attr(this.domNode, "align", dojo._isBodyLtr() ? 'left' : 'right');
			return view;
		},

		buildViews: function(){
			for(var i=0, vs; (vs=this.layout.structure[i]); i++){
				this.createView(vs.type || dojox._scopeName + ".grid._View", i).setStructure(vs);
			}
			this.scroller.setContentNodes(this.views.getContentNodes());
		},

		_setStructureAttr: function(structure){
			var s = structure;
			if(s && dojo.isString(s)){
				dojo.deprecated("dojox.grid._Grid.set('structure', 'objVar')", "use dojox.grid._Grid.set('structure', objVar) instead", "2.0");
				s=dojo.getObject(s);
			}
			this.structure = s;
			if(!s){
				if(this.layout.structure){
					s = this.layout.structure;
				}else{
					return;
				}
			}
			this.views.destroyViews();
			this.focus.focusView = null;
			if(s !== this.layout.structure){
				this.layout.setStructure(s);
			}
			this._structureChanged();
		},

		setStructure: function(/* dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]] */ inStructure){
			// summary:
			//		Install a new structure and rebuild the grid.
			dojo.deprecated("dojox.grid._Grid.setStructure(obj)", "use dojox.grid._Grid.set('structure', obj) instead.", "2.0");
			this._setStructureAttr(inStructure);
		},
		
		getColumnTogglingItems: function(){
			// Summary: returns an array of dijit.CheckedMenuItem widgets that can be
			//		added to a menu for toggling columns on and off.
			return dojo.map(this.layout.cells, function(cell){
				if(!cell.menuItems){ cell.menuItems = []; }

				var self = this;
				var item = new dijit.CheckedMenuItem({
					label: cell.name,
					checked: !cell.hidden,
					_gridCell: cell,
					onChange: function(checked){
						if(self.layout.setColumnVisibility(this._gridCell.index, checked)){
							var items = this._gridCell.menuItems;
							if(items.length > 1){
								dojo.forEach(items, function(item){
									if(item !== this){
										item.setAttribute("checked", checked);
									}
								}, this);
							}
							checked = dojo.filter(self.layout.cells, function(c){
								if(c.menuItems.length > 1){
									dojo.forEach(c.menuItems, "item.set('disabled', false);");
								}else{
									c.menuItems[0].set('disabled', false);
								}
								return !c.hidden;
							});
							if(checked.length == 1){
								dojo.forEach(checked[0].menuItems, "item.set('disabled', true);");
							}
						}
					},
					destroy: function(){
						var index = dojo.indexOf(this._gridCell.menuItems, this);
						this._gridCell.menuItems.splice(index, 1);
						delete this._gridCell;
						dijit.CheckedMenuItem.prototype.destroy.apply(this, arguments);
					}
				});
				cell.menuItems.push(item);
				return item;
			}, this); // dijit.CheckedMenuItem[]
		},

		_setHeaderMenuAttr: function(menu){
			if(this._placeholders && this._placeholders.length){
				dojo.forEach(this._placeholders, function(p){
					p.unReplace(true);
				});
				this._placeholders = [];
			}
			if(this.headerMenu){
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.headerMenu = menu;
			if(!menu){ return; }

			this.headerMenu.bindDomNode(this.viewsHeaderNode);
			if(this.headerMenu.getPlaceholders){
				this._placeholders = this.headerMenu.getPlaceholders(this.placeholderLabel);
			}
		},

		setHeaderMenu: function(/* dijit.Menu */ menu){
			dojo.deprecated("dojox.grid._Grid.setHeaderMenu(obj)", "use dojox.grid._Grid.set('headerMenu', obj) instead.", "2.0");
			this._setHeaderMenuAttr(menu);
		},
		
		setupHeaderMenu: function(){
			if(this._placeholders && this._placeholders.length){
				dojo.forEach(this._placeholders, function(p){
					if(p._replaced){
						p.unReplace(true);
					}
					p.replace(this.getColumnTogglingItems());
				}, this);
			}
		},

		_fetch: function(start){
			this.setScrollTop(0);
		},

		getItem: function(inRowIndex){
			return null;
		},
		
		showMessage: function(message){
			if(message){
				this.messagesNode.innerHTML = message;
				this.messagesNode.style.display = "";
			}else{
				this.messagesNode.innerHTML = "";
				this.messagesNode.style.display = "none";
			}
		},

		_structureChanged: function() {
			this.buildViews();
			if(this.autoRender && this._started){
				this.render();
			}
		},

		hasLayout: function() {
			return this.layout.cells.length;
		},

		// sizing
		resize: function(changeSize, resultSize){
			// summary:
			//		Update the grid's rendering dimensions and resize it
			
			// Calling sizeChange calls update() which calls _resize...so let's
			// save our input values, if any, and use them there when it gets
			// called.  This saves us an extra call to _resize(), which can
			// get kind of heavy.
			this._pendingChangeSize = changeSize;
			this._pendingResultSize = resultSize;
			this.sizeChange();
		},

		_getPadBorder: function() {
			this._padBorder = this._padBorder || dojo._getPadBorderExtents(this.domNode);
			return this._padBorder;
		},

		_getHeaderHeight: function(){
			var vns = this.viewsHeaderNode.style, t = vns.display == "none" ? 0 : this.views.measureHeader();
			vns.height = t + 'px';
			// header heights are reset during measuring so must be normalized after measuring.
			this.views.normalizeHeaderNodeHeight();
			return t;
		},
		
		_resize: function(changeSize, resultSize){
			// Restore our pending values, if any
			changeSize = changeSize || this._pendingChangeSize;
			resultSize = resultSize || this._pendingResultSize;
			delete this._pendingChangeSize;
			delete this._pendingResultSize;
			// if we have set up everything except the DOM, we cannot resize
			if(!this.domNode){ return; }
			var pn = this.domNode.parentNode;
			if(!pn || pn.nodeType != 1 || !this.hasLayout() || pn.style.visibility == "hidden" || pn.style.display == "none"){
				return;
			}
			// useful measurement
			var padBorder = this._getPadBorder();
			var hh = undefined;
			var h;
			// grid height
			if(this._autoHeight){
				this.domNode.style.height = 'auto';
			}else if(typeof this.autoHeight == "number"){
				h = hh = this._getHeaderHeight();
				h += (this.scroller.averageRowHeight * this.autoHeight);
				this.domNode.style.height = h + "px";
			}else if(this.domNode.clientHeight <= padBorder.h){
				if(pn == document.body){
					this.domNode.style.height = this.defaultHeight;
				}else if(this.height){
					this.domNode.style.height = this.height;
				}else{
					this.fitTo = "parent";
				}
			}
			// if we are given dimensions, size the grid's domNode to those dimensions
			if(resultSize){
				changeSize = resultSize;
			}
			if(changeSize){
				dojo.marginBox(this.domNode, changeSize);
				this.height = this.domNode.style.height;
				delete this.fitTo;
			}else if(this.fitTo == "parent"){
				h = this._parentContentBoxHeight = this._parentContentBoxHeight || dojo._getContentBox(pn).h;
				this.domNode.style.height = Math.max(0, h) + "px";
			}
			
			var hasFlex = dojo.some(this.views.views, function(v){ return v.flexCells; });

			if(!this._autoHeight && (h || dojo._getContentBox(this.domNode).h) === 0){
				// We need to hide the header, since the Grid is essentially hidden.
				this.viewsHeaderNode.style.display = "none";
			}else{
				// Otherwise, show the header and give it an appropriate height.
				this.viewsHeaderNode.style.display = "block";
				if(!hasFlex && hh === undefined){
					hh = this._getHeaderHeight();
				}
			}
			if(hasFlex){
				hh = undefined;
			}

			// NOTE: it is essential that width be applied before height
			// Header height can only be calculated properly after view widths have been set.
			// This is because flex column width is naturally 0 in Firefox.
			// Therefore prior to width sizing flex columns with spaces are maximally wrapped
			// and calculated to be too tall.
			this.adaptWidth();
			this.adaptHeight(hh);

			this.postresize();
		},

		adaptWidth: function() {
			// private: sets width and position for views and update grid width if necessary
			var doAutoWidth = (!this.initialWidth && this.autoWidth);
			var w = doAutoWidth ? 0 : this.domNode.clientWidth || (this.domNode.offsetWidth - this._getPadBorder().w),
				vw = this.views.arrange(1, w);
			this.views.onEach("adaptWidth");
			if(doAutoWidth){
				this.domNode.style.width = vw + "px";
			}
		},

		adaptHeight: function(inHeaderHeight){
			// private: measures and normalizes header height, then sets view heights, and then updates scroller
			// content extent
			var t = inHeaderHeight === undefined ? this._getHeaderHeight() : inHeaderHeight;
			var h = (this._autoHeight ? -1 : Math.max(this.domNode.clientHeight - t, 0) || 0);
			this.views.onEach('setSize', [0, h]);
			this.views.onEach('adaptHeight');
			if(!this._autoHeight){
				var numScroll = 0, numNoScroll = 0;
				var noScrolls = dojo.filter(this.views.views, function(v){
					var has = v.hasHScrollbar();
					if(has){ numScroll++; }else{ numNoScroll++; }
					return (!has);
				});
				if(numScroll > 0 && numNoScroll > 0){
					dojo.forEach(noScrolls, function(v){
						v.adaptHeight(true);
					});
				}
			}
			if(this.autoHeight === true || h != -1 || (typeof this.autoHeight == "number" && this.autoHeight >= this.get('rowCount'))){
				this.scroller.windowHeight = h;
			}else{
				this.scroller.windowHeight = Math.max(this.domNode.clientHeight - t, 0);
			}
		},

		// startup
		startup: function(){
			if(this._started){return;}
			this.inherited(arguments);
			if(this.autoRender){
				this.render();
			}
		},

		// render
		render: function(){
			// summary:
			//	Render the grid, headers, and views. Edit and scrolling states are reset. To retain edit and
			// scrolling states, see Update.

			if(!this.domNode){return;}
			if(!this._started){return;}

			if(!this.hasLayout()) {
				this.scroller.init(0, this.keepRows, this.rowsPerPage);
				return;
			}
			//
			this.update = this.defaultUpdate;
			this._render();
		},

		_render: function(){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this.setScrollTop(0);
			this.postrender();
		},

		prerender: function(){
			// if autoHeight, make sure scroller knows not to virtualize; everything must be rendered.
			this.keepRows = this._autoHeight ? 0 : this.keepRows;
			this.scroller.setKeepInfo(this.keepRows);
			this.views.render();
			this._resize();
		},

		postrender: function(){
			this.postresize();
			this.focus.initFocusView();
			// make rows unselectable
			dojo.setSelectable(this.domNode, this.selectable);
		},

		postresize: function(){
			// views are position absolute, so they do not inflate the parent
			if(this._autoHeight){
				var size = Math.max(this.views.measureContent()) + 'px';
				
				this.viewsNode.style.height = size;
			}
		},

		renderRow: function(inRowIndex, inNodes){
			// summary: private, used internally to render rows
			this.views.renderRow(inRowIndex, inNodes, this._skipRowRenormalize);
		},

		rowRemoved: function(inRowIndex){
			// summary: private, used internally to remove rows
			this.views.rowRemoved(inRowIndex);
		},

		invalidated: null,

		updating: false,

		beginUpdate: function(){
			// summary:
			//		Use to make multiple changes to rows while queueing row updating.
			// NOTE: not currently supporting nested begin/endUpdate calls
			this.invalidated = [];
			this.updating = true;
		},

		endUpdate: function(){
			// summary:
			//		Use after calling beginUpdate to render any changes made to rows.
			this.updating = false;
			var i = this.invalidated, r;
			if(i.all){
				this.update();
			}else if(i.rowCount != undefined){
				this.updateRowCount(i.rowCount);
			}else{
				for(r in i){
					this.updateRow(Number(r));
				}
			}
			this.invalidated = [];
		},

		// update
		defaultUpdate: function(){
			// note: initial update calls render and subsequently this function.
			if(!this.domNode){return;}
			if(this.updating){
				this.invalidated.all = true;
				return;
			}
			//this.edit.saveState(inRowIndex);
			this.lastScrollTop = this.scrollTop;
			this.prerender();
			this.scroller.invalidateNodes();
			this.setScrollTop(this.lastScrollTop);
			this.postrender();
			//this.edit.restoreState(inRowIndex);
		},

		update: function(){
			// summary:
			//		Update the grid, retaining edit and scrolling states.
			this.render();
		},

		updateRow: function(inRowIndex){
			// summary:
			//		Render a single row.
			// inRowIndex: Integer
			//		Index of the row to render
			inRowIndex = Number(inRowIndex);
			if(this.updating){
				this.invalidated[inRowIndex]=true;
			}else{
				this.views.updateRow(inRowIndex);
				this.scroller.rowHeightChanged(inRowIndex);
			}
		},

		updateRows: function(startIndex, howMany){
			// summary:
			//		Render consecutive rows at once.
			// startIndex: Integer
			//		Index of the starting row to render
			// howMany: Integer
			//		How many rows to update.
			startIndex = Number(startIndex);
			howMany = Number(howMany);
			var i;
			if(this.updating){
				for(i=0; i<howMany; i++){
					this.invalidated[i+startIndex]=true;
				}
			}else{
				for(i=0; i<howMany; i++){
					this.views.updateRow(i+startIndex, this._skipRowRenormalize);
				}
				this.scroller.rowHeightChanged(startIndex);
			}
		},

		updateRowCount: function(inRowCount){
			//summary:
			//	Change the number of rows.
			// inRowCount: int
			//	Number of rows in the grid.
			if(this.updating){
				this.invalidated.rowCount = inRowCount;
			}else{
				this.rowCount = inRowCount;
				this._setAutoHeightAttr(this.autoHeight, true);
				if(this.layout.cells.length){
					this.scroller.updateRowCount(inRowCount);
				}
				this._resize();
				if(this.layout.cells.length){
					this.setScrollTop(this.scrollTop);
				}
			}
		},

		updateRowStyles: function(inRowIndex){
			// summary:
			//		Update the styles for a row after it's state has changed.
			this.views.updateRowStyles(inRowIndex);
		},
		getRowNode: function(inRowIndex){
			// summary:
			//		find the rowNode that is not a rowSelector
			if (this.focus.focusView && !(this.focus.focusView instanceof dojox.grid._RowSelector)){
					return this.focus.focusView.rowNodes[inRowIndex];
			}else{ // search through views
				for (var i = 0, cView; (cView = this.views.views[i]); i++) {
					if (!(cView instanceof dojox.grid._RowSelector)) {
						return cView.rowNodes[inRowIndex];
					}
				}
			}
			return null;
		},
		rowHeightChanged: function(inRowIndex){
			// summary:
			//		Update grid when the height of a row has changed. Row height is handled automatically as rows
			//		are rendered. Use this function only to update a row's height outside the normal rendering process.
			// inRowIndex: Integer
			// 		index of the row that has changed height

			this.views.renormalizeRow(inRowIndex);
			this.scroller.rowHeightChanged(inRowIndex);
		},

		// fastScroll: Boolean
		//		flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
		//		scroll performance but more immediate scrolling feedback
		fastScroll: true,

		delayScroll: false,

		// scrollRedrawThreshold: int
		//	pixel distance a user must scroll vertically to trigger grid scrolling.
		scrollRedrawThreshold: (dojo.isIE ? 100 : 50),

		// scroll methods
		scrollTo: function(inTop){
			// summary:
			//		Vertically scroll the grid to a given pixel position
			// inTop: Integer
			//		vertical position of the grid in pixels
			if(!this.fastScroll){
				this.setScrollTop(inTop);
				return;
			}
			var delta = Math.abs(this.lastScrollTop - inTop);
			this.lastScrollTop = inTop;
			if(delta > this.scrollRedrawThreshold || this.delayScroll){
				this.delayScroll = true;
				this.scrollTop = inTop;
				this.views.setScrollTop(inTop);
				if(this._pendingScroll){
					window.clearTimeout(this._pendingScroll);
				}
				var _this = this;
				this._pendingScroll = window.setTimeout(function(){
					delete _this._pendingScroll;
					_this.finishScrollJob();
				}, 200);
			}else{
				this.setScrollTop(inTop);
			}
		},

		finishScrollJob: function(){
			this.delayScroll = false;
			this.setScrollTop(this.scrollTop);
		},

		setScrollTop: function(inTop){
			this.scroller.scroll(this.views.setScrollTop(inTop));
		},

		scrollToRow: function(inRowIndex){
			// summary:
			//		Scroll the grid to a specific row.
			// inRowIndex: Integer
			// 		grid row index
			this.setScrollTop(this.scroller.findScrollTop(inRowIndex) + 1);
		},

		// styling (private, used internally to style individual parts of a row)
		styleRowNode: function(inRowIndex, inRowNode){
			if(inRowNode){
				this.rows.styleRowNode(inRowIndex, inRowNode);
			}
		},
		
		// called when the mouse leaves the grid so we can deselect all hover rows
		_mouseOut: function(e){
			this.rows.setOverRow(-2);
		},
	
		// cells
		getCell: function(inIndex){
			// summary:
			//		Retrieves the cell object for a given grid column.
			// inIndex: Integer
			// 		Grid column index of cell to retrieve
			// returns:
			//		a grid cell
			return this.layout.cells[inIndex];
		},

		setCellWidth: function(inIndex, inUnitWidth){
			this.getCell(inIndex).unitWidth = inUnitWidth;
		},

		getCellName: function(inCell){
			// summary: Returns the cell name of a passed cell
			return "Cell " + inCell.index; // String
		},

		// sorting
		canSort: function(inSortInfo){
			// summary:
			//		Determines if the grid can be sorted
			// inSortInfo: Integer
			//		Sort information, 1-based index of column on which to sort, positive for an ascending sort
			// 		and negative for a descending sort
			// returns: Boolean
			//		True if grid can be sorted on the given column in the given direction
		},

		sort: function(){
		},

		getSortAsc: function(inSortInfo){
			// summary:
			//		Returns true if grid is sorted in an ascending direction.
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Boolean(inSortInfo > 0); // Boolean
		},

		getSortIndex: function(inSortInfo){
			// summary:
			//		Returns the index of the column on which the grid is sorted
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Math.abs(inSortInfo) - 1; // Integer
		},

		setSortIndex: function(inIndex, inAsc){
			// summary:
			// 		Sort the grid on a column in a specified direction
			// inIndex: Integer
			// 		Column index on which to sort.
			// inAsc: Boolean
			// 		If true, sort the grid in ascending order, otherwise in descending order
			var si = inIndex +1;
			if(inAsc != undefined){
				si *= (inAsc ? 1 : -1);
			} else if(this.getSortIndex() == inIndex){
				si = -this.sortInfo;
			}
			this.setSortInfo(si);
		},

		setSortInfo: function(inSortInfo){
			if(this.canSort(inSortInfo)){
				this.sortInfo = inSortInfo;
				this.sort();
				this.update();
			}
		},

		// DOM event handler
		doKeyEvent: function(e){
			e.dispatch = 'do' + e.type;
			this.onKeyEvent(e);
		},

		// event dispatch
		//: protected
		_dispatch: function(m, e){
			if(m in this){
				return this[m](e);
			}
			return false;
		},

		dispatchKeyEvent: function(e){
			this._dispatch(e.dispatch, e);
		},

		dispatchContentEvent: function(e){
			this.edit.dispatchEvent(e) || e.sourceView.dispatchContentEvent(e) || this._dispatch(e.dispatch, e);
		},

		dispatchHeaderEvent: function(e){
			e.sourceView.dispatchHeaderEvent(e) || this._dispatch('doheader' + e.type, e);
		},

		dokeydown: function(e){
			this.onKeyDown(e);
		},

		doclick: function(e){
			if(e.cellNode){
				this.onCellClick(e);
			}else{
				this.onRowClick(e);
			}
		},

		dodblclick: function(e){
			if(e.cellNode){
				this.onCellDblClick(e);
			}else{
				this.onRowDblClick(e);
			}
		},

		docontextmenu: function(e){
			if(e.cellNode){
				this.onCellContextMenu(e);
			}else{
				this.onRowContextMenu(e);
			}
		},

		doheaderclick: function(e){
			if(e.cellNode){
				this.onHeaderCellClick(e);
			}else{
				this.onHeaderClick(e);
			}
		},

		doheaderdblclick: function(e){
			if(e.cellNode){
				this.onHeaderCellDblClick(e);
			}else{
				this.onHeaderDblClick(e);
			}
		},

		doheadercontextmenu: function(e){
			if(e.cellNode){
				this.onHeaderCellContextMenu(e);
			}else{
				this.onHeaderContextMenu(e);
			}
		},

		// override to modify editing process
		doStartEdit: function(inCell, inRowIndex){
			this.onStartEdit(inCell, inRowIndex);
		},

		doApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
			this.onApplyCellEdit(inValue, inRowIndex, inFieldIndex);
		},

		doCancelEdit: function(inRowIndex){
			this.onCancelEdit(inRowIndex);
		},

		doApplyEdit: function(inRowIndex){
			this.onApplyEdit(inRowIndex);
		},

		// row editing
		addRow: function(){
			// summary:
			//		Add a row to the grid.
			this.updateRowCount(this.get('rowCount')+1);
		},

		removeSelectedRows: function(){
			// summary:
			//		Remove the selected rows from the grid.
			if(this.allItemsSelected){
				this.updateRowCount(0);
			}else{
				this.updateRowCount(Math.max(0, this.get('rowCount') - this.selection.getSelected().length));
			}
			this.selection.clear();
		}

	});

	dojox.grid._Grid.markupFactory = function(props, node, ctor, cellFunc){
		var d = dojo;
		var widthFromAttr = function(n){
			var w = d.attr(n, "width")||"auto";
			if((w != "auto")&&(w.slice(-2) != "em")&&(w.slice(-1) != "%")){
				w = parseInt(w, 10)+"px";
			}
			return w;
		};
		// if(!props.store){ console.debug("no store!"); }
		// if a structure isn't referenced, do we have enough
		// data to try to build one automatically?
		if(	!props.structure &&
			node.nodeName.toLowerCase() == "table"){

			// try to discover a structure
			props.structure = d.query("> colgroup", node).map(function(cg){
				var sv = d.attr(cg, "span");
				var v = {
					noscroll: (d.attr(cg, "noscroll") == "true") ? true : false,
					__span: (!!sv ? parseInt(sv, 10) : 1),
					cells: []
				};
				if(d.hasAttr(cg, "width")){
					v.width = widthFromAttr(cg);
				}
				return v; // for vendetta
			});
			if(!props.structure.length){
				props.structure.push({
					__span: Infinity,
					cells: [] // catch-all view
				});
			}
			// check to see if we're gonna have more than one view

			// for each tr in our th, create a row of cells
			d.query("thead > tr", node).forEach(function(tr, tr_idx){
				var cellCount = 0;
				var viewIdx = 0;
				var lastViewIdx;
				var cView = null;
				d.query("> th", tr).map(function(th){
					// what view will this cell go into?

					// NOTE:
					//		to prevent extraneous iteration, we start counters over
					//		for each row, incrementing over the surface area of the
					//		structure that colgroup processing generates and
					//		creating cell objects for each <th> to place into those
					//		cell groups.  There's a lot of state-keepking logic
					//		here, but it is what it has to be.
					if(!cView){ // current view book keeping
						lastViewIdx = 0;
						cView = props.structure[0];
					}else if(cellCount >= (lastViewIdx+cView.__span)){
						viewIdx++;
						// move to allocating things into the next view
						lastViewIdx += cView.__span;
						var lastView = cView;
						cView = props.structure[viewIdx];
					}

					// actually define the cell from what markup hands us
					var cell = {
						name: d.trim(d.attr(th, "name")||th.innerHTML),
						colSpan: parseInt(d.attr(th, "colspan")||1, 10),
						type: d.trim(d.attr(th, "cellType")||""),
						id: d.trim(d.attr(th,"id")||"")
					};
					cellCount += cell.colSpan;
					var rowSpan = d.attr(th, "rowspan");
					if(rowSpan){
						cell.rowSpan = rowSpan;
					}
					if(d.hasAttr(th, "width")){
						cell.width = widthFromAttr(th);
					}
					if(d.hasAttr(th, "relWidth")){
						cell.relWidth = window.parseInt(dojo.attr(th, "relWidth"), 10);
					}
					if(d.hasAttr(th, "hidden")){
						cell.hidden = (d.attr(th, "hidden") == "true" || d.attr(th, "hidden") === true/*always boolean true in Chrome*/);
					}

					if(cellFunc){
						cellFunc(th, cell);
					}

					cell.type = cell.type ? dojo.getObject(cell.type) : dojox.grid.cells.Cell;

					if(cell.type && cell.type.markupFactory){
						cell.type.markupFactory(th, cell);
					}

					if(!cView.cells[tr_idx]){
						cView.cells[tr_idx] = [];
					}
					cView.cells[tr_idx].push(cell);
				});
			});
		}

		return new ctor(props, node);
	};
})();

}

if(!dojo._hasResource["dojox.grid.DataSelection"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.DataSelection"] = true;
dojo.provide("dojox.grid.DataSelection");


dojo.declare("dojox.grid.DataSelection", dojox.grid.Selection, {
	getFirstSelected: function(){
		var idx = dojox.grid.Selection.prototype.getFirstSelected.call(this);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

	getNextSelected: function(inPrev){
		var old_idx = this.grid.getItemIndex(inPrev);
		var idx = dojox.grid.Selection.prototype.getNextSelected.call(this, old_idx);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

	getSelected: function(){
		var result = [];
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				result.push(this.grid.getItem(i));
			}
		}
		return result;
	},

	addToSelection: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		dojox.grid.Selection.prototype.addToSelection.call(this, idx);
	},

	deselect: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		dojox.grid.Selection.prototype.deselect.call(this, idx);
	},

	deselectAll: function(inItemOrIndex){
		var idx = null;
		if(inItemOrIndex || typeof inItemOrIndex == "number"){
			if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
				idx = inItemOrIndex;
			}else{
				idx = this.grid.getItemIndex(inItemOrIndex);
			}
			dojox.grid.Selection.prototype.deselectAll.call(this, idx);
		}else{
			this.inherited(arguments);
		}
	}
});

}

if(!dojo._hasResource["dojox.grid.DataGrid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.DataGrid"] = true;
dojo.provide("dojox.grid.DataGrid");




/*=====
dojo.declare("dojox.grid.__DataCellDef", dojox.grid.__CellDef, {
	constructor: function(){
		//	field: String?
		//		The attribute to read from the dojo.data item for the row.
		//  fields: String[]?
		//		An array of fields to grab the values of and pass as an array to the grid
		//	get: Function?
		//		function(rowIndex, item?){} rowIndex is of type Integer, item is of type
		//		Object.  This function will be called when a cell requests data.  Returns
		//		the unformatted data for the cell.
	}
});
=====*/

/*=====
dojo.declare("dojox.grid.__DataViewDef", dojox.grid.__ViewDef, {
	constructor: function(){
		//	cells: dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]?
		//		The structure of the cells within this grid.
		//	defaultCell: dojox.grid.__DataCellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
	}
});
=====*/

dojo.declare("dojox.grid.DataGrid", dojox.grid._Grid, {
	store: null,
	query: null,
	queryOptions: null,
	fetchText: '...',
	sortFields: null,
	
	// updateDelay: int
	//		Time, in milliseconds, to delay updates automatically so that multiple
	//		calls to onSet/onNew/onDelete don't keep rerendering the grid.  Set
	//		to 0 to immediately cause updates.  A higher value will result in
	//		better performance at the expense of responsiveness of the grid.
	updateDelay: 1,

/*=====
	// structure: dojox.grid.__DataViewDef|dojox.grid.__DataViewDef[]|dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]
	//		View layout defintion.
	structure: '',
=====*/

	// You can specify items instead of a query, if you like.  They do not need
	// to be loaded - but the must be items in the store
	items: null,
	
	_store_connects: null,
	_by_idty: null,
	_by_idx: null,
	_cache: null,
	_pages: null,
	_pending_requests: null,
	_bop: -1,
	_eop: -1,
	_requests: 0,
	rowCount: 0,

	_isLoaded: false,
	_isLoading: false,
	
	postCreate: function(){
		this._pages = [];
		this._store_connects = [];
		this._by_idty = {};
		this._by_idx = [];
		this._cache = [];
		this._pending_requests = {};

		this._setStore(this.store);
		this.inherited(arguments);
	},

	createSelection: function(){
		this.selection = new dojox.grid.DataSelection(this);
	},

	get: function(inRowIndex, inItem){
		// summary: Default data getter.
		// description:
		//		Provides data to display in a grid cell. Called in grid cell context.
		//		So this.cell.index is the column index.
		// inRowIndex: Integer
		//		Row for which to provide data
		// returns:
		//		Data to display for a given grid cell.
		
		if(inItem && this.field == "_item" && !this.fields){
			return inItem;
		}else if(inItem && this.fields){
			var ret = [];
			var s = this.grid.store;
			dojo.forEach(this.fields, function(f){
				ret = ret.concat(s.getValues(inItem, f));
			});
			return ret;
		}else if(!inItem && typeof inRowIndex === "string"){
			return this.inherited(arguments);
		}
		return (!inItem ? this.defaultValue : (!this.field ? this.value : (this.field == "_item" ? inItem : this.grid.store.getValue(inItem, this.field))));
	},

	_checkUpdateStatus: function(){
		if(this.updateDelay > 0){
			var iStarted = false;
			if(this._endUpdateDelay){
				clearTimeout(this._endUpdateDelay);
				delete this._endUpdateDelay;
				iStarted = true;
			}
			if(!this.updating){
				this.beginUpdate();
				iStarted = true;
			}
			if(iStarted){
				var _this = this;
				this._endUpdateDelay = setTimeout(function(){
					delete _this._endUpdateDelay;
					_this.endUpdate();
				}, this.updateDelay);
			}
		}
	},
	
	_onSet: function(item, attribute, oldValue, newValue){
		this._checkUpdateStatus();
		var idx = this.getItemIndex(item);
		if(idx>-1){
			this.updateRow(idx);
		}
	},
	
	_createItem: function(item, index){
		var idty = this._hasIdentity ? this.store.getIdentity(item) : dojo.toJson(this.query) + ":idx:" + index + ":sort:" + dojo.toJson(this.getSortProps());
		var o = this._by_idty[idty] = { idty: idty, item: item };
		return o;
	},

	_addItem: function(item, index, noUpdate){
		this._by_idx[index] = this._createItem(item, index);
		if(!noUpdate){
			this.updateRow(index);
		}
	},

	_onNew: function(item, parentInfo){
		this._checkUpdateStatus();
		var rowCount = this.get('rowCount');
		this._addingItem = true;
		this.updateRowCount(rowCount+1);
		this._addingItem = false;
		this._addItem(item, rowCount);
		this.showMessage();
	},

	_onDelete: function(item){
		this._checkUpdateStatus();
		var idx = this._getItemIndex(item, true);

		if(idx >= 0){
			// When a row is deleted, all rest rows are shifted down,
			// and migrate from page to page. If some page is not
			// loaded yet empty rows can migrate to initialized pages
			// without refreshing. It causes empty rows in some pages, see:
			// http://bugs.dojotoolkit.org/ticket/6818
			// this code fix this problem by reseting loaded page info
			this._pages = [];
			this._bop = -1;
			this._eop = -1;

			var o = this._by_idx[idx];
			this._by_idx.splice(idx, 1);
			delete this._by_idty[o.idty];
			this.updateRowCount(this.get('rowCount')-1);
			if(this.get('rowCount') === 0){
				this.showMessage(this.noDataMessage);
			}
		}
	},

	_onRevert: function(){
		this._refresh();
	},

	setStore: function(store, query, queryOptions){
		this._setQuery(query, queryOptions);
		this._setStore(store);
		this._refresh(true);
	},
	
	setQuery: function(query, queryOptions){
		this._setQuery(query, queryOptions);
		this._refresh(true);
	},
	
	setItems: function(items){
		this.items = items;
		this._setStore(this.store);
		this._refresh(true);
	},
	
	_setQuery: function(query, queryOptions){
		this.query = query;
		this.queryOptions = queryOptions || this.queryOptions;
	},

	_setStore: function(store){
		if(this.store && this._store_connects){
			dojo.forEach(this._store_connects, this.disconnect, this);
		}
		this.store = store;

		if(this.store){
			var f = this.store.getFeatures();
			var h = [];

			this._canEdit = !!f["dojo.data.api.Write"] && !!f["dojo.data.api.Identity"];
			this._hasIdentity = !!f["dojo.data.api.Identity"];

			if(!!f["dojo.data.api.Notification"] && !this.items){
				h.push(this.connect(this.store, "onSet", "_onSet"));
				h.push(this.connect(this.store, "onNew", "_onNew"));
				h.push(this.connect(this.store, "onDelete", "_onDelete"));
			}
			if(this._canEdit){
				h.push(this.connect(this.store, "revert", "_onRevert"));
			}

			this._store_connects = h;
		}
	},

	_onFetchBegin: function(size, req){
		if(!this.scroller){ return; }
		if(this.rowCount != size){
			if(req.isRender){
				this.scroller.init(size, this.keepRows, this.rowsPerPage);
				this.rowCount = size;
				this._setAutoHeightAttr(this.autoHeight, true);
				this._skipRowRenormalize = true;
				this.prerender();
				this._skipRowRenormalize = false;
			}else{
				this.updateRowCount(size);
			}
		}
		if(!size){
			this.views.render();
			this._resize();
			this.showMessage(this.noDataMessage);
			this.focus.initFocusView();
		}else{
			this.showMessage();
		}
	},

	_onFetchComplete: function(items, req){
		if(!this.scroller){ return; }
		if(items && items.length > 0){
			//console.log(items);
			dojo.forEach(items, function(item, idx){
				this._addItem(item, req.start+idx, true);
			}, this);
			this.updateRows(req.start, items.length);
			if(req.isRender){
				this.setScrollTop(0);
				this.postrender();
			}else if(this._lastScrollTop){
				this.setScrollTop(this._lastScrollTop);
			}
		}
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
		}
		this._pending_requests[req.start] = false;
	},

	_onFetchError: function(err, req){
		console.log(err);
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
			this.showMessage(this.errorMessage);
		}
		this._pending_requests[req.start] = false;
		this.onFetchError(err, req);
	},

	onFetchError: function(err, req){
	},

	_fetch: function(start, isRender){
		start = start || 0;
		if(this.store && !this._pending_requests[start]){
			if(!this._isLoaded && !this._isLoading){
				this._isLoading = true;
				this.showMessage(this.loadingMessage);
			}
			this._pending_requests[start] = true;
			//console.log("fetch: ", start);
			try{
				if(this.items){
					var items = this.items;
					var store = this.store;
					this.rowsPerPage = items.length;
					var req = {
						start: start,
						count: this.rowsPerPage,
						isRender: isRender
					};
					this._onFetchBegin(items.length, req);
					
					// Load them if we need to
					var waitCount = 0;
					dojo.forEach(items, function(i){
						if(!store.isItemLoaded(i)){ waitCount++; }
					});
					if(waitCount === 0){
						this._onFetchComplete(items, req);
					}else{
						var onItem = function(item){
							waitCount--;
							if(waitCount === 0){
								this._onFetchComplete(items, req);
							}
						};
						dojo.forEach(items, function(i){
							if(!store.isItemLoaded(i)){
								store.loadItem({item: i, onItem: onItem, scope: this});
							}
						}, this);
					}
				}else{
					this.store.fetch({
						start: start,
						count: this.rowsPerPage,
						query: this.query,
						sort: this.getSortProps(),
						queryOptions: this.queryOptions,
						isRender: isRender,
						onBegin: dojo.hitch(this, "_onFetchBegin"),
						onComplete: dojo.hitch(this, "_onFetchComplete"),
						onError: dojo.hitch(this, "_onFetchError")
					});
				}
			}catch(e){
				this._onFetchError(e, {start: start, count: this.rowsPerPage});
			}
		}
	},

	_clearData: function(){
		this.updateRowCount(0);
		this._by_idty = {};
		this._by_idx = [];
		this._pages = [];
		this._bop = this._eop = -1;
		this._isLoaded = false;
		this._isLoading = false;
	},

	getItem: function(idx){
		var data = this._by_idx[idx];
		if(!data||(data&&!data.item)){
			this._preparePage(idx);
			return null;
		}
		return data.item;
	},

	getItemIndex: function(item){
		return this._getItemIndex(item, false);
	},
	
	_getItemIndex: function(item, isDeleted){
		if(!isDeleted && !this.store.isItem(item)){
			return -1;
		}

		var idty = this._hasIdentity ? this.store.getIdentity(item) : null;

		for(var i=0, l=this._by_idx.length; i<l; i++){
			var d = this._by_idx[i];
			if(d && ((idty && d.idty == idty) || (d.item === item))){
				return i;
			}
		}
		return -1;
	},

	filter: function(query, reRender){
		this.query = query;
		if(reRender){
			this._clearData();
		}
		this._fetch();
	},

	_getItemAttr: function(idx, attr){
		var item = this.getItem(idx);
		return (!item ? this.fetchText : this.store.getValue(item, attr));
	},

	// rendering
	_render: function(){
		if(this.domNode.parentNode){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this._fetch(0, true);
		}
	},

	// paging
	_requestsPending: function(inRowIndex){
		return this._pending_requests[inRowIndex];
	},

	_rowToPage: function(inRowIndex){
		return (this.rowsPerPage ? Math.floor(inRowIndex / this.rowsPerPage) : inRowIndex);
	},

	_pageToRow: function(inPageIndex){
		return (this.rowsPerPage ? this.rowsPerPage * inPageIndex : inPageIndex);
	},

	_preparePage: function(inRowIndex){
		if((inRowIndex < this._bop || inRowIndex >= this._eop) && !this._addingItem){
			var pageIndex = this._rowToPage(inRowIndex);
			this._needPage(pageIndex);
			this._bop = pageIndex * this.rowsPerPage;
			this._eop = this._bop + (this.rowsPerPage || this.get('rowCount'));
		}
	},

	_needPage: function(inPageIndex){
		if(!this._pages[inPageIndex]){
			this._pages[inPageIndex] = true;
			this._requestPage(inPageIndex);
		}
	},

	_requestPage: function(inPageIndex){
		var row = this._pageToRow(inPageIndex);
		var count = Math.min(this.rowsPerPage, this.get('rowCount') - row);
		if(count > 0){
			this._requests++;
			if(!this._requestsPending(row)){
				setTimeout(dojo.hitch(this, "_fetch", row, false), 1);
				//this.requestRows(row, count);
			}
		}
	},

	getCellName: function(inCell){
		return inCell.field;
		//console.log(inCell);
	},

	_refresh: function(isRender){
		this._clearData();
		this._fetch(0, isRender);
	},

	sort: function(){
		this.edit.apply();
		this._lastScrollTop = this.scrollTop;
		this._refresh();
	},

	canSort: function(){
		return (!this._isLoading);
	},

	getSortProps: function(){
		var c = this.getCell(this.getSortIndex());
		if(!c){
			if(this.sortFields){
				return this.sortFields;
			}
			return null;
		}else{
			var desc = c["sortDesc"];
			var si = !(this.sortInfo>0);
			if(typeof desc == "undefined"){
				desc = si;
			}else{
				desc = si ? !desc : desc;
			}
			return [{ attribute: c.field, descending: desc }];
		}
	},

	styleRowState: function(inRow){
		// summary: Perform row styling
		if(this.store && this.store.getState){
			var states=this.store.getState(inRow.index), c='';
			for(var i=0, ss=["inflight", "error", "inserting"], s; s=ss[i]; i++){
				if(states[s]){
					c = ' dojoxGridRow-' + s;
					break;
				}
			}
			inRow.customClasses += c;
		}
	},

	onStyleRow: function(inRow){
		this.styleRowState(inRow);
		this.inherited(arguments);
	},

	// editing
	canEdit: function(inCell, inRowIndex){
		return this._canEdit;
	},

	_copyAttr: function(idx, attr){
		var row = {};
		var backstop = {};
		var src = this.getItem(idx);
		return this.store.getValue(src, attr);
	},

	doStartEdit: function(inCell, inRowIndex){
		if(!this._cache[inRowIndex]){
			this._cache[inRowIndex] = this._copyAttr(inRowIndex, inCell.field);
		}
		this.onStartEdit(inCell, inRowIndex);
	},

	doApplyCellEdit: function(inValue, inRowIndex, inAttrName){
		this.store.fetchItemByIdentity({
			identity: this._by_idx[inRowIndex].idty,
			onItem: dojo.hitch(this, function(item){
				var oldValue = this.store.getValue(item, inAttrName);
				if(typeof oldValue == 'number'){
					inValue = isNaN(inValue) ? inValue : parseFloat(inValue);
				}else if(typeof oldValue == 'boolean'){
					inValue = inValue == 'true' ? true : inValue == 'false' ? false : inValue;
				}else if(oldValue instanceof Date){
					var asDate = new Date(inValue);
					inValue = isNaN(asDate.getTime()) ? inValue : asDate;
				}
				this.store.setValue(item, inAttrName, inValue);
				this.onApplyCellEdit(inValue, inRowIndex, inAttrName);
			})
		});
	},

	doCancelEdit: function(inRowIndex){
		var cache = this._cache[inRowIndex];
		if(cache){
			this.updateRow(inRowIndex);
			delete this._cache[inRowIndex];
		}
		this.onCancelEdit.apply(this, arguments);
	},

	doApplyEdit: function(inRowIndex, inDataAttr){
		var cache = this._cache[inRowIndex];
		/*if(cache){
			var data = this.getItem(inRowIndex);
			if(this.store.getValue(data, inDataAttr) != cache){
				this.update(cache, data, inRowIndex);
			}
			delete this._cache[inRowIndex];
		}*/
		this.onApplyEdit(inRowIndex);
	},

	removeSelectedRows: function(){
		// summary:
		//		Remove the selected rows from the grid.
		if(this._canEdit){
			this.edit.apply();
			var fx = dojo.hitch(this, function(items){
				if(items.length){
					dojo.forEach(items, this.store.deleteItem, this.store);
					this.selection.clear();
				}
			});
			if(this.allItemsSelected){
				this.store.fetch({
							query: this.query,
							queryOptions: this.queryOptions,
							onComplete: fx});
			}else{
				fx(this.selection.getSelected());
			}
		}
	}
});

dojox.grid.DataGrid.cell_markupFactory = function(cellFunc, node, cellDef){
	var field = dojo.trim(dojo.attr(node, "field")||"");
	if(field){
		cellDef.field = field;
	}
	cellDef.field = cellDef.field||cellDef.name;
	var fields = dojo.trim(dojo.attr(node, "fields")||"");
	if(fields){
		cellDef.fields = fields.split(",");
	}
	if(cellFunc){
		cellFunc(node, cellDef);
	}
};

dojox.grid.DataGrid.markupFactory = function(props, node, ctor, cellFunc){
	return dojox.grid._Grid.markupFactory(props, node, ctor,
					dojo.partial(dojox.grid.DataGrid.cell_markupFactory, cellFunc));
};

}

if(!dojo._hasResource['bfree.widget.admin.user.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.admin.user.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 12/10/11
 * Time: 10:55 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.admin.user.Administration');


















dojo.declare('bfree.widget.admin.user.Administration', [dijit._Widget, dijit._Templated], {

    templateString: dojo.cache("bfree/widget/admin/user", "template/Administration.html", "<div style=\"width: 100%; height: 100%;\">\n    <table>\n        <tr>\n            <td dojoAttachPoint=\"lblUserName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Username:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtUserName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblFirstName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                First Name:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtFirstName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblLastName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Last Name:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtLastName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblEmail\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Email:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtEmail\"/>\n            </td>\n        </tr><tr dojoAttachPoint=\"trResetPass\">\n            <td dojoAttachPoint=\"lblResetPass\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Password:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtResetPass\"/>\n                <div dojoAttachPoint=\"btnResetPass\"></div>\n            </td>\n        </tr><tr dojoAttachPoint=\"trGeneratePass\" style=\"display: none;\">\n            <td dojoAttachPoint=\"lblGeneratePass\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Password:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtGeneratePass\"/>\n                <div dojoAttachPoint=\"btnGeneratePass\"></div>\n            </td>\n        </tr>\n    </table>\n</div>\n"),
    widgetsInTemplate: true,

    widgetType: "user",

    users: null,

    activeUser: null,

    constructor: function(args){
        this.users=args.users;
        this.onItemChange=args.onItemChange;
        this.onSelect=args.onSelect;
        this._grdUsers=args.grid;
    },

    onItemChange: function(){

    },

    _setActiveItemAttr: function(user){
        this.activeUser=user;
        this._populateUser();
        this.onSelect(this.activeUser!=null);

        if(this.activeUser!=null&&this.users.isDirty({item: this.activeUser})){
            this._editUserValues();
        }else{
            this._disableUserValues();
        }
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._txtUserName = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			invalidMessage: 'You must provide a \'Username\' value',
			promptMessage: 'User (login) name.<br>NOTE: this value cannot be changed<br> after the user has been saved',
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtUserName_onChange)
		}, this.txtUserName);

        this._txtFirstName = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'User\'s first name',
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtFirstName_onChange)
		}, this.txtFirstName);

		this._txtLastName = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'User\'s last name',
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtLastName_onChange)
		}, this.txtLastName);

		this._txtEmail = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'User\'s email address',
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtEmail_onChange)
		}, this.txtEmail);

        this._txtGeneratePass = new dijit.form.ValidationTextBox({
            intermediateChanges: true,
			invalidMessage: '',
			promptMessage: 'Enter or generate a new password for the user',
			require: true,
			trim: false,
            disabled: true,
            style: "width:190px",
			onChange: dojo.hitch(this, this._txtGeneratePass_onChange)
		}, this.txtGeneratePass);

        this._txtResetPass = new dijit.form.ValidationTextBox({
            intermediateChanges: true,
			invalidMessage: '',
			promptMessage: 'Enter or generate a new password for the user',
			require: true,
			trim: false,
            disabled: true,
            style: "width:190px",
			onChange: dojo.hitch(this, this._txtResetPass_onChange)
		}, this.txtResetPass);

        this._btnGeneratePass = new dijit.form.Button({
			iconClass: 'imageIcon bfreeIconLock',
			label: 'Generate Random Password',
			showLabel: false,
            disabled: true,
            onClick: dojo.hitch(this, this._btnGeneratePass_onClick)
		}, this.btnGeneratePass);

        this._btnResetPass = new dijit.form.Button({
			iconClass: 'imageIcon bfreeIconUnlock',
			label: 'Reset Password',
			showLabel: false,
            disabled: true,
            onClick: dojo.hitch(this, this._btnResetPass_onClick)
		}, this.btnResetPass);

//        this.startup();
    },

    _txtUserName_onChange: function(newValue){
        if(this.activeUser!=null&&newValue!=this.activeUser.name){
            this.users.setValue(this.activeUser, "name", newValue);
        }
    },

    _txtFirstName_onChange: function(newValue){
        if(this.activeUser!=null&&newValue!=this.activeUser.first_name){
            this.users.setValue(this.activeUser, "first_name", newValue);
        }
    },

    _txtLastName_onChange: function(newValue){
        if(this.activeUser!=null&&newValue!=this.activeUser.last_name){
            this.users.setValue(this.activeUser, "last_name", newValue);
        }
    },

    _txtEmail_onChange: function(newValue){
        if(this.activeUser!=null&&newValue!=this.activeUser.email){
            this.users.setValue(this.activeUser, "email", newValue);
        }
    },

    _btnResetPass_onClick: function(evt){
        if(confirm("Are you sure you want to reset "+(this.activeUser.first_name+" "+this.activeUser.last_name).trim()+"'s password?")){
            var newPass = bfree.api.RkoUsers.generatePassword({length: 8 });
            this.users.setValue(this.activeUser, 'resetPassword', newPass);
            this._txtResetPass.set('disabled', false);
            dojo.toggleClass(this.lblResetPass, 'bfreeDarkDisabled', false);
            this._txtResetPass.set('value', newPass);
            this._txtResetPass.focus();
        }
    },

    _btnGeneratePass_onClick: function(evt){
        var newPass = bfree.api.RkoUsers.generatePassword({length: 8 });
        this.users.setValue(this.activeUser, 'password', newPass);
        this._txtGeneratePass.set('value', newPass);
        this._txtGeneratePass.focus();
    },

    _txtGeneratePass_onChange: function(newValue){
        if(this.activeUser!=null&&this.activeUser.password!=newValue&&newValue!=''){
            this.users.setValue(this.activeUser, 'password', newValue);
        }
    },

    _txtResetPass_onChange: function(newValue){
        if(this.activeUser!=null&&this.activeUser.resetPassword!=newValue&&newValue!=''){
            this.users.setValue(this.activeUser, 'resetPassword', newValue);
        }
    },

    _editUserValues: function(){
        this._txtUserName.set('disabled', false);
        this._txtFirstName.set('disabled', false);
        this._txtLastName.set('disabled', false);
        this._txtEmail.set('disabled', false);

        if(this.activeUser.id!=null){
            dojo.style(this.trGeneratePass, {display: "none"});
            dojo.style(this.trResetPass, {display: ""});
//            this._txtResetPass.set('disabled', true);
            this._btnResetPass.set('disabled', false);
            this._btnGeneratePass.set('disabled', true);
            this._txtGeneratePass.set('disabled', true);
        }else{
            dojo.style(this.trGeneratePass, {display: ""});
            dojo.style(this.trResetPass, {display: "none"});
//            this._txtResetPass.set('disabled', false);
            this._txtResetPass.set('disabled', true);
            this._btnResetPass.set('disabled', true);
            this._txtGeneratePass.set('disabled', false);
            this._btnGeneratePass.set('disabled', false);
        }
    },

    _disableUserValues: function(){
        this._txtUserName.set('disabled', true);
        this._txtFirstName.set('disabled', true);
        this._txtLastName.set('disabled', true);
        this._txtEmail.set('disabled', true);
        this._txtGeneratePass.set('disabled', true);
        this._txtResetPass.set('disabled', true);
        this._btnGeneratePass.set('disabled', true);
        this._btnResetPass.set('disabled', true);
    },

    _populateUser: function(){
        if(this.activeUser==null){
            this._txtUserName.set('value', '');
            this._txtFirstName.set('value', '');
            this._txtLastName.set('value', '');
            this._txtEmail.set('value', '');
            this._txtGeneratePass.set('value', '');
            this._txtResetPass.set('value', '');
        }else{
            this._txtUserName.set('value', this.activeUser.name?this.activeUser.name:'');
            this._txtFirstName.set('value', this.activeUser.first_name?this.activeUser.first_name:'');
            this._txtLastName.set('value', this.activeUser.last_name?this.activeUser.last_name:'');
            this._txtEmail.set('value', this.activeUser.email?this.activeUser.email:'');
            this._txtGeneratePass.set('value', '');
            this._txtResetPass.set('value', '');
        }
    },

    _validateItems: function(){
        var valid = true;

        for(var idx = 0; idx < this._grdUsers.rowCount; idx++){
            var item = this._grdUsers.getItem(idx);
            if(this.users.isDirty({item: item})){
                valid &= item.isValid();
            }
        }

        return valid;
    },

    save: function(){
        if(!this._validateItems()){
            var msg = 'Cannot save User changes: One or more Users contain invalid data';
            alert(msg);
            return false;
        }

        this.users.save();
        this.onItemChange(false);
        this._grdUsers.selection.select(null);

        return true;
    },

    edit: function(){
        this.users.setDirty({item: this.activeUser});
        this.onItemChange(true);
        this._editUserValues();
        this._txtUserName.focus();
    },

    createItem: function(){
        this.activeUser=this.users.create();
        this.users.setValue(this.activeUser, 'password', bfree.api.RkoUsers.generatePassword({length: 8 }));
        this._txtGeneratePass.set('value', this.activeUser.password);
        this._grdUsers.selection.select(this.activeUser);
        this.onItemChange(true);
        this._editUserValues();
    },

    revert: function(){
        this.users.revert();
        this._grdUsers.update();
        this._grdUsers.sort();
        this.onItemChange(false);
        this._populateUser();
        this._disableUserValues();
    },

    remove: function(){
        this.users.destroy({no_save: true,item: this.activeUser});
        this._grdUsers.selection.select(null);
        this.onItemChange(true);
    },

    startup: function(){
        this.inherited('startup', arguments)
    },

    isDirty: function(){
        for(var idx = 0; idx < this._grdUsers.rowCount; idx++){
            var item = this._grdUsers.getItem(idx);
            if(this.users.isDirty({item: item})){
                return true;
            }
        }
        return false;
    }
});

}

if(!dojo._hasResource["dojox.data.KeyValueStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.KeyValueStore"] = true;
dojo.provide("dojox.data.KeyValueStore");




dojo.declare("dojox.data.KeyValueStore", null, {
	//	summary:
	//		This is a dojo.data store implementation.  It can take in either a Javascript
	//		array, JSON string, or URL as the data source.  Data is expected to be in the
	//		following format:
	//			[
	//				{ "key1": "value1" },
	//				{ "key2": "value2" }
	//			]
	//		This is to mimic the Java Properties file format.  Each 'item' from this store
	//		is a JS object representing a key-value pair.  If an item in the above array has
	//		more than one key/value pair, only the first will be used/accessed.
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: string}
		//	keywordParameters: {dataVar: jsonObject}
		if(keywordParameters.url){
			this.url = keywordParameters.url;
		}
		this._keyValueString = keywordParameters.data;
		this._keyValueVar = keywordParameters.dataVar;
		this._keyAttribute = "key";
		this._valueAttribute = "value";
		this._storeProp = "_keyValueStore";
		this._features = {
			'dojo.data.api.Read': true,
			'dojo.data.api.Identity': true
		};
		this._loadInProgress = false;	//Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters && "urlPreventCache" in keywordParameters){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
	},
	
	url: "",
	data: "",

	//urlPreventCache: boolean
	//Controls if urlPreventCache should be used with underlying xhrGet.
	urlPreventCache: false,
	
	_assertIsItem: function(/* item */ item){
		//	summary:
		//      This function tests whether the item passed in is indeed an item in the store.
		//	item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			throw new Error("dojox.data.KeyValueStore: a function was passed an item argument that was not an item");
		}
	},
	
	_assertIsAttribute: function(/* item */ item, /* String */ attribute){
		//	summary:
		//      This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute:
		//		The attribute to test for being contained by the store.
		if(!dojo.isString(attribute)){
			throw new Error("dojox.data.KeyValueStore: a function was passed an attribute argument that was not an attribute object nor an attribute name string");
		}
	},

/***************************************
     dojo.data.api.Read API
***************************************/
	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		//	summary:
		//		See dojo.data.api.Read.getValue()
		this._assertIsItem(item);
		this._assertIsAttribute(item, attribute);
		var value;
		if(attribute == this._keyAttribute){ // Looking for key
			value = item[this._keyAttribute];
		}else{
			value = item[this._valueAttribute]; // Otherwise, attribute == ('value' || the actual key )
		}
		if(value === undefined){
			value = defaultValue;
		}
		return value;
	},

	getValues: function(/* item */ item,
						/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.getValues()
		// 		Key/Value syntax does not support multi-valued attributes, so this is just a
		// 		wrapper function for getValue().
		var value = this.getValue(item, attribute);
		return (value ? [value] : []); //Array
	},

	getAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getAttributes()
		return [this._keyAttribute, this._valueAttribute, item[this._keyAttribute]];
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(item, attribute);
		return (attribute == this._keyAttribute || attribute == this._valueAttribute || attribute == item[this._keyAttribute]);
	},

	containsValue: function(/* item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		//	summary:
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item,
								/* attribute || attribute-name-string */ attribute,
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary:
		//		Internal function for looking at the values contained by the item.
		//	description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		var values = this.getValues(item, attribute);
		for(var i = 0; i < values.length; ++i){
			var possibleValue = values[i];
			if(typeof possibleValue === "string" && regexp){
				return (possibleValue.match(regexp) !== null);
			}else{
				//Non-string matching.
				if(value === possibleValue){
					return true; // Boolean
				}
			}
		}
		return false; // Boolean
	},

	isItem: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeProp] === this){
			return true; //Boolean
		}
		return false; //Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItemLoaded()
		//		The KeyValueStore always loads all items, so if it's an item, then it's loaded.
		return this.isItem(something); //Boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Read.loadItem()
		//	description:
		//		The KeyValueStore always loads all items, so if it's an item, then it's loaded.
		//		From the dojo.data.api.Read.loadItem docs:
		//			If a call to isItemLoaded() returns true before loadItem() is even called,
		//			then loadItem() need not do any work at all and will not even invoke
		//			the callback handlers.
	},

	getFeatures: function(){
		//	summary:
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		//	summary:
		//		See dojo.data.api.Read.close()
	},

	getLabel: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabel()
		return item[this._keyAttribute];
	},

	getLabelAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabelAttributes()
		return [this._keyAttribute];
	},
	
	// The dojo.data.api.Read.fetch() function is implemented as
	// a mixin from dojo.data.util.simpleFetch.
	// That mixin requires us to define _fetchItems().
	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		//	summary:
		//		See dojo.data.util.simpleFetch.fetch()
		
		var self = this;

		var filter = function(requestArgs, arrayOfAllItems){
			var items = null;
			if(requestArgs.query){
				items = [];
				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(var key in requestArgs.query){
					var value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}
				}

				for(var i = 0; i < arrayOfAllItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfAllItems[i];
					for(var key in requestArgs.query){
						var value = requestArgs.query[key];
						if(!self._containsValue(candidateItem, key, value, regexpList[key])){
							match = false;
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
			}else if(requestArgs.identity){
				items = [];
				var item;
				for(var key in arrayOfAllItems){
					item = arrayOfAllItems[key];
					if(item[self._keyAttribute] == requestArgs.identity){
						items.push(item);
						break;
					}
				}
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array.  We shouldn't allow resort
				// of the internal list so that multiple callers can get lists and sort without affecting each other.
				if(arrayOfAllItems.length> 0){
					items = arrayOfAllItems.slice(0,arrayOfAllItems.length);
				}
			}
			findCallback(items, requestArgs);
		};

		if(this._loadFinished){
			filter(keywordArgs, this._arrayOfAllItems);
		}else{
			if(this.url !== ""){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self.url,
							handleAs: "json-comment-filtered",
							preventCache: this.urlPreventCache
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						self._processData(data);
						filter(keywordArgs, self._arrayOfAllItems);
						self._handleQueuedFetches();
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						throw error;
					});
				}
			}else if(this._keyValueString){
				this._processData(eval(this._keyValueString));
				this._keyValueString = null;
				filter(keywordArgs, this._arrayOfAllItems);
			}else if(this._keyValueVar){
				this._processData(this._keyValueVar);
				this._keyValueVar = null;
				filter(keywordArgs, this._arrayOfAllItems);
			}else{
				throw new Error("dojox.data.KeyValueStore: No source data was provided as either URL, String, or Javascript variable data input.");
			}
		}
		
	},

	_handleQueuedFetches: function(){
		//	summary:
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedFilter = fData.filter;
				var delayedQuery = fData.args;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._arrayOfAllItems);
				}else{
					this.fetchItemByIdentity(fData.args);
				}
			}
			this._queuedFetches = [];
		}
	},
	
	_processData: function(/* Array */ data){
		this._arrayOfAllItems = [];
		for(var i=0; i<data.length; i++){
			this._arrayOfAllItems.push(this._createItem(data[i]));
		}
		this._loadFinished = true;
		this._loadInProgress = false;
	},
	
	_createItem: function(/* Object */ something){
		var item = {};
		item[this._storeProp] = this;
		for(var i in something){
			item[this._keyAttribute] = i;
			item[this._valueAttribute] = something[i];
			break;
		}
		return item; //Object
	},

/***************************************
     dojo.data.api.Identity API
***************************************/
	getIdentity: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentity()
		if(this.isItem(item)){
			return item[this._keyAttribute]; //String
		}
		return null; //null
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentifierAttributes()
		return [this._keyAttribute];
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Identity.fetchItemByIdentity()
		keywordArgs.oldOnItem = keywordArgs.onItem;
		keywordArgs.onItem = null;
		keywordArgs.onComplete = this._finishFetchItemByIdentity ;
		this.fetch(keywordArgs);
	},
	
	_finishFetchItemByIdentity: function(/* Array */ items, /* object */ request){
		var scope = request.scope || dojo.global;
		if(items.length){
			request.oldOnItem.call(scope, items[0]);
		}else{
			request.oldOnItem.call(scope, null);
		}
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojox.data.KeyValueStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource['bfree.widget.admin.server.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.admin.server.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 12/10/11
 * Time: 10:55 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.admin.server.Administration');



















dojo.declare('bfree.widget.admin.server.Administration', [dijit._Widget, dijit._Templated], {

    templateString: dojo.cache("bfree/widget/admin/server", "template/Administration.html", "<div style=\"width: 100%; height: 100%;\">\n    <table>\n        <tr>\n            <td dojoAttachPoint=\"lblServerExists\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Server Exists:\n            </td>\n            <td>\n                <span dojoAttachPoint=\"lblServerExistsSpan\" class=\"dijitLabel dijitDarkLabel\">\n                    NO!\n                </span>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblServerName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Server Name:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtServerName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblProtocol\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Protocol:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboProtocolSelect\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblHost\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Host:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtHost\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblPort\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Port:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtPort\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblActive\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Active:\n            </td>\n            <td>\n                <span dojoAttachPoint=\"spanActive\" class=\"dijitLabel dijitDarkLabel\">\n                    No\n                </span>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblCurrent\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Current:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"chkCurrent\"/>\n            </td>\n        </tr>\n    </table>\n</div>\n"),
    widgetsInTemplate: true,

    widgetType: "server",

    servers: null,

    activeServer: null,
    activeServerExists: false,

    constructor: function(args){
        this.servers=args.servers;
        this.onItemChange=args.onItemChange;
        this.onSelect=args.onSelect;
        this._grdServers=args.grid;
    },

    onItemChange: function(){

    },

    _setActiveItemAttr: function(server){
        if(this.activeServer!=null&&!this.activeServerExists&&!(this.activeServer===server)){
            alert('The current server cannot be found, correct before editing another');
            this._grdServers.selection.select(this.activeServer);
            return;
        }
        this.activeServer=server;
        this._populateServer();
        this.onSelect(this.activeServer!=null);

        if(this.activeServer!=null&&this.servers.isDirty({item: this.activeServer})){
            this._editServerValues();
        }else{
            this._disableServerValues();
        }
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._txtServerName = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			invalidMessage: 'You must provide a \'Server Name\' value',
			promptMessage: 'The server\'s name',
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtServerName_onChange)
		}, this.txtServerName);

        this.protocolStore=new dojox.data.KeyValueStore({
            dataVar:[
                {https:"https"},
                {http: "http"}
            ]
        });

        this._cboProtocolSelect = new dijit.form.FilteringSelect({
            value: "http",
            store: this.protocolStore,
            searchAttr: "protocol",
            disabled: true,
            validator: dojo.hitch(this, this._existsValidator),
            onChange: dojo.hitch(this, this._cboProtocolSelect_onChange)
        }, this.cboProtocolSelect);

        this._txtHost = new dijit.form.ValidationTextBox({
			invalidMessage: 'You must provide a server host value',
			promptMessage: 'The server\'s host name',
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
            validator: dojo.hitch(this, this._existsValidator),
            onChange: dojo.hitch(this, this._txtHost_onChange)
		}, this.txtHost);

        this._txtPort = new dijit.form.ValidationTextBox({
			invalidMessage: 'You must provide a valid port number',
			promptMessage: 'The server\'s port number',
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
            validator: dojo.hitch(this, this._existsValidator),
            onChange: dojo.hitch(this, this._txtPort_onChange)
		}, this.txtPort);

        this._chkCurrent = new dijit.form.CheckBox({
            name: "checkBox",
            value: "1",
            checked: false,
            onChange: dojo.hitch(this, this._chkCurrent_onChange)
        }, this.chkCurrent);

        this.domNode.style.display='none';

    },

    _existsValidator: function(){
        return this.activeServerExists;
    },

//    _hostValidator: function(value, constraints){
//
//
//        return bfree.api.Server.validateHost(this.activeServer);
//    },

//    _portValidator: function(value, constraints){
//        return bfree.api.Server.validatePort(value);
//    },

    _txtServerName_onChange: function(newValue){
        if(this.activeServer!=null&&newValue!=this.activeServer.name){
            this.servers.setValue(this.activeServer, "name", newValue);
        }
    },

    _setValid: function(){
        this.activeServerExists=true;
        this._validate();
    },

    _validate: function(){
        if(this.activeServerExists){
            this.lblServerExistsSpan.innerHTML='Yes';
        }else{
            this.lblServerExistsSpan.innerHTML='NO!';
        }

//        console.log(this.activeServerExists);

        this._cboProtocolSelect.validate();
        this._txtPort.validate();
        this._txtHost.validate();
    },

    _validateServerExists: function(){
        if(!this.activeServer){
            return;
        }
        this.activeServerExists=false;
        this._validate();
        try{
            dojo.io.script.get({
                url: dojo.replace('{0}://{1}{2}/zones/exists.json', [this.activeServer.protocol, this.activeServer.host, this.activeServer.port?(':'+this.activeServer.port):('')]),
                callbackParamName: "exists",
                load: function(data){
                    this.admin._setValid();
                },
                error: function(error){

                },
                timeout: 10000,
                admin: this
            });
        }catch(e){

        }

    },

    _cboProtocolSelect_onChange: function(newValue){
        if(this.activeServer!=null&&newValue!=this.activeServer.protocol){
            this.servers.setValue(this.activeServer, "protocol", newValue);
            this._validateServerExists();
        }
    },

    _txtHost_onChange: function(newValue){
        if(this.activeServer!=null&&newValue!=this.activeServer.host){
            this.servers.setValue(this.activeServer, "host", newValue);
            this._validateServerExists();
        }
    },

    _txtPort_onChange: function(newValue){
        if(this.activeServer!=null&&newValue!=this.activeServer.port&&(!(newValue==""&&this.activeServer.port==null))){
            this.servers.setValue(this.activeServer, "port", newValue);
            this._validateServerExists();
        }
    },

    _chkCurrent_onChange: function(newValue){
        if(this.activeServer!=null&&newValue!=(this.activeServer.current==1)){
            var current = this.servers.query({query:{}});
            for(var c in current){
                if(current[c].current){
                    this.servers.setValue(current[c], "current", false);
                }
            }

            this.servers.setValue(this.activeServer, "current", newValue);
        }
    },

    _editServerValues: function(){
        this._txtServerName.set('disabled', false);
        this._cboProtocolSelect.set('disabled', false);
        this._txtHost.set('disabled', false);
        this._txtPort.set('disabled', false);
        this._txtPort.validate();
        this._chkCurrent.set('disabled', false);
    },

    _disableServerValues: function(){
        this._txtServerName.set('disabled', true);
        this._cboProtocolSelect.set('disabled', true);
        this._txtHost.set('disabled', true);
        this._txtPort.set('disabled', true);
        this._chkCurrent.set('disabled', true);
    },

    _populateServer: function(){
        if(this.activeServer==null){
            this._txtServerName.set('value', '');
            this._cboProtocolSelect.set('searchAttr', 'https');
            this._txtHost.set('value', '');
            this._txtPort.set('value', '');
            this.spanActive.innerHTML='No';
            this._chkCurrent.set('checked', false);
        }else{
            this._txtServerName.set('value', this.activeServer.name?this.activeServer.name:'');
            this._cboProtocolSelect.set('searchAttr', this.activeServer.protocol?this.activeServer.protocol:'');
            this._txtHost.set('value', this.activeServer.host?this.activeServer.host:'');
            this._txtPort.set('value', this.activeServer.port?this.activeServer.port:'');
            this.spanActive.innerHTML=this.activeServer.active?'Yes':'No';
            this._chkCurrent.set('checked', this.activeServer.current);
        }
        this._validateServerExists();
    },

    _validateItems: function(){
        var valid = true;

        for(var idx = 0; idx < this._grdServers.rowCount; idx++){
            var item = this._grdServers.getItem(idx);
            if(this.servers.isDirty({item: item})){
                valid &= item.isValid();
            }
        }

        return valid;
    },

    save: function(){
        if(!this._validateItems()||!this.activeServerExists){
            var msg = 'Cannot save Server changes: One or more Servers contain invalid data';
            alert(msg);
            return false;
        }

        this.servers.save();
        this.onItemChange(false);
        this._disableServerValues();
        this._grdServers.selection.select(null);

        return true;
    },

    edit: function(){
        this.servers.setDirty({item: this.activeServer});
        this.onItemChange(true);
        this._editServerValues();
        this._txtServerName.focus();
        this._validateServerExists();
    },

    createItem: function(){
        this.activeServer=this.servers.create();
        this.servers.setValue(this.activeServer, "active", 0);
        this.servers.setValue(this.activeServer, "protocol", "http");
        this.servers.setValue(this.activeServer, "current", false);
        this._grdServers.selection.select(this.activeServer);
        this.onItemChange(true);
        this._editServerValues();
    },

    revert: function(){
        this.servers.revert();
        this._grdServers.update();
        this._grdServers.sort();
        this.onItemChange(false);
        this._populateServer();
        this._disableServerValues();
    },

    remove: function(){
        this.servers.destroy({no_save: true,item: this.activeServer});
        this._grdServers.selection.select(null);
        this.onItemChange(true);
    },

    startup: function(){
        this.inherited('startup', arguments)
    },

    isDirty: function(){
        for(var idx = 0; idx < this._grdServers.rowCount; idx++){
            var item = this._grdServers.getItem(idx);
            if(this.servers.isDirty({item: item})){
                return true;
            }
        }
        return false;
    }
});

}

if(!dojo._hasResource['bfree.api.Regions']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Regions'] = true;
dojo.provide('bfree.api.Regions');

bfree.api.Regions.provinces=[
{AB: "Alberta"},
{BC: "British Columbia"},
{MB: "Manitoba"},
{NB: "New Brunswick"},
{NF: "Newfoundland"},
{NT: "Northwest Territories"},
{NS: "Nova Scotia"},
{NU: "Nunavut"},
{ON: "Ontario"},
{PE: "Prince Edward Island"},
{QC: "Quebec"},
{YT: "Yukon"}]

bfree.api.Regions.states=[
{AL: 'Alabama'},
{AK: 'Alaska'},
{AZ: 'Arizona'},
{AR: 'Arkansas'},
{CA: 'California'},
{CO: 'Colorado'},
{CT: 'Connecticut'},
{DE: 'Delaware'},
{DC: 'District of Columbia'},
{FL: 'Florida'},
{GA: 'Georgia'},
{HI: 'Hawaii'},
{ID: 'Idaho'},
{IL: 'Illinois'},
{IN: 'Indiana'},
{IA: 'Iowa'},
{KS: 'Kansas'},
{KY: 'Kentucky'},
{LA: 'Louisiana'},
{ME: 'Maine'},
{MD: 'Maryland'},
{MA: 'Massachusetts'},
{MI: 'Michigan'},
{MN: 'Minnesota'},
{MO: 'Missouri'},
{MT: 'Montana'},
{NE: 'Nebraska'},
{NV: 'Nevada'},
{NH: 'New Hampshire'},
{NJ: 'New Jersey'},
{NM: 'New Mexico'},
{NY: 'New York'},
{NC: 'North Carolina'},
{ND: 'North Dakota'},
{OH: 'Ohio'},
{OK: 'Oklahoma'},
{OR: 'Oregon'},
{PA: 'Pennsylvania'},
{RI: 'Rhode Island'},
{SC: 'South Carolina'},
{SD: 'South Dakota'},
{TN: 'Tennessee'},
{TX: 'Texas'},
{UT: 'Utah'},
{VT: 'Vermont'},
{VA: 'Virginia'},
{WA: 'Washington'},
{WV: 'West Virginia'},
{WI: 'Wisconsin'},
{WY: 'Wyoming'}];

bfree.api.Regions.countries=[
{CA: "Canada"},
{US: "United States"},
{AL: "Albania"},
{DZ: "Algeria"},
{AD: "Andorra"},
{AO: "Angola"},
{AI: "Anguilla"},
{AG: "Antigua and Barbuda"},
{AR: "Argentina"},
{AM: "Armenia"},
{AW: "Aruba"},
{AU: "Australia"},
{AT: "Austria"},
{AZ: "Azerbaijan Republic"},
{BS: "Bahamas"},
{BH: "Bahrain"},
{BB: "Barbados"},
{BE: "Belgium"},
{BZ: "Belize"},
{BJ: "Benin"},
{BM: "Bermuda"},
{BT: "Bhutan"},
{BO: "Bolivia"},
{BA: "Bosnia and Herzegovina"},
{BW: "Botswana"},
{BR: "Brazil"},
{VG: "British Virgin Islands"},
{BN: "Brunei"},
{BG: "Bulgaria"},
{BF: "Burkina Faso"},
{BI: "Burundi"},
{KH: "Cambodia"},
{CV: "Cape Verde"},
{KY: "Cayman Islands"},
{TD: "Chad"},
{CL: "Chile"},
{C2: "China Worldwide"},
{CO: "Colombia"},
{KM: "Comoros"},
{CK: "Cook Islands"},
{CR: "Costa Rica"},
{HR: "Croatia"},
{CY: "Cyprus"},
{CZ: "Czech Republic"},
{CD: "Democratic Republic of the Congo"},
{DK: "Denmark"},
{DJ: "Djibouti"},
{DM: "Dominica"},
{DO: "Dominican Republic"},
{EC: "Ecuador"},
{SV: "El Salvador"},
{ER: "Eritrea"},
{EE: "Estonia"},
{ET: "Ethiopia"},
{FK: "Falkland Islands"},
{FO: "Faroe Islands"},
{FM: "Federated States of Micronesia"},
{FJ: "Fiji"},
{FI: "Finland"},
{FR: "France"},
{GF: "French Guiana"},
{PF: "French Polynesia"},
{GA: "Gabon Republic"},
{GM: "Gambia"},
{DE: "Germany"},
{GI: "Gibraltar"},
{GR: "Greece"},
{GL: "Greenland"},
{GD: "Grenada"},
{GP: "Guadeloupe"},
{GT: "Guatemala"},
{GN: "Guinea"},
{GW: "Guinea Bissau"},
{GY: "Guyana"},
{HN: "Honduras"},
{HK: "Hong Kong"},
{HU: "Hungary"},
{IS: "Iceland"},
{IN: "India"},
{ID: "Indonesia"},
{IE: "Ireland"},
{IL: "Israel"},
{IT: "Italy"},
{JM: "Jamaica"},
{JP: "Japan"},
{JO: "Jordan"},
{KZ: "Kazakhstan"},
{KE: "Kenya"},
{KI: "Kiribati"},
{KW: "Kuwait"},
{KG: "Kyrgyzstan"},
{LA: "Laos"},
{LV: "Latvia"},
{LS: "Lesotho"},
{LI: "Liechtenstein"},
{LT: "Lithuania"},
{LU: "Luxembourg"},
{MG: "Madagascar"},
{MW: "Malawi"},
{MY: "Malaysia"},
{MV: "Maldives"},
{ML: "Mali"},
{MT: "Malta"},
{MH: "Marshall Islands"},
{MQ: "Martinique"},
{MR: "Mauritania"},
{MU: "Mauritius"},
{YT: "Mayotte"},
{MX: "Mexico"},
{MN: "Mongolia"},
{MS: "Montserrat"},
{MA: "Morocco"},
{MZ: "Mozambique"},
{NA: "Namibia"},
{NR: "Nauru"},
{NP: "Nepal"},
{NL: "Netherlands"},
{AN: "Netherlands Antilles"},
{NC: "New Caledonia"},
{NZ: "New Zealand"},
{NI: "Nicaragua"},
{NE: "Niger"},
{NU: "Niue"},
{NF: "Norfolk Island"},
{NO: "Norway"},
{OM: "Oman"},
{PW: "Palau"},
{PA: "Panama"},
{PG: "Papua New Guinea"},
{PE: "Peru"},
{PH: "Philippines"},
{PN: "Pitcairn Islands"},
{PL: "Poland"},
{PT: "Portugal"},
{QA: "Qatar"},
{CG: "Republic of the Congo"},
{RE: "Reunion"},
{RO: "Romania"},
{RU: "Russia"},
{RW: "Rwanda"},
{VC: "Saint Vincent and the Grenadines"},
{WS: "Samoa"},
{SM: "San Marino"},
{ST: "São Tomé and Príncipe"},
{SA: "Saudi Arabia"},
{SN: "Senegal"},
{SC: "Seychelles"},
{SL: "Sierra Leone"},
{SG: "Singapore"},
{SK: "Slovakia"},
{SI: "Slovenia"},
{SB: "Solomon Islands"},
{SO: "Somalia"},
{ZA: "South Africa"},
{KR: "South Korea"},
{ES: "Spain"},
{LK: "Sri Lanka"},
{SH: "St. Helena"},
{KN: "St. Kitts and Nevis"},
{LC: "St. Lucia"},
{PM: "St. Pierre and Miquelon"},
{SR: "Suriname"},
{SJ: "Svalbard and Jan Mayen Islands"},
{SZ: "Swaziland"},
{SE: "Sweden"},
{CH: "Switzerland"},
{TW: "Taiwan"},
{TJ: "Tajikistan"},
{TZ: "Tanzania"},
{TH: "Thailand"},
{TG: "Togo"},
{TO: "Tonga"},
{TT: "Trinidad and Tobago"},
{TN: "Tunisia"},
{TR: "Turkey"},
{TM: "Turkmenistan"},
{TC: "Turks and Caicos Islands"},
{TV: "Tuvalu"},
{UG: "Uganda"},
{UA: "Ukraine"},
{AE: "United Arab Emirates"},
{GB: "United Kingdom"},
{UY: "Uruguay"},
{VU: "Vanuatu"},
{VA: "Vatican City State"},
{VE: "Venezuela"},
{VN: "Vietnam"},
{WF: "Wallis and Futuna Islands"},
{YE: "Yemen"},
{ZM: "Zambia"}];

}

if(!dojo._hasResource['bfree.widget.ValidationTextBox']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.ValidationTextBox'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/09/11
 * Time: 3:49 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.ValidationTextBox');


dojo.declare('bfree.widget.ValidationTextBox', [dijit.form.ValidationTextBox],
{
    scrollOnFocus: false,

    blur: function(){
        this._hasBeenBlurred = true;
    },

    constructor: function(args){

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);
	},

	setFocus: function(doSelect){
		this.focus();
		if(doSelect)
			this.textbox.select();
	},

    startup: function(){
        this._hasBeenBlurred = true;
        this.inherited('startup', arguments);

        this.validate();
    }



});

}

if(!dojo._hasResource["dojo.cldr.supplemental"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.supplemental"] = true;
dojo.provide("dojo.cldr.supplemental");


dojo.getObject("cldr.supplemental", true, dojo);

dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,
		ly:6,ma:6,om:6,qa:6,sa:6,sd:6,so:6,sy:6,tn:6,ye:6,
		ar:0,as:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,
		il:0,'in':0,jm:0,jp:0,kg:0,kr:0,la:0,mh:0,mn:0,mo:0,mp:0,
		mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,
		vi:0,zw:0
// variant. do not use?		gb:0,
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
};

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		'in':0,
		af:4,dz:4,ir:4,om:4,sa:4,ye:4,
		ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
	};

	var weekendEnd = {/*default is 0=Sunday*/
		af:5,dz:5,ir:5,om:5,sa:5,ye:5,
		ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

}

if(!dojo._hasResource["dojo.date"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date"] = true;
dojo.provide("dojo.date");

dojo.getObject("date", true, dojo);

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
};

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
};

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string,
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
};

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}
	
	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

}

if(!dojo._hasResource["dojo.date.locale"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.locale"] = true;
dojo.provide("dojo.date.locale");







dojo.getObject("date.locale", true, dojo);

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.


// Load the bundles containing localization information for
// names and formats

//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

(function(){
	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.locale._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dojo.date.locale._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						dojo.string.pad(Math.floor(Math.abs(offset)/60), 2),
						dojo.string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = dojo.string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale._getZone = function(/*Date*/dateObject, /*boolean*/getName, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return dojo.date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = dojo.date.locale._getGregorianBundle(locale),
		str = [],
		sauce = dojo.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.date.locale._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, dojo.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	// remove non-printing bidi control chars from input and pattern
	var controlChars = /[\u200E\u200F\u202A\u202E]/g,
		info = dojo.date.locale._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
			info.strict ? "" : "i"),
		match = re.exec(value && value.replace(controlChars, ""));

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99),
							num = (v < cutoff) ? century + v : century - 100 + v;
						result[0] = num;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = dojo.date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings)
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = dojo.regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
				break;
			case 'D':
				s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p3+'[1-9][0-9]|'+p2+'[1-9]';
				break;
			case 'd':
				s = '3[01]|[12]\\d|'+p2+'[1-9]';
				break;
			case 'w':
				s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
				break;
			case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = '1[0-2]|'+p2+'[1-9]';
				break;
			case 'k': //hour (0-11)
				s = '1[01]|'+p2+'\\d';
				break;
			case 'H': //hour (0-23)
				s = '1\\d|2[0-3]|'+p2+'\\d';
				break;
			case 'K': //hour (1-24)
				s = '1\\d|2[0-4]|'+p2+'[1-9]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				s = am + '|' + pm;
				if(!options.strict){
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}
})();

(function(){
var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = dojo.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};
})();

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'narrow' || 'abbr' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = dojo.date.locale._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = dojo.cldr.supplemental.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return dojo.date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

}

if(!dojo._hasResource["dijit.form.DropDownButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DropDownButton"] = true;
dojo.provide("dijit.form.DropDownButton");




}

if(!dojo._hasResource["dijit.Calendar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Calendar"] = true;
dojo.provide("dijit.Calendar");









dojo.declare(
	"dijit.Calendar",
	[dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
		// summary:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//
		// description:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//		This widget can't be used in a form because it doesn't serialize the date to an
		//		`<input>` field.  For a form element, use dijit.form.DateTextBox instead.
		//
		//		Note that the parser takes all dates attributes passed in the
		//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
		//		so that they are serializable and locale-independent.
		//
		// example:
		//	|	var calendar = new dijit.Calendar({}, dojo.byId("calendarNode"));
		//
		// example:
		//	|	<div dojoType="dijit.Calendar"></div>

		templateString: dojo.cache("dijit", "templates/Calendar.html", "<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" dojoAttachEvent=\"onkeypress: _onKeyPress\" aria-labelledby=\"${id}_year\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th class='dijitReset dijitCalendarArrow' dojoAttachPoint=\"decrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"/>\n\t\t\t\t<span dojoAttachPoint=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' colspan=\"5\">\n\t\t\t\t<div dojoType=\"dijit.form.DropDownButton\" dojoAttachPoint=\"monthDropDownButton\"\n\t\t\t\t\tid=\"${id}_mddb\" tabIndex=\"-1\">\n\t\t\t\t</div>\n\t\t\t</th>\n\t\t\t<th class='dijitReset dijitCalendarArrow' dojoAttachPoint=\"incrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"/>\n\t\t\t\t<span dojoAttachPoint=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class=\"dijitReset dijitCalendarDayLabelTemplate\" role=\"columnheader\"><span class=\"dijitCalendarDayLabel\"></span></th>\n\t\t</tr>\n\t</thead>\n\t<tbody dojoAttachEvent=\"onclick: _onDayClick, onmouseover: _onDayMouseOver, onmouseout: _onDayMouseOut, onmousedown: _onDayMouseDown, onmouseup: _onDayMouseUp\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t<tr class=\"dijitReset dijitCalendarWeekTemplate\" role=\"row\">\n\t\t\t<td class=\"dijitReset dijitCalendarDateTemplate\" role=\"gridcell\"><span class=\"dijitCalendarDateLabel\"></span></td>\n\t\t</tr>\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\">\n\t\t\t\t<h3 class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span dojoAttachPoint=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" id=\"${id}_year\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\"></span>\n\t\t\t\t</h3>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n"),
		widgetsInTemplate: true,

		// value: Date
		//		The currently selected Date, initially set to invalid date to indicate no selection.
		value: new Date(""),
		// TODO: for 2.0 make this a string (ISO format) rather than a Date

		// datePackage: String
		//		JavaScript namespace to find Calendar routines.  Uses Gregorian Calendar routines
		//		at dojo.date by default.
		datePackage: "dojo.date",

		// dayWidth: String
		//		How to represent the days of the week in the calendar header. See dojo.date.locale
		dayWidth: "narrow",

		// tabIndex: Integer
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		
		// currentFocus: Date
		//		Date object containing the currently focused date, or the date which would be focused
		//		if the calendar itself was focused.   Also indicates which year and month to display,
		//		i.e. the current "page" the calendar is on.
		currentFocus: new Date(),

		baseClass:"dijitCalendar",

		// Set node classes for various mouse events, see dijit._CssStateMixin for more details
		cssStateNodes: {
			"decrementMonth": "dijitCalendarArrow",
			"incrementMonth": "dijitCalendarArrow",
			"previousYearLabelNode": "dijitCalendarPreviousYear",
			"nextYearLabelNode": "dijitCalendarNextYear"
		},

		_isValidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking that it's a valid date, rather
			//		than blank or NaN.
			// tags:
			//		private
			return value && !isNaN(value) && typeof value == "object" &&
				value.toString() != this.constructor.prototype.value.toString();
		},

		setValue: function(/*Date*/ value){
			// summary:
			//      Deprecated.   Use set('value', ...) instead.
			// tags:
			//      deprecated
			dojo.deprecated("dijit.Calendar:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_getValueAttr: function(){
			// summary:
			//		Support get('value')

			// this.value is set to 1AM, but return midnight, local time for back-compat
			var value = new this.dateClassObj(this.value);
			value.setHours(0, 0, 0, 0);

			// If daylight savings pushes midnight to the previous date, fix the Date
			// object to point at 1am so it will represent the correct day. See #9366
			if(value.getDate() < this.value.getDate()){
				value = this.dateFuncObj.add(value, "hour", 1);
			}
			return value;
		},

		_setValueAttr: function(/*Date|Number*/ value, /*Boolean*/ priorityChange){
			// summary:
			//		Support set("value", ...)
			// description:
			// 		Set the current date and update the UI.  If the date is disabled, the value will
			//		not change, but the display will change to the corresponding month.
			// value:
			//		Either a Date or the number of seconds since 1970.
			// tags:
			//      protected
			if(value){
				// convert from Number to Date, or make copy of Date object so that setHours() call below
				// doesn't affect original value
				value = new this.dateClassObj(value);
			}
			if(this._isValidDate(value)){
				if(!this._isValidDate(this.value) || this.dateFuncObj.compare(value, this.value)){
					value.setHours(1, 0, 0, 0); // round to nearest day (1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
	
					if(!this.isDisabledDate(value, this.lang)){
						this._set("value", value);
		
						// Set focus cell to the new value.   Arguably this should only happen when there isn't a current
						// focus point.   This will also repopulate the grid, showing the new selected value (and possibly
						// new month/year).
						this.set("currentFocus", value);
	
						if(priorityChange || typeof priorityChange == "undefined"){
							this.onChange(this.get('value'));
							this.onValueSelected(this.get('value'));	// remove in 2.0
						}
					}
				}
			}else{
				// clear value, and repopulate grid (to deselect the previously selected day) without changing currentFocus
				this._set("value", null);
				this.set("currentFocus", this.currentFocus);
			}
		},

		_setText: function(node, text){
			// summary:
			//		This just sets the content of node to the specified text.
			//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
			// tags:
			//      private
			while(node.firstChild){
				node.removeChild(node.firstChild);
			}
			node.appendChild(dojo.doc.createTextNode(text));
		},

		_populateGrid: function(){
			// summary:
			//      Fills in the calendar grid with each day (1-31)
			// tags:
			//      private

			var month = new this.dateClassObj(this.currentFocus);
			month.setDate(1);

			var firstDay = month.getDay(),
				daysInMonth = this.dateFuncObj.getDaysInMonth(month),
				daysInPreviousMonth = this.dateFuncObj.getDaysInMonth(this.dateFuncObj.add(month, "month", -1)),
				today = new this.dateClassObj(),
				dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			if(dayOffset > firstDay){ dayOffset -= 7; }

			// Iterate through dates in the calendar and fill in date numbers and style info
			dojo.query(".dijitCalendarDateTemplate", this.domNode).forEach(function(template, i){
				i += dayOffset;
				var date = new this.dateClassObj(month),
					number, clazz = "dijitCalendar", adj = 0;

				if(i < firstDay){
					number = daysInPreviousMonth - firstDay + i + 1;
					adj = -1;
					clazz += "Previous";
				}else if(i >= (firstDay + daysInMonth)){
					number = i - firstDay - daysInMonth + 1;
					adj = 1;
					clazz += "Next";
				}else{
					number = i - firstDay + 1;
					clazz += "Current";
				}

				if(adj){
					date = this.dateFuncObj.add(date, "month", adj);
				}
				date.setDate(number);

				if(!this.dateFuncObj.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
				}

				if(this._isSelectedDate(date, this.lang)){
					clazz = "dijitCalendarSelectedDate " + clazz;
				}

				if(this.isDisabledDate(date, this.lang)){
					clazz = "dijitCalendarDisabledDate " + clazz;
				}

				var clazz2 = this.getClassForDate(date, this.lang);
				if(clazz2){
					clazz = clazz2 + " " + clazz;
				}

				template.className = clazz + "Month dijitCalendarDateTemplate";
				template.dijitDateValue = date.valueOf();				// original code
				dojo.attr(template, "dijitDateValue", date.valueOf());	// so I can dojo.query() it
				var label = dojo.query(".dijitCalendarDateLabel", template)[0],
					text = date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate();
				this._setText(label, text);
			}, this);

			// Repopulate month drop down list based on current year.
			// Need to do this to hide leap months in Hebrew calendar.
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month);
			this.monthDropDownButton.dropDown.set("months", monthNames);

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.monthDropDownButton.containerNode.innerHTML =
				(dojo.isIE == 6 ? "" : "<div class='dijitSpacer'>" + this.monthDropDownButton.dropDown.domNode.innerHTML + "</div>") +
				"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" +  monthNames[month.getMonth()] + "</div>";

			// Fill in localized prev/current/next years
			var y = month.getFullYear() - 1;
			var d = new this.dateClassObj();
			dojo.forEach(["previous", "current", "next"], function(name){
				d.setFullYear(y++);
				this._setText(this[name+"YearLabelNode"],
					this.dateLocaleModule.format(d, {selector:'year', locale:this.lang}));
			}, this);
		},

		goToToday: function(){
			// summary:
			//      Sets calendar's value to today's date
			this.set('value', new this.dateClassObj());
		},

		constructor: function(/*Object*/args){
			var dateClass = (args.datePackage && (args.datePackage != "dojo.date"))? args.datePackage + ".Date" : "Date";
			this.dateClassObj = dojo.getObject(dateClass, false);
			this.datePackage = args.datePackage || this.datePackage;
			this.dateFuncObj = dojo.getObject(this.datePackage, false);
			this.dateLocaleModule = dojo.getObject(this.datePackage + ".locale", false);
		},

		postMixInProperties: function(){
			// Parser.instantiate sometimes passes in NaN for IE.  Use default value in prototype instead.
			// TODO: remove this for 2.0 (thanks to #11511)
			if(isNaN(this.value)){ delete this.value; }

			this.inherited(arguments);
		},

		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);

			var cloneClass = dojo.hitch(this, function(clazz, n){
				var template = dojo.query(clazz, this.domNode)[0];
	 			for(var i=0; i<n; i++){
					template.parentNode.appendChild(template.cloneNode(true));
				}
			});

			// clone the day label and calendar day templates 6 times to make 7 columns
			cloneClass(".dijitCalendarDayLabelTemplate", 6);
			cloneClass(".dijitCalendarDateTemplate", 6);

			// now make 6 week rows
			cloneClass(".dijitCalendarWeekTemplate", 5);

			// insert localized day names in the header
			var dayNames = this.dateLocaleModule.getNames('days', this.dayWidth, 'standAlone', this.lang);
			var dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			dojo.query(".dijitCalendarDayLabel", this.domNode).forEach(function(label, i){
				this._setText(label, dayNames[(i + dayOffset) % 7]);
			}, this);

			var dateObj = new this.dateClassObj(this.currentFocus);

			this.monthDropDownButton.dropDown = new dijit.Calendar._MonthDropDown({
				id: this.id + "_mdd",
				onChange: dojo.hitch(this, "_onMonthSelect")
			});

			this.set('currentFocus', dateObj, false);	// draw the grid to the month specified by currentFocus

			// Set up repeating mouse behavior for increment/decrement of months/years
			var _this = this;
			var typematic = function(nodeProp, dateProp, adj){
				_this._connects.push(
					dijit.typematic.addMouseListener(_this[nodeProp], _this, function(count){
						if(count >= 0){ _this._adjustDisplay(dateProp, adj); }
					}, 0.8, 500)
				);
			};
			typematic("incrementMonth", "month", 1);
			typematic("decrementMonth", "month", -1);
			typematic("nextYearLabelNode", "year", 1);
			typematic("previousYearLabelNode", "year", -1);
		},

		_adjustDisplay: function(/*String*/ part, /*int*/ amount){
			// summary:
			//      Moves calendar forwards or backwards by months or years
			// part:
			//      "month" or "year"
			// amount:
			//      Number of months or years
			// tags:
			//      private
			this._setCurrentFocusAttr(this.dateFuncObj.add(this.currentFocus, part, amount));
		},

		_setCurrentFocusAttr: function(/*Date*/ date, /*Boolean*/ forceFocus){
			// summary:
			//		If the calendar currently has focus, then focuses specified date,
			//		changing the currently displayed month/year if necessary.
			//		If the calendar doesn't have focus, updates currently
			//		displayed month/year, and sets the cell that will get focus.
			// forceFocus:
			//		If true, will focus() the cell even if calendar itself doesn't have focus

			var oldFocus = this.currentFocus,
				oldCell = oldFocus ? dojo.query("[dijitDateValue=" + oldFocus.valueOf() + "]", this.domNode)[0] : null;

			// round specified value to nearest day (1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
			date = new this.dateClassObj(date);
			date.setHours(1, 0, 0, 0);

			this._set("currentFocus", date);

			// TODO: only re-populate grid when month/year has changed
			this._populateGrid();

			// set tabIndex=0 on new cell, and focus it (but only if Calendar itself is focused)
			var newCell = dojo.query("[dijitDateValue=" + date.valueOf() + "]", this.domNode)[0];
			newCell.setAttribute("tabIndex", this.tabIndex);
			if(this._focused || forceFocus){
				newCell.focus();
			}

			// set tabIndex=-1 on old focusable cell
			if(oldCell && oldCell != newCell){
				if(dojo.isWebKit){	// see #11064 about webkit bug
					oldCell.setAttribute("tabIndex", "-1");
				}else{
						oldCell.removeAttribute("tabIndex");
				}
			}
		},

		focus: function(){
			// summary:
			//		Focus the calendar by focusing one of the calendar cells
			this._setCurrentFocusAttr(this.currentFocus, true);
		},

		_onMonthSelect: function(/*Number*/ newMonth){
			// summary:
			//      Handler for when user selects a month from the drop down list
			// tags:
			//      protected

			// move to selected month, bounding by the number of days in the month
			// (ex: dec 31 --> jan 28, not jan 31)
			this.currentFocus = this.dateFuncObj.add(this.currentFocus, "month",
				newMonth - this.currentFocus.getMonth());
			this._populateGrid();
		},

		_onDayClick: function(/*Event*/ evt){
			// summary:
			//      Handler for day clicks, selects the date if appropriate
			// tags:
			//      protected
			dojo.stopEvent(evt);
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode);
			if(node && !dojo.hasClass(node, "dijitCalendarDisabledDate")){
				this.set('value', node.dijitDateValue);
			}
		},

		_onDayMouseOver: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse over events on days, sets hovered style
			// tags:
			//      protected

			// event can occur on <td> or the <span> inside the td,
			// set node to the <td>.
			var node =
				dojo.hasClass(evt.target, "dijitCalendarDateLabel") ?
				evt.target.parentNode :
				evt.target;

			if(node && (node.dijitDateValue || node == this.previousYearLabelNode || node == this.nextYearLabelNode) ){
				dojo.addClass(node, "dijitCalendarHoveredDate");
				this._currentNode = node;
			}
		},

		_onDayMouseOut: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse out events on days, clears hovered style
			// tags:
			//      protected
	
			if(!this._currentNode){ return; }
			
			// if mouse out occurs moving from <td> to <span> inside <td>, ignore it
			if(evt.relatedTarget && evt.relatedTarget.parentNode == this._currentNode){ return; }
			var cls = "dijitCalendarHoveredDate";
			if(dojo.hasClass(this._currentNode, "dijitCalendarActiveDate")) {
				cls += " dijitCalendarActiveDate";
			}
			dojo.removeClass(this._currentNode, cls);
			this._currentNode = null;
		},
		
		_onDayMouseDown: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue){
				dojo.addClass(node, "dijitCalendarActiveDate");
				this._currentNode = node;
			}
		},
		
		_onDayMouseUp: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue){
				dojo.removeClass(node, "dijitCalendarActiveDate");
			}
		},

//TODO: use typematic
		handleKey: function(/*Event*/ evt){
			// summary:
			//		Provides keyboard navigation of calendar.
			// description:
			//		Called from _onKeyPress() to handle keypress on a stand alone Calendar,
			//		and also from `dijit.form._DateTimeTextBox` to pass a keypress event
			//		from the `dijit.form.DateTextBox` to be handled in this widget
			// returns:
			//		False if the key was recognized as a navigation key,
			//		to indicate that the event was handled by Calendar and shouldn't be propogated
			// tags:
			//		protected
			var dk = dojo.keys,
				increment = -1,
				interval,
				newValue = this.currentFocus;
			switch(evt.keyCode){
				case dk.RIGHT_ARROW:
					increment = 1;
					//fallthrough...
				case dk.LEFT_ARROW:
					interval = "day";
					if(!this.isLeftToRight()){ increment *= -1; }
					break;
				case dk.DOWN_ARROW:
					increment = 1;
					//fallthrough...
				case dk.UP_ARROW:
					interval = "week";
					break;
				case dk.PAGE_DOWN:
					increment = 1;
					//fallthrough...
				case dk.PAGE_UP:
					interval = evt.ctrlKey || evt.altKey ? "year" : "month";
					break;
				case dk.END:
					// go to the next month
					newValue = this.dateFuncObj.add(newValue, "month", 1);
					// subtract a day from the result when we're done
					interval = "day";
					//fallthrough...
				case dk.HOME:
					newValue = new this.dateClassObj(newValue);
					newValue.setDate(1);
					break;
				case dk.ENTER:
				case dk.SPACE:
					this.set("value", this.currentFocus);
					break;
				default:
					return true;
			}

			if(interval){
				newValue = this.dateFuncObj.add(newValue, interval, increment);
			}

			this._setCurrentFocusAttr(newValue);

			return false;
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		For handling keypress events on a stand alone calendar
			if(!this.handleKey(evt)){
				dojo.stopEvent(evt);
			}
		},

		onValueSelected: function(/*Date*/ date){
			// summary:
			//		Notification that a date cell was selected.  It may be the same as the previous value.
			// description:
			//      Formerly used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
			//      to get notification when the user has clicked a date.  Now onExecute() (above) is used.
			// tags:
			//      protected
		},

		onChange: function(/*Date*/ date){
			// summary:
			//		Called only when the selected date has changed
		},

		_isSelectedDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		Extension point so developers can subclass Calendar to
			//		support multiple (concurrently) selected dates
			// tags:
			//		protected extension
			return this._isValidDate(this.value) && !this.dateFuncObj.compare(dateObject, this.value, "date")
		},

		isDisabledDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// tags:
			//      extension
/*=====
			return false; // Boolean
=====*/
		},

		getClassForDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// tags:
			//      extension

/*=====
			return ""; // String
=====*/
		}
	}
);

dojo.declare("dijit.Calendar._MonthDropDown", [dijit._Widget, dijit._Templated], {
	// summary:
	//		The month drop down

	// months: String[]
	//		List of names of months, possibly w/some undefined entries for Hebrew leap months
	//		(ex: ["January", "February", undefined, "April", ...])
	months: [],

	templateString: "<div class='dijitCalendarMonthMenu dijitMenu' " +
		"dojoAttachEvent='onclick:_onClick,onmouseover:_onMenuHover,onmouseout:_onMenuHover'></div>",

	_setMonthsAttr: function(/*String[]*/ months){
		this.domNode.innerHTML = dojo.map(months, function(month, idx){
				return month ? "<div class='dijitCalendarMonthLabel' month='" + idx +"'>" + month + "</div>" : "";
			}).join("");
	},

	_onClick: function(/*Event*/ evt){
		this.onChange(dojo.attr(evt.target, "month"));
	},

	onChange: function(/*Number*/ month){
		// summary:
		//		Callback when month is selected from drop down
	},

	_onMenuHover: function(evt){
		dojo.toggleClass(evt.target, "dijitCalendarMonthLabelHover", evt.type == "mouseover");
	}
});

}

if(!dojo._hasResource["dijit.form._DateTimeTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._DateTimeTextBox"] = true;
dojo.provide("dijit.form._DateTimeTextBox");







new Date("X"); // workaround for #11279, new Date("") == NaN

/*=====
dojo.declare(
	"dijit.form._DateTimeTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.date.locale.__FormatOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (first/last date/time allowed),
	//		and also formatting options for how the date/time is displayed.
	// example:
	//		To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
	//	|		{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}
});
=====*/

dojo.declare(
	"dijit.form._DateTimeTextBox",
	[ dijit.form.RangeBoundTextBox, dijit._HasDropDown ],
	{
		// summary:
		//		Base class for validating, serializable, range-bound date or time text box.

		templateString: dojo.cache("dijit.form", "templates/DropDownBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"\n\t/></div\n></div>\n"),

		// hasDownArrow: [const] Boolean
		//		Set this textbox to display a down arrow button, to open the drop down list.
		hasDownArrow: true,

		// openOnClick: [const] Boolean
		//		Set to true to open drop down upon clicking anywhere on the textbox.
		openOnClick: true,

		/*=====
		// constraints: dijit.form._DateTimeTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including starting/ending dates/times allowed) as well as
		//		formatting options like whether the date is displayed in long (ex: December 25, 2005)
		//		or short (ex: 12/25/2005) format.  See `dijit.form._DateTimeTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: dojo.date.locale.regexp,

		// datePackage: String
		//		JavaScript namespace to find calendar routines.	 Uses Gregorian calendar routines
		//		at dojo.date, by default.
		datePackage: "dojo.date",

		// Override _FormWidget.compare() to work for dates/times
		compare: function(/*Date*/ val1, /*Date*/ val2){
			var isInvalid1 = this._isInvalidDate(val1);
			var isInvalid2 = this._isInvalidDate(val2);
			return isInvalid1 ? (isInvalid2 ? 0 : -1) : (isInvalid2 ? 1 : dojo.date.compare(val1, val2, this._selector));
		},

		// flag to _HasDropDown to make drop down Calendar width == <input> width
		forceWidth: true,

		format: function(/*Date*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Date, according to specified locale (second argument)
			// tags:
			//		protected
			if(!value){ return ''; }
			return this.dateLocaleModule.format(value, constraints);
		},

		"parse": function(/*String*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Parses as string as a Date, according to constraints
			// tags:
			//		protected

			return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);	 // Date
		},

		// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
		serialize: function(/*anything*/ val, /*Object?*/ options){
			if(val.toGregorian){
				val = val.toGregorian();
			}
			return dojo.date.stamp.toISOString(val, options);
		},

		// dropDownDefaultValue: Date
		//		The default value to focus in the popupClass widget when the textbox value is empty.
		dropDownDefaultValue : new Date(),

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
		//		When passed to the parser in markup, must be specified according to `dojo.date.stamp.fromISOString`
		value: new Date(""),	// value.toString()="NaN"

		_blankValue: null,	// used by filter() when the textbox is blank

		// popupClass: [protected extension] String
		//		Name of the popup widget class used to select a date/time.
		//		Subclasses should specify this.
		popupClass: "", // default is no popup = text only


		// _selector: [protected extension] String
		//		Specifies constraints.selector passed to dojo.date functions, should be either
		//		"date" or "time".
		//		Subclass must specify this.
		_selector: "",

		constructor: function(/*Object*/ args){
			var dateClass = args.datePackage ? args.datePackage + ".Date" : "Date";
			this.dateClassObj = dojo.getObject(dateClass, false);
			this.value = new this.dateClassObj("");

			this.datePackage = args.datePackage || this.datePackage;
			this.dateLocaleModule = dojo.getObject(this.datePackage + ".locale", false);
			this.regExpGen = this.dateLocaleModule.regexp;
			this._invalidDate = dijit.form._DateTimeTextBox.prototype.value.toString();
		},

		buildRendering: function(){
			this.inherited(arguments);

			if(!this.hasDownArrow){
				this._buttonNode.style.display = "none";
			}

			// If openOnClick is true, we basically just want to treat the whole widget as the
			// button.  We need to do that also if the actual drop down button will be hidden,
			// so that there's a mouse method for opening the drop down.
			if(this.openOnClick || !this.hasDownArrow){
				this._buttonNode = this.domNode;
				this.baseClass += " dijitComboBoxOpenOnClick";
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			constraints.selector = this._selector;
			constraints.fullYear = true; // see #5465 - always format with 4-digit years
			var fromISO = dojo.date.stamp.fromISOString;
			if(typeof constraints.min == "string"){ constraints.min = fromISO(constraints.min); }
 			if(typeof constraints.max == "string"){ constraints.max = fromISO(constraints.max); }
			this.inherited(arguments);
		},

		_isInvalidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking for invalid conditions
			// tags:
			//		private
			return !value || isNaN(value) || typeof value != "object" || value.toString() == this._invalidDate;
		},

		_setValueAttr: function(/*Date|String*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Sets the date on this textbox. Note: value can be a JavaScript Date literal or a string to be parsed.
			if(value !== undefined){
				if(typeof value == "string"){
					value = dojo.date.stamp.fromISOString(value);
				}
				if(this._isInvalidDate(value)){
					value = null;
				}
				if(value instanceof Date && !(this.dateClassObj instanceof Date)){
					value = new this.dateClassObj(value);
				}
			}
			this.inherited(arguments);
			if(this.dropDown){
				this.dropDown.set('value', value, false);
			}
		},

		_set: function(attr, value){
			// Avoid spurious watch() notifications when value is changed to new Date object w/the same value
			if(attr == "value" && this.value instanceof Date && this.compare(value, this.value) == 0){
				return;
			}
			this.inherited(arguments);
		},

		_setDropDownDefaultValueAttr: function(/*Date*/ val){
			if(this._isInvalidDate(val)){
				// convert null setting into today's date, since there needs to be *some* default at all times.
				 val = new this.dateClassObj()
						}
			this.dropDownDefaultValue = val;
		},

		openDropDown: function(/*Function*/ callback){
			// rebuild drop down every time, so that constraints get copied (#6002)
			if(this.dropDown){
				this.dropDown.destroy();
			}
			var PopupProto = dojo.getObject(this.popupClass, false),
				textBox = this,
				value = this.get("value");
			this.dropDown = new PopupProto({
				onChange: function(value){
						// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
						dijit.form._DateTimeTextBox.superclass._setValueAttr.call(textBox, value, true);
					},
					id: this.id + "_popup",
					dir: textBox.dir,
					lang: textBox.lang,
				value: value,
				currentFocus: !this._isInvalidDate(value) ? value : this.dropDownDefaultValue,
					constraints: textBox.constraints,
				filterString: textBox.filterString, // for TimeTextBox, to filter times shown

					datePackage: textBox.datePackage,

					isDisabledDate: function(/*Date*/ date){
						// summary:
						// 	disables dates outside of the min/max of the _DateTimeTextBox
						return !textBox.rangeCheck(date, textBox.constraints);
					}
				});

			this.inherited(arguments);
		},

		_getDisplayedValueAttr: function(){
			return this.textbox.value;
		},

		_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.DateTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DateTextBox"] = true;
dojo.provide("dijit.form.DateTextBox");




dojo.declare(
	"dijit.form.DateTextBox",
	dijit.form._DateTimeTextBox,
	{
		// summary:
		//		A validating, serializable, range-bound date text box with a drop down calendar
		//
		//		Example:
		// |	new dijit.form.DateTextBox({value: new Date(2009, 0, 20)})
		//
		//		Example:
		// |	<input dojotype='dijit.form.DateTextBox' value='2009-01-20'>

		baseClass: "dijitTextBox dijitComboBox dijitDateTextBox",
		popupClass: "dijit.Calendar",
		_selector: "date",

		// value: Date
		//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
		//		If specified in markup, use the format specified in `dojo.date.stamp.fromISOString`.
		//		set("value", ...) accepts either a Date object or a string.
		value: new Date("")	// value.toString()="NaN"
	}
);

}

if(!dojo._hasResource['bfree.widget.admin.account.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.admin.account.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 12/10/11
 * Time: 10:55 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.admin.account.Administration');






















dojo.declare('bfree.widget.admin.account.Administration', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("bfree/widget/admin/account", "template/Administration.html", "<div style=\"width: 100%; height: 100%;\">\n    <table>\n        <tr>\n            <td dojoAttachPoint=\"lblCompanyName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Company Name:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtCompanyName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblFirstName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                First Name:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtFirstName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblLastName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Last Name:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtLastName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblEmail\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Email:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtEmail\"/>\n            </td>\n        </tr><tr dojoAttachPoint=\"trResetPass\">\n            <td dojoAttachPoint=\"lblResetPass\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Password:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtResetPass\"/>\n                <div dojoAttachPoint=\"btnResetPass\"></div>\n            </td>\n        </tr><tr dojoAttachPoint=\"trGeneratePass\" style=\"display: none;\">\n            <td dojoAttachPoint=\"lblGeneratePass\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Password:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtGeneratePass\"/>\n                <div dojoAttachPoint=\"btnGeneratePass\"></div>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblAddress\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Address:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtAddress\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblCity\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                City:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtCity\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblCountry\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Country:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboCountry\"/>\n            </td>\n        </tr><tr dojoAttachPoint=\"trProvince\">\n            <td dojoAttachPoint=\"lblProvince\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Province:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboProvince\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblPostal\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Postal Code:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtPostal\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblPhone\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Phone Number:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtPhone\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblBillingType\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Billing Type:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboBillingType\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblAccountType\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Account Type:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboAccountType\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblStartDate\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Trial Period:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cmbTrialPeriod\"/>\n            </td>\n        </tr>\n    </table>\n</div>\n"),
    widgetsInTemplate: true,

    _grdAccounts: null,

    accounts: null,
    widgetType: "account",
    servers: null,
    activeAccount: null,

    periodStore: null,

    _cmbTrialPeriod_onChange: function(newValue){
        if(this.activeAccount != null && newValue != this.activeAccount.trial_period){
            this.accounts.setValue(this.activeAccount, "trial_period", newValue);
        }
    },

     _setActiveItemAttr: function(account){
        this.activeAccount=account;
        this._populateAccount();
        this.onSelect(this.activeAccount!=null);

        if(this.activeAccount!=null&&this.accounts.isDirty({item: this.activeAccount})){
            this._editAccountValues();
        }else{
            this._disableAccountValues();
        }
    },

    constructor: function(args){
        this.accounts = args.accounts;
        this.onItemChange = args.onItemChange;
        this.onSelect=args.onSelect;
        this._grdAccounts=args.grid;
    },

    onItemChange: function(){

    },

    onSelect: function(){

    },



    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._txtCompanyName = new bfree.widget.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'Company Name',
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtCompanyName_onChange)
		}, this.txtCompanyName);

        this._txtFirstName = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'Account Holder\'s first name',
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtFirstName_onChange)
		}, this.txtFirstName);

        this._txtLastName = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'Account Holder\'s last name',
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtLastName_onChange)
		}, this.txtLastName);

        this._txtEmail = new bfree.widget.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'Account Holder\'s email address (login name)',
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtEmail_onChange)
		}, this.txtEmail);

        this._txtAddress = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			promptMessage: 'Account Holder\'s address',
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtAddress_onChange)
		}, this.txtAddress);

        this._txtCity = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtCity_onChange)
		}, this.txtCity);

        this.provinceStore = new dojox.data.KeyValueStore({
            dataVar: bfree.api.Regions.provinces
        });

        this.stateStore = new dojox.data.KeyValueStore({
            dataVar: bfree.api.Regions.states
        });

        this.countryStore = new dojox.data.KeyValueStore({
            dataVar: bfree.api.Regions.countries
        });


        //SEE: bfree.api.Account.BillingTypes
        this.billingStore = new dojox.data.KeyValueStore({
            dataVar: [
                { 0 : 'Monthly' },
                { 1 : 'Yearly' }
            ]
        });

        //SEE: bfree.api.Account.AccountTypes
        this.accountStore = new dojox.data.KeyValueStore({
            dataVar: [
                { 0 : 'Free Trial' },
                { 1 : 'Paying' }
            ]
        });

        this.periodStore = new dojox.data.KeyValueStore({
            dataVar: [
                { 0 : 'Never Expires' },
                { 30 : '30 Days' },
                { 90 : '90 Days' },
                { 365 : '1 Year' }
            ]
        })

        this._cboCountry = new dijit.form.FilteringSelect({
            store: this.countryStore,
            searchAttr: "country",
            disabled: true,
            onChange: dojo.hitch(this, this._cboCountry_onChange)
        }, this.cboCountry);

        this._cboProvince = new dijit.form.FilteringSelect({
            store: this.provinceStore,
            searchAttr: "province",
            disabled: true,
            onChange: dojo.hitch(this, this._cboProvince_onChange)
        }, this.cboProvince);

        this._txtPostal = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtPostal_onChange)
		}, this.txtPostal);

        this._txtPhone = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			required: false,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtPhone_onChange)
		}, this.txtPhone);

        this._cboBillingType = new dijit.form.FilteringSelect({
            store: this.billingStore,
            searchAttr: "billing",
            disabled: true,
            onChange: dojo.hitch(this, this._cboBillingType_onChange)
        }, this.cboBillingType);

        this._cboAccountType = new dijit.form.FilteringSelect({
            store: this.accountStore,
            searchAttr: "account",
            disabled: true,
            onChange: dojo.hitch(this, this._cboAccountType_onChange)
        }, this.cboAccountType);

        this._cmbTrialPeriod = new dijit.form.FilteringSelect({
			store: this.periodStore,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._cmbTrialPeriod_onChange)
		}, this.cmbTrialPeriod);

        this._txtGeneratePass = new dijit.form.ValidationTextBox({
            intermediateChanges: true,
			invalidMessage: '',
			promptMessage: 'Enter or generate a new password for the user',
			require: true,
			trim: false,
            disabled: true,
            style: "width:190px",
			onChange: dojo.hitch(this, this._txtGeneratePass_onChange)
		}, this.txtGeneratePass);

        this._txtResetPass = new dijit.form.ValidationTextBox({
            intermediateChanges: true,
			invalidMessage: '',
			promptMessage: 'Enter or generate a new password for the user',
			require: true,
			trim: false,
            disabled: true,
            style: "width:190px",
			onChange: dojo.hitch(this, this._txtResetPass_onChange)
		}, this.txtResetPass);

        this._btnGeneratePass = new dijit.form.Button({
			iconClass: 'imageIcon bfreeIconLock',
			label: 'Generate Random Password',
			showLabel: false,
            disabled: true,
            onClick: dojo.hitch(this, this._btnGeneratePass_onClick)
		}, this.btnGeneratePass);

        this._btnResetPass = new dijit.form.Button({
			iconClass: 'imageIcon bfreeIconUnlock',
			label: 'Reset Password',
			showLabel: false,
            disabled: true,
            onClick: dojo.hitch(this, this._btnResetPass_onClick)
		}, this.btnResetPass);

        this.domNode.style.display='none';
    },

    _txtCompanyName_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.name){
            this.accounts.setValue(this.activeAccount, "name", newValue);
        }
    },

    _txtFirstName_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.first_name){
            this.accounts.setValue(this.activeAccount, "first_name", newValue);
        }
    },

    _txtLastName_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.last_name){
            this.accounts.setValue(this.activeAccount, "last_name", newValue);
        }
    },

    _txtEmail_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.email){
            this.accounts.setValue(this.activeAccount, "email", newValue);
        }
    },

    _txtGeneratePass_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.password){
            this.accounts.setValue(this.activeAccount, "password", newValue);
        }
    },

    _txtResetPass_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.resetPassword){
            this.accounts.setValue(this.activeAccount, "resetPassword", newValue);
        }
    },

    _txtAddress_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.address){
            this.accounts.setValue(this.activeAccount, "address", newValue);
        }
    },

    _txtCity_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.city){
            this.accounts.setValue(this.activeAccount, "city", newValue);
        }
    },

    _cboCountry_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.country){
            if(newValue=='CA'){
                dojo.style(this.trProvince, {display: ""});
                this._cboProvince.set('store', this.provinceStore);
            }else if(newValue=='US'){
                dojo.style(this.trProvince, {display: ""});
                this._cboProvince.set('store', this.stateStore);
            }else{
                dojo.style(this.trProvince, {display: "none"});
                this.accounts.setValue(this.activeAccount, 'province', null);
            }
            this.accounts.setValue(this.activeAccount, "country", newValue);
        }
    },

    _cboProvince_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.province){
            this.accounts.setValue(this.activeAccount, "province", newValue);
        }
    },

    _txtPostal_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.postal_code){
            this.accounts.setValue(this.activeAccount, "postal_code", newValue);
        }
    },

    _txtPhone_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.phone){
            this.accounts.setValue(this.activeAccount, "phone", newValue);
        }
    },

    _cboBillingType_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.billing_type){
            this.accounts.setValue(this.activeAccount, "billing_type", newValue);
        }
    },

    _cboAccountType_onChange: function(newValue){
        if(this.activeAccount!=null&&newValue!=this.activeAccount.account_type){
            this.accounts.setValue(this.activeAccount, "account_type", newValue);
        }
    },

    _btnResetPass_onClick: function(evt){
        if(confirm("Are you sure you want to reset "+(this.activeAccount.name+"'s password?"))){
            var newPass = bfree.api.Accounts.generatePassword({length: 8 });
            this.accounts.setValue(this.activeAccount, 'resetPassword', newPass);
            this._txtResetPass.set('disabled', false);
            dojo.toggleClass(this.lblResetPass, 'bfreeDarkDisabled', false);
            this._txtResetPass.set('value', newPass);
            this._txtResetPass.focus();
        }
    },

    _btnGeneratePass_onClick: function(evt){
        var newPass = bfree.api.Accounts.generatePassword({length: 8 });
        this.accounts.setValue(this.activeAccount, 'password', newPass);
        this._txtGeneratePass.set('value', newPass);
        this._txtGeneratePass.focus();
    },

    _editAccountValues: function(){
        this._txtCompanyName.set('disabled', false);
        this._txtFirstName.set('disabled', false);
        this._txtLastName.set('disabled', false);

        this._txtEmail.set('disabled', false);
        this._txtAddress.set('disabled', false);
        this._txtCity.set('disabled', false);
        this._cboCountry.set('disabled', false);
        this._cboProvince.set('disabled', false);
        this._txtPostal.set('disabled', false);
        this._txtPhone.set('disabled', false);
        this._cboBillingType.set('disabled', false);
        this._cboAccountType.set('disabled', false);
        this._cmbTrialPeriod.set('disabled', false);

        if(this.activeAccount.id!=null){
            dojo.style(this.trGeneratePass, {display: "none"});
            dojo.style(this.trResetPass, {display: ""});
            this._btnResetPass.set('disabled', false);
            this._btnGeneratePass.set('disabled', true);
            this._txtGeneratePass.set('disabled', true);
        }else{
            dojo.style(this.trGeneratePass, {display: ""});
            dojo.style(this.trResetPass, {display: "none"});
            this._txtResetPass.set('disabled', true);
            this._btnResetPass.set('disabled', true);
            this._txtGeneratePass.set('disabled', false);
            this._btnGeneratePass.set('disabled', false);
        }
    },

    _disableAccountValues: function(){
        this._txtCompanyName.set('disabled', true);
        this._txtFirstName.set('disabled', true);
        this._txtLastName.set('disabled', true);
        this._txtEmail.set('disabled', true);
        this._txtAddress.set('disabled', true);
        this._txtCity.set('disabled', true);
        this._cboCountry.set('disabled', true);
        this._cboProvince.set('disabled', true);
        this._txtPostal.set('disabled', true);
        this._txtPhone.set('disabled', true);
        this._cboBillingType.set('disabled', true);
        this._cboAccountType.set('disabled', true);
        this._cmbTrialPeriod.set('disabled', true);
        this._txtResetPass.set('disabled', true);
        this._btnResetPass.set('disabled', true);
        this._txtGeneratePass.set('disabled', true);
        this._btnGeneratePass.set('disabled', true);
    },

    _populateAccount: function(){

        if(this.activeAccount == null){
            this._txtCompanyName.set('value', '');
            this._txtFirstName.set('value', '');
            this._txtLastName.set('value', '');
            this._txtEmail.set('value', '');
            this._txtGeneratePass.set('value', '');
            this._txtResetPass.set('value', '');
            this._txtAddress.set('value', '');
            this._txtCity.set('value', '');
            this._cboCountry.set('value', '');
            this._cboProvince.set('value', '');
            this._txtPostal.set('value', '');
            this._txtPhone.set('value', '');
            this._cboBillingType.set('value', '');
            this._cboAccountType.set('value', '');
            this._cmbTrialPeriod.set('value', '');

        }else{
            this._txtCompanyName.set('value', this.activeAccount.name ? this.activeAccount.name : '');
            this._txtFirstName.set('value', this.activeAccount.first_name?this.activeAccount.first_name:'');
            this._txtLastName.set('value', this.activeAccount.last_name?this.activeAccount.last_name:'');
            this._txtEmail.set('value', this.activeAccount.email?this.activeAccount.email:'');
            this._txtGeneratePass.set('value', this.activeAccount.password?this.activeAccount.password:'');
            this._txtResetPass.set('value', this.activeAccount.resetPassword?this.activeAccount.resetPassword:'');
            this._txtAddress.set('value', this.activeAccount.address?this.activeAccount.address:'');
            this._txtCity.set('value', this.activeAccount.city?this.activeAccount.city:'');
            this._cboCountry.set('value', this.activeAccount.country?this.activeAccount.country:'');
            this._cboProvince.set('value', this.activeAccount.province?this.activeAccount.province:'');
            this._txtPostal.set('value', this.activeAccount.postal_code ? this.activeAccount.postal_code : '');
            this._txtPhone.set('value', this.activeAccount.phone?this.activeAccount.phone:'');
            this._cboBillingType.set('value', this.activeAccount.billing_type);
            this._cboAccountType.set('value', this.activeAccount.account_type);
            this._cmbTrialPeriod.set('value', this.activeAccount.trial_period);

        }
    },

    _validateItems: function(){
        var valid = true;

        for(var idx = 0; idx < this._grdAccounts.rowCount; idx++){
            var item = this._grdAccounts.getItem(idx);
            if(this.accounts.isDirty({item: item})){
                valid &= item.isValid();
            }
        }

        return valid;
    },

    save: function(){
        if(!this._validateItems()){
            var msg = 'Cannot save Account changes: One or more Accounts contain invalid data';
            alert(msg);
            return false;
        }

        this.accounts.save();
        this.onItemChange(false);
        this._grdAccounts.selection.select(null);

        return true;
    },

    edit: function(){
        this.accounts.setDirty({item: this.activeAccount});
        this.onItemChange(true);
        this._editAccountValues();
        this._txtCompanyName.focus();
    },

    createItem: function(){

        this.activeAccount = this.accounts.create();

        this.accounts.setValue(this.activeAccount, "password", bfree.api.Accounts.generatePassword({length: 8 }));
        this.accounts.setValue(this.activeAccount, "status", 0);
        this.accounts.setValue(this.activeAccount, "billing_type", 0);
        this.accounts.setValue(this.activeAccount, "account_type", 0);

        this._grdAccounts.selection.select(this.activeAccount);

        this.onItemChange(true);

        this._editAccountValues();
    },

    revert: function(){
        this.accounts.revert();
        this._grdAccounts.update();
        this._grdAccounts.sort();
        this.onItemChange(false);
        this._populateAccount();
        this._disableAccountValues();
    },

    remove: function(){
        this.accounts.destroy({no_save: true, item: this.activeAccount});
        this._grdAccounts.selection.select(null);
        this.onItemChange(true);
    },

    startup: function(){
        this.inherited('startup', arguments)

        this._txtCompanyName.startup();
        this._txtEmail.startup();
    },

    isDirty: function(){
        for(var idx = 0; idx < this._grdAccounts.rowCount; idx++){
            var item = this._grdAccounts.getItem(idx);
            if(this.accounts.isDirty({item: item})){
                return true;
            }
        }
        return false;
    }
});

}

if(!dojo._hasResource['bfree.widget.admin.zone.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.admin.zone.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 12/10/11
 * Time: 10:55 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.admin.zone.Administration');


















dojo.declare('bfree.widget.admin.zone.Administration', [dijit._Widget, dijit._Templated], {

    templateString: dojo.cache("bfree/widget/admin/zone", "template/Administration.html", "<div style=\"width: 100%; height: 100%;\">\n    <table>\n        <tr>\n            <td dojoAttachPoint=\"lblZoneName\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Zone Name:\n            </td>\n            <td style=\"width: 300px\">\n                <input dojoAttachPoint=\"txtZoneName\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblSubdomain\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Subdomain:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtSubdomain\"/>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblFingerprint\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Fingerprint:\n            </td>\n            <td>\n                <span dojoAttachPoint=\"txtFingerprint\" class=\"dijitLabel dijitDarkLabel\"></span>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblCurrentUsers\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Current Users:\n            </td>\n            <td>\n                <span dojoAttachPoint=\"txtCurrentUsers\" class=\"dijitLabel dijitDarkLabel\">0</span>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblMaxUsers\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Max Users:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"txtMaxUsers\">\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblCurrentQuota\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Current Disk Quota:\n            </td>\n            <td>\n                <span dojoAttachPoint=\"txtCurrentQuota\" class=\"dijitLabel dijitDarkLabel\">0 bytes</span>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblMaxQuota\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Max Disk Quota:\n            </td>\n            <td style=\"white-space: nowrap;\">\n                <input dojoAttachPoint=\"txtMaxQuota\"><span class=\"dijitLabel dijitDarkLabel\"> GB</span>\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblAccount\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Account:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboAccount\">\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblServer\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Server:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboServer\">\n            </td>\n        </tr><tr>\n            <td dojoAttachPoint=\"lblStatus\" class=\"dijitLabel dijitDarkLabel\" style=\"padding-right:8px;text-align:right;white-space:nowrap;\">\n                Status:\n            </td>\n            <td>\n                <input dojoAttachPoint=\"cboStatus\">\n            </td>\n        </tr><tr>\n            <td colspan=\"2\" style=\"text-align: right;\">\n                <div dojoAttachPoint=\"btnUpdate\">\n                    <div style=\"width:40px\">Update</div>\n                </div>\n                <div dojoAttachPoint=\"btnDeploy\">\n                    <div style=\"width:40px\">Deploy</div>\n                </div>\n            </td>\n        </tr>\n    </table>\n</div>\n"),
    widgetsInTemplate: true,

    widgetType: "zone",

    zones: null,
    servers: null,
    accounts: null,

    activeZone: null,

    constructor: function(args){
        this.zones=args.zones;
        this.servers=args.servers;
        this.accounts=args.accounts;
        this.onItemChange=args.onItemChange;
        this.onSelect=args.onSelect;
        this._grdZones=args.grid;
    },

    onItemChange: function(){

    },

    _setActiveItemAttr: function(zone){
        this.activeZone=zone;
        this._populateZone();
        this.onSelect(this.activeZone!=null);

        if(this.activeZone!=null&&this.zones.isDirty({item: this.activeZone})){
            this._editZoneValues();
        }else{
            this._disableZoneValues();
        }
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._txtZoneName = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			invalidMessage: 'You must provide a \'Zone Name\' value',
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtZoneName_onChange)
		}, this.txtZoneName);

        this._txtSubdomain = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtSubdomain_onChange)
		}, this.txtSubdomain);

        this._txtMaxUsers = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtMaxUsers_onChange)
		}, this.txtMaxUsers);

        this._txtMaxQuota = new dijit.form.ValidationTextBox({
			intermediateChanges: true,
			required: true,
			trim: true,
			disabled: true,
            style: "width:100%",
			onChange: dojo.hitch(this, this._txtMaxQuota_onChange)
		}, this.txtMaxQuota);

        this.statusStore=new dojox.data.KeyValueStore({
            dataVar: [
                {0:'Disabled'},
                {1:'Enabled'}
            ]
        });

        this._cboAccount = new dijit.form.FilteringSelect({
            store: this.accounts.store,
            searchAttr: "name",
            disabled: true,
            onChange: dojo.hitch(this, this._cboAccount_onChange),
            style: "width: 300px;"
        }, this.cboAccount);

        this._cboServer = new dijit.form.FilteringSelect({
            store: this.servers.store,
            searchAttr: "name",
            disabled: true,
            onChange: dojo.hitch(this, this._cboServer_onChange),
            style: "width: 300px;"
        }, this.cboServer);

        this._cboStatus = new dijit.form.FilteringSelect({
            store: this.statusStore,
            searchAttr: "name",
            disabled: true,
            onChange: dojo.hitch(this, this._cboStatus_onChange),
            style: "width: 300px;"
        }, this.cboStatus);

        this._btnUpdate = new dijit.form.Button({
			iconClass: 'buttonIcon bfreeIconLock',
			label: 'Update',
			disabled: true,
            onClick: dojo.hitch(this, this._btnUpdate_onClick)
		}, this.btnUpdate);

        this._btnDeploy = new dijit.form.Button({
			iconClass: 'buttonIcon bfreeIconLock',
			label: 'Deploy',
			disabled: true,
            onClick: dojo.hitch(this, this._btnDeploy_onClick)
		}, this.btnDeploy);

        this.updateServer();

        this.domNode.style.display='none';
    },

    updateServer: function(){
        var servers=this.servers.fetch();

        for(s in servers){
            if(servers[s].current){
                this.activeServer=servers[s];
            }
        }
    },

    _txtZoneName_onChange: function(newValue){
        if(this.activeZone!=null&&newValue!=this.activeZone.name){
            this.zones.setValue(this.activeZone, "name", newValue);
        }
    },

    _txtSubdomain_onChange: function(newValue){
        if(this.activeZone!=null&&newValue!=this.activeZone.subdomain){
            this.zones.setValue(this.activeZone, "subdomain", newValue);
        }
    },

    _txtMaxUsers_onChange: function(newValue){
        if(this.activeZone!=null&&newValue!=this.activeZone.max_users){
            this.zones.setValue(this.activeZone, "max_users", newValue);
        }
    },

    _txtMaxQuota_onChange: function(newValue){
        if(this.activeZone!=null&&(1024*1024*1024)*newValue!=this.activeZone.max_disk_space){
            //convert GB entry into B
            this.zones.setValue(this.activeZone, "max_disk_space", newValue*(1024*1024*1024));
        }
    },

    _cboAccount_onChange: function(newValue){
        if(this.activeZone!=null&&newValue!=this.activeZone.account_id){
            this.zones.setValue(this.activeZone, "account_id", newValue);
        }
    },

    _cboServer_onChange: function(newValue){
        if(this.activeZone!=null&&newValue!=this.activeZone.server_id){
            this.zones.setValue(this.activeZone, "server_id", newValue);
        }
    },

    _cboStatus_onChange: function(newValue){
        if(this.activeZone!=null&&newValue!=this.activeZone.status){
            this.zones.setValue(this.activeZone, "status", newValue);
        }
    },

    _btnUpdate_onClick: function(){
        this.activeZone=this.zones.updateUsage(this.activeZone);
        this._populateZone();
    },

    _btnDeploy_onClick: function(){
        this.activeZone=this.zones.deploy(this.activeZone);
        this._populateZone();
    },

    _editZoneValues: function(){
        this._txtZoneName.set('disabled', false);
        this._txtSubdomain.set('disabled', false);
        this._txtMaxUsers.set('disabled', false);
        this._txtMaxQuota.set('disabled', false);
        this._cboStatus.set('disabled', false);

        if(this.activeZone.deployed){
            this._cboAccount.set('disabled', true);
            this._cboServer.set('disabled', true);
        }else{
            this._cboAccount.set('disabled', false);
            this._cboServer.set('disabled', false);
        }
    },

    _disableZoneValues: function(){
        this._txtZoneName.set('disabled', true);
        this._txtSubdomain.set('disabled', true);
        this._txtMaxUsers.set('disabled', true);
        this._txtMaxQuota.set('disabled', true);
        this._cboAccount.set('disabled', true);
        this._cboServer.set('disabled', true);
        this._cboStatus.set('disabled', true);
    },

    _populateZone: function(){
        if(this.activeZone==null){
            this._txtZoneName.set('value', '');
            this._txtSubdomain.set('value', '');
            this.txtFingerprint.innerHTML='';
            this.txtCurrentUsers.innerHTML='0';
            this._txtMaxUsers.set('value', '');
            this.txtCurrentQuota.innerHTML='0 bytes';
            this._txtMaxQuota.set('value', '');
            this._cboAccount.set('value', '');
            this._cboServer.set('value', this.activeServer?this.activeServer.id:'');
            this._cboStatus.set('value', '');

            this._btnUpdate.set('disabled', true);
            this._btnDeploy.set('disabled', true);
        }else{
            this._txtZoneName.set('value', this.activeZone.name?this.activeZone.name:'');
            this._txtSubdomain.set('value', this.activeZone.subdomain?this.activeZone.subdomain:'');
            this.txtFingerprint.innerHTML=this.activeZone.fingerprint?this.activeZone.fingerprint:'';
            this.txtCurrentUsers.innerHTML=this.activeZone.current_users?this.activeZone.current_users:'0';
            this._txtMaxUsers.set('value', this.activeZone.max_users?this.activeZone.max_users:'');

            var currentQuota=bfree.api.Utilities.readablizeBytes({bytes: this.activeZone.current_disk_space?this.activeZone.current_disk_space:0});

            this.txtCurrentQuota.innerHTML=currentQuota;
            this._txtMaxQuota.set('value', this.activeZone.max_disk_space?this.activeZone.max_disk_space/(1024*1024*1024):'');
            this._cboServer.set('value', this.activeZone.server_id?this.activeZone.server_id:this.activeServer.id);
            this._cboAccount.set('value', this.activeZone.account_id?this.activeZone.account_id:'');
            this._cboStatus.set('value', this.activeZone.status);

            if(this.activeZone.deployed){
                this._btnUpdate.set('disabled', false);
                this._btnDeploy.set('disabled', true);
            }else{
                this._btnUpdate.set('disabled', true);
                if(this.zones.isNew({item: this.activeZone})){
                    this._btnDeploy.set('disabled', true);
                }else{
                    this._btnDeploy.set('disabled', false);
                }
            }
        }
    },

    _validateItems: function(){
        var valid = true;

        for(var idx = 0; idx < this._grdZones.rowCount; idx++){
            var item = this._grdZones.getItem(idx);
            if(this.zones.isDirty({item: item})){
                valid &= item.isValid();
            }
        }

        return valid;
    },

    save: function(){
        if(!this._validateItems()){
            var msg = 'Cannot save Zone changes: One or more Zones contain invalid data';
            alert(msg);
            return true;
        }

        this.zones.save();
        this._grdZones.selection.select(null);
        this.onItemChange(false);

        return false;
    },

    edit: function(){
        this.zones.setDirty({item: this.activeZone});
        this.onItemChange(true);
        this._editZoneValues();
        this._txtZoneName.focus();
    },

    createItem: function(){
        this.activeZone=this.zones.create();
        this.zones.setValue(this.activeZone, 'status', 1);
        this.zones.setValue(this.activeZone, 'deployed', 0);
        this.zones.setValue(this.activeZone, 'server_id', this.activeServer.id);
        this._grdZones.selection.select(this.activeZone);
        this.onItemChange(true);
        this._editZoneValues();
    },

    revert: function(){
        this.zones.revert();
        this._grdZones.update();
        this._grdZones.sort();
        this.onItemChange(false);
        this._populateZone();
        this._disableZoneValues();
    },

    remove: function(){
        this.zones.destroy({no_save: true,item: this.activeZone});
        this._grdZones.selection.select(null);
        this.onItemChange(true);
    },

    startup: function(){
        this.inherited('startup', arguments)
    },

    isDirty: function(){
        for(var idx = 0; idx < this._grdZones.rowCount; idx++){
            var item = this._grdZones.getItem(idx);
            if(this.zones.isDirty({item: item})){
                return true;
            }
        }
        return false;
    }
});

}

if(!dojo._hasResource['bfree.widget.admin.Show']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.admin.Show'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 13/09/11
 * Time: 9:32 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.admin.Show');











dojo.declare('bfree.widget.admin.Show', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("bfree.widget.admin", "template/Show.html", "<div style=\"background:#D9D9D6;height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"center\"\n            spitter=\"false\"\n            style=\"padding:8px 8px 0 8px\">\n\n        <div    dojoType=\"dijit.layout.BorderContainer\"\n                design=\"headline\"\n                gutters=\"false\"\n                style=\"height:100%;width:100%\">\n\n            <div    dojoType=\"dijit.layout.BorderContainer\"\n                    design=\"sidebar\"\n                    gutters=\"false\"\n                    region=\"top\"\n                    splitter=\"false\"\n                    class=\"versaTopPane\">\n\n                <div    dojoType=\"dijit.layout.ContentPane\"\n                        region=\"left\"\n                        splitter=\"false\"\n                        class=\"versaHeadPane\">\n                    <img src=\"/images/versafile-64-tm.png\" height=\"56\" style=\"position:relative;top:-8px;left:-8px\"/>\n                </div>\n\n                <div    dojoType=\"dijit.layout.BorderContainer\"\n                        design=\"sidebar\"\n                        gutters=\"false\"\n                        region=\"center\"\n                        class=\"versaBarPane\">\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            region=\"center\"\n                            splitter=\"false\"\n                            style=\"padding:0;overflow:hidden;position:relative;\">\n\n                        <div dojoAttachPoint=\"toolbarNode\"></div>\n\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.BorderContainer\"\n                            design=\"headline\"\n                            gutters=\"false\"\n                            region=\"right\"\n                            splitter=\"false\"\n                            style=\"width:256px;\">\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"center\"\n                                splitter=\"false\"\n                                style=\"position:relative;text-align:right;padding:2px 0 0 0\">\n\n                            <table cellpadding=\"0\" cellspacing=\"0\" style=\"position:absolute;right:0\"><tr>\n                                <td style=\"padding-right:4px; border-right: 1px solid #75787B\">\n                                    <span dojoAttachPoint=\"nameNode\"></span>\n                                </td>\n                                <td style=\"padding-left:4px;\">\n                                    <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: logoff\">Logout</a>\n                                </td>\n                            </tr></table>\n\n                        </div>\n                    </div>\n\n                </div>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.BorderContainer\"\n                    design=\"headline\"\n                    gutters=\"false\"\n                    region=\"center\"\n                    splitter=\"false\"\n                    class=\"versaMainPane\">\n\n                <div    dojoType=\"dijit.layout.BorderContainer\"\n                        design=\"sidebar\"\n                        gutters=\"true\"\n                        region=\"center\"\n                        splitter=\"false\"\n                        class=\"\">\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            region=\"left\"\n                            splitter=\"true\"\n                            class=\"versaInfoPane\"\n                            style=\"padding:0;width:256px;\">\n\n                        <div style=\"height: 100%\">\n                           <div dojoAttachPoint=\"grdGrid\" style=\"height: 100%\"></div>\n                       </div>\n\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            region=\"center\"\n                            splitter=\"true\"\n                            class=\"versaInfoPane\"\n                            style=\"padding:0\">\n                        <div dojoAttachPoint=\"usersPane\">\n\n                        </div>\n                        <div dojoAttachPoint=\"serversPane\" style=\"display: none;\">\n\n                        </div>\n                        <div dojoAttachPoint=\"accountsPane\" style=\"display: none;\">\n\n                        </div>\n                        <div dojoAttachPoint=\"zonesPane\" style=\"display: none;\">\n\n                        </div>\n\n                    </div>\n\n                </div>\n\n            </div>\n\n\n        </div>\n\n    </div>\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _grdShow: null,

    activeWidget: null,

    _wgtUsers: null,
    _wgtServers: null,
    _wgtZones: null,
    _wgtAccounts: null,

    _onCommand: function(cmd, item){
        switch(cmd){
            case bfree.widget.admin.CommandBar.COMMANDS.USERS:
                if(!(this.activeWidget===this._wgtUsers)){
                    if(this.activeWidget.isDirty()){
                        if(confirm("There are unsaved changes, save them?")){
                            if(!this.activeWidget.save()){
                                break;
                            }
                        }else{
                            break;
                        }
                    }
                    this.activeWidget=this._wgtUsers;

                    this._grdShow.setStore(this.users.store, '', {cache: false});
//                    this._grdShow.setQuery('', {cache: false});
                    this._grdShow.set('structure', bfree.widget.admin.Show.userGridLayout);

                    dojo.style(this._wgtUsers.domNode, {display: ""});
                    dojo.style(this._wgtServers.domNode, {display: "none"});
                    dojo.style(this._wgtAccounts.domNode, {display: "none"});
                    dojo.style(this._wgtZones.domNode, {display: "none"});

                    this._grdShow.selection.select(null);
                    this._barCommandBar.changesMade(false);
                }
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.SERVERS:
                if(!(this.activeWidget===this._wgtServers)){
                    if(this.activeWidget.isDirty()){
                        if(confirm("There are unsaved changes, save them?")){
                            if(!this.activeWidget.save()){
                                break;
                            }
                        }else{
                            break;
                        }
                    }
                    this.activeWidget=this._wgtServers;
                    this._grdShow.setStore(this.servers.store, '', {cache: false});
                    this._grdShow.set('structure', bfree.widget.admin.Show.serverGridLayout);

                    dojo.style(this._wgtUsers.domNode, {display: "none"});
                    dojo.style(this._wgtServers.domNode, {display: ""});
                    dojo.style(this._wgtAccounts.domNode, {display: "none"});
                    dojo.style(this._wgtZones.domNode, {display: "none"});

                    this._grdShow.selection.select(null);
                    this._barCommandBar.changesMade(false);
                }
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.ACCOUNTS:
                if(!(this.activeWidget===this._wgtAccounts)){
                    if(this.activeWidget.isDirty()){
                        if(confirm("There are unsaved changes, save them?")){
                            if(!this.activeWidget.save()){
                                break;
                            }
                        }else{
                            break;
                        }
                    }
                    this.activeWidget=this._wgtAccounts;
                    this._grdShow.setStore(this.accounts.store, '', {cache: false});
                    this._grdShow.set('structure', bfree.widget.admin.Show.accountGridLayout);

                    dojo.style(this._wgtUsers.domNode, {display: "none"});
                    dojo.style(this._wgtServers.domNode, {display: "none"});
                    dojo.style(this._wgtAccounts.domNode, {display: ""});
                    dojo.style(this._wgtZones.domNode, {display: "none"});

                    this._grdShow.selection.select(null);
                    this._barCommandBar.changesMade(false);
                }
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.ZONES:
                if(!(this.activeWidget===this._wgtZones)){
                    if(this.activeWidget.isDirty()){
                        if(confirm("There are unsaved changes, save them?")){
                            if(!this.activeWidget.save()){
                                break;
                            }
                        }else{
                            break;
                        }
                    }
                    this.activeWidget=this._wgtZones;
                    this.activeWidget.updateServer();
                    this._grdShow.setStore(this.zones.store, '', {cache: false});
                    this._grdShow.set('structure', bfree.widget.admin.Show.zoneGridLayout);

                    dojo.style(this._wgtUsers.domNode, {display: "none"});
                    dojo.style(this._wgtServers.domNode, {display: "none"});
                    dojo.style(this._wgtAccounts.domNode, {display: "none"});
                    dojo.style(this._wgtZones.domNode, {display: ""});

                    this._grdShow.selection.select(null);
                    this._barCommandBar.changesMade(false);
                }
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.USER_SAVE:
                try{
                    this.activeWidget.save();
                }catch(e){
                    var err = new bfree.api.Error('Failed to save', e);
                    bfree.widget.ErrorManager.handleError({
                        error: err
                    });
                    this.activeWidget.set('activeItem', null);
                }
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.USER_NEW:
                this.activeWidget.createItem();
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.USER_DELETE:
                this.activeWidget.remove();
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.USER_EDIT:
                this.activeWidget.edit();
                break;
            case bfree.widget.admin.CommandBar.COMMANDS.USER_UNDO:
                this.activeWidget.revert();
                break;
        }
    },

    constructor: function(args){
    },


    postCreate: function(){

        this.nameNode.innerHTML=this.user.name;

        this._barCommandBar=new bfree.widget.admin.CommandBar({
            onCommand: dojo.hitch(this, this._onCommand),
            style:'z-index: 512'
        }, this.toolbarNode);

        this._grdShow=new dojox.grid.DataGrid({
			store: this.users.store,
			query: '',
			queryOptions: {cache: false},
			updateDelay: 100,
			selectionMode: 'single',
			clientSort: true,
			sortInfo: 1,
            structure: bfree.widget.admin.Show.userGridLayout,
			formatterScope: this,
			noDataMessage: 'No Items Found',
			onSelected: dojo.hitch(this, this._grdShow_onSelected),
            height: "310px"
		}, this.grdGrid);

        this._wgtUsers=new bfree.widget.admin.user.Administration({
            users: this.users,
            grid: this._grdShow,
            onItemChange: dojo.hitch(this._barCommandBar, this._barCommandBar.changesMade),
            onSelect: dojo.hitch(this._barCommandBar, this._barCommandBar.itemEditable)
        }, this.usersPane);

        this._wgtServers=new bfree.widget.admin.server.Administration({
            servers: this.servers,
            grid: this._grdShow,
            onItemChange: dojo.hitch(this._barCommandBar, this._barCommandBar.changesMade),
            onSelect: dojo.hitch(this._barCommandBar, this._barCommandBar.itemEditable)
        }, this.serversPane);

        this._wgtAccounts=new bfree.widget.admin.account.Administration({
            accounts: this.accounts,
            grid: this._grdShow,
            onItemChange: dojo.hitch(this._barCommandBar, this._barCommandBar.changesMade),
            onSelect: dojo.hitch(this._barCommandBar, this._barCommandBar.itemEditable)
        }, this.accountsPane);

        this._wgtZones=new bfree.widget.admin.zone.Administration({
            zones: this.zones,
            accounts: this.accounts,
            servers: this.servers,
            grid: this._grdShow,
            onItemChange: dojo.hitch(this._barCommandBar, this._barCommandBar.changesMade),
            onSelect: dojo.hitch(this._barCommandBar, this._barCommandBar.itemEditable)
        }, this.zonesPane);

        this.activeWidget=this._wgtUsers;

        this._grdShow.startup();
        this._grdShow.resize();
        this.startup();

        this.onLoad();
    },

    _grdShow_onSelected: function(){
        var item=this._grdShow.selection.getFirstSelected();

        this.activeWidget.set('activeItem', item);
    },

    startup: function(){
        this.inherited('startup', arguments);
//        this._wgtUsers().startup();
    },

    logoff: function(){
        this.users.logoff();
        var cmd = 'window.location.reload(true)';
        setTimeout(cmd, 1000);
    }
});

bfree.widget.admin.Show.generateUserNode = function(name, rowIndex){
    var userItem = this._grdShow.getItem(rowIndex);

    var dirty=this.users.isDirty({item:userItem});

    var name=userItem.name?userItem.name:'New User';

    if(dirty){
        name=dojo.replace("<i>{0}</i>", [name]);
    }

    return name;
}

bfree.widget.admin.Show.userGridLayout = [{
    cells: [{
        field: 'name',
        name: 'User',
        width: 'auto',
        formatter: bfree.widget.admin.Show.generateUserNode
    }],
    noscroll: false,
    width: 'auto'
}];

bfree.widget.admin.Show.generateServerNode = function(name, rowIndex){
    var serverItem = this._grdShow.getItem(rowIndex);

    var dirty=this.servers.isDirty({item:serverItem});

    var name=serverItem.name?serverItem.name:'New Server';

    if(dirty){
        name=dojo.replace("<i>{0}</i>", [name]);
    }

    return name;
}

bfree.widget.admin.Show.serverGridLayout = [{
    cells: [{
        field: 'name',
        name: 'Server',
        width: 'auto',
        formatter: bfree.widget.admin.Show.generateServerNode
    }],
    noscroll: false,
    width: 'auto'
}];

bfree.widget.admin.Show.generateAccountNode = function(name, rowIndex){
    var accountItem = this._grdShow.getItem(rowIndex);

    var dirty=this.accounts.isDirty({item:accountItem});

    var name=accountItem.name?accountItem.name:'New Account';

    if(dirty){
        name=dojo.replace("<i>{0}</i>", [name]);
    }

    return name;
}

bfree.widget.admin.Show.accountGridLayout = [{
    cells: [{
        field: 'name',
        name: 'Account',
        width: 'auto',
        formatter: bfree.widget.admin.Show.generateAccountNode
    }],
    noscroll: false,
    width: 'auto'
}];


bfree.widget.admin.Show.generateZoneNode = function(name, rowIndex){
    var zoneItem = this._grdShow.getItem(rowIndex);

    var dirty=this.zones.isDirty({item:zoneItem});

    var name=zoneItem.name?zoneItem.name:'New Zone';

    if(dirty){
        name=dojo.replace("<i>{0}</i>", [name]);
    }

    return name;
}

bfree.widget.admin.Show.zoneGridLayout = [{
    cells: [{
        field: 'name',
        name: 'Zone',
        width: 'auto',
        formatter: bfree.widget.admin.Show.generateZoneNode
    }],
    noscroll: false,
    width: 'auto'
}];

}

if(!dojo._hasResource["dijit.form._FormMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormMixin"] = true;
dojo.provide("dijit.form._FormMixin");



dojo.declare("dijit.form._FormMixin", null, {
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)
	// description:
	//		Can extract all the form widgets
	//		values and combine them into a single javascript object, or alternately
	//		take such an object and set the values for all the contained
	//		form widgets

/*=====
	// value: Object
	//		Name/value hash for each child widget with a name and value.
	//		Child widgets without names are not part of the hash.
	//
	//		If there are multiple child widgets w/the same name, value is an array,
	//		unless they are radio buttons in which case value is a scalar (since only
	//		one radio button can be checked at a time).
	//
	//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
	//
	//		Example:
	//	|	{ name: "John Smith", interests: ["sports", "movies"] }
=====*/

	// state: [readonly] String
	//		Will be "Error" if one or more of the child widgets has an invalid value,
	//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
	//		which indicates that the form is ready to be submitted.
	state: "",

	//	TODO:
	//	* Repeater
	//	* better handling for arrays.  Often form elements have names with [] like
	//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
	//
	//

		reset: function(){
			dojo.forEach(this.getDescendants(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features.
			//		1 - it will highlight any sub-widgets that are not
			//			valid
			//		2 - it will call focus() on the first invalid
			//			sub-widget
			var didFocus = false;
			return dojo.every(dojo.map(this.getDescendants(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					dojo.window.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item){ return item; });
		},

		setValues: function(val){
			dojo.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			dojo.forEach(this.getDescendants(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = dojo.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				if(!dojo.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					dojo.forEach(widgets, function(w, i){
						w.set('value', dojo.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					dojo.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			dojo.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							dojo.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						dojo.forEach(element.options, function(option){
							option.selected = dojo.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						dojo.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/
			
			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			dojo.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the setTimout(..., 0) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			dojo.forEach(this.getDescendants(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							dojo.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = dojo.getObject(name, false, obj);
							if(value === undefined){
								dojo.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=dojo.getObject(name, false, obj);
						if(!ary){
							ary=[];
							dojo.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=dojo.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(dojo.isArray(prev)){
							prev.push(value);
						}else{
							dojo.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						dojo.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also dojo.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			dojo.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					} else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					} else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					} else{
						// can not set value when there is no name
					}
				} else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				} else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(isValid){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = dojo.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return dojo.indexOf(states, "Error") >= 0 ? "Error" :
				dojo.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Remove connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			dojo.forEach(this._childConnections || [], dojo.hitch(this, "disconnect"));
			dojo.forEach(this._childWatches || [], function(w){ w.unwatch(); });
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		Setup connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			//
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			var _this = this;

			// Remove old connections, if any
			this.disconnectChildren();

			this._descendants = this.getDescendants();

			// (Re)set this.value and this.state.   Send watch() notifications but not on startup.
			var set = inStartup ? function(name, val){ _this[name] = val; } : dojo.hitch(this, "_set");
			set("value", this.get("value"));
			set("state", this._getState());

			// Monitor changes to error state and disabled state in order to update
			// Form.state
			var conns = (this._childConnections = []),
				watches = (this._childWatches = []);
			dojo.forEach(dojo.filter(this._descendants,
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget changes validity state - or
				// whenever the disabled attribute on that widget is changed.
				dojo.forEach(["state", "disabled"], function(attr){
					watches.push(widget.watch(attr, function(attr, oldVal, newVal){
						_this.set("state", _this._getState());
					}));
				});
			});

			// And monitor calls to child.onChange so we can update this.value
			var onChange = function(){
				// summary:
				//		Called when child's value or disabled state changes
				
				// Use setTimeout() to collapse value changes in multiple children into a single
				// update to my value.   Multiple updates will occur on:
				//	1. Form.set()
				//	2. Form.reset()
				//	3. user selecting a radio button (which will de-select another radio button,
				//		 causing two onChange events)
				if(_this._onChangeDelayTimer){
					clearTimeout(_this._onChangeDelayTimer);
				}
				_this._onChangeDelayTimer = setTimeout(function(){
					delete _this._onChangeDelayTimer;
					_this._set("value", _this.get("value"));
				}, 10);
			};
			dojo.forEach(
				dojo.filter(this._descendants, function(item){ return item.onChange; } ),
				function(widget){
					// When a child widget's value changes,
					// the efficient thing to do is to just update that one attribute in this.value,
					// but that gets a little complicated when a checkbox is checked/unchecked
					// since this.value["checkboxName"] contains an array of all the checkboxes w/the same name.
					// Doing simple thing for now.
					conns.push(_this.connect(widget, "onChange", onChange));

					// Disabling/enabling a child widget should remove it's value from this.value.
					// Again, this code could be more efficient, doing simple thing for now.
					watches.push(widget.watch("disabled", onChange));
				}
			);
		},

		startup: function(){
			this.inherited(arguments);

			// Initialize value and valid/invalid state tracking.  Needs to be done in startup()
			// so that children are initialized.
			this.connectChildren(true);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.disconnectChildren();
			this.inherited(arguments);
		}

	});

}

if(!dojo._hasResource["dijit.form.Form"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Form"] = true;
dojo.provide("dijit.form.Form");






dojo.declare(
	"dijit.form.Form",
	[dijit._Widget, dijit._Templated, dijit.form._FormMixin, dijit.layout._ContentPaneResizeMixin],
	{
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form dojoType="dijit.form.Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	myObj = {name: "John Doe"};
		//	|	dijit.byId('myForm').set('value', myObj);
		//	|
		//	|	myObj=dijit.byId('myForm').get('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form dojoAttachPoint='containerNode' dojoAttachEvent='onreset:_onReset,onsubmit:_onSubmit' ${!nameAttrSetting}></form>",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			action: "",
			method: "",
			encType: "",
			"accept-charset": "",
			accept: "",
			target: ""
		}),

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ formContents){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			this.encType = value;
			dojo.attr(this.domNode, "encType", value);
			if(dojo.isIE){ this.domNode.encoding = value; }
		},

		postCreate: function(){
			// IE tries to hide encType
			// TODO: remove in 2.0, no longer necessary with data-dojo-params
			if(dojo.isIE && this.srcNodeRef && this.srcNodeRef.attributes){
				var item = this.srcNodeRef.attributes.getNamedItem('encType');
				if(item && !item.specified && (typeof item.value == "string")){
					this.set('encType', item.value);
				}
			}
			this.inherited(arguments);
		},

		reset: function(/*Event?*/ e){
			// summary:
			//		restores all widget values back to their init values,
			//		calls onReset() which can cancel the reset by returning false

			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){ // not IE
							this.returnValue = false;
						},
				stopPropagation: function(){},
				currentTarget: e ? e.target : this.domNode,
				target: e ? e.target : this.domNode
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.inherited(arguments, []);
			}
		},

		onReset: function(/*Event?*/ e){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			this.reset(e);
			dojo.stopEvent(e);
			return false;
		},

		_onSubmit: function(e){
			var fp = dijit.form.Form.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				dojo.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				dojo.stopEvent(e);
			}
		},

		onSubmit: function(/*Event?*/ e){
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	}
);

}

if(!dojo._hasResource['bfree.widget.Button']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.Button'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/09/11
 * Time: 3:32 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.Button');


dojo.declare('bfree.widget.Button', [dijit.form.Button],
{
	_iconClass: null,
	disabledIconClass: null,
    scrollOnFocus: false,

	constructor: function(/*Object*/args){
		this._iconClass = (args.iconClass == null) ? this.iconClass : args.iconClass;
	},

	postCreate: function(){
		this.inherited('postCreate', arguments);
		this._setDisabledAttr(this.disabled);
	},

	_setDisabledAttr: function(val){
		this.inherited(arguments);

		var newClass = ((this.disabledIconClass != null) && (val)) ? this.disabledIconClass : this._iconClass;
		this.set('iconClass', newClass)
	}

});

}

if(!dojo._hasResource["dojo.fx.Toggler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.Toggler"] = true;
dojo.provide("dojo.fx.Toggler");


dojo.declare("dojo.fx.Toggler", null, {
	// summary:
	//		A simple `dojo.Animation` toggler API.
	//
	// description:
	//		class constructor for an animation toggler. It accepts a packed
	//		set of arguments about what type of animation to use in each
	//		direction, duration, etc. All available members are mixed into
	//		these animations from the constructor (for example, `node`,
	//		`showDuration`, `hideDuration`).
	//
	// example:
	//	|	var t = new dojo.fx.Toggler({
	//	|		node: "nodeId",
	//	|		showDuration: 500,
	//	|		// hideDuration will default to "200"
	//	|		showFunc: dojo.fx.wipeIn,
	//	|		// hideFunc will default to "fadeOut"
	//	|	});
	//	|	t.show(100); // delay showing for 100ms
	//	|	// ...time passes...
	//	|	t.hide();

	// node: DomNode
	//		the node to target for the showing and hiding animations
	node: null,

	// showFunc: Function
	//		The function that returns the `dojo.Animation` to show the node
	showFunc: dojo.fadeIn,

	// hideFunc: Function
	//		The function that returns the `dojo.Animation` to hide the node
	hideFunc: dojo.fadeOut,

	// showDuration:
	//		Time in milliseconds to run the show Animation
	showDuration: 200,

	// hideDuration:
	//		Time in milliseconds to run the hide Animation
	hideDuration: 200,

	// FIXME: need a policy for where the toggler should "be" the next
	// time show/hide are called if we're stopped somewhere in the
	// middle.
	// FIXME: also would be nice to specify individual showArgs/hideArgs mixed into
	// each animation individually.
	// FIXME: also would be nice to have events from the animations exposed/bridged

	/*=====
	_showArgs: null,
	_showAnim: null,

	_hideArgs: null,
	_hideAnim: null,

	_isShowing: false,
	_isHiding: false,
	=====*/

	constructor: function(args){
		var _t = this;

		dojo.mixin(_t, args);
		_t.node = args.node;
		_t._showArgs = dojo.mixin({}, args);
		_t._showArgs.node = _t.node;
		_t._showArgs.duration = _t.showDuration;
		_t.showAnim = _t.showFunc(_t._showArgs);

		_t._hideArgs = dojo.mixin({}, args);
		_t._hideArgs.node = _t.node;
		_t._hideArgs.duration = _t.hideDuration;
		_t.hideAnim = _t.hideFunc(_t._hideArgs);

		dojo.connect(_t.showAnim, "beforeBegin", dojo.hitch(_t.hideAnim, "stop", true));
		dojo.connect(_t.hideAnim, "beforeBegin", dojo.hitch(_t.showAnim, "stop", true));
	},

	show: function(delay){
		// summary: Toggle the node to showing
		// delay: Integer?
		//		Ammount of time to stall playing the show animation
		return this.showAnim.play(delay || 0);
	},

	hide: function(delay){
		// summary: Toggle the node to hidden
		// delay: Integer?
		//		Ammount of time to stall playing the hide animation
		return this.hideAnim.play(delay || 0);
	}
});

}

if(!dojo._hasResource["dojo.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx"] = true;
dojo.provide("dojo.fx");



/*=====
dojo.fx = {
	// summary: Effects library on top of Base animations
};
=====*/
(function(){
	
	var d = dojo,
		_baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		d.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	d.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			d.disconnect(this._onAnimateCtx);
			d.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = d.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = d.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = d.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					d.disconnect(beforeBegin);
					d.disconnect(onBegin);
					d.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				d.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				d.disconnect(this._onEndCtx);
			}
			this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = d.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						d.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			d.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = d.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						d.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ d.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ d.disconnect(this._onEndCtx); }
		}
	});
	d.extend(_chain, _baseObj);

	dojo.fx.chain = function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Chain a list of `dojo.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo.Animation` which will play all passed
		//		`dojo.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain,
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations) // dojo.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		d.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(d.connect(a, "onEnd", this, "_onEnd"));
		}, this);
		
		this._pseudoAnimation = new d.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		d.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"],
			function(evt){
				self._connects.push(d.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	d.extend(_combine, {
		_doAction: function(action, args){
			d.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			d.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			d.forEach(this._connects, dojo.disconnect);
		}
	});
	d.extend(_combine, _baseObj);

	dojo.fx.combine = function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Combine a list of `dojo.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo.Animation`s to run in parallel,
		//		providing a new `dojo.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo.Animation
	};

	dojo.fx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeIn({
		//	|		node:"someId"
		//	|	}).play()
		var node = args.node = d.byId(args.node), s = node.style, o;

		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = d.style(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		d.connect(anim, "onEnd", function(){
			s.height = "auto";
			s.overflow = o;
		});

		return anim; // dojo.Animation
	};

	dojo.fx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it.
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeOut({ node:"someId" }).play()
		
		var node = args.node = d.byId(args.node), s = node.style, o;
		
		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		d.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		d.connect(anim, "onEnd", function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		});

		return anim; // dojo.Animation
	};

	dojo.fx.slideTo = function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node"
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	dojo.fx.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = d.byId(args.node),
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = d.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = d.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = d.animateProperty(d.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		d.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo.Animation
	};

})();

}

if(!dojo._hasResource['bfree.widget.zone.Logon']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.zone.Logon'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 06/09/11
 * Time: 10:15 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.zone.Logon');



 ;








dojo.declare('bfree.widget.zone.Logon', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree.widget.zone", "template/Logon.html", "<div align=\"center\" style=\"height:68px;width:408px;position:relative\">\n\n<div dojoAttachPoint=\"logonNode\">\n<div dojoAttachPoint=\"logonFormNode\">\n\n    <span style=\"position:absolute;top:24px;left:0\" class=\"logonLabel\">Username</span>\n    <div style=\"position:absolute;top:38px\"><input dojoAttachPoint=\"userNameNode\"/></div>\n\n    <span style=\"position:absolute;top:24px;left:168px\" class=\"logonLabel\">Password</span>\n    <div style=\"position:absolute;top:38px;left:168px;\"><input dojoAttachPoint=\"passwordNode\"/></div>\n\n    <span style=\"position:absolute;top:60px;left:168px\" class=\"logonLabel\">\n        <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onResetClick\">Forgot your password?</a>\n    </span>\n\n    <div style=\"position:absolute;top:32px;left:332px;\">\n        <button dojoAttachPoint=\"logonButtonNode\" type=\"submit\"></button>\n    </div>\n\n</div>\n</div>\n\n<div dojoAttachPoint=\"resetNode\" class=\"versaHide\">\n<div dojoAttachPoint=\"resetFormNode\">\n\n    <span style=\"position:absolute;top:0;left:0\" class=\"logonLabel\">Enter your username and email address to reset your password:</span>\n\n    <span style=\"position:absolute;top:24px;left:0\" class=\"logonLabel\">Username</span>\n    <div style=\"position:absolute;top:38px\"><input dojoAttachPoint=\"resetNameNode\"/></div>\n\n    <span style=\"position:absolute;top:24px;left:168px\" class=\"logonLabel\">Email</span>\n    <div style=\"position:absolute;top:38px;left:168px;\"><input dojoAttachPoint=\"emailNode\"/></div>\n\n    <span style=\"position:absolute;top:60px;left:168px\" class=\"logonLabel\">\n        <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onReturnClick\">Return to log in</a>\n    </span>\n\n    <div style=\"position:absolute;top:32px;left:332px;\">\n        <button dojoAttachPoint=\"resetButtonNode\" type=\"submit\"></button>\n    </div>\n</div>\n\n</div>\n</div>\n"),

    _btnReset: null,
    _btnSubmit: null,
    _frmLogon: null,
    _txtEmail: null,
    _txtPassword: null,
    _txtResetName: null,
    _txtUserName: null,


    user: null,
    zone: null,

    _onResetClick: function(e){

        var a1 = dojo.fadeOut({
            node: this.logonNode,
            duration: 500,
            onEnd: dojo.hitch(this, function(){
                dojo.toggleClass(this.logonNode, 'versaHide', true);
                dojo.toggleClass(this.resetNode, 'versaHide', false);
                var username = this._txtUsername.get('value');
                this._txtResetName.set('value', username);
            })
        });
        var a2 = dojo.fadeIn({
            node: this.resetNode,
            duration: 500,
            onEnd: dojo.hitch(this, function(){
                this._btnReset.set('disabled', true);
                this._txtResetName.blur();
                this._txtResetName.validate();
                this._txtEmail.blur();
                this._txtEmail.validate();
                this._txtResetName.focus();
                this._btnReset.set('disabled', false);
            })
        });

        dojo.fx.chain([a1, a2]).play();

    },

    _onReturnClick: function(e){
        var a1 = dojo.fadeOut({
            node: this.resetNode,
            duration: 500,
            onEnd: dojo.hitch(this, function(){
                dojo.toggleClass(this.logonNode, 'versaHide', false);
                dojo.toggleClass(this.resetNode, 'versaHide', true);
            })
        });
        var a2 = dojo.fadeIn({
            node: this.logonNode,
            duration: 500,
            onEnd: dojo.hitch(this, function(){
                this._txtPassword.reset();
                this._txtUsername.setFocus();

            })
        });

        dojo.fx.chain([a1, a2]).play();
    },

    _onResetSubmit: function(e){

        try{

            if(this._frmReset.validate()){

                var username = this._txtResetName.get('value');
                var email = this._txtEmail.get('value');

                this.zone.resetPassword(username, email);
                this.onReset(username);
                this._txtUsername.set('value', username);
            }

        }
        catch(e){
            this.onResetError(e);
            this._txtResetName.reset();
            this._txtEmail.reset();
            this._txtResetName.setFocus();
        }
        finally{
            e.preventDefault();
        }

    },

    _onLogonSubmit: function(e){

        try{

            if(this._frmLogon.isValid()){

                var username = this._txtUsername.get('value');
                var password = this._txtPassword.get('value');

                var user = this.zone.logon(username, password);
                this.onLogon(user);

            }
            else{
				this._txtUsername.validate();
            }

        }
        catch(e){
            this.onError(e);
            this._txtPassword.reset();
            this._txtUsername.setFocus(true);
        }
        finally{
            e.preventDefault();
        }

        //this.statusNode.innerHTML = stsMessage;
    },

    constructor: function(args){

    },

    onError: function(e){
    },

    onLogon: function(user){
    },

    onReset: function(username){
    },

    onResetError: function(e){
    },

    postCreate: function(){
		this.inherited('postCreate', arguments);

        this._frmLogon = new dijit.form.Form({
			onSubmit: dojo.hitch(this, this._onLogonSubmit)
		}, this.logonFormNode);

        this._frmReset = new dijit.form.Form({
            onSubmit: dojo.hitch(this, this._onResetSubmit)
        }, this.resetFormNode);

        this._txtUsername = new bfree.widget.ValidationTextBox({
			name: 'txtUsername',
			required: true,
			//placeHolder: 'User name',
            missingMessage: 'Username is required',
            value: (this.user == null) ? null : this.user.name,
            disabled: (this.user != null),
            style:'width:160px'
		}, this.userNameNode);

        this._txtPassword = new bfree.widget.ValidationTextBox({
			name: 'txtPassword',
			//placeHolder: 'Password',
            required: false,
			type: 'password',
            style:'width:160px'
		}, this.passwordNode);

        this._btnSubmit = new bfree.widget.Button({
			iconClass: 'buttonIcon bfreeIconLock',
			label: 'Log in',
			type: 'submit'
		}, this.logonButtonNode);

        this._txtResetName = new bfree.widget.ValidationTextBox({
			name: 'txtResetName',
			required: true,
			//placeHolder: 'User name',
            missingMessage: 'Username is required',
            value: (this.user == null) ? null : this.user.name,
            disabled: (this.user != null),
            style:'width:160px'
		}, this.resetNameNode);

        this._txtEmail = new bfree.widget.ValidationTextBox({
			name: 'txtEmail',
			//placeHolder: 'Password',
            required: true,
            style:'width:160px'
		}, this.emailNode);

        this._btnReset = new bfree.widget.Button({
			iconClass: 'buttonIcon bfreeIconLock',
			label: 'Reset',
			type: 'submit'
		}, this.resetButtonNode);

        this._txtUsername.focus();

    },

    startup: function(){
        this.inherited('startup', arguments);

    }

});

bfree.widget.zone.Logon.STS_CODES = {'ERR': 0x0, 'OK': 0x1};
bfree.widget.zone.Logon.ERR_MESSAGE = 'Error: <b>{message}</b>';
bfree.widget.zone.Logon.OK_MESSAGE = 'Success: <b>Logged in as user \'{name}\'.</b>';

}

if(!dojo._hasResource['bfree.widget.Bfree']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.Bfree'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 3:07 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.Bfree');

dojo.declare('bfree.widget.Bfree', null,{
});

bfree.widget.Bfree.ObjectTypes = {
    'NONE':         0x0000,
    'ZONE':         0x0001,
    'USER':         0x0002,
    'GROUP':        0x0003,
    'PROP_DEF':     0x0008,
    'DOC_TYPE':     0x0009,
    'CHOICE_LIST':  0x000A,
    'VIEW_DEF':     0x000B,
    'DOCUMENT':     0x000C,
    'VERSION':      0x000D,
    'FOLDER':       0x0010,
    'SHARE':        0x0011,
    'QUOTA':        0x00F0
}

bfree.widget.Bfree.Commands = {
    'NONE':                 0x0000,
    'USRGRPEDIT':           0x0001,
    'EDIT_PERMISSIONS':     0x0002,
    'PRINT':                0x0003,
    'NEW':                  0x0004,
    'SAVE':                 0x0005,
    'EDIT':                 0x0006,
    'REFRESH':              0x0007,
    'UNDO':                 0x0008,
    'DELETE':               0x0009,
    'RESTORE':              0x000A,
    'MOVEUP':               0x000B,
    'MOVEDOWN':             0x000C,
    'EXPORT':               0x000D,
    'ADD':                  0x000E,
    'REMOVE':               0x000F,
    'MOVE_UP':              0x0010,
    'MOVE_DOWN':            0x0011,
    'VIEW':                 0x0012,
    'COPY':                 0x0013,
    'MOVE':                 0x0014,
    'CHECKOUT':             0x0015,
    'CHECKIN':              0x0016,
    'CANCEL_CKO':           0x0017,
    'SECURE':               0x0018,
    'EMPTY':                0x0019,
    'DESTROY':              0x001A,
    'NEXT':                 0x001B,
    'PREV':                 0x001C,
    'SHARE':                0x001D,
    'UNSHARE':              0x001E,
    'RENAME':               0x001F,
    'ADMIN':                0x00FF,

    'EDIT_USER':            0x0401,

    'ADMIN_USERS':          0xF001,
    'ADMIN_GROUPS':         0xF002,
    'ADMIN_PROP_DEFS':      0xF003,
    'ADMIN_DOC_TYPES':      0xF004,
    'ADMIN_CHOICE_LISTS':   0xF005,

    'HELP':         0x00FF,
    'LOGOFF':       0xFFFF,

    'COLUMN_TOGGLE':        0xE001,
    'COLUMN_RESIZE':        0xE002,
    'COLUMN_REORDER':       0xE003
};

dojo.has = function(array, item){
    return dojo.indexOf(array, item) >= 0;
};

}

if(!dojo._hasResource["dijit.layout.StackController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackController"] = true;
dojo.provide("dijit.layout.StackController");







dojo.declare(
		"dijit.layout.StackController",
		[dijit._Widget, dijit._Templated, dijit._Container],
		{
			// summary:
			//		Set of buttons to select a page in a page list.
			// description:
			//		Monitors the specified StackContainer, and whenever a page is
			//		added, deleted, or selected, updates itself accordingly.

			templateString: "<span role='tablist' dojoAttachEvent='onkeypress' class='dijitStackController'></span>",

			// containerId: [const] String
			//		The id of the page container that I point to
			containerId: "",

			// buttonWidget: [const] String
			//		The name of the button widget to create to correspond to each page
			buttonWidget: "dijit.layout._StackButton",

			constructor: function(){
				this.pane2button = {};		// mapping from pane id to buttons
				this.pane2connects = {};	// mapping from pane id to this.connect() handles
				this.pane2watches = {};		// mapping from pane id to watch() handles
			},

			buildRendering: function(){
				this.inherited(arguments);
				dijit.setWaiRole(this.domNode, "tablist");	// TODO: unneeded?   it's in template above.
			},

			postCreate: function(){
				this.inherited(arguments);

				// Listen to notifications from StackContainer
				this.subscribe(this.containerId+"-startup", "onStartup");
				this.subscribe(this.containerId+"-addChild", "onAddChild");
				this.subscribe(this.containerId+"-removeChild", "onRemoveChild");
				this.subscribe(this.containerId+"-selectChild", "onSelectChild");
				this.subscribe(this.containerId+"-containerKeyPress", "onContainerKeyPress");
			},

			onStartup: function(/*Object*/ info){
				// summary:
				//		Called after StackContainer has finished initializing
				// tags:
				//		private
				dojo.forEach(info.children, this.onAddChild, this);
				if(info.selected){
					// Show button corresponding to selected pane (unless selected
					// is null because there are no panes)
					this.onSelectChild(info.selected);
				}
			},

			destroy: function(){
				for(var pane in this.pane2button){
					this.onRemoveChild(dijit.byId(pane));
				}
				this.inherited(arguments);
			},

			onAddChild: function(/*dijit._Widget*/ page, /*Integer?*/ insertIndex){
				// summary:
				//		Called whenever a page is added to the container.
				//		Create button corresponding to the page.
				// tags:
				//		private

				// create an instance of the button widget
				var cls = dojo.getObject(this.buttonWidget);
				var button = new cls({
					id: this.id + "_" + page.id,
					label: page.title,
					dir: page.dir,
					lang: page.lang,
					showLabel: page.showTitle,
					iconClass: page.iconClass,
					closeButton: page.closable,
					title: page.tooltip
				});
				dijit.setWaiState(button.focusNode,"selected", "false");


				// map from page attribute to corresponding tab button attribute
				var pageAttrList = ["title", "showTitle", "iconClass", "closable", "tooltip"],
					buttonAttrList = ["label", "showLabel", "iconClass", "closeButton", "title"];

				// watch() so events like page title changes are reflected in tab button
				this.pane2watches[page.id] = dojo.map(pageAttrList, function(pageAttr, idx){
					return page.watch(pageAttr, function(name, oldVal, newVal){
						button.set(buttonAttrList[idx], newVal);
					});
				});
					
				// connections so that clicking a tab button selects the corresponding page
				this.pane2connects[page.id] = [
					this.connect(button, 'onClick', dojo.hitch(this,"onButtonClick", page)),
					this.connect(button, 'onClickCloseButton', dojo.hitch(this,"onCloseButtonClick", page))
				];

				this.addChild(button, insertIndex);
				this.pane2button[page.id] = button;
				page.controlButton = button;	// this value might be overwritten if two tabs point to same container
				if(!this._currentChild){ // put the first child into the tab order
					button.focusNode.setAttribute("tabIndex", "0");
					dijit.setWaiState(button.focusNode, "selected", "true");
					this._currentChild = page;
				}
				// make sure all tabs have the same length
				if(!this.isLeftToRight() && dojo.isIE && this._rectifyRtlTabList){
					this._rectifyRtlTabList();
				}
			},

			onRemoveChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever a page is removed from the container.
				//		Remove the button corresponding to the page.
				// tags:
				//		private

				if(this._currentChild === page){ this._currentChild = null; }

				// disconnect/unwatch connections/watches related to page being removed
				dojo.forEach(this.pane2connects[page.id], dojo.hitch(this, "disconnect"));
				delete this.pane2connects[page.id];
				dojo.forEach(this.pane2watches[page.id], function(w){ w.unwatch(); });
				delete this.pane2watches[page.id];

				var button = this.pane2button[page.id];
				if(button){
					this.removeChild(button);
					delete this.pane2button[page.id];
					button.destroy();
				}
				delete page.controlButton;
			},

			onSelectChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called when a page has been selected in the StackContainer, either by me or by another StackController
				// tags:
				//		private

				if(!page){ return; }

				if(this._currentChild){
					var oldButton=this.pane2button[this._currentChild.id];
					oldButton.set('checked', false);
					dijit.setWaiState(oldButton.focusNode, "selected", "false");
					oldButton.focusNode.setAttribute("tabIndex", "-1");
				}

				var newButton=this.pane2button[page.id];
				newButton.set('checked', true);
				dijit.setWaiState(newButton.focusNode, "selected", "true");
				this._currentChild = page;
				newButton.focusNode.setAttribute("tabIndex", "0");
				var container = dijit.byId(this.containerId);
				dijit.setWaiState(container.containerNode, "labelledby", newButton.id);
			},

			onButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons is pressed in an attempt to select a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.selectChild(page);
			},

			onCloseButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.closeChild(page);
				if(this._currentChild){
					var b = this.pane2button[this._currentChild.id];
					if(b){
						dijit.focus(b.focusNode || b.domNode);
					}
				}
			},

			// TODO: this is a bit redundant with forward, back api in StackContainer
			adjacent: function(/*Boolean*/ forward){
				// summary:
				//		Helper for onkeypress to find next/previous button
				// tags:
				//		private

				if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){ forward = !forward; }
				// find currently focused button in children array
				var children = this.getChildren();
				var current = dojo.indexOf(children, this.pane2button[this._currentChild.id]);
				// pick next button to focus on
				var offset = forward ? 1 : children.length - 1;
				return children[ (current + offset) % children.length ]; // dijit._Widget
			},

			onkeypress: function(/*Event*/ e){
				// summary:
				//		Handle keystrokes on the page list, for advancing to next/previous button
				//		and closing the current page if the page is closable.
				// tags:
				//		private

				if(this.disabled || e.altKey ){ return; }
				var forward = null;
				if(e.ctrlKey || !e._djpage){
					var k = dojo.keys;
					switch(e.charOrCode){
						case k.LEFT_ARROW:
						case k.UP_ARROW:
							if(!e._djpage){ forward = false; }
							break;
						case k.PAGE_UP:
							if(e.ctrlKey){ forward = false; }
							break;
						case k.RIGHT_ARROW:
						case k.DOWN_ARROW:
							if(!e._djpage){ forward = true; }
							break;
						case k.PAGE_DOWN:
							if(e.ctrlKey){ forward = true; }
							break;
						case k.HOME:
						case k.END:
							var children = this.getChildren();
							if(children && children.length){
								children[e.charOrCode == k.HOME ? 0 : children.length-1].onClick();
							}
							dojo.stopEvent(e);
							break;
						case k.DELETE:
							if(this._currentChild.closable){
								this.onCloseButtonClick(this._currentChild);
							}
							dojo.stopEvent(e);
							break;
						default:
							if(e.ctrlKey){
								if(e.charOrCode === k.TAB){
									this.adjacent(!e.shiftKey).onClick();
									dojo.stopEvent(e);
								}else if(e.charOrCode == "w"){
									if(this._currentChild.closable){
										this.onCloseButtonClick(this._currentChild);
									}
									dojo.stopEvent(e); // avoid browser tab closing.
								}
							}
					}
					// handle next/previous page navigation (left/right arrow, etc.)
					if(forward !== null){
						this.adjacent(forward).onClick();
						dojo.stopEvent(e);
					}
				}
			},

			onContainerKeyPress: function(/*Object*/ info){
				// summary:
				//		Called when there was a keypress on the container
				// tags:
				//		private
				info.e._djpage = info.page;
				this.onkeypress(info.e);
			}
	});


dojo.declare("dijit.layout._StackButton",
		dijit.form.ToggleButton,
		{
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			dijit.setWaiRole((this.focusNode || this.domNode), "tab");
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		This is for TabContainer where the tabs are <span> rather than button,
			//		so need to set focus explicitly (on some browsers)
			//		Note that you shouldn't override this method, but you can connect to it.
			dijit.focus(this.focusNode);

			// ... now let StackController catch the event and tell me what to do
		},

		onClickCloseButton: function(/*Event*/ evt){
			// summary:
			//		StackContainer connects to this function; if your widget contains a close button
			//		then clicking it should call this function.
			//		Note that you shouldn't override this method, but you can connect to it.
			evt.stopPropagation();
		}
	});

}

if(!dojo._hasResource["dijit.layout.StackContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackContainer"] = true;
dojo.provide("dijit.layout.StackContainer");







dojo.declare(
	"dijit.layout.StackContainer",
	dijit.layout._LayoutWidget,
	{
	// summary:
	//		A container that has multiple children, but shows only
	//		one child at a time
	//
	// description:
	//		A container for widgets (ContentPanes, for example) That displays
	//		only one Widget at a time.
	//
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//
	//		Can be base class for container, Wizard, Show, etc.

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size
	doLayout: true,

	// persist: Boolean
	//		Remembers the selected child across sessions
	persist: false,

	baseClass: "dijitStackContainer",

/*=====
	// selectedChildWidget: [readonly] dijit._Widget
	//		References the currently selected child widget, if any.
	//		Adjust selected child with selectChild() method.
	selectedChildWidget: null,
=====*/

	buildRendering: function(){
		this.inherited(arguments);
		dojo.addClass(this.domNode, "dijitLayoutContainer");
		dijit.setWaiRole(this.containerNode, "tabpanel");
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onkeypress", this._onKeyPress);
	},

	startup: function(){
		if(this._started){ return; }

		var children = this.getChildren();

		// Setup each page panel to be initially hidden
		dojo.forEach(children, this._setupChild, this);

		// Figure out which child to initially display, defaulting to first one
		if(this.persist){
			this.selectedChildWidget = dijit.byId(dojo.cookie(this.id + "_selectedChild"));
		}else{
			dojo.some(children, function(child){
				if(child.selected){
					this.selectedChildWidget = child;
				}
				return child.selected;
			}, this);
		}
		var selected = this.selectedChildWidget;
		if(!selected && children[0]){
			selected = this.selectedChildWidget = children[0];
			selected.selected = true;
		}

		// Publish information about myself so any StackControllers can initialize.
		// This needs to happen before this.inherited(arguments) so that for
		// TabContainer, this._contentBox doesn't include the space for the tab labels.
		dojo.publish(this.id+"-startup", [{children: children, selected: selected}]);

		// Startup each child widget, and do initial layout like setting this._contentBox,
		// then calls this.resize() which does the initial sizing on the selected child.
		this.inherited(arguments);
	},

	resize: function(){
		// Resize is called when we are first made visible (it's called from startup()
		// if we are initially visible).   If this is the first time we've been made
		// visible then show our first child.
		var selected = this.selectedChildWidget;
		if(selected && !this._hasBeenShown){
			this._hasBeenShown = true;
			this._showChild(selected);
		}
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Overrides _LayoutWidget._setupChild()

		this.inherited(arguments);

		dojo.replaceClass(child.domNode, "dijitHidden", "dijitVisible");

		// remove the title attribute so it doesn't show up when i hover
		// over a node
		child.domNode.title = "";
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Overrides _Container.addChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			dojo.publish(this.id+"-addChild", [child, insertIndex]);

			// in case the tab titles have overflowed from one line to two lines
			// (or, if this if first child, from zero lines to one line)
			// TODO: w/ScrollingTabController this is no longer necessary, although
			// ScrollTabController.resize() does need to get called to show/hide
			// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild()
			this.layout();

			// if this is the first child, then select it
			if(!this.selectedChildWidget){
				this.selectChild(child);
			}
		}
	},

	removeChild: function(/*dijit._Widget*/ page){
		// Overrides _Container.removeChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			// this will notify any tablists to remove a button; do this first because it may affect sizing
			dojo.publish(this.id + "-removeChild", [page]);
		}

		// If we are being destroyed than don't run the code below (to select another page), because we are deleting
		// every page one by one
		if(this._beingDestroyed){ return; }

		// Select new page to display, also updating TabController to show the respective tab.
		// Do this before layout call because it can affect the height of the TabController.
		if(this.selectedChildWidget === page){
			this.selectedChildWidget = undefined;
			if(this._started){
				var children = this.getChildren();
				if(children.length){
					this.selectChild(children[0]);
				}
			}
		}

		if(this._started){
			// In case the tab titles now take up one line instead of two lines
			// (note though that ScrollingTabController never overflows to multiple lines),
			// or the height has changed slightly because of addition/removal of tab which close icon
			this.layout();
		}
	},

	selectChild: function(/*dijit._Widget|String*/ page, /*Boolean*/ animate){
		// summary:
		//		Show the given widget (which must be one of my children)
		// page:
		//		Reference to child widget or id of child widget

		page = dijit.byId(page);

		if(this.selectedChildWidget != page){
			// Deselect old page and select new one
			var d = this._transition(page, this.selectedChildWidget, animate);
			this._set("selectedChildWidget", page);
			dojo.publish(this.id+"-selectChild", [page]);

			if(this.persist){
				dojo.cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
			}
		}

		return d;		// If child has an href, promise that fires when the child's href finishes loading
	},

	_transition: function(/*dijit._Widget*/ newWidget, /*dijit._Widget*/ oldWidget, /*Boolean*/ animate){
		// summary:
		//		Hide the old widget and display the new widget.
		//		Subclasses should override this.
		// tags:
		//		protected extension
		if(oldWidget){
			this._hideChild(oldWidget);
		}
		var d = this._showChild(newWidget);

		// Size the new widget, in case this is the first time it's being shown,
		// or I have been resized since the last time it was shown.
		// Note that page must be visible for resizing to work.
		if(newWidget.resize){
			if(this.doLayout){
				newWidget.resize(this._containerContentBox || this._contentBox);
			}else{
				// the child should pick it's own size but we still need to call resize()
				// (with no arguments) to let the widget lay itself out
				newWidget.resize();
			}
		}

		return d;	// If child has an href, promise that fires when the child's href finishes loading
	},

	_adjacent: function(/*Boolean*/ forward){
		// summary:
		//		Gets the next/previous child widget in this container from the current selection.
		var children = this.getChildren();
		var index = dojo.indexOf(children, this.selectedChildWidget);
		index += forward ? 1 : children.length - 1;
		return children[ index % children.length ]; // dijit._Widget
	},

	forward: function(){
		// summary:
		//		Advance to next page.
		return this.selectChild(this._adjacent(true), true);
	},

	back: function(){
		// summary:
		//		Go back to previous page.
		return this.selectChild(this._adjacent(false), true);
	},

	_onKeyPress: function(e){
		dojo.publish(this.id+"-containerKeyPress", [{ e: e, page: this}]);
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		if(this.doLayout && this.selectedChildWidget && this.selectedChildWidget.resize){
			this.selectedChildWidget.resize(this._containerContentBox || this._contentBox);
		}
	},

	_showChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
		//		it can do any updates it needs regarding loading href's etc.
		// returns:
		//		Promise that fires when page has finished showing, or true if there's no href
		var children = this.getChildren();
		page.isFirstChild = (page == children[0]);
		page.isLastChild = (page == children[children.length-1]);
		page._set("selected", true);

		dojo.replaceClass(page.domNode, "dijitVisible", "dijitHidden");

		return page._onShow() || true;
	},

	_hideChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Hide the specified child by changing it's CSS, and call _onHide() so
		//		it's notified.
		page._set("selected", false);
		dojo.replaceClass(page.domNode, "dijitHidden", "dijitVisible");

		page.onHide();
	},

	closeChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Callback when user clicks the [X] to remove a page.
		//		If onClose() returns true then remove and destroy the child.
		// tags:
		//		private
		var remove = page.onClose(this, page);
		if(remove){
			this.removeChild(page);
			// makes sure we can clean up executeScripts in ContentPane onUnLoad
			page.destroyRecursive();
		}
	},

	destroyDescendants: function(/*Boolean*/ preserveDom){
		dojo.forEach(this.getChildren(), function(child){
			this.removeChild(child);
			child.destroyRecursive(preserveDom);
		}, this);
	}
});

// For back-compat, remove for 2.0


// These arguments can be specified for the children of a StackContainer.
// Since any widget can be specified as a StackContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// selected: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		Specifies that this widget should be the initially displayed pane.
	//		Note: to change the selected child use `dijit.layout.StackContainer.selectChild`
	selected: false,

	// closable: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
	closable: false,

	// iconClass: String
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		CSS Class specifying icon to use in label associated with this pane.
	iconClass: "",

	// showTitle: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		When true, display title of this widget as tab label etc., rather than just using
	//		icon specified in iconClass
	showTitle: true
});

}

if(!dojo._hasResource['bfree.widget.Label']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.Label'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/12/11
 * Time: 11:22 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.Label');





dojo.declare('bfree.widget.Label', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget", "template/Label.html", "<div style=\"display:inline-block\">\n    <div dojoAttachPoint=\"labelNode\" class=\"dijitDarkLabel dijitBoldLabel\" style=\"vertical-align:middle;height:100%;white-space:nowrap;\"></div>\n</div>\n"),
    widgetsInTemplate: false,

    isError: false,
    value: null,

    _setValueAttr: function(newValue){
        this.value = newValue;
        this.labelNode.innerHTML = this.value;
    },

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        if(this.isError)
            dojo.addClass(this.labelNode, 'dijitStrongErrorLabel');

        this.labelNode.innerHTML = this.value;
    },

    reset: function(label, value){
        this.set('label', ((label == null) ? '': label));
        this.labelNode.innerHTML = ((value == null) ? '': value);
    },

    startup: function(){
        this.inherited('startup', arguments);

    }

});

}

if(!dojo._hasResource['versa.widget.error.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.error.CommandBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/03/12
 * Time: 3:40 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.error.CommandBar');






dojo.declare('versa.widget.error.CommandBar', dijit.Toolbar, {

    _btnNext: null,
    _btnBack: null,
    _lblPageInfo: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setLabelAttr: function(value){
        this._lblPageInfo.set('value', value);
    },

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnNext = new bfree.widget.Button({
                label: 'Next Error...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconErrorRight',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.NEXT)
            });
        this.addChild(this._btnNext);

        this._lblPageInfo = new bfree.widget.Label({
            value: '',
            isError: true,
            style: 'width:144px;text-align:center;'
        });
        this.addChild(this._lblPageInfo);

        this._btnBack = new bfree.widget.Button({
                label: 'Previous Error...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconErrorLeft',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.PREV)
            });
        this.addChild(this._btnBack);

        /*
        this._btnHelp =  new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconHelp',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            });
        this.addChild(this._btnHelp);
        */
    }

});

}

if(!dojo._hasResource['versa.widget.error.Show']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.error.Show'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/03/12
 * Time: 12:17 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.error.Show');









dojo.declare('versa.widget.error.Show', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget], {

    templateString: dojo.cache("versa/widget/error", "template/Show.html", "<div style=\"height:100%;width:100%;position:relative\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        dojoAttachPoint=\"mainContainer\"\n        design=\"sidebar\"\n        gutters=\"false\"\n        style=\"padding:8px 8px 0 8px;height:100%;width:100%;\">\n\n    <div \tdojoType=\"dijit.layout.ContentPane\"\n            region=\"left\"\n            splitter=\"false\"\n            style=\"width:32px;padding:8px 8px 0 0\">\n\n        <img src=\"/images/icons/32/error-orb.png\" height=\"32\" width=\"32\">\n\n    </div>\n\n    <div    dojoAttachPoint=\"errorNode\"\n            dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            region=\"center\"\n            splitter=\"false\">\n\n\n        <div \tdojoAttachPoint=\"messageNode\"\n                dojoType=\"dijit.layout.ContentPane\"\n                region=\"top\"\n                splitter=\"false\"\n                class=\"errorPane\"\n                style=\"height:126px;padding:0px\">\n\n            <div dojoAttachPoint=\"errorStackNode\"></div>\n\n        </div>\n\n        <div    dojoAttachPoint=\"pageNode\"\n                dojoType=\"dijit.layout.ContentPane\"\n                region=\"center\"\n                splitter=\"false\"\n                style=\"padding:0 88px 0 0;display:none\">\n\n            <div dojoAttachPoint=\"pageBarNode\"></div>\n\n        </div>\n\n    </div>\n\n\n\n</div>\n\n\n</div>\n"),
    widgetsInTemplate: true,

    _wdgPageBar: null,
    _wdgStack: null,

    error: null,

    _loadItem: function(){

        try{
          //this.messageNode.innerHTML = this.error.message;
          //this.descriptionNode.innerHTML = this.error.err.message;
        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onCommand: function(){
        this._wdgStack.forward();
        this._setMessage();
    },

    _setMessage: function(){
        var idx = this._wdgStack.getIndexOfChild(this._wdgStack.selectedChildWidget);
        var count = this._wdgStack.getChildren().length;
        var msg = dojo.replace('Showing: {0} of {1} errors', [idx + 1, count]);
        this._wdgPageBar.set('label', msg);
    },

    addError: function(error){

        var pane = new dijit.layout.ContentPane({
            title: 'Error',
            content: dojo.replace(versa.widget.error.Show.MESSAGE_HTML, [error.message, error.err.message])
        });
        this._wdgStack.addChild(pane);

        this._setMessage();

        if( this._wdgStack.getChildren().length > 1){
            this.messageNode.resize({h: 108});
            dojo.style(this.pageNode.domNode, {display: 'block'});
            this.errorNode.resize();
        }
    },


    constructor: function(args){

    },

    destroy: function(){

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._wdgStack = new dijit.layout.StackContainer({
            id: 'wdgErrorStack',
            style: 'height:100%'
        }, this.errorStackNode);

        this._wdgPageBar = new versa.widget.error.CommandBar({
            'class': 'versaSidebar',
            dir: 'rtl',
            onCommand: dojo.hitch(this, this._onCommand)
        }, this.pageBarNode);

    },

    startup: function(){
        this.inherited('startup', arguments);
        setTimeout(versa.widget.error.Show._loadFnRef(this), 10);
        this.onWidgetLoaded();
    }

});

versa.widget.error.Show.MESSAGE_HTML = '<div class="dijitErrorLabel dijitBoldLabel dijitLargeLabel" style="margin-bottom:4px;">{0}</div><div class="dijitErrorLabel dijitLargeLabel">{1}</div>';

versa.widget.error.Show._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

}

if(!dojo._hasResource['bfree.widget.ErrorManager']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.ErrorManager'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 19/09/11
 * Time: 10:44 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.ErrorManager');



dojo.declare('bfree.widget.ErrorManager', null, {
});

bfree.widget.ErrorManager.errorToaster = null;
bfree.widget.ErrorManager._errorQueue = [];

bfree.widget.ErrorManager.handleError = function(args){
    var dlg = null;

    function __addErrors(){
        while(bfree.widget.ErrorManager._errorQueue.length){
            var err = bfree.widget.ErrorManager._errorQueue.pop();
            if(err) dlg.widget.addError(err);
        }
    }

    console.error(args.error.getMessage(true));

    bfree.widget.ErrorManager._errorQueue.push(args.error);

    dlg = dijit.byId('dlgError');
    if(!dlg){
        //create dialog
        dlg = new bfree.widget.Dialog({
            id: 'dlgError',
            title: 'ERROR',
            widgetConstructor: versa.widget.error.Show,
            widgetParams: {
                error: args.error
            },
            noResize: true,
            height: 200,
            width: 400,
            buttons: bfree.widget.Dialog.buttons.close,
            onLoad: __addErrors
        });
        dlg.startup();
        dlg.show();
    }
    else if(dlg.widget){
        //dialog/widget has been created
        __addErrors();
    }


};

}

if(!dojo._hasResource["dojox.widget.Standby"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.widget.Standby"] = true;
dojo.provide("dojox.widget.Standby");






dojo.experimental("dojox.widget.Standby");

dojo.declare("dojox.widget.Standby",[dijit._Widget, dijit._Templated],{
	// summary:
	//		A widget designed to act as a Standby/Busy/Disable/Blocking widget to indicate a
	//		particular DOM node is processing and cannot be clicked on at this time.
	//		This widget uses absolute positioning to apply the overlay and image.
	//
	// image:
	//		A URL to an image to center within the blocking overlay.
	//		The default is a basic spinner.
	//
	// imageText:
	//		Text to set on the ALT tag of the image.
	//		The default is 'Please wait...'
	//
	// text:
	//		Text to display in the center instead of an image.
	//		Defaults to 'Please Wait...'
	//
	// centerIndicator:
	//		Which to use as the center info, the text or the image.
	//		Defaults to image.
	//
	// color:
	//		The color to use for the translucent overlay.
	//		Text string such as: darkblue, #FE02FD, etc.
	//
	// duration:
	//		How long the fade in and out effects should run in milliseconds.
	//		Default is 500ms
	//
	// zIndex:
	//		Control that lets you specify if the zIndex for the overlay
	//		should be auto-computed based off parent zIndex, or should be set
	//		to a particular value.  This is useful when you want to overlay
	//		things in digit.Dialogs, you can specify a base zIndex to append from.
	//		Default is 'auto'.

	// templateString: [protected] String
	//		The template string defining out the basics of the widget.  No need for an external
	//		file.
	templateString:
		"<div>" +
			"<div style=\"display: none; opacity: 0; z-index: 9999; " +
				"position: absolute; cursor:wait;\" dojoAttachPoint=\"_underlayNode\"></div>" +
			"<img src=\"${image}\" style=\"opacity: 0; display: none; z-index: -10000; " +
				"position: absolute; top: 0px; left: 0px; cursor:wait;\" "+
				"dojoAttachPoint=\"_imageNode\">" +
			"<div style=\"opacity: 0; display: none; z-index: -10000; position: absolute; " +
				"top: 0px;\" dojoAttachPoint=\"_textNode\"></div>" +
		"</div>",

	// _underlayNode: [private] DOMNode
	//		The node that is the translucent underlay for the
	//		image that blocks access to the target.
	_underlayNode: null,

	// _imageNode: [private] DOMNode
	//		The image node where we attach and define the image to display.
	_imageNode: null,

	// _textNode: [private] DOMNode
	//		The div to attach text/HTML in the overlay center item.
	_textNode: null,

	// _centerNode: [private] DOMNode
	//		Which node to use as the center node, the image or the text node.
	_centerNode: null,

	// image: String
	//		The URL to the image to center in the overlay.
	image: dojo.moduleUrl("dojox", "widget/Standby/images/loading.gif").toString(),

	// imageText: String
	//		Text for the ALT tag.
	imageText: "Please Wait...",

	// text: String
	//		Text/HTML to display in the center of the overlay
	//		This is used if image center is disabled.
	text: "Please wait...",

	// centerIndicator: String
	//		Property to define if the image and its alt text should be used, or
	//		a simple Text/HTML node should be used.  Allowable values are 'image'
	//		and 'text'.
	//		Default is 'image'.
	centerIndicator: "image",

	// _displayed: [private] Boolean
	//		Flag to indicate if the overlay is displayed or not.
	_displayed: false,

	// _resizeCheck: [private] Object
	//		Handle to interval function that checks the target for changes.
	_resizeCheck: null,
	
	// target: DOMNode||DOMID(String)||WidgetID(String)
	//		The target to overlay when active.  Can be a widget id, a
	//		dom id, or a direct node reference.
	target: "",

	// color:	String
	//		The color to set the overlay.  Should be in #XXXXXX form.
	//		Default color for the translucent overlay is light gray.
	color: "#C0C0C0",

	// duration: integer
	//		Integer defining how long the show and hide effects should take.
	duration: 500,

	// _started: [private] Boolean
	//		Trap flag to ensure startup only processes once.
	_started: false,

	// _parent: [private] DOMNode
	//		Wrapping div for the widget, also used for IE 7 in dealing with the
	//		zoom issue.
	_parent: null,

	// zIndex: String
	//		Control that lets you specify if the zIndex for the overlay
	//		should be auto-computed based off parent zIndex, or should be set
	//		to a particular value.  This is useful when you want to overlay
	//		things in digit.Dialogs, you can specify a base zIndex to append from.
	zIndex: "auto",

	startup: function(args){
		// summary:
		//		Over-ride of the basic widget startup function.
		//		Configures the target node and sets the image to use.
		if(!this._started){
			if(typeof this.target === "string"){
				var w = dijit.byId(this.target);
				if(w){
					this.target = w.domNode;
				}else{
					this.target = dojo.byId(this.target);
				}
			}

			if(this.text){
				this._textNode.innerHTML = this.text;
			}
			if(this.centerIndicator === "image"){
				this._centerNode = this._imageNode;
				dojo.attr(this._imageNode, "src", this.image);
				dojo.attr(this._imageNode, "alt", this.imageText);
			}else{
				this._centerNode = this._textNode;
			}
			dojo.style(this._underlayNode, {
				display: "none",
				backgroundColor: this.color
			});
			dojo.style(this._centerNode, "display", "none");
			this.connect(this._underlayNode, "onclick", "_ignore");

			//Last thing to do is move the widgets parent, if any, to the current document body.
			//Avoids having to deal with parent relative/absolute mess.  Otherwise positioning
			//tends to go goofy.
			if(this.domNode.parentNode && this.domNode.parentNode != dojo.body()){
				dojo.body().appendChild(this.domNode);
			}

			//IE 7 has a horrible bug with zoom, so we have to create this node
			//to cross-check later.  Sigh.
			if(dojo.isIE == 7){
				this._ieFixNode = dojo.doc.createElement("div");
				dojo.style(this._ieFixNode, {
					opacity: "0",
					zIndex: "-1000",
					position: "absolute",
					top: "-1000px"
				});
				dojo.body().appendChild(this._ieFixNode);
			}
		}
	},

	show: function(){
		// summary:
		//		Function to display the blocking overlay and busy/status icon or text.
		if(!this._displayed){
			if(this._anim){
				this._anim.stop();
				delete this._anim;
			}
			this._displayed = true;
			this._size();
			this._disableOverflow();
			this._fadeIn();
		}
	},

	hide: function(){
		// summary:
		//		Function to hide the blocking overlay and status icon or text.
		if(this._displayed){
			if(this._anim){
				this._anim.stop();
				delete this._anim;
			}
			this._size();
			this._fadeOut();
			this._displayed = false;
			if(this._resizeCheck !== null){
				clearInterval(this._resizeCheck);
				this._resizeCheck = null;
			}
		}
	},

	isVisible: function(){
		// summary:
		//		Helper function so you can test if the widget is already visible or not.
		// returns:
		//		boolean indicating if the widget is in 'show' state or not.
		return this._displayed; // boolean
	},

	onShow: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	onHide: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	uninitialize: function(){
		// summary:
		//		Over-ride to hide the widget, which clears intervals, before cleanup.
		this._displayed = false;
		if(this._resizeCheck){
			clearInterval(this._resizeCheck);
		}
		dojo.style(this._centerNode, "display", "none");
		dojo.style(this._underlayNode, "display", "none");
		if(dojo.isIE == 7){
			dojo.body().removeChild(this._ieFixNode);
			delete this._ieFixNode;
		}
		if(this._anim){
			this._anim.stop();
			delete this._anim;
		}
		this.target = null;
		this._imageNode = null;
		this._textNode = null;
		this._centerNode = null;
		this.inherited(arguments);
	},

	_size: function(){
		// summary:
		//		Internal function that handles resizing the overlay and
		//		centering of the image on window resizing.
		// tags:
		//		private
		if(this._displayed){
			var dir = dojo.attr(dojo.body(), "dir");
			if(dir){dir = dir.toLowerCase();}
			var _ie7zoom;
			var scrollers = this._scrollerWidths();

			var target = this.target;

			//Show the image and make sure the zIndex is set high.
			var curStyle = dojo.style(this._centerNode, "display");
			dojo.style(this._centerNode, "display", "block");
			var box = dojo.position(target, true);
			if(target === dojo.body() || target === dojo.doc){
				// Target is the whole doc, so scale to viewport.
				box = dojo.window.getBox();
				box.x = box.l;
				box.y = box.t;
			}

			var cntrIndicator = dojo.marginBox(this._centerNode);
			dojo.style(this._centerNode, "display", curStyle);

			//IE has a horrible zoom bug.  So, we have to try and account for
			//it and fix up the scaling.
			if(this._ieFixNode){
				_ie7zoom = -this._ieFixNode.offsetTop / 1000;
				box.x = Math.floor((box.x + 0.9) / _ie7zoom);
				box.y = Math.floor((box.y + 0.9) / _ie7zoom);
				box.w = Math.floor((box.w + 0.9) / _ie7zoom);
				box.h = Math.floor((box.h + 0.9) / _ie7zoom);
			}

			//Figure out how to zIndex this thing over the target.
			var zi = dojo.style(target, "zIndex");
			var ziUl = zi;
			var ziIn = zi;

			if(this.zIndex === "auto"){
				if(zi != "auto"){
					ziUl = parseInt(ziUl, 10) + 1;
					ziIn = parseInt(ziIn, 10) + 2;
				}else{
					//We need to search up the chain to see if there
					//are any parent zIndexs to overlay.
					var cNode = target.parentNode;
					var oldZi = -100000;
					while(cNode && cNode !== dojo.body()){
						zi = dojo.style(cNode, "zIndex");
						if(!zi || zi === "auto"){
							cNode = cNode.parentNode;
						}else{
							var newZi = parseInt(zi, 10);
							if(oldZi < newZi){
								oldZi = newZi;
								ziUl = newZi + 1;
								ziIn = newZi + 2;
							}
							// Keep looking until we run out, we want the highest zIndex.
							cNode = cNode.parentNode;
						}
					}
				}
			}else{
				ziUl = parseInt(this.zIndex, 10) + 1;
				ziIn = parseInt(this.zIndex, 10) + 2;
			}

			dojo.style(this._centerNode, "zIndex", ziIn);
			dojo.style(this._underlayNode, "zIndex", ziUl);


			var pn = target.parentNode;
			if(pn && pn !== dojo.body() &&
				target !== dojo.body() &&
				target !== dojo.doc){
				
				// If the parent is the body tag itself,
				// we can avoid all this, the body takes
				// care of overflow for me.  Besides, browser
				// weirdness with height and width on body causes
				// problems with this sort of intersect testing
				// anyway.
				var obh = box.h;
				var obw = box.w;
				var pnBox = dojo.position(pn, true);

				//More IE zoom corrections.  Grr.
				if(this._ieFixNode){
					_ie7zoom = -this._ieFixNode.offsetTop / 1000;
					pnBox.x = Math.floor((pnBox.x + 0.9) / _ie7zoom);
					pnBox.y = Math.floor((pnBox.y + 0.9) / _ie7zoom);
					pnBox.w = Math.floor((pnBox.w + 0.9) / _ie7zoom);
					pnBox.h = Math.floor((pnBox.h + 0.9) / _ie7zoom);
				}
				
				//Shift the parent width/height a bit if scollers are present.
				pnBox.w -= pn.scrollHeight > pn.clientHeight &&
					pn.clientHeight > 0 ? scrollers.v: 0;
				pnBox.h -= pn.scrollWidth > pn.clientWidth &&
					pn.clientWidth > 0 ? scrollers.h: 0;

				//RTL requires a bit of massaging in some cases
				//(and differently depending on browser, ugh!)
				//WebKit and others still need work.
				if(dir === "rtl"){
					if(dojo.isOpera){
						box.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(dojo.isIE){
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(dojo.isWebKit){
						//TODO:  FIX THIS!
					}
				}

				//Figure out if we need to adjust the overlay to fit a viewable
				//area, then resize it, we saved the original height/width above.
				//This is causing issues on IE.  Argh!
				if(pnBox.w < box.w){
					//Scale down the width if necessary.
					box.w = box.w - pnBox.w;
				}
				if(pnBox.h < box.h){
					//Scale down the width if necessary.
					box.h = box.h - pnBox.h;
				}

				//Look at the y positions and see if we intersect with the
				//viewport borders.  Will have to do computations off it.
				var vpTop = pnBox.y;
				var vpBottom = pnBox.y + pnBox.h;
				var bTop = box.y;
				var bBottom = box.y + obh;
				var vpLeft = pnBox.x;
				var vpRight = pnBox.x + pnBox.w;
				var bLeft = box.x;
				var bRight = box.x + obw;
				var delta;
				//Adjust the height now
				if(bBottom > vpTop &&
					bTop < vpTop){
					box.y = pnBox.y;
					//intersecting top, need to do some shifting.
					delta = vpTop - bTop;
					var visHeight = obh - delta;
					//If the visible height < viewport height,
					//We need to shift it.
					if(visHeight < pnBox.h){
						box.h = visHeight;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.h -= 2*(pn.scrollWidth > pn.clientWidth &&
							pn.clientWidth > 0? scrollers.h: 0);
					}
				}else if(bTop < vpBottom && bBottom > vpBottom){
					//Intersecting bottom, just figure out how much
					//overlay to show.
					box.h = vpBottom - bTop;
				}else if(bBottom <= vpTop || bTop >= vpBottom){
					//Outside view, hide it.
					box.h = 0;
				}

				//adjust width
				if(bRight > vpLeft && bLeft < vpLeft){
					box.x = pnBox.x;
					//intersecting left, need to do some shifting.
					delta = vpLeft - bLeft;
					var visWidth = obw - delta;
					//If the visible width < viewport width,
					//We need to shift it.
					if(visWidth < pnBox.w){
						box.w = visWidth;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.w -= 2*(pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0? scrollers.w:0);
					}
				}else if(bLeft < vpRight && bRight > vpRight){
					//Intersecting right, just figure out how much
					//overlay to show.
					box.w = vpRight - bLeft;
				}else if(bRight <= vpLeft || bLeft >= vpRight){
					//Outside view, hide it.
					box.w = 0;
				}
			}

			if(box.h > 0 && box.w > 0){
				//Set position and size of the blocking div overlay.
				dojo.style(this._underlayNode, {
					display: "block",
					width: box.w + "px",
					height: box.h + "px",
					top: box.y + "px",
					left: box.x + "px"
				});

				var styles = ["borderRadius", "borderTopLeftRadius",
					"borderTopRightRadius","borderBottomLeftRadius",
					"borderBottomRightRadius"];
				this._cloneStyles(styles);
				if(!dojo.isIE){
					//Browser specific styles to try and clone if non-IE.
					styles = ["MozBorderRadius", "MozBorderRadiusTopleft",
						"MozBorderRadiusTopright","MozBorderRadiusBottomleft",
						"MozBorderRadiusBottomright","WebkitBorderRadius",
						"WebkitBorderTopLeftRadius", "WebkitBorderTopRightRadius",
						"WebkitBorderBottomLeftRadius","WebkitBorderBottomRightRadius"
					];
					this._cloneStyles(styles, this);
				}
				var cntrIndicatorTop = (box.h/2) - (cntrIndicator.h/2);
				var cntrIndicatorLeft = (box.w/2) - (cntrIndicator.w/2);
				//Only show the image if there is height and width room.
				if(box.h >= cntrIndicator.h && box.w >= cntrIndicator.w){
					dojo.style(this._centerNode, {
						top: (cntrIndicatorTop + box.y) + "px",
						left: (cntrIndicatorLeft + box.x) + "px",
						display: "block"
					});
				}else{
					dojo.style(this._centerNode, "display", "none");
				}
			}else{
				//Target has no size, display nothing on it!
				dojo.style(this._underlayNode, "display", "none");
				dojo.style(this._centerNode, "display", "none");
			}
			if(this._resizeCheck === null){
				//Set an interval timer that checks the target size and scales as needed.
				//Checking every 10th of a second seems to generate a fairly smooth update.
				var self = this;
				this._resizeCheck = setInterval(function(){self._size();}, 100);
			}
		}
	},

	_cloneStyles: function(list){
		// summary:
		//		Internal function to clone a set of styles from the target to
		//		the underlay.
		// list: Array
		//		An array of style names to clone.
		//
		// tags:
		//		private
		dojo.forEach(list, function(style){
			dojo.style(this._underlayNode,style,dojo.style(this.target,style));
		}, this);
	},

	_fadeIn: function(){
		// summary:
		//		Internal function that does the opacity style fade in animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: 0, end: 0.75}}
		});
		var imageAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 0, end: 1}},
			onEnd: function(){
				self.onShow();
				delete self._anim;
			}
		});
		this._anim = dojo.fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_fadeOut: function(){
		// summary:
		//		Internal function that does the opacity style fade out animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: 0.75, end: 0}},
			onEnd: function(){
				dojo.style(this.node,{"display":"none", "zIndex": "-1000"});
			}
		});
		var imageAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 1, end: 0}},
			onEnd: function(){
				dojo.style(this.node,{"display":"none", "zIndex": "-1000"});
				self.onHide();
				self._enableOverflow();
				delete self._anim;
			}
		});
		this._anim = dojo.fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_ignore: function(event){
		// summary:
		//		Function to ignore events that occur on the overlay.
		// event: Event
		//		The event to halt
		// tags:
		//		private
		if(event){
			dojo.stopEvent(event);
		}
	},

	_scrollerWidths: function(){
		// summary:
		//		This function will calculate the size of the vertical and
		//		horizontaol scrollbars.
		// returns:
		//		Object of form: {v: Number, h: Number} where v is vertical scrollbar width
		//		and h is horizontal scrollbar width.
		// tags:
		//		private
		var div = dojo.doc.createElement("div");
		dojo.style(div, {
			position: "absolute",
			opacity: 0,
			overflow: "hidden",
			width: "50px",
			height: "50px",
			zIndex: "-100",
			top: "-200px",
			left: "-200px",
			padding: "0px",
			margin: "0px"
		});
		var iDiv = dojo.doc.createElement("div");
		dojo.style(iDiv, {
			width: "200px",
			height: "10px"
		});
		div.appendChild(iDiv);
		dojo.body().appendChild(div);

		//Figure out content size before and after
		//scrollbars are there, then just subtract to
		//get width.
		var b = dojo.contentBox(div);
		dojo.style(div, "overflow", "scroll");
		var a = dojo.contentBox(div);
		dojo.body().removeChild(div);
		return { v: b.w - a.w, h: b.h - a.h };
	},

	/* The following are functions that tie into _Widget.attr() */

	_setTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the text displayed in center
		//		if using text display.
		// text: String
		//		The text to set.
		this._textNode.innerHTML = text;
		this.text = text;
	},

	_setColorAttr: function(c){
		// summary:
		//		Function to allow widget.attr to set the color used for the translucent
		//		div overlay.
		// c: String
		//		The color to set the background underlay to in #XXXXXX format..
		dojo.style(this._underlayNode, "backgroundColor", c);
		this.color = c;
	},

	_setImageTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the ALT text text displayed for
		//		the image (if using image center display).
		// text: String
		//		The text to set.
		dojo.attr(this._imageNode, "alt", text);
		this.imageText = text;
	},

	_setImageAttr: function(url){
		// summary:
		//		Function to allow widget.attr to set the url source for the center image
		// text: String
		//		The url to set for the image.
		dojo.attr(this._imageNode, "src", url);
		this.image = url;
	},

	_setCenterIndicatorAttr: function(indicator){
		// summary:
		//		Function to allow widget.attr to set the node used for the center indicator,
		//		either the image or the text.
		// indicator: String
		//		The indicator to use, either 'image' or 'text'.
		this.centerIndicator = indicator;
		if(indicator === "image"){
			this._centerNode = this._imageNode;
			dojo.style(this._textNode, "display", "none");
		}else{
			this._centerNode = this._textNode;
			dojo.style(this._imageNode, "display", "none");
		}
	},

	_disableOverflow: function(){
		 // summary:
		 //		Function to disable scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this.target === dojo.body() || this.target === dojo.doc){
			 // Store the overflow state we have to restore later.
			 // IE had issues, so have to check that it's defined.  Ugh.
			 this._overflowDisabled = true;
			 var body = dojo.body();
			 if(body.style && body.style.overflow){
				 this._oldOverflow = dojo.style(body, "overflow");
			 }else{
				 this._oldOverflow = "";
			 }
			 if(dojo.isIE && !dojo.isQuirks){
				 // IE will put scrollbars in anyway, html (parent of body)
				 // also controls them in standards mode, so we have to
				 // remove them, argh.
				 if(body.parentNode &&
					body.parentNode.style &&
					body.parentNode.style.overflow){
					 this._oldBodyParentOverflow = body.parentNode.style.overflow;
				 }else{
					 try{
						this._oldBodyParentOverflow = dojo.style(body.parentNode, "overflow");
					 }catch(e){
						 this._oldBodyParentOverflow = "scroll";
					 }
				 }
				 dojo.style(body.parentNode, "overflow", "hidden");
			 }
			 dojo.style(body, "overflow", "hidden");
		 }
	},

	_enableOverflow: function(){
		 // summary:
		 //		Function to restore scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this._overflowDisabled){
			delete this._overflowDisabled;
			var body = dojo.body();
			// Restore all the overflow.
			if(dojo.isIE && !dojo.isQuirks){
				body.parentNode.style.overflow = this._oldBodyParentOverflow;
				delete this._oldBodyParentOverflow;
			}
			dojo.style(body, "overflow", this._oldOverflow);
			if(dojo.isWebKit){
				//Gotta poke WebKit, or scrollers don't come back. :-(
				var div = dojo.create("div", { style: {
						height: "2px"
					}
				});
				body.appendChild(div);
				setTimeout(function(){
					body.removeChild(div);
				}, 0);
			}
			delete this._oldOverflow;
		}
	}
});

}

if(!dojo._hasResource['bfree.widget.Standby']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.Standby'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 18/10/11
 * Time: 4:12 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.Standby');


dojo.declare('bfree.widget.Standby', [dojox.widget.Standby],
{
    duration: 1000,
    opacity: 0.75,
    image: '/images/loading/loading64.gif',
    showOnStart: false,

    _scrollerWidths: function(){
        return { v: 0, h: 0 };
    },

	constructor: function(/*Object*/args){

	},

    _fadeIn: function(){
		// summary:
		//		Internal function that does the opacity style fade in animation.
		// tags:
		//		private
		var self = this;

        var startOpacity = (this.showOnStart) ? this.opacity : 0;
        var startDuration = (this.showOnStart)? 10: this.duration;

		var underlayNodeAnim = dojo.animateProperty({
			duration: startDuration,
			node: self._underlayNode,
			properties: {opacity: {start: startOpacity, end: this.opacity}}
		});
		var imageAnim = dojo.animateProperty({
			duration: startDuration,
			node: self._centerNode,
			properties: {opacity: {start: startOpacity, end: 1}},
			onEnd: function(){
				self.onShow();
				delete self._anim;
			}
		});
		this._anim = dojo.fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_fadeOut: function(){
		// summary:
		//		Internal function that does the opacity style fade out animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: this.opacity, end: 0}},
			onEnd: function(){
				dojo.style(this.node,{"display":"none", "zIndex": "-1000"});
			}
		});
		var imageAnim = dojo.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 1, end: 0}},
			onEnd: function(){
				dojo.style(this.node,{"display":"none", "zIndex": "-1000"});
				self.onHide();
				self._enableOverflow();
				delete self._anim;
			}
		});
		this._anim = dojo.fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	}


});

}

if(!dojo._hasResource["dojo.dnd.move"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.move"] = true;
dojo.provide("dojo.dnd.move");




/*=====
dojo.declare("dojo.dnd.move.__constrainedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// constraints: Function
	//		Calculates a constraint box.
	//		It is called in a context of the moveable object.
	constraints: function(){},

	// within: Boolean
	//		restrict move within boundaries.
	within: false
});
=====*/

dojo.declare("dojo.dnd.move.constrainedMoveable", dojo.dnd.Moveable, {
	// object attributes (for markup)
	constraints: function(){},
	within: false,
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.constrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object that makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__constrainedMoveableArgs?
		//		an optional object with additional parameters;
		//		the rest is passed to the base class
		if(!params){ params = {}; }
		this.constraints = params.constraints;
		this.within = params.within;
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		var c = this.constraintBox = this.constraints.call(this, mover);
		c.r = c.l + c.w;
		c.b = c.t + c.h;
		if(this.within){
			var mb = dojo._getMarginSize(mover.node);
			c.r -= mb.w;
			c.b -= mb.h;
		}
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		var c = this.constraintBox, s = mover.node.style;
		this.onMoving(mover, leftTop);
		leftTop.l = leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l;
		leftTop.t = leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	}
});

/*=====
dojo.declare("dojo.dnd.move.__boxConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// box: Object
	//		a constraint box
	box: {}
});
=====*/

dojo.declare("dojo.dnd.move.boxConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// box:
	//		object attributes (for markup)
	box: {},
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.boxConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__boxConstrainedMoveableArgs?
		//		an optional object with parameters
		var box = params && params.box;
		this.constraints = function(){ return box; };
	}
});

/*=====
dojo.declare("dojo.dnd.move.__parentConstrainedMoveableArgs", [dojo.dnd.move.__constrainedMoveableArgs], {
	// area: String
	//		A parent's area to restrict the move.
	//		Can be "margin", "border", "padding", or "content".
	area: ""
});
=====*/

dojo.declare("dojo.dnd.move.parentConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// area:
	//		object attributes (for markup)
	area: "content",

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.parentConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.move.__parentConstrainedMoveableArgs?
		//		an optional object with parameters
		var area = params && params.area;
		this.constraints = function(){
			var n = this.node.parentNode,
				s = dojo.getComputedStyle(n),
				mb = dojo._getMarginBox(n, s);
			if(area == "margin"){
				return mb;	// Object
			}
			var t = dojo._getMarginExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "border"){
				return mb;	// Object
			}
			t = dojo._getBorderExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "padding"){
				return mb;	// Object
			}
			t = dojo._getPadExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			return mb;	// Object
		};
	}
});

// patching functions one level up for compatibility

dojo.dnd.constrainedMover = dojo.dnd.move.constrainedMover;
dojo.dnd.boxConstrainedMover = dojo.dnd.move.boxConstrainedMover;
dojo.dnd.parentConstrainedMover = dojo.dnd.move.parentConstrainedMover;

}

if(!dojo._hasResource["dojo.dnd.TimedMoveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.TimedMoveable"] = true;
dojo.provide("dojo.dnd.TimedMoveable");



/*=====
dojo.declare("dojo.dnd.__TimedMoveableArgs", [dojo.dnd.__MoveableArgs], {
	// timeout: Number
	//		delay move by this number of ms,
	//		accumulating position changes during the timeout
	timeout: 0
});
=====*/

(function(){
	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;
		
	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.
		
		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps
	
		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: dojo.dnd.__TimedMoveableArgs
			//		object with additional parameters.
			
			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},
	
		// markup methods
		markupFactory: function(params, node){
			return new dojo.dnd.TimedMoveable(node, params);
		},
	
		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer)
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
})();

}

if(!dojo._hasResource["dijit._DialogMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._DialogMixin"] = true;
dojo.provide("dijit._DialogMixin");



dojo.declare("dijit._DialogMixin", null,
	{
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		attributeMap: dijit._Widget.prototype.attributeMap,

		execute: function(/*Object*/ formContents){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.get('value'));
		},

		_getFocusItems: function(){
			// summary:
			//		Finds focusable items in dialog,
			//		and sets this._firstFocusItem and this._lastFocusItem
			// tags:
			//		protected

			var elems = dijit._getTabNavigable(this.containerNode);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		}
	}
);

}

if(!dojo._hasResource["dijit.DialogUnderlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.DialogUnderlay"] = true;
dojo.provide("dijit.DialogUnderlay");





dojo.declare(
	"dijit.DialogUnderlay",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' dojoAttachPoint='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		attributeMap: { id: "domNode" },

		_setDialogIdAttr: function(id){
			dojo.attr(this.node, "id", id + "_underlay");
			this._set("dialogId", id);
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
			this._set("class", clazz);
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			dojo.body().appendChild(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = dojo.window.getBox();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.bgIframe.destroy();
			delete this.bgIframe;
			this.domNode.style.display = "none";
		}
	}
);

}

if(!dojo._hasResource["dijit.TooltipDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TooltipDialog"] = true;
dojo.provide("dijit.TooltipDialog");






dojo.declare(
		"dijit.TooltipDialog",
		[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
		{
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			// 		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget.
			doLayout: false,

			// autofocus: Boolean
			// 		A Toggle to modify the default focus behavior of a Dialog, which
			// 		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing. Default: true
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private] [readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_firstFocusItem: null,

			// _lastFocusItem: [private] [readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_lastFocusItem: null,

			templateString: dojo.cache("dijit", "templates/TooltipDialog.html", "<div role=\"presentation\" tabIndex=\"-1\">\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" role=\"dialog\"></div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\"></div>\n</div>\n"),

			_setTitleAttr: function(/*String*/ title){
				this.containerNode.title = title;
				this._set("title", title)
			},

			postCreate: function(){
				this.inherited(arguments);
				this.connect(this.containerNode, "onkeypress", "_onKey");
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected
				var newC = "dijitTooltipAB" + (corner.charAt(1) == 'L' ? "Left" : "Right")
						+ " dijitTooltip"
						+ (corner.charAt(0) == 'T' ? "Below" : "Above");
				
				dojo.replaceClass(this.domNode, newC, this._currentOrientClass || "");
				this._currentOrientClass = newC;
			},

			focus: function(){
				// summary:
				//		Focus on first field
				this._getFocusItems(this.containerNode);
				dijit.focus(this._firstFocusItem);
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected

				this.orient(this.domNode,pos.aroundCorner, pos.corner);
				this._onShow(); // lazy load trigger
			},

			onClose: function(){
				// summary:
				//		Called when dialog is hidden.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
				this.onHide();
			},

			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keyboard events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				var node = evt.target;
				var dk = dojo.keys;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.containerNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				if(evt.charOrCode == dk.ESCAPE){
					// Use setTimeout to avoid crash on IE, see #10396.
					setTimeout(dojo.hitch(this, "onCancel"), 0);
					dojo.stopEvent(evt);
				}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else if(evt.charOrCode === dk.TAB){
					// we want the browser's default tab handling to move focus
					// but we don't want the tab to propagate upwards
					evt.stopPropagation();
				}
			}
		}
	);

}

if(!dojo._hasResource["dijit.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Dialog"] = true;
dojo.provide("dijit.Dialog");















// dijit/TooltipDialog required for back-compat.  TODO: remove in 2.0

/*=====
dijit._underlay = function(kwArgs){
	// summary:
	//		A shared instance of a `dijit.DialogUnderlay`
	//
	// description:
	//		A shared instance of a `dijit.DialogUnderlay` created and
	//		used by `dijit.Dialog`, though never created until some Dialog
	//		or subclass thereof is shown.
};
=====*/
dojo.declare(
	"dijit._DialogBase",
	[dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin, dijit._CssStateMixin],
	{
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div dojoType="dijit.Dialog" href="test.html"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();

		templateString: dojo.cache("dijit", "templates/Dialog.html", "<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n"),
		
		baseClass: "dijitDialog",
		
		cssStateNodes: {
			closeButtonNode: "dijitDialogCloseIcon"
		},

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			title: [
				{ node: "titleNode", type: "innerHTML" },
				{ node: "titleBar", type: "attribute" }
			],
			"aria-describedby":""
		}),

		// open: [readonly] Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: dijit.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,

		// _lastFocusItem: [private readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget.
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		//aria-describedby: String
		//		Allows the user to add an aria-describedby attribute onto the dialog.   The value should
		//		be the id of the container element of text that describes the dialog purpose (usually
		//		the first text in the dialog).
		//		<div dojoType="dijit.Dialog" aria-describedby="intro" .....>
		//			<div id="intro">Introductory text</div>
		//			<div>rest of dialog contents</div>
		//		</div>
		"aria-describedby":"",

		postMixInProperties: function(){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			dojo.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			dojo.style(this.domNode, {
				display: "none",
				position:"absolute"
			});
			dojo.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overridden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			// and find the focusable elements
			this._position();
			if(this.autofocus && dijit._DialogLevelManager.isTop(this)){
				this._getFocusItems(this.domNode);
				dijit.focus(this._firstFocusItem);
			}
			this.inherited(arguments);
		},

		_endDrag: function(e){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport.
			// tags:
			//		private
			if(e && e.node && e.node === this.domNode){
				this._relativePosition = dojo.position(e.node);
			}
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = (dojo.isIE == 6) ?
					new dojo.dnd.TimedMoveable(node, { handle: this.titleBar }) :	// prevent overload, see #5285
					new dojo.dnd.Moveable(node, { handle: this.titleBar, timeout: 0 });
				this._dndListener = dojo.subscribe("/dnd/move/stop",this,"_endDrag");
			}else{
				dojo.addClass(node,"dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": dojo.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};
		},

		_size: function(){
			// summary:
			// 		If necessary, shrink dialog contents so dialog fits in viewport
			// tags:
			//		private

			this._checkIfSingleChild();

			// If we resized the dialog contents earlier, reset them back to original size, so
			// that if the user later increases the viewport size, the dialog can display w/out a scrollbar.
			// Need to do this before the dojo.marginBox(this.domNode) call below.
			if(this._singleChild){
				if(this._singleChildOriginalStyle){
					this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
				}
				delete this._singleChildOriginalStyle;
			}else{
				dojo.style(this.containerNode, {
					width:"auto",
					height:"auto"
				});
			}

			var mb = dojo._getMarginSize(this.domNode);
			var viewport = dojo.window.getBox();
			if(mb.w >= viewport.w || mb.h >= viewport.h){
				// Reduce size of dialog contents so that dialog fits in viewport

				var w = Math.min(mb.w, Math.floor(viewport.w * 0.75)),
					h = Math.min(mb.h, Math.floor(viewport.h * 0.75));

				if(this._singleChild && this._singleChild.resize){
					this._singleChildOriginalStyle = this._singleChild.domNode.style.cssText;
					this._singleChild.resize({w: w, h: h});
				}else{
					dojo.style(this.containerNode, {
						width: w + "px",
						height: h + "px",
						overflow: "auto",
						position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
					});
				}
			}else{
				if(this._singleChild && this._singleChild.resize){
					this._singleChild.resize();
				}
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			// tags:
			//		private
			if(!dojo.hasClass(dojo.body(),"dojoMove")){
				var node = this.domNode,
					viewport = dojo.window.getBox(),
					p = this._relativePosition,
					bb = p ? null : dojo._getBorderBox(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
				;
				dojo.style(node,{
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			if(evt.charOrCode){
				var dk = dojo.keys;
				var node = evt.target;
				if(evt.charOrCode === dk.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode || dojo.hasClass(node, "dijitPopup")){
							if(evt.charOrCode == dk.ESCAPE){
								this.onCancel();
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== dk.TAB){ // allow tabbing into the dialog for a11y
						dojo.stopEvent(evt);
					// opera won't tab to a div
					}else if(!dojo.isOpera){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the display animation is complete

			if(this.open){ return; }

			if(!this._started){
				this.startup();
			}

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}

			this._modalconnects.push(dojo.connect(window, "onscroll", this, "layout"));
			this._modalconnects.push(dojo.connect(window, "onresize", this, function(){
				// IE gives spurious resize events and can actually get stuck
				// in an infinite loop if we don't ignore them
				var viewport = dojo.window.getBox();
				if(!this._oldViewport ||
						viewport.h != this._oldViewport.h ||
						viewport.w != this._oldViewport.w){
					this.layout();
					this._oldViewport = viewport;
				}
			}));
			this._modalconnects.push(dojo.connect(this.domNode, "onkeypress", this, "_onKey"));

			dojo.style(this.domNode, {
				opacity:0,
				display:""
			});

			this._set("open", true);
			this._onShow(); // lazy load trigger

			this._size();
			this._position();

			// fade-in Animation object, setup below
			var fadeIn;

			this._fadeInDeferred = new dojo.Deferred(dojo.hitch(this, function(){
				fadeIn.stop();
				delete this._fadeInDeferred;
			}));

			fadeIn = dojo.fadeIn({
				node: this.domNode,
				duration: this.duration,
				beforeBegin: dojo.hitch(this, function(){
					dijit._DialogLevelManager.show(this, this.underlayAttrs);
				}),
				onEnd: dojo.hitch(this, function(){
					if(this.autofocus && dijit._DialogLevelManager.isTop(this)){
						// find focusable items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems(this.domNode);
						dijit.focus(this._firstFocusItem);
					}
					this._fadeInDeferred.callback(true);
					delete this._fadeInDeferred;
				})
			}).play();
			
			return this._fadeInDeferred;
		},

		hide: function(){
			// summary:
			//		Hide the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the hide animation is complete

			// if we haven't been initialized yet then we aren't showing and we can just return
			if(!this._alreadyInitialized){
				return;
			}
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}

			// fade-in Animation object, setup below
			var fadeOut;

			this._fadeOutDeferred = new dojo.Deferred(dojo.hitch(this, function(){
				fadeOut.stop();
				delete this._fadeOutDeferred;
			}));

			fadeOut = dojo.fadeOut({
				node: this.domNode,
				duration: this.duration,
				onEnd: dojo.hitch(this, function(){
					this.domNode.style.display = "none";
					dijit._DialogLevelManager.hide(this);
					this.onHide();
					this._fadeOutDeferred.callback(true);
					delete this._fadeOutDeferred;
				})
			 }).play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);
			this._modalconnects = [];

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this._set("open", false);

			return this._fadeOutDeferred;
		},

		layout: function(){
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.display != "none"){
				if(dijit._underlay){	// avoid race condition during show()
					dijit._underlay.layout();
				}
				this._position();
			}
		},

		destroy: function(){
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}
			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			if(this._dndListener){
				dojo.unsubscribe(this._dndListener);
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);

			dijit._DialogLevelManager.hide(this);

			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.Dialog",
	[dijit.layout.ContentPane, dijit._DialogBase],
	{}
);

dijit._DialogLevelManager = {
	// summary:
	//		Controls the various active "levels" on the page, starting with the
	//		stuff initially visible on the page (at z-index 0), and then having an entry for
	//		each Dialog shown.

	show: function(/*dijit._Widget*/ dialog, /*Object*/ underlayAttrs){
		// summary:
		//		Call right before fade-in animation for new dialog.
		//		Saves current focus, displays/adjusts underlay for new dialog,
		//		and sets the z-index of the dialog itself.
		//
		//		New dialog will be displayed on top of all currently displayed dialogs.
		//
		//		Caller is responsible for setting focus in new dialog after the fade-in
		//		animation completes.

		var ds = dijit._dialogStack;

		// Save current focus
		ds[ds.length-1].focus = dijit.getFocus(dialog);

		// Display the underlay, or if already displayed then adjust for this new dialog
		var underlay = dijit._underlay;
		if(!underlay || underlay._destroyed){
			underlay = dijit._underlay = new dijit.DialogUnderlay(underlayAttrs);
		}else{
			underlay.set(dialog.underlayAttrs);
		}

		// Set z-index a bit above previous dialog
		var zIndex = ds[ds.length-1].dialog ? ds[ds.length-1].zIndex + 2 : 950;
		if(ds.length == 1){	// first dialog
			underlay.show();
		}
		dojo.style(dijit._underlay.domNode, 'zIndex', zIndex - 1);

		// Dialog
		dojo.style(dialog.domNode, 'zIndex', zIndex);

		ds.push({dialog: dialog, underlayAttrs: underlayAttrs, zIndex: zIndex});
	},

	hide: function(/*dijit._Widget*/ dialog){
		// summary:
		//		Called when the specified dialog is hidden/destroyed, after the fade-out
		//		animation ends, in order to reset page focus, fix the underlay, etc.
		//		If the specified dialog isn't open then does nothing.
		//
		//		Caller is responsible for either setting display:none on the dialog domNode,
		//		or calling dijit.popup.hide(), or removing it from the page DOM.

		var ds = dijit._dialogStack;

		if(ds[ds.length-1].dialog == dialog){
			// Removing the top (or only) dialog in the stack, return focus
			// to previous dialog

			ds.pop();

			var pd = ds[ds.length-1];	// the new active dialog (or the base page itself)

			// Adjust underlay
			if(ds.length == 1){
				// Returning to original page.
				// Hide the underlay, unless the underlay widget has already been destroyed
				// because we are being called during page unload (when all widgets are destroyed)
				if(!dijit._underlay._destroyed){
					dijit._underlay.hide();
				}
			}else{
				// Popping back to previous dialog, adjust underlay
				dojo.style(dijit._underlay.domNode, 'zIndex', pd.zIndex - 1);
				dijit._underlay.set(pd.underlayAttrs);
			}

			// Adjust focus
			if(dialog.refocus){
				// If we are returning control to a previous dialog but for some reason
				// that dialog didn't have a focused field, set focus to first focusable item.
				// This situation could happen if two dialogs appeared at nearly the same time,
				// since a dialog doesn't set it's focus until the fade-in is finished.
				var focus = pd.focus;
				if(!focus || (pd.dialog && !dojo.isDescendant(focus.node, pd.dialog.domNode))){
					pd.dialog._getFocusItems(pd.dialog.domNode);
					focus = pd.dialog._firstFocusItem;
				}
	
				try{
					dijit.focus(focus);
				}catch(e){
					/* focus() will fail if user opened the dialog by clicking a non-focusable element */
				}
			}
		}else{
			// Removing a dialog out of order (#9944, #10705).
			// Don't need to mess with underlay or z-index or anything.
			var idx = dojo.indexOf(dojo.map(ds, function(elem){return elem.dialog}), dialog);
			if(idx != -1){
				ds.splice(idx, 1);
			}
		}
	},

	isTop: function(/*dijit._Widget*/ dialog){
		// summary:
		//		Returns true if specified Dialog is the top in the task
		var ds = dijit._dialogStack;
		return ds[ds.length-1].dialog == dialog;
	}
};

// Stack representing the various active "levels" on the page, starting with the
// stuff initially visible on the page (at z-index 0), and then having an entry for
// each Dialog shown.
// Each element in stack has form {
//		dialog: dialogWidget,
//		focus: returnFromGetFocus(),
//		underlayAttrs: attributes to set on underlay (when this widget is active)
// }
dijit._dialogStack = [
	{dialog: null, focus: null, underlayAttrs: null}	// entry for stuff at z-index: 0
];

}

if(!dojo._hasResource['bfree.widget.Dialog']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.Dialog'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 06/12/11
 * Time: 8:13 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.Dialog');








dojo.declare('bfree.widget.Dialog', [dijit.Dialog],{
    templateString: null,
	templateString: dojo.cache("bfree/widget", "template/Dialog.html", "<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: _onDialogCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t<div    data-dojo-attach-point=\"containerNode\"\n            class=\"dijitDialogPaneContent\"\n            style=\"overflow:hidden;padding:0 !important;position:absolute;top:0;left:0;height:100% !important;width:100% !important;z-index:-1\">\n\n        <div \tdata-dojo-type=\"dijit.layout.BorderContainer\"\n                data-dojo-props='design:\"headline\",gutters:false,style:\"width:100%;height:100%\"'>\n\n            <div \tdata-dojo-type=\"dijit.layout.ContentPane\"\n                    data-dojo-props='region:\"top\",splitter:false,style:\"height:8px\"'>\n                <!-- buffer for header -->\n\t\t\t</div>\n\n            <div \tdata-dojo-type=\"dijit.layout.BorderContainer\"\n                    data-dojo-attach-point=\"mainWidget\"\n                    data-dojo-props='region:\"center\",splitter:false,design:\"headline\",gutters:false,style:\"width:100%;height:100%\"'>\n\n               <div \tdata-dojo-type=\"dijit.layout.ContentPane\"\n                        data-dojo-props='region:\"center\",splitter:false,style:\"padding:0;overflow:hidden\"'>\n                    <div data-dojo-attach-point=\"widgetNode\" style=\"height:100%;width:100%;\"></div>\n                </div>\n\n                <div \tdata-dojo-attach-point=\"buttonPane\"\n                        data-dojo-type=\"dijit.layout.ContentPane\"\n                        data-dojo-props='region:\"bottom\",splitter:false,style:\"height:36px;padding:0 8px 0 0;text-align:right\"'>\n\n                    <div data-dojo-attach-point=\"btnOkNode\"></div>\n                    <div data-dojo-attach-point=\"btnCancelNode\"></div>\n                    <div data-dojo-attach-point=\"btnCloseNode\"></div>\n\n                </div>\n\n             </div>\n\n        </div>\n\n\t</div>\n    <div data-dojo-attach-point=\"standbyNode\"></div>\n</div>\n"),
    widgetsInTemplate: true,
    widget: null,
    width: 640,
	height: 480,

    shown: false,

    _buttons: [],
    _wdgBusy: null,

    _buildWidget: function(){

        try{

            this.widget = new this.widgetConstructor(this.widgetParams, this.widgetNode);
            this.widget.dialog = this;

            dojo.connect(this.widget, 'onWidgetLoaded', dojo.hitch(this, this._onWidgetLoaded));
            dojo.connect(this.widget, 'onValueChange', dojo.hitch(this, this._onValueChange));
            dojo.connect(this.widget, 'onDialogClose', dojo.hitch(this, this._onClose));

            this.widget.startup();
		    this.widget.focus();
        }
        catch(e){
            this._wdgBusy.hide();
            var err = new bfree.api.Error('Failed to create widget', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this.onLoad();
        }


	},

    _onClose: function(dlg_result){

        var canClose = true;
        //this._wdgBusy.show();

        try{

            this.onClosing();

            if(this.widget){

                canClose = this.widget.onDialogClosing(dlg_result);
                if(canClose){
                    canClose &= this.onClose(dlg_result, this.widget.returnValue);
                }

            }
		}
		catch(e){
			var err = new bfree.api.Error('Failed to close dialog box', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
			canClose = false;
		}

        if(!canClose){
			//this._stbBusy.hide();
		}
        else{
            this.hide();
        }


    },

    _onDialogCancel: function(evt){
        this._onClose(bfree.widget.Dialog.dialogResult.cancel);
	},

    _onShow: function(){
        if(!this.shown){
            var fnRef = bfree.widget.Dialog.buildWidgetFnRef(this);
            setTimeout(fnRef, 100);
            this.shown=true;
        }
	},

    _onValueChange: function(){
		this._setState();
	},

    _onWidgetLoaded: function(){
        this._wdgBusy.hide();
    },

    _setState: function(){
        var isValid = false;

		if(this.widget)
			isValid = this.widget.isValid();
		this._btnOk.set('disabled', !isValid);
    },

    constructor: function(args){

    },

    onClose: function(){
        return true;
    },


    onClosing: function(){

    },

    onHide: function(){
        setTimeout(bfree.widget.Dialog.destroyFnRef(this), this.duration);
    },

    onLoad: function(){

    },

    postCreate: function(){
		this.inherited('postCreate', arguments);

        var vp = dijit.getViewport();
		if(this.height > (vp.h - 8))
			this.height = (vp.h - 8);
		if(this.width > (vp.w - 8))
			this.width = (vp.w - 8);
		this._setStyleAttr({width: this.width + 'px', height: this.height + 'px'});

        this._wdgBusy = new bfree.widget.Standby({
			target: this.mainWidget.domNode,
			color: 'white',
            showOnStart: true,
            opacity: 0.75,
			zIndex: 2048
		}, this.standbyNode);
        this._wdgBusy.startup();
        this._wdgBusy.show();

        if(this.buttons & bfree.widget.Dialog.buttons.ok){
			this._btnOk = new bfree.widget.Button({
				'class': 'versaButton',
				iconClass: 'buttonIcon bfreeIconOk',
				disabledIconClass: 'buttonIcon bfreeIconOkD',
				label: 'OK',
				disabled: true,
				onClick: dojo.hitch(this, this._onClose, bfree.widget.Dialog.dialogResult.ok)
			}, this.btnOkNode);
		};

		if(this.buttons & bfree.widget.Dialog.buttons.cancel){
			new dijit.form.Button({
				'class': 'versaButton',
				iconClass: 'buttonIcon bfreeIconCancel',
                disabledIconClass: 'buttonIcon bfreeIconCancelD',
				label: 'Cancel',
				onClick: dojo.hitch(this, this._onClose, bfree.widget.Dialog.dialogResult.cancel)
			}, this.btnCancelNode);
		};

        if (this.buttons & bfree.widget.Dialog.buttons.close){
			this._buttons.push(
                new bfree.widget.Button({
                    'class': 'versaButton',
                    iconClass: 'buttonIcon bfreeIconClose',
                    disabledIconClass: 'buttonIcon bfreeIconCloseD',
                    label: 'Close',
                    onClick: dojo.hitch(this, this._onClose, bfree.widget.Dialog.dialogResult.cancel)
                }, this.btnCloseNode)
            );

		};

        if(this.buttons == bfree.widget.Dialog.buttons.none){
            dojo.style(this.buttonPane.domNode, {display: 'none'});
        };

        dojo.removeAttr(this.titleBar, 'title');
    },

    resize: function(args){
        this.inherited('resize', arguments);
        this.widget.resize();
        this._position();
    },

    startup: function(){
        this.inherited('startup', arguments);
    }

});

bfree.widget.Dialog.dialogResult = { none: 0, ok: 1, cancel: 2, abort: 3, retry: 4, ignore: 5, yes: 6, no: 7};
bfree.widget.Dialog.buttons = { none: 0, ok: 1, cancel: 2, close: 4};

bfree.widget.Dialog.destroyFnRef = function(dlg){
	return ( function(){
        try{

            if(dlg.widget){
                dlg.widget.destroy();
                dlg.widget = null;
            }

            if(this._wdgBusy){
                dlg._wdgBusy.hide();
                dlg._wdgBusy.destroy();
                dlg._wdgBusy = null;
            }

        dlg.destroy();
      }
      catch(e){
          console.log(e);
      }
	});
};

bfree.widget.Dialog.buildWidgetFnRef = function(dlg){
	return ( function(){
		dlg._buildWidget();
	});
};

}

if(!dojo._hasResource['bfree.widget._Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget._Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 11/10/11
 * Time: 11:37 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget._Grid');



dojo.declare('bfree.widget._Grid', dojox.grid.DataGrid, {

    autoSelect: true,
    noHeader: false,

    //Must override here: seems if grid is in an 'updating' state and revert is called
    //the grid is
    _onRevert: function(){
        this.inherited('_onRevert', arguments);
        if(this.invalidated)
            delete this.invalidated.rowCount;
	},


    constructor: function(args){

    },

    onSelectionChanged: function(){
        this.onSelectedItems(this.selection.getSelected());
    },

    onSelectedItems: function(items){
    },
    onItemClick: function(item){
    },

    postCreate: function(){
        this.inherited(arguments);

    },

    refresh: function(){
        var q = this.query;
        var o = this.queryOptions;
        this.setStore(this.store, q, o );
        this.onSelectedItems(this.selection.getSelected());
    },

    selectItem: function(item){

        this.selection.clear();

		if(item){
			var idx = this.getItemIndex(item);
			this.selection.select(idx);
			this.updateRow();
			//this.scrollToRow(idx);
			this.onRowClick({rowIndex: idx});
		}
		else{
			this.onSelectedItem(null);
		}

	},

    selectItems: function(items, defaultIndex){

        defaultIndex = ((!defaultIndex) || (defaultIndex < 1)) ? 0:  defaultIndex;

        try{
            this.selection._beginUpdate();
            this.selection.clear();
            dojo.forEach(items, function(item, idx){
                this.selection.addToSelection(item);
            }, this);

            //If nothing is selected default
            if(this.selection.getSelectedCount() < 1){
                this.setSelectedIndex(defaultIndex);
            }
        }
        finally{
            this.selection._endUpdate();
        }

    },

    setSelectedIndex: function(idx){

        //validate idx is not greater than number of rows
        while(idx >= this.rowCount)
            idx--;

        //validate idx is not less than 0 or less than min rows
        if((idx < 0) && (this.rowCount <= 0)){
            this.selection.clear(); //selectItem(null);
            this.onSelectedItems([]);
        }
        else{
            //Set to first row if idx invalid
            if(idx < 1) idx = 0

            if(this.selection.isSelected(idx)){
                this.onSelectedItems(this.selection.getSelected());
            }
            else{
                this.selection.select(idx);
            }

        }

    },

    startup: function(){
        this.inherited('startup', arguments);

    },


    _setDeletingAttr: function(deleting){
        this.deleting=deleting;
        if(!this.deleting){
            this.refresh();
        }
    }
});

}

if(!dojo._hasResource["dojo.data.ItemFileWriteStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileWriteStore"] = true;
dojo.provide("dojo.data.ItemFileWriteStore");



dojo.declare("dojo.data.ItemFileWriteStore", dojo.data.ItemFileReadStore, {
	constructor: function(/* object */ keywordParameters){
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  It is serialized assuming object.toString()
		//		serialization.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//			serialize:	function(object) //The function that converts the object back into the proper file format form.
		//		}

		// ItemFileWriteStore extends ItemFileReadStore to implement these additional dojo.data APIs
		this._features['dojo.data.api.Write'] = true;
		this._features['dojo.data.api.Notification'] = true;
		
		// For keeping track of changes so that we can implement isDirty and revert
		this._pending = {
			_newItems:{},
			_modifiedItems:{},
			_deletedItems:{}
		};

		if(!this._datatypeMap['Date'].serialize){
			this._datatypeMap['Date'].serialize = function(obj){
				return dojo.date.stamp.toISOString(obj, {zulu:true});
			};
		}
		//Disable only if explicitly set to false.
		if(keywordParameters && (keywordParameters.referenceIntegrity === false)){
			this.referenceIntegrity = false;
		}

		// this._saveInProgress is set to true, briefly, from when save() is first called to when it completes
		this._saveInProgress = false;
	},

	referenceIntegrity: true, //Flag that defaultly enabled reference integrity tracking.  This way it can also be disabled pogrammatially or declaratively.

	_assert: function(/* boolean */ condition){
		if(!condition){
			throw new Error("assertion failed in ItemFileWriteStore");
		}
	},

	_getIdentifierAttribute: function(){
		var identifierAttribute = this.getFeatures()['dojo.data.api.Identity'];
		// this._assert((identifierAttribute === Number) || (dojo.isString(identifierAttribute)));
		return identifierAttribute;
	},
	
	
/* dojo.data.api.Write */

	newItem: function(/* Object? */ keywordArgs, /* Object? */ parentInfo){
		// summary: See dojo.data.api.Write.newItem()

		this._assert(!this._saveInProgress);

		if(!this._loadFinished){
			// We need to do this here so that we'll be able to find out what
			// identifierAttribute was specified in the data file.
			this._forceLoad();
		}

		if(typeof keywordArgs != "object" && typeof keywordArgs != "undefined"){
			throw new Error("newItem() was passed something other than an object");
		}
		var newIdentity = null;
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute === Number){
			newIdentity = this._arrayOfAllItems.length;
		}else{
			newIdentity = keywordArgs[identifierAttribute];
			if(typeof newIdentity === "undefined"){
				throw new Error("newItem() was not passed an identity for the new item");
			}
			if(dojo.isArray(newIdentity)){
				throw new Error("newItem() was not passed an single-valued identity");
			}
		}
		
		// make sure this identity is not already in use by another item, if identifiers were
		// defined in the file.  Otherwise it would be the item count,
		// which should always be unique in this case.
		if(this._itemsByIdentity){
			this._assert(typeof this._itemsByIdentity[newIdentity] === "undefined");
		}
		this._assert(typeof this._pending._newItems[newIdentity] === "undefined");
		this._assert(typeof this._pending._deletedItems[newIdentity] === "undefined");
		
		var newItem = {};
		newItem[this._storeRefPropName] = this;
		newItem[this._itemNumPropName] = this._arrayOfAllItems.length;
		if(this._itemsByIdentity){
			this._itemsByIdentity[newIdentity] = newItem;
			//We have to set the identifier now, otherwise we can't look it
			//up at calls to setValueorValues in parentInfo handling.
			newItem[identifierAttribute] = [newIdentity];
		}
		this._arrayOfAllItems.push(newItem);

		//We need to construct some data for the onNew call too...
		var pInfo = null;
		
		// Now we need to check to see where we want to assign this thingm if any.
		if(parentInfo && parentInfo.parent && parentInfo.attribute){
			pInfo = {
				item: parentInfo.parent,
				attribute: parentInfo.attribute,
				oldValue: undefined
			};

			//See if it is multi-valued or not and handle appropriately
			//Generally, all attributes are multi-valued for this store
			//So, we only need to append if there are already values present.
			var values = this.getValues(parentInfo.parent, parentInfo.attribute);
			if(values && values.length > 0){
				var tempValues = values.slice(0, values.length);
				if(values.length === 1){
					pInfo.oldValue = values[0];
				}else{
					pInfo.oldValue = values.slice(0, values.length);
				}
				tempValues.push(newItem);
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, tempValues, false);
				pInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);
			}else{
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, newItem, false);
				pInfo.newValue = newItem;
			}
		}else{
			//Toplevel item, add to both top list as well as all list.
			newItem[this._rootItemPropName]=true;
			this._arrayOfTopLevelItems.push(newItem);
		}
		
		this._pending._newItems[newIdentity] = newItem;
		
		//Clone over the properties to the new item
		for(var key in keywordArgs){
			if(key === this._storeRefPropName || key === this._itemNumPropName){
				// Bummer, the user is trying to do something like
				// newItem({_S:"foo"}).  Unfortunately, our superclass,
				// ItemFileReadStore, is already using _S in each of our items
				// to hold private info.  To avoid a naming collision, we
				// need to move all our private info to some other property
				// of all the items/objects.  So, we need to iterate over all
				// the items and do something like:
				//    item.__S = item._S;
				//    item._S = undefined;
				// But first we have to make sure the new "__S" variable is
				// not in use, which means we have to iterate over all the
				// items checking for that.
				throw new Error("encountered bug in ItemFileWriteStore.newItem");
			}
			var value = keywordArgs[key];
			if(!dojo.isArray(value)){
				value = [value];
			}
			newItem[key] = value;
			if(this.referenceIntegrity){
				for(var i = 0; i < value.length; i++){
					var val = value[i];
					if(this.isItem(val)){
						this._addReferenceToMap(val, newItem, key);
					}
				}
			}
		}
		this.onNew(newItem, pInfo); // dojo.data.api.Notification call
		return newItem; // item
	},
	
	_removeArrayElement: function(/* Array */ array, /* anything */ element){
		var index = dojo.indexOf(array, element);
		if(index != -1){
			array.splice(index, 1);
			return true;
		}
		return false;
	},
	
	deleteItem: function(/* item */ item){
		// summary: See dojo.data.api.Write.deleteItem()
		this._assert(!this._saveInProgress);
		this._assertIsItem(item);

		// Remove this item from the _arrayOfAllItems, but leave a null value in place
		// of the item, so as not to change the length of the array, so that in newItem()
		// we can still safely do: newIdentity = this._arrayOfAllItems.length;
		var indexInArrayOfAllItems = item[this._itemNumPropName];
		var identity = this.getIdentity(item);

		//If we have reference integrity on, we need to do reference cleanup for the deleted item
		if(this.referenceIntegrity){
			//First scan all the attributes of this items for references and clean them up in the map
			//As this item is going away, no need to track its references anymore.

			//Get the attributes list before we generate the backup so it
			//doesn't pollute the attributes list.
			var attributes = this.getAttributes(item);

			//Backup the map, we'll have to restore it potentially, in a revert.
			if(item[this._reverseRefMap]){
				item["backup_" + this._reverseRefMap] = dojo.clone(item[this._reverseRefMap]);
			}
			
			//TODO:  This causes a reversion problem.  This list won't be restored on revert since it is
			//attached to the 'value'. item, not ours.  Need to back tese up somehow too.
			//Maybe build a map of the backup of the entries and attach it to the deleted item to be restored
			//later.  Or just record them and call _addReferenceToMap on them in revert.
			dojo.forEach(attributes, function(attribute){
				dojo.forEach(this.getValues(item, attribute), function(value){
					if(this.isItem(value)){
						//We have to back up all the references we had to others so they can be restored on a revert.
						if(!item["backupRefs_" + this._reverseRefMap]){
							item["backupRefs_" + this._reverseRefMap] = [];
						}
						item["backupRefs_" + this._reverseRefMap].push({id: this.getIdentity(value), attr: attribute});
						this._removeReferenceFromMap(value, item, attribute);
					}
				}, this);
			}, this);

			//Next, see if we have references to this item, if we do, we have to clean them up too.
			var references = item[this._reverseRefMap];
			if(references){
				//Look through all the items noted as references to clean them up.
				for(var itemId in references){
					var containingItem = null;
					if(this._itemsByIdentity){
						containingItem = this._itemsByIdentity[itemId];
					}else{
						containingItem = this._arrayOfAllItems[itemId];
					}
					//We have a reference to a containing item, now we have to process the
					//attributes and clear all references to the item being deleted.
					if(containingItem){
						for(var attribute in references[itemId]){
							var oldValues = this.getValues(containingItem, attribute) || [];
							var newValues = dojo.filter(oldValues, function(possibleItem){
								return !(this.isItem(possibleItem) && this.getIdentity(possibleItem) == identity);
							}, this);
							//Remove the note of the reference to the item and set the values on the modified attribute.
							this._removeReferenceFromMap(item, containingItem, attribute);
							if(newValues.length < oldValues.length){
								this._setValueOrValues(containingItem, attribute, newValues, true);
							}
						}
					}
				}
			}
		}

		this._arrayOfAllItems[indexInArrayOfAllItems] = null;

		item[this._storeRefPropName] = null;
		if(this._itemsByIdentity){
			delete this._itemsByIdentity[identity];
		}
		this._pending._deletedItems[identity] = item;
		
		//Remove from the toplevel items, if necessary...
		if(item[this._rootItemPropName]){
			this._removeArrayElement(this._arrayOfTopLevelItems, item);
		}
		this.onDelete(item); // dojo.data.api.Notification call
		return true;
	},

	setValue: function(/* item */ item, /* attribute-name-string */ attribute, /* almost anything */ value){
		// summary: See dojo.data.api.Write.set()
		return this._setValueOrValues(item, attribute, value, true); // boolean
	},
	
	setValues: function(/* item */ item, /* attribute-name-string */ attribute, /* array */ values){
		// summary: See dojo.data.api.Write.setValues()
		return this._setValueOrValues(item, attribute, values, true); // boolean
	},
	
	unsetAttribute: function(/* item */ item, /* attribute-name-string */ attribute){
		// summary: See dojo.data.api.Write.unsetAttribute()
		return this._setValueOrValues(item, attribute, [], true);
	},
	
	_setValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ newValueOrValues, /*boolean?*/ callOnSet){
		this._assert(!this._saveInProgress);
		
		// Check for valid arguments
		this._assertIsItem(item);
		this._assert(dojo.isString(attribute));
		this._assert(typeof newValueOrValues !== "undefined");

		// Make sure the user isn't trying to change the item's identity
		var identifierAttribute = this._getIdentifierAttribute();
		if(attribute == identifierAttribute){
			throw new Error("ItemFileWriteStore does not have support for changing the value of an item's identifier.");
		}

		// To implement the Notification API, we need to make a note of what
		// the old attribute value was, so that we can pass that info when
		// we call the onSet method.
		var oldValueOrValues = this._getValueOrValues(item, attribute);

		var identity = this.getIdentity(item);
		if(!this._pending._modifiedItems[identity]){
			// Before we actually change the item, we make a copy of it to
			// record the original state, so that we'll be able to revert if
			// the revert method gets called.  If the item has already been
			// modified then there's no need to do this now, since we already
			// have a record of the original state.
			var copyOfItemState = {};
			for(var key in item){
				if((key === this._storeRefPropName) || (key === this._itemNumPropName) || (key === this._rootItemPropName)){
					copyOfItemState[key] = item[key];
				}else if(key === this._reverseRefMap){
					copyOfItemState[key] = dojo.clone(item[key]);
				}else{
					copyOfItemState[key] = item[key].slice(0, item[key].length);
				}
			}
			// Now mark the item as dirty, and save the copy of the original state
			this._pending._modifiedItems[identity] = copyOfItemState;
		}
		
		// Okay, now we can actually change this attribute on the item
		var success = false;
		
		if(dojo.isArray(newValueOrValues) && newValueOrValues.length === 0){
			
			// If we were passed an empty array as the value, that counts
			// as "unsetting" the attribute, so we need to remove this
			// attribute from the item.
			success = delete item[attribute];
			newValueOrValues = undefined; // used in the onSet Notification call below

			if(this.referenceIntegrity && oldValueOrValues){
				var oldValues = oldValueOrValues;
				if(!dojo.isArray(oldValues)){
					oldValues = [oldValues];
				}
				for(var i = 0; i < oldValues.length; i++){
					var value = oldValues[i];
					if(this.isItem(value)){
						this._removeReferenceFromMap(value, item, attribute);
					}
				}
			}
		}else{
			var newValueArray;
			if(dojo.isArray(newValueOrValues)){
				var newValues = newValueOrValues;
				// Unfortunately, it's not safe to just do this:
				//    newValueArray = newValues;
				// Instead, we need to copy the array, which slice() does very nicely.
				// This is so that our internal data structure won't
				// get corrupted if the user mucks with the values array *after*
				// calling setValues().
				newValueArray = newValueOrValues.slice(0, newValueOrValues.length);
			}else{
				newValueArray = [newValueOrValues];
			}

			//We need to handle reference integrity if this is on.
			//In the case of set, we need to see if references were added or removed
			//and update the reference tracking map accordingly.
			if(this.referenceIntegrity){
				if(oldValueOrValues){
					var oldValues = oldValueOrValues;
					if(!dojo.isArray(oldValues)){
						oldValues = [oldValues];
					}
					//Use an associative map to determine what was added/removed from the list.
					//Should be O(n) performant.  First look at all the old values and make a list of them
					//Then for any item not in the old list, we add it.  If it was already present, we remove it.
					//Then we pass over the map and any references left it it need to be removed (IE, no match in
					//the new values list).
					var map = {};
					dojo.forEach(oldValues, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							map[id.toString()] = true;
						}
					}, this);
					dojo.forEach(newValueArray, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							if(map[id.toString()]){
								delete map[id.toString()];
							}else{
								this._addReferenceToMap(possibleItem, item, attribute);
							}
						}
					}, this);
					for(var rId in map){
						var removedItem;
						if(this._itemsByIdentity){
							removedItem = this._itemsByIdentity[rId];
						}else{
							removedItem = this._arrayOfAllItems[rId];
						}
						this._removeReferenceFromMap(removedItem, item, attribute);
					}
				}else{
					//Everything is new (no old values) so we have to just
					//insert all the references, if any.
					for(var i = 0; i < newValueArray.length; i++){
						var value = newValueArray[i];
						if(this.isItem(value)){
							this._addReferenceToMap(value, item, attribute);
						}
					}
				}
			}
			item[attribute] = newValueArray;
			success = true;
		}

		// Now we make the dojo.data.api.Notification call
		if(callOnSet){
			this.onSet(item, attribute, oldValueOrValues, newValueOrValues);
		}
		return success; // boolean
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		//	summary:
		//		Method to add an reference map entry for an item and attribute.
		//	description:
		//		Method to add an reference map entry for an item and attribute. 		 //
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item that holds the new reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the new reference.
		 
		var parentId = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];

		if(!references){
			references = refItem[this._reverseRefMap] = {};
		}
		var itemRef = references[parentId];
		if(!itemRef){
			itemRef = references[parentId] = {};
		}
		itemRef[attribute] = true;
	},

	_removeReferenceFromMap: function(/* item */ refItem, /* item */ parentItem, /*strin*/ attribute){
		//	summary:
		//		Method to remove an reference map entry for an item and attribute.
		//	description:
		//		Method to remove an reference map entry for an item and attribute.  This will
		//		also perform cleanup on the map such that if there are no more references at all to
		//		the item, its reference object and entry are removed.
		//
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item holding a reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the reference.
		var identity = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];
		var itemId;
		if(references){
			for(itemId in references){
				if(itemId == identity){
					delete references[itemId][attribute];
					if(this._isEmpty(references[itemId])){
						delete references[itemId];
					}
				}
			}
			if(this._isEmpty(references)){
				delete refItem[this._reverseRefMap];
			}
		}
	},

	_dumpReferenceMap: function(){
		//	summary:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		//	description:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		var i;
		for(i = 0; i < this._arrayOfAllItems.length; i++){
			var item = this._arrayOfAllItems[i];
			if(item && item[this._reverseRefMap]){
				console.log("Item: [" + this.getIdentity(item) + "] is referenced by: " + dojo.toJson(item[this._reverseRefMap]));
			}
		}
	},
	
	_getValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute){
		var valueOrValues = undefined;
		if(this.hasAttribute(item, attribute)){
			var valueArray = this.getValues(item, attribute);
			if(valueArray.length == 1){
				valueOrValues = valueArray[0];
			}else{
				valueOrValues = valueArray;
			}
		}
		return valueOrValues;
	},
	
	_flatten: function(/* anything */ value){
		if(this.isItem(value)){
			var item = value;
			// Given an item, return an serializable object that provides a
			// reference to the item.
			// For example, given kermit:
			//    var kermit = store.newItem({id:2, name:"Kermit"});
			// we want to return
			//    {_reference:2}
			var identity = this.getIdentity(item);
			var referenceObject = {_reference: identity};
			return referenceObject;
		}else{
			if(typeof value === "object"){
				for(var type in this._datatypeMap){
					var typeMap = this._datatypeMap[type];
					if(dojo.isObject(typeMap) && !dojo.isFunction(typeMap)){
						if(value instanceof typeMap.type){
							if(!typeMap.serialize){
								throw new Error("ItemFileWriteStore:  No serializer defined for type mapping: [" + type + "]");
							}
							return {_type: type, _value: typeMap.serialize(value)};
						}
					} else if(value instanceof typeMap){
						//SImple mapping, therefore, return as a toString serialization.
						return {_type: type, _value: value.toString()};
					}
				}
			}
			return value;
		}
	},
	
	_getNewFileContentString: function(){
		// summary:
		//		Generate a string that can be saved to a file.
		//		The result should look similar to:
		//		http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json
		var serializableStructure = {};
		
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute !== Number){
			serializableStructure.identifier = identifierAttribute;
		}
		if(this._labelAttr){
			serializableStructure.label = this._labelAttr;
		}
		serializableStructure.items = [];
		for(var i = 0; i < this._arrayOfAllItems.length; ++i){
			var item = this._arrayOfAllItems[i];
			if(item !== null){
				var serializableItem = {};
				for(var key in item){
					if(key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName){
						var attribute = key;
						var valueArray = this.getValues(item, attribute);
						if(valueArray.length == 1){
							serializableItem[attribute] = this._flatten(valueArray[0]);
						}else{
							var serializableArray = [];
							for(var j = 0; j < valueArray.length; ++j){
								serializableArray.push(this._flatten(valueArray[j]));
								serializableItem[attribute] = serializableArray;
							}
						}
					}
				}
				serializableStructure.items.push(serializableItem);
			}
		}
		var prettyPrint = true;
		return dojo.toJson(serializableStructure, prettyPrint);
	},

	_isEmpty: function(something){
		//	summary:
		//		Function to determine if an array or object has no properties or values.
		//	something:
		//		The array or object to examine.
		var empty = true;
		if(dojo.isObject(something)){
			var i;
			for(i in something){
				empty = false;
				break;
			}
		}else if(dojo.isArray(something)){
			if(something.length > 0){
				empty = false;
			}
		}
		return empty; //boolean
	},
	
	save: function(/* object */ keywordArgs){
		// summary: See dojo.data.api.Write.save()
		this._assert(!this._saveInProgress);
		
		// this._saveInProgress is set to true, briefly, from when save is first called to when it completes
		this._saveInProgress = true;
		
		var self = this;
		var saveCompleteCallback = function(){
			self._pending = {
				_newItems:{},
				_modifiedItems:{},
				_deletedItems:{}
			};

			self._saveInProgress = false; // must come after this._pending is cleared, but before any callbacks
			if(keywordArgs && keywordArgs.onComplete){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onComplete.call(scope);
			}
		};
		var saveFailedCallback = function(err){
			self._saveInProgress = false;
			if(keywordArgs && keywordArgs.onError){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onError.call(scope, err);
			}
		};
		
		if(this._saveEverything){
			var newFileContentString = this._getNewFileContentString();
			this._saveEverything(saveCompleteCallback, saveFailedCallback, newFileContentString);
		}
		if(this._saveCustom){
			this._saveCustom(saveCompleteCallback, saveFailedCallback);
		}
		if(!this._saveEverything && !this._saveCustom){
			// Looks like there is no user-defined save-handler function.
			// That's fine, it just means the datastore is acting as a "mock-write"
			// store -- changes get saved in memory but don't get saved to disk.
			saveCompleteCallback();
		}
	},
	
	revert: function(){
		// summary: See dojo.data.api.Write.revert()
		this._assert(!this._saveInProgress);

		var identity;
		for(identity in this._pending._modifiedItems){
			// find the original item and the modified item that replaced it
			var copyOfItemState = this._pending._modifiedItems[identity];
			var modifiedItem = null;
			if(this._itemsByIdentity){
				modifiedItem = this._itemsByIdentity[identity];
			}else{
				modifiedItem = this._arrayOfAllItems[identity];
			}
	
			// Restore the original item into a full-fledged item again, we want to try to
			// keep the same object instance as if we don't it, causes bugs like #9022.
			copyOfItemState[this._storeRefPropName] = this;
			for(key in modifiedItem){
				delete modifiedItem[key];
			}
			dojo.mixin(modifiedItem, copyOfItemState);
		}
		var deletedItem;
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			deletedItem[this._storeRefPropName] = this;
			var index = deletedItem[this._itemNumPropName];

			//Restore the reverse refererence map, if any.
			if(deletedItem["backup_" + this._reverseRefMap]){
				deletedItem[this._reverseRefMap] = deletedItem["backup_" + this._reverseRefMap];
				delete deletedItem["backup_" + this._reverseRefMap];
			}
			this._arrayOfAllItems[index] = deletedItem;
			if(this._itemsByIdentity){
				this._itemsByIdentity[identity] = deletedItem;
			}
			if(deletedItem[this._rootItemPropName]){
				this._arrayOfTopLevelItems.push(deletedItem);
			}
		}
		//We have to pass through it again and restore the reference maps after all the
		//undeletes have occurred.
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			if(deletedItem["backupRefs_" + this._reverseRefMap]){
				dojo.forEach(deletedItem["backupRefs_" + this._reverseRefMap], function(reference){
					var refItem;
					if(this._itemsByIdentity){
						refItem = this._itemsByIdentity[reference.id];
					}else{
						refItem = this._arrayOfAllItems[reference.id];
					}
					this._addReferenceToMap(refItem, deletedItem, reference.attr);
				}, this);
				delete deletedItem["backupRefs_" + this._reverseRefMap];
			}
		}

		for(identity in this._pending._newItems){
			var newItem = this._pending._newItems[identity];
			newItem[this._storeRefPropName] = null;
			// null out the new item, but don't change the array index so
			// so we can keep using _arrayOfAllItems.length.
			this._arrayOfAllItems[newItem[this._itemNumPropName]] = null;
			if(newItem[this._rootItemPropName]){
				this._removeArrayElement(this._arrayOfTopLevelItems, newItem);
			}
			if(this._itemsByIdentity){
				delete this._itemsByIdentity[identity];
			}
		}

		this._pending = {
			_newItems:{},
			_modifiedItems:{},
			_deletedItems:{}
		};
		return true; // boolean
	},
	
	isDirty: function(/* item? */ item){
		// summary: See dojo.data.api.Write.isDirty()
		if(item){
			// return true if the item is dirty
			var identity = this.getIdentity(item);
			return new Boolean(this._pending._newItems[identity] ||
				this._pending._modifiedItems[identity] ||
				this._pending._deletedItems[identity]).valueOf(); // boolean
		}else{
			// return true if the store is dirty -- which means return true
			// if there are any new items, dirty items, or modified items
			if(!this._isEmpty(this._pending._newItems) ||
				!this._isEmpty(this._pending._modifiedItems) ||
				!this._isEmpty(this._pending._deletedItems)){
				return true;
			}
			return false; // boolean
		}
	},

/* dojo.data.api.Notification */

	onSet: function(/* item */ item,
					/*attribute-name-string*/ attribute,
					/*object | array*/ oldValue,
					/*object | array*/ newValue){
		// summary: See dojo.data.api.Notification.onSet()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	onNew: function(/* item */ newItem, /*object?*/ parentInfo){
		// summary: See dojo.data.api.Notification.onNew()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	onDelete: function(/* item */ deletedItem){
		// summary: See dojo.data.api.Notification.onDelete()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	close: function(/* object? */ request){
		 // summary:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 // description:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 //		If the store is still dirty (unsaved changes), then an error will be thrown instead of
		 //		clearing the internal state for reload from the url.

		 //Clear if not dirty ... or throw an error
		 if(this.clearOnClose){
			 if(!this.isDirty()){
				 this.inherited(arguments);
			 }else{
				 //Only throw an error if the store was dirty and we were loading from a url (cannot reload from url until state is saved).
				 throw new Error("dojo.data.ItemFileWriteStore: There are unsaved changes present in the store.  Please save or revert the changes before invoking close.");
			 }
		 }
	}
});

}

if(!dojo._hasResource["dijit._TimePicker"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._TimePicker"] = true;
dojo.provide("dijit._TimePicker");




/*=====
dojo.declare(
	"dijit._TimePicker.__Constraints",
	dojo.date.locale.__FormatOptions,
	{
		// clickableIncrement: String
		//		See `dijit._TimePicker.clickableIncrement`
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		See `dijit._TimePicker.visibleIncrement`
		visibleIncrement: "T01:00:00",

		// visibleRange: String
		//		See `dijit._TimePicker.visibleRange`
		visibleRange: "T05:00:00"
	}
);
=====*/

dojo.declare("dijit._TimePicker",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		A graphical time picker.
		//		This widget is used internally by other widgets and is not available
		//		as a standalone widget due to lack of accessibility support.

		templateString: dojo.cache("dijit", "templates/TimePicker.html", "<div id=\"widget_${id}\" class=\"dijitMenu\"\n    ><div dojoAttachPoint=\"upArrow\" class=\"dijitButtonNode dijitUpArrowButton\" dojoAttachEvent=\"onmouseenter:_buttonMouse,onmouseleave:_buttonMouse\"\n\t\t><div class=\"dijitReset dijitInline dijitArrowButtonInner\" role=\"presentation\">&nbsp;</div\n\t\t><div class=\"dijitArrowButtonChar\">&#9650;</div></div\n    ><div dojoAttachPoint=\"timeMenu,focusNode\" dojoAttachEvent=\"onclick:_onOptionSelected,onmouseover,onmouseout\"></div\n    ><div dojoAttachPoint=\"downArrow\" class=\"dijitButtonNode dijitDownArrowButton\" dojoAttachEvent=\"onmouseenter:_buttonMouse,onmouseleave:_buttonMouse\"\n\t\t><div class=\"dijitReset dijitInline dijitArrowButtonInner\" role=\"presentation\">&nbsp;</div\n\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div></div\n></div>\n"),

		// baseClass: [protected] String
		//		The root className to use for the various states of this widget
		baseClass: "dijitTimePicker",

		// clickableIncrement: String
		//		ISO-8601 string representing the amount by which
		//		every clickable element in the time picker increases.
		//		Set in local time, without a time zone.
		//		Example: `T00:15:00` creates 15 minute increments
		//		Must divide dijit._TimePicker.visibleIncrement evenly
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		ISO-8601 string representing the amount by which
		//		every element with a visible time in the time picker increases.
		//		Set in local time, without a time zone.
		//		Example: `T01:00:00` creates text in every 1 hour increment
		visibleIncrement: "T01:00:00",

		// visibleRange: String
		//		ISO-8601 string representing the range of this TimePicker.
		//		The TimePicker will only display times in this range.
		//		Example: `T05:00:00` displays 5 hours of options
		visibleRange: "T05:00:00",

		// value: String
		//		Date to display.
		//		Defaults to current time and date.
		//		Can be a Date object or an ISO-8601 string.
		//		If you specify the GMT time zone (`-01:00`),
		//		the time will be converted to the local time in the local time zone.
		//		Otherwise, the time is considered to be in the local time zone.
		//		If you specify the date and isDate is true, the date is used.
		//		Example: if your local time zone is `GMT -05:00`,
		//		`T10:00:00` becomes `T10:00:00-05:00` (considered to be local time),
		//		`T10:00:00-01:00` becomes `T06:00:00-05:00` (4 hour difference),
		//		`T10:00:00Z` becomes `T05:00:00-05:00` (5 hour difference between Zulu and local time)
		//		`yyyy-mm-ddThh:mm:ss` is the format to set the date and time
		//		Example: `2007-06-01T09:00:00`
		value: new Date(),

		_visibleIncrement:2,
		_clickableIncrement:1,
		_totalIncrements:10,

		// constraints: dijit._TimePicker.__Constraints
		//		Specifies valid range of times (start time, end time)
		constraints:{},

/*=====
		serialize: function(val, options){
			// summary:
			//		User overridable function used to convert the attr('value') result to a String
			// val: Date
			//		The current value
			// options: Object?
			// tags:
			//		protected
		},
=====*/
		serialize: dojo.date.stamp.toISOString,

/*=====
		// filterString: string
		//		The string to filter by
		filterString: "",
=====*/

		setValue: function(/*Date*/ value){
			// summary:
			//		Deprecated.  Used set('value') instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit._TimePicker:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_setValueAttr: function(/*Date*/ date){
			// summary:
			//		Hook so set('value', ...) works.
			// description:
			//		Set the value of the TimePicker.
			//		Redraws the TimePicker around the new date.
			// tags:
			//		protected
			this._set("value", date);
			this._showText();
		},

		_setFilterStringAttr: function(val){
			// summary:
			//		Called by TimeTextBox to filter the values shown in my list
			this._set("filterString", val);
			this._showText();
		},

		isDisabledDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to disable certain dates in the TimePicker e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// type:
			//		extension
			return false; // Boolean
		},

		_getFilteredNodes: function(/*number*/ start, /*number*/ maxNum, /*Boolean*/ before, /*DOMnode*/ lastNode){
			// summary:
			//		Returns an array of nodes with the filter applied.  At most maxNum nodes
			//		will be returned - but fewer may be returned as well.  If the
			//		before parameter is set to true, then it will return the elements
			//		before the given index
			// tags:
			//		private
			var
				nodes = [],
				lastValue = lastNode ? lastNode.date : this._refDate,
				n,
				i = start,
				max = this._maxIncrement + Math.abs(i),
				chk = before ? -1 : 1,
				dec = before ? 1 : 0,
				inc = 1 - dec;
			do{
				i = i - dec;
				n = this._createOption(i);
				if(n){
					if((before && n.date > lastValue) || (!before && n.date < lastValue)){
						break; // don't wrap
					}
					nodes[before ? "unshift" : "push"](n);
					lastValue = n.date;
				}
				i = i + inc;
			}while(nodes.length < maxNum && (i*chk) < max);
			return nodes;
		},

		_showText: function(){
			// summary:
			//		Displays the relevant choices in the drop down list
			// tags:
			//		private
			var fromIso = dojo.date.stamp.fromISOString;
			this.timeMenu.innerHTML = "";
			this._clickableIncrementDate=fromIso(this.clickableIncrement);
			this._visibleIncrementDate=fromIso(this.visibleIncrement);
			this._visibleRangeDate=fromIso(this.visibleRange);
			// get the value of the increments and the range in seconds (since 00:00:00) to find out how many divs to create
			var
				sinceMidnight = function(/*Date*/ date){
				return date.getHours() * 60 * 60 + date.getMinutes() * 60 + date.getSeconds();
				},
				clickableIncrementSeconds = sinceMidnight(this._clickableIncrementDate),
				visibleIncrementSeconds = sinceMidnight(this._visibleIncrementDate),
				visibleRangeSeconds = sinceMidnight(this._visibleRangeDate),

			// round reference date to previous visible increment
				time = (this.value || this.currentFocus).getTime();

			this._refDate = new Date(time - time % (visibleIncrementSeconds*1000));
			this._refDate.setFullYear(1970,0,1); // match parse defaults

			// assume clickable increment is the smallest unit
			this._clickableIncrement = 1;
			// divide the visible range by the clickable increment to get the number of divs to create
			// example: 10:00:00/00:15:00 -> display 40 divs
			this._totalIncrements = visibleRangeSeconds / clickableIncrementSeconds;
			// divide the visible increments by the clickable increments to get how often to display the time inline
			// example: 01:00:00/00:15:00 -> display the time every 4 divs
			this._visibleIncrement = visibleIncrementSeconds / clickableIncrementSeconds;
			// divide the number of seconds in a day by the clickable increment in seconds to get the
			// absolute max number of increments.
			this._maxIncrement = (60 * 60 * 24) / clickableIncrementSeconds;

			var
				// Find the nodes we should display based on our filter.
				// Limit to 10 nodes displayed as a half-hearted attempt to stop drop down from overlapping <input>.
				after = this._getFilteredNodes(0, Math.min(this._totalIncrements >> 1, 10) - 1),
				before = this._getFilteredNodes(0, Math.min(this._totalIncrements, 10) - after.length, true, after[0]);
			dojo.forEach(before.concat(after), function(n){this.timeMenu.appendChild(n);}, this);
		},

		constructor: function(){
			this.constraints = {}; // create instance object
		},

		postMixInProperties: function(){
		        this.inherited(arguments);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls
		},

		_setConstraintsAttr: function(/* Object */ constraints){
			// brings in visibleRange, increments, etc.
			dojo.mixin(this, constraints);

			// dojo.date.locale needs the lang in the constraints as locale
			if(!constraints.locale){
				constraints.locale = this.lang;
			}
		},

		postCreate: function(){
			// assign typematic mouse listeners to the arrow buttons
			this.connect(this.timeMenu, dojo.isIE ? "onmousewheel" : 'DOMMouseScroll', "_mouseWheeled");
			this._connects.push(dijit.typematic.addMouseListener(this.upArrow, this, "_onArrowUp", 33, 250));
			this._connects.push(dijit.typematic.addMouseListener(this.downArrow, this, "_onArrowDown", 33, 250));

			this.inherited(arguments);
		},

		_buttonMouse: function(/*Event*/ e){
			// summary:
			//		Handler for hover (and unhover) on up/down arrows
			// tags:
			//		private

			// in non-IE browser the "mouseenter" event will become "mouseover",
			// but in IE it's still "mouseenter"
			dojo.toggleClass(e.currentTarget, e.currentTarget == this.upArrow ? "dijitUpArrowHover" : "dijitDownArrowHover",
				e.type == "mouseenter" || e.type == "mouseover");
		},

		_createOption: function(/*Number*/ index){
			// summary:
			//		Creates a clickable time option
			// tags:
			//		private
			var date = new Date(this._refDate);
			var incrementDate = this._clickableIncrementDate;
			date.setHours(date.getHours() + incrementDate.getHours() * index,
				date.getMinutes() + incrementDate.getMinutes() * index,
				date.getSeconds() + incrementDate.getSeconds() * index);
			if(this.constraints.selector == "time"){
				date.setFullYear(1970,0,1); // make sure each time is for the same date
			}
			var dateString = dojo.date.locale.format(date, this.constraints);
			if(this.filterString && dateString.toLowerCase().indexOf(this.filterString) !== 0){
				// Doesn't match the filter - return null
				return null;
			}

			var div = dojo.create("div", {"class": this.baseClass+"Item"});
			div.date = date;
			div.index = index;
			dojo.create('div',{
				"class": this.baseClass + "ItemInner",
				innerHTML: dateString
			}, div);

			if(index%this._visibleIncrement<1 && index%this._visibleIncrement>-1){
				dojo.addClass(div, this.baseClass+"Marker");
			}else if(!(index%this._clickableIncrement)){
				dojo.addClass(div, this.baseClass+"Tick");
			}

			if(this.isDisabledDate(date)){
				// set disabled
				dojo.addClass(div, this.baseClass+"ItemDisabled");
			}
			if(this.value && !dojo.date.compare(this.value, date, this.constraints.selector)){
				div.selected = true;
				dojo.addClass(div, this.baseClass+"ItemSelected");
				if(dojo.hasClass(div, this.baseClass+"Marker")){
					dojo.addClass(div, this.baseClass+"MarkerSelected");
				}else{
					dojo.addClass(div, this.baseClass+"TickSelected");
				}

				// Initially highlight the current value.   User can change highlight by up/down arrow keys
				// or mouse movement.
				this._highlightOption(div, true);
			}
			return div;
		},

		_onOptionSelected: function(/*Object*/ tgt){
			// summary:
			//		Called when user clicks an option in the drop down list
			// tags:
			//		private
			var tdate = tgt.target.date || tgt.target.parentNode.date;
			if(!tdate || this.isDisabledDate(tdate)){ return; }
			this._highlighted_option = null;
			this.set('value', tdate);
			this.onChange(tdate);
		},

		onChange: function(/*Date*/ time){
			// summary:
			//		Notification that a time was selected.  It may be the same as the previous value.
			// tags:
			//      public
		},

		_highlightOption: function(/*node*/ node, /*Boolean*/ highlight){
			// summary:
			//		Turns on/off highlight effect on a node based on mouse out/over event
			// tags:
			//		private
			if(!node){return;}
			if(highlight){
				if(this._highlighted_option){
					this._highlightOption(this._highlighted_option, false);
				}
				this._highlighted_option = node;
			}else if(this._highlighted_option !== node){
				return;
			}else{
				this._highlighted_option = null;
			}
			dojo.toggleClass(node, this.baseClass+"ItemHover", highlight);
			if(dojo.hasClass(node, this.baseClass+"Marker")){
				dojo.toggleClass(node, this.baseClass+"MarkerHover", highlight);
			}else{
				dojo.toggleClass(node, this.baseClass+"TickHover", highlight);
			}
		},

		onmouseover: function(/*Event*/ e){
			// summary:
			//		Handler for onmouseover event
			// tags:
			//		private
			this._keyboardSelected = null;
			var tgr = (e.target.parentNode === this.timeMenu) ? e.target : e.target.parentNode;
			// if we aren't targeting an item, then we return
			if(!dojo.hasClass(tgr, this.baseClass+"Item")){return;}
			this._highlightOption(tgr, true);
		},

		onmouseout: function(/*Event*/ e){
			// summary:
			//		Handler for onmouseout event
			// tags:
			//		private
			this._keyboardSelected = null;
			var tgr = (e.target.parentNode === this.timeMenu) ? e.target : e.target.parentNode;
			this._highlightOption(tgr, false);
		},

		_mouseWheeled: function(/*Event*/ e){
			// summary:
			//		Handle the mouse wheel events
			// tags:
			//		private
			this._keyboardSelected = null;
			dojo.stopEvent(e);
			// we're not _measuring_ the scroll amount, just direction
			var scrollAmount = (dojo.isIE ? e.wheelDelta : -e.detail);
			this[(scrollAmount>0 ? "_onArrowUp" : "_onArrowDown")](); // yes, we're making a new dom node every time you mousewheel, or click
		},

		_onArrowUp: function(count){
			// summary:
			//		Handler for up arrow key.
			// description:
			//		Removes the bottom time and add one to the top
			// tags:
			//		private
			if(typeof count == "number" && count == -1){ return; } // typematic end
			if(!this.timeMenu.childNodes.length){ return; }
			var index = this.timeMenu.childNodes[0].index;
			var divs = this._getFilteredNodes(index, 1, true, this.timeMenu.childNodes[0]);
			if(divs.length){
				this.timeMenu.removeChild(this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1]);
				this.timeMenu.insertBefore(divs[0], this.timeMenu.childNodes[0]);
			}
		},

		_onArrowDown: function(count){
			// summary:
			//		Handler for up arrow key.
			// description:
			//		Remove the top time and add one to the bottom
			// tags:
			//		private
			if(typeof count == "number" && count == -1){ return; } // typematic end
			if(!this.timeMenu.childNodes.length){ return; }
			var index = this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1].index + 1;
			var divs = this._getFilteredNodes(index, 1, false, this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1]);
			if(divs.length){
				this.timeMenu.removeChild(this.timeMenu.childNodes[0]);
				this.timeMenu.appendChild(divs[0]);
			}
		},

		handleKey: function(/*Event*/ e){
			// summary:
			//		Called from `dijit.form._DateTimeTextBox` to pass a keypress event
			//		from the `dijit.form.TimeTextBox` to be handled in this widget
			// tags:
			//		protected
			var dk = dojo.keys;
			if(e.charOrCode == dk.DOWN_ARROW || e.charOrCode == dk.UP_ARROW){
				dojo.stopEvent(e);
				// Figure out which option to highlight now and then highlight it
				if(this._highlighted_option && !this._highlighted_option.parentNode){
					this._highlighted_option = null;
				}
				var timeMenu = this.timeMenu,
					tgt = this._highlighted_option || dojo.query("." + this.baseClass + "ItemSelected", timeMenu)[0];
				if(!tgt){
					tgt = timeMenu.childNodes[0];
				}else if(timeMenu.childNodes.length){
					if(e.charOrCode == dk.DOWN_ARROW && !tgt.nextSibling){
						this._onArrowDown();
					}else if(e.charOrCode == dk.UP_ARROW && !tgt.previousSibling){
						this._onArrowUp();
					}
					if(e.charOrCode == dk.DOWN_ARROW){
						tgt = tgt.nextSibling;
					}else{
						tgt = tgt.previousSibling;
					}
				}
				this._highlightOption(tgt, true);
				this._keyboardSelected = tgt;
				return false;
			}else if(e.charOrCode == dk.ENTER || e.charOrCode === dk.TAB){
				// mouse hover followed by TAB is NO selection
				if(!this._keyboardSelected && e.charOrCode === dk.TAB){
					return true;	// true means don't call stopEvent()
				}

				// Accept the currently-highlighted option as the value
				if(this._highlighted_option){
				this._onOptionSelected({target: this._highlighted_option});
			}

				// Call stopEvent() for ENTER key so that form doesn't submit,
				// but not for TAB, so that TAB does switch focus
				return e.charOrCode === dk.TAB;
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.TimeTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TimeTextBox"] = true;
dojo.provide("dijit.form.TimeTextBox");




/*=====
dojo.declare(
	"dijit.form.TimeTextBox.__Constraints",
	[dijit.form._DateTimeTextBox.__Constraints, dijit._TimePicker.__Constraints]
);
=====*/

dojo.declare(
	"dijit.form.TimeTextBox",
	dijit.form._DateTimeTextBox,
	{
		// summary:
		//		A validating, serializable, range-bound time text box with a drop down time picker

		baseClass: "dijitTextBox dijitComboBox dijitTimeTextBox",
		popupClass: "dijit._TimePicker",
		_selector: "time",

/*=====
		// constraints: dijit.form.TimeTextBox.__Constraints
		constraints:{},
=====*/

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Note that the date portion implies time zone and daylight savings rules.
		//
		//		Example:
		// |	new dijit.form.TimeTextBox({value: dojo.date.stamp.fromISOString("T12:59:59", new Date())})
		//
		//		When passed to the parser in markup, must be specified according to locale-independent
		//		`dojo.date.stamp.fromISOString` format.
		//
		//		Example:
		// |	<input dojotype='dijit.form.TimeTextBox' value='T12:34:00'>
		value: new Date(""),		// value.toString()="NaN"
		//FIXME: in markup, you have no control over daylight savings

		_onKey: function(evt){
			this.inherited(arguments);

			// If the user has backspaced or typed some numbers, then filter the result list
			// by what they typed.  Maybe there's a better way to detect this, like _handleOnChange()?
			switch(evt.keyCode){
				case dojo.keys.ENTER:
				case dojo.keys.TAB:
				case dojo.keys.ESCAPE:
				case dojo.keys.DOWN_ARROW:
				case dojo.keys.UP_ARROW:
					// these keys have special meaning
					break;
				default:
					// setTimeout() because the keystroke hasn't yet appeared in the <input>,
					// so the get('displayedValue') call below won't give the result we want.
					setTimeout(dojo.hitch(this, function(){
						// set this.filterString to the filter to apply to the drop down list;
						// it will be used in openDropDown()
						var val = this.get('displayedValue');
						this.filterString = (val && !this.parse(val, this.constraints)) ? val.toLowerCase() : "";
	
						// close the drop down and reopen it, in order to filter the items shown in the list
						// and also since the drop down may need to be repositioned if the number of list items has changed
						// and it's being displayed above the <input>
						if(this._opened){
							this.closeDropDown();
						}
						this.openDropDown();
					}), 0);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form._Spinner"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._Spinner"] = true;
dojo.provide("dijit.form._Spinner");



dojo.declare(
	"dijit.form._Spinner",
	dijit.form.RangeBoundTextBox,
	{
		// summary:
		//		Mixin for validation widgets with a spinner.
		// description:
		//		This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
		//		It modifies the template to have up/down arrows, and provides related handling code.

		// defaultTimeout: Number
		//		Number of milliseconds before a held arrow key or up/down button becomes typematic
		defaultTimeout: 500,

		// minimumTimeout: Number
		//		minimum number of milliseconds that typematic event fires when held key or button is held
		minimumTimeout: 10,

		// timeoutChangeRate: Number
		//		Fraction of time used to change the typematic timer between events.
		//		1.0 means that each typematic event fires at defaultTimeout intervals.
		//		< 1.0 means that each typematic event fires at an increasing faster rate.
		timeoutChangeRate: 0.90,

		// smallDelta: Number
		//		Adjust the value by this much when spinning using the arrow keys/buttons
		smallDelta: 1,

		// largeDelta: Number
		//		Adjust the value by this much when spinning using the PgUp/Dn keys
		largeDelta: 10,

		templateString: dojo.cache("dijit.form", "templates/Spinner.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitButtonNode dijitSpinnerButtonContainer\"\n\t\t><input class=\"dijitReset dijitInputField dijitSpinnerButtonInner\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t/><div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitUpArrowButton\"\n\t\t\tdojoAttachPoint=\"upArrowNode\"\n\t\t\t><div class=\"dijitArrowButtonInner\"\n\t\t\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9650;\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t\t${_buttonInputDisabled}\n\t\t\t/></div\n\t\t></div\n\t\t><div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitDownArrowButton\"\n\t\t\tdojoAttachPoint=\"downArrowNode\"\n\t\t\t><div class=\"dijitArrowButtonInner\"\n\t\t\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9660;\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t\t${_buttonInputDisabled}\n\t\t\t/></div\n\t\t></div\n\t></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935;\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' dojoAttachPoint=\"textbox,focusNode\" type=\"${type}\" dojoAttachEvent=\"onkeypress:_onKeyPress\"\n\t\t\trole=\"spinbutton\" autocomplete=\"off\" ${!nameAttrSetting}\n\t/></div\n></div>\n"),

		baseClass: "dijitTextBox dijitSpinner",

		// Set classes like dijitUpArrowButtonHover or dijitDownArrowButtonActive depending on
		// mouse action over specified node
		cssStateNodes: {
			"upArrowNode": "dijitUpArrowButton",
			"downArrowNode": "dijitDownArrowButton"
		},

		adjust: function(/*Object*/ val, /*Number*/ delta){
			// summary:
			//		Overridable function used to adjust a primitive value(Number/Date/...) by the delta amount specified.
			// 		The val is adjusted in a way that makes sense to the object type.
			// tags:
			//		protected extension
			return val;
		},

		_arrowPressed: function(/*Node*/ nodePressed, /*Number*/ direction, /*Number*/ increment){
			// summary:
			//		Handler for arrow button or arrow key being pressed
			if(this.disabled || this.readOnly){ return; }
			this._setValueAttr(this.adjust(this.get('value'), direction*increment), false);
			dijit.selectInputText(this.textbox, this.textbox.value.length);
		},

		_arrowReleased: function(/*Node*/ node){
			// summary:
			//		Handler for arrow button or arrow key being released
			this._wheelTimer = null;
			if(this.disabled || this.readOnly){ return; }
		},

		_typematicCallback: function(/*Number*/ count, /*DOMNode*/ node, /*Event*/ evt){
			var inc=this.smallDelta;
			if(node == this.textbox){
				var k=dojo.keys;
				var key = evt.charOrCode;
				inc = (key == k.PAGE_UP || key == k.PAGE_DOWN) ? this.largeDelta : this.smallDelta;
				node = (key == k.UP_ARROW || key == k.PAGE_UP) ? this.upArrowNode : this.downArrowNode;
			}
			if(count == -1){ this._arrowReleased(node); }
			else{ this._arrowPressed(node, (node == this.upArrowNode) ? 1 : -1, inc); }
		},

		_wheelTimer: null,
		_mouseWheeled: function(/*Event*/ evt){
			// summary:
			//		Mouse wheel listener where supported

			dojo.stopEvent(evt);
			// FIXME: Safari bubbles

			// be nice to DOH and scroll as much as the event says to
			var scrollAmount = evt.detail ? (evt.detail * -1) : (evt.wheelDelta / 120);
			if(scrollAmount !== 0){
				var node = this[(scrollAmount > 0 ? "upArrowNode" : "downArrowNode" )];

				this._arrowPressed(node, scrollAmount, this.smallDelta);

				if(!this._wheelTimer){
					clearTimeout(this._wheelTimer);
				}
				this._wheelTimer = setTimeout(dojo.hitch(this,"_arrowReleased",node), 50);
			}

		},

		postCreate: function(){
			this.inherited(arguments);

			// extra listeners
			this.connect(this.domNode, !dojo.isMozilla ? "onmousewheel" : 'DOMMouseScroll', "_mouseWheeled");
			this._connects.push(dijit.typematic.addListener(this.upArrowNode, this.textbox, {charOrCode:dojo.keys.UP_ARROW,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
			this._connects.push(dijit.typematic.addListener(this.downArrowNode, this.textbox, {charOrCode:dojo.keys.DOWN_ARROW,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
			this._connects.push(dijit.typematic.addListener(this.upArrowNode, this.textbox, {charOrCode:dojo.keys.PAGE_UP,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
			this._connects.push(dijit.typematic.addListener(this.downArrowNode, this.textbox, {charOrCode:dojo.keys.PAGE_DOWN,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
		}
});

}

if(!dojo._hasResource["dijit.form.NumberTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberTextBox"] = true;
dojo.provide("dijit.form.NumberTextBox");




/*=====
dojo.declare(
	"dijit.form.NumberTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.number.__FormatOptions, dojo.number.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused.
	// example:
	//		Minimum/maximum:
	//		To specify a field between 0 and 120:
	//	|		{min:0,max:120}
	//		To specify a field that must be an integer:
	//	|		{fractional:false}
	//		To specify a field where 0 to 3 decimal places are allowed on input:
	//	|		{places:'0,3'}
});
=====*/

dojo.declare("dijit.form.NumberTextBoxMixin",
	null,
	{
		// summary:
		//		A mixin for all number textboxes
		// tags:
		//		protected

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale (plus formatting options too?)
		regExpGen: dojo.number.regexp,

		/*=====
		// constraints: dijit.form.NumberTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options like places (the number of digits to display after
		//		the decimal point).  See `dijit.form.NumberTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// value: Number
		//		The value of this NumberTextBox as a Javascript Number (i.e., not a String).
		//		If the displayed value is blank, the value is NaN, and if the user types in
		//		an gibberish value (like "hello world"), the value is undefined
		//		(i.e. get('value') returns undefined).
		//
		//		Symmetrically, set('value', NaN) will clear the displayed value,
		//		whereas set('value', undefined) will have no effect.
		value: NaN,

		// editOptions: [protected] Object
		//		Properties to mix into constraints when the value is being edited.
		//		This is here because we edit the number in the format "12345", which is
		//		different than the display value (ex: "12,345")
		editOptions: { pattern: '#.######' },

		/*=====
		_formatter: function(value, options){
			// summary:
			//		_formatter() is called by format().  It's the base routine for formatting a number,
			//		as a string, for example converting 12345 into "12,345".
			// value: Number
			//		The number to be converted into a string.
			// options: dojo.number.__FormatOptions?
			//		Formatting options
			// tags:
			//		protected extension

			return "12345";		// String
		},
		 =====*/
		_formatter: dojo.number.format,

		_setConstraintsAttr: function(/*Object*/ constraints){
			var places = typeof constraints.places == "number"? constraints.places : 0;
			if(places){ places++; } // decimal rounding errors take away another digit of precision
			if(typeof constraints.max != "number"){
				constraints.max = 9 * Math.pow(10, 15-places);
			}
			if(typeof constraints.min != "number"){
				constraints.min = -9 * Math.pow(10, 15-places);
			}
			this.inherited(arguments, [ constraints ]);
			if(this.focusNode && this.focusNode.value && !isNaN(this.value)){
				this.set('value', this.value);
			}
		},

		_onFocus: function(){
			if(this.disabled){ return; }
			var val = this.get('value');
			if(typeof val == "number" && !isNaN(val)){
				var formattedValue = this.format(val, this.constraints);
				if(formattedValue !== undefined){
					this.textbox.value = formattedValue;
				}
			}
			this.inherited(arguments);
		},

		format: function(/*Number*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Number, according to constraints.
			// tags:
			//		protected

			var formattedValue = String(value);
			if(typeof value != "number"){ return formattedValue; }
			if(isNaN(value)){ return ""; }
			// check for exponential notation that dojo.number.format chokes on
			if(!("rangeCheck" in this && this.rangeCheck(value, constraints)) && constraints.exponent !== false && /\de[-+]?\d/i.test(formattedValue)){
				return formattedValue;
			}
			if(this.editOptions && this._focused){
				constraints = dojo.mixin({}, constraints, this.editOptions);
			}
			return this._formatter(value, constraints);
		},

		/*=====
		_parser: function(value, constraints){
			// summary:
			//		Parses the string value as a Number, according to constraints.
			// value: String
			//		String representing a number
			// constraints: dojo.number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return 123.45;		// Number
		},
		=====*/
		_parser: dojo.number.parse,

		parse: function(/*String*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a number value
			// tags:
			//		protected extension

			var v = this._parser(value, dojo.mixin({}, constraints, (this.editOptions && this._focused) ? this.editOptions : {}));
			if(this.editOptions && this._focused && isNaN(v)){
				v = this._parser(value, constraints); // parse w/o editOptions: not technically needed but is nice for the user
			}
			return v;
		},

		_getDisplayedValueAttr: function(){
			var v = this.inherited(arguments);
			return isNaN(v) ? this.textbox.value : v;
		},

		filter: function(/*Number*/ value){
			// summary:
			//		This is called with both the display value (string), and the actual value (a number).
			//		When called with the actual value it does corrections so that '' etc. are represented as NaN.
			//		Otherwise it dispatches to the superclass's filter() method.
			//
			//		See `dijit.form.TextBox.filter` for more details.
			return (value === null || value === '' || value === undefined) ? NaN : this.inherited(arguments); // set('value', null||''||undefined) should fire onChange(NaN)
		},

		serialize: function(/*Number*/ value, /*Object?*/ options){
			// summary:
			//		Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)
			// tags:
			//		protected
			return (typeof value != "number" || isNaN(value)) ? '' : this.inherited(arguments);
		},

		_setBlurValue: function(){
			var val = dojo.hitch(dojo.mixin({}, this, { _focused: true }), "get")('value'); // parse with editOptions
			this._setValueAttr(val, true);
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			if(value !== undefined && formattedValue === undefined){
				formattedValue = String(value);
				if(typeof value == "number"){
					if(isNaN(value)){ formattedValue = '' }
					// check for exponential notation that dojo.number.format chokes on
					else if(("rangeCheck" in this && this.rangeCheck(value, this.constraints)) || this.constraints.exponent === false || !/\de[-+]?\d/i.test(formattedValue)){
						formattedValue = undefined; // lets format comnpute a real string value
					}
				}else if(!value){ // 0 processed in if branch above, ''|null|undefined flow thru here
					formattedValue = '';
					value = NaN;
				}else{ // non-numeric values
					value = undefined;
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			//		Returns Number, NaN for '', or undefined for unparsable text
			var v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values

			// If the displayed value of the textbox is gibberish (ex: "hello world"), this.inherited() above
			// returns NaN; this if() branch converts the return value to undefined.
			// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).
			// A blank displayed value is still returned as NaN.
			if(isNaN(v) && this.textbox.value !== ''){
				if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value) && (new RegExp("^"+dojo.number._realNumberRegexp(dojo.mixin({}, this.constraints))+"$").test(this.textbox.value))){	// check for exponential notation that parse() rejected (erroneously?)
					var n = Number(this.textbox.value);
					return isNaN(n) ? undefined : n; // return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)
				}else{
					return undefined; // gibberish
				}
			}else{
				return v; // Number or NaN for ''
			}
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.RangeBoundTextBox.isValid to check that the editing-mode value is valid since
			// it may not be formatted according to the regExp vaidation rules
			if(!this._focused || this._isEmpty(this.textbox.value)){
				return this.inherited(arguments);
			}else{
				var v = this.get('value');
				if(!isNaN(v) && this.rangeCheck(v, this.constraints)){
					if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value)){ // exponential, parse doesn't like it
						return true; // valid exponential number in range
					}else{
						return this.inherited(arguments);
					}
				}else{
					return false;
				}
			}
		}
	}
);

dojo.declare("dijit.form.NumberTextBox",
	[dijit.form.RangeBoundTextBox,dijit.form.NumberTextBoxMixin],
	{
		// summary:
		//		A TextBox for entering numbers, with formatting and range checking
		// description:
		//		NumberTextBox is a textbox for entering and displaying numbers, supporting
		//		the following main features:
		//
		//			1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
		//				a number rather than a random string)
		//			2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
		//				depending on locale).
		//			3. Separate modes for editing the value and displaying it, specifically that
		//				the thousands separator character (typically comma) disappears when editing
		//				but reappears after the field is blurred.
		//			4. Formatting and constraints regarding the number of places (digits after the decimal point)
		//				allowed on input, and number of places displayed when blurred (see `constraints` parameter).

		baseClass: "dijitTextBox dijitNumberTextBox"
	}
);

}

if(!dojo._hasResource["dijit.form.NumberSpinner"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberSpinner"] = true;
dojo.provide("dijit.form.NumberSpinner");




dojo.declare("dijit.form.NumberSpinner",
	[dijit.form._Spinner, dijit.form.NumberTextBoxMixin],
	{
	// summary:
	//		Extends NumberTextBox to add up/down arrows and pageup/pagedown for incremental change to the value
	//
	// description:
	//		A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	//		as well as icons for spinning direction. When using the keyboard, the typematic rules
	//		apply, meaning holding the key will gradually increase or decrease the value and
	// 		accelerate.
	//
	// example:
	//	| new dijit.form.NumberSpinner({ constraints:{ max:300, min:100 }}, "someInput");

	adjust: function(/*Object*/ val, /*Number*/ delta){
		// summary:
		//		Change Number val by the given amount
		// tags:
		//		protected

		var tc = this.constraints,
			v = isNaN(val),
			gotMax = !isNaN(tc.max),
			gotMin = !isNaN(tc.min)
		;
		if(v && delta != 0){ // blank or invalid value and they want to spin, so create defaults
			val = (delta > 0) ?
				gotMin ? tc.min : gotMax ? tc.max : 0 :
				gotMax ? this.constraints.max : gotMin ? tc.min : 0
			;
		}
		var newval = val + delta;
		if(v || isNaN(newval)){ return val; }
		if(gotMax && (newval > tc.max)){
			newval = tc.max;
		}
		if(gotMin && (newval < tc.min)){
			newval = tc.min;
		}
		return newval;
	},

	_onKeyPress: function(e){
		if((e.charOrCode == dojo.keys.HOME || e.charOrCode == dojo.keys.END) && !(e.ctrlKey || e.altKey || e.metaKey)
		&& typeof this.get('value') != 'undefined' /* gibberish, so HOME and END are default editing keys*/){
			var value = this.constraints[(e.charOrCode == dojo.keys.HOME ? "min" : "max")];
			if(typeof value == "number"){
				this._setValueAttr(value, false);
			}
			// eat home or end key whether we change the value or not
			dojo.stopEvent(e);
		}
	}
});

}

if(!dojo._hasResource["dojo.cldr.monetary"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.monetary"] = true;
dojo.provide("dojo.cldr.monetary");

dojo.getObject("cldr.monetary", true, dojo);

dojo.cldr.monetary.getData = function(/*String*/code){
// summary: A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.
// code: an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code

// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/currencyData/fractions

	var placesData = {
		ADP:0,AFN:0,ALL:0,AMD:0,BHD:3,BIF:0,BYR:0,CLF:0,CLP:0,
		COP:0,CRC:0,DJF:0,ESP:0,GNF:0,GYD:0,HUF:0,IDR:0,IQD:0,
		IRR:3,ISK:0,ITL:0,JOD:3,JPY:0,KMF:0,KPW:0,KRW:0,KWD:3,
		LAK:0,LBP:0,LUF:0,LYD:3,MGA:0,MGF:0,MMK:0,MNT:0,MRO:0,
		MUR:0,OMR:3,PKR:0,PYG:0,RSD:0,RWF:0,SLL:0,SOS:0,STD:0,
		SYP:0,TMM:0,TND:3,TRL:0,TZS:0,UGX:0,UZS:0,VND:0,VUV:0,
		XAF:0,XOF:0,XPF:0,YER:0,ZMK:0,ZWD:0
	};

	var roundingData = {CHF:5};

	var places = placesData[code], round = roundingData[code];
	if(typeof places == "undefined"){ places = 2; }
	if(typeof round == "undefined"){ round = 0; }

	return {places: places, round: round}; // Object
};

}

if(!dojo._hasResource["dojo.currency"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.currency"] = true;
dojo.provide("dojo.currency");





dojo.getObject("currency", true, dojo);

/*=====
dojo.currency = {
	// summary: localized formatting and parsing routines for currencies
	//
	// description: extends dojo.number to provide culturally-appropriate formatting of values
	//	in various world currencies, including use of a currency symbol.  The currencies are specified
	//	by a three-letter international symbol in all uppercase, and support for the currencies is
	//	provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	//	currency support is included.  A fixed number of decimal places is determined based
	//	on the currency type and is not determined by the 'pattern' argument.  The fractional
	//	portion is optional, by default, and variable length decimals are not supported.
}
=====*/

dojo.currency._mixInDefaults = function(options){
	options = options || {};
	options.type = "currency";

	// Get locale-dependent currency data, like the symbol
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "currency", options.locale) || {};

	// Mixin locale-independent currency data, like # of places
	var iso = options.currency;
	var data = dojo.cldr.monetary.getData(iso);

	dojo.forEach(["displayName","symbol","group","decimal"], function(prop){
		data[prop] = bundle[iso+"_"+prop];
	});

	data.fractional = [true, false];

	// Mixin with provided options
	return dojo.mixin(data, options);
};

/*=====
dojo.declare("dojo.currency.__FormatOptions", [dojo.number.__FormatOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be "currency".
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	places: Number?
	//		number of decimal places to show.  Default is defined based on which currency is used.
	type: "",
	symbol: "",
	currency: "",
	places: ""
});
=====*/

dojo.currency.format = function(/*Number*/value, /*dojo.currency.__FormatOptions?*/options){
// summary:
//		Format a Number as a currency, using locale-specific settings
//
// description:
//		Create a string from a Number using a known, localized pattern.
//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
//		appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
//		as well as the appropriate symbols and delimiters and number of decimal places.
//
// value:
//		the number to be formatted.

	return dojo.number.format(value, dojo.currency._mixInDefaults(options));
};

dojo.currency.regexp = function(/*dojo.number.__RegexpOptions?*/options){
//
// summary:
//		Builds the regular needed to parse a currency value
//
// description:
//		Returns regular expression with positive and negative match, group and decimal separators
//		Note: the options.places default, the number of decimal places to accept, is defined by the currency type.
	return dojo.number.regexp(dojo.currency._mixInDefaults(options)); // String
};

/*=====
dojo.declare("dojo.currency.__ParseOptions", [dojo.number.__ParseOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be currency.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	places: Number?
	//		fixed number of decimal places to accept.  The default is determined based on which currency is used.
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by the currency
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	//		By default for currencies, it the fractional portion is optional.
	type: "",
	currency: "",
	symbol: "",
	places: "",
	fractional: ""
});
=====*/

dojo.currency.parse = function(/*String*/expression, /*dojo.currency.__ParseOptions?*/options){
	//
	// summary:
	//		Convert a properly formatted currency string to a primitive Number,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Number from a string using a known, localized pattern.
	//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	//		and number of decimal places.
	//
	// expression: A string representation of a currency value

	return dojo.number.parse(expression, dojo.currency._mixInDefaults(options));
};

}

if(!dojo._hasResource["dijit.form.CurrencyTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CurrencyTextBox"] = true;
dojo.provide("dijit.form.CurrencyTextBox");




/*=====
dojo.declare(
	"dijit.form.CurrencyTextBox.__Constraints",
	[dijit.form.NumberTextBox.__Constraints, dojo.currency.__FormatOptions, dojo.currency.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused (currency symbol,
	//		etc.)
	// description:
	//		Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	//		In general developers won't need to set this parameter
	// example:
	//		To ensure that the user types in the cents (for example, 1.00 instead of just 1):
	//	|		{fractional:true}
});
=====*/

dojo.declare(
	"dijit.form.CurrencyTextBox",
	dijit.form.NumberTextBox,
	{
		// summary:
		//		A validating currency textbox
		// description:
		//		CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
		//		extra features related to currency:
		//
		//		1. After specifying the currency type (american dollars, euros, etc.) it automatically
		//			sets parse/format options such as how many decimal places to show.
		//		2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
		//			but erased during editing, so that the user can just enter a plain number.

		// currency: [const] String
		//		the [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD"
		currency: "",

		/*=====
		// constraints: dijit.form.CurrencyTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options.  See `dijit.form.CurrencyTextBox.__Constraints` for details.
		constraints: {},
		======*/
		
		baseClass: "dijitTextBox dijitCurrencyTextBox",

		// Override regExpGen ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: function(constraints){
			// if focused, accept either currency data or NumberTextBox format
			return '(' + (this._focused? this.inherited(arguments, [ dojo.mixin({}, constraints, this.editOptions) ]) + '|' : '')
				+ dojo.currency.regexp(constraints) + ')';
		},

		// Override NumberTextBox._formatter to deal with currencies, ex: converts "123.45" to "$123.45"
		_formatter: dojo.currency.format,

		_parser: dojo.currency.parse,

		parse: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			// 		Parses string value as a Currency, according to the constraints object
			// tags:
			// 		protected extension
			var v = this.inherited(arguments);
			if(isNaN(v) && /\d+/.test(value)){ // currency parse failed, but it could be because they are using NumberTextBox format so try its parse
				v = dojo.hitch(dojo.mixin({}, this, { _parser: dijit.form.NumberTextBox.prototype._parser }), "inherited")(arguments);
			}
			return v;
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.currency && this.currency){
				constraints.currency = this.currency;
			}
			this.inherited(arguments, [ dojo.currency._mixInDefaults(dojo.mixin(constraints, { exponent: false })) ]); // get places
		}
	}
);

}

if(!dojo._hasResource["dijit.form.HorizontalSlider"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalSlider"] = true;
dojo.provide("dijit.form.HorizontalSlider");







dojo.declare(
	"dijit.form.HorizontalSlider",
	[dijit.form._FormValueWidget, dijit._Container],
{
	// summary:
	//		A form widget that allows one to select a value with a horizontally draggable handle

	templateString: dojo.cache("dijit.form", "templates/HorizontalSlider.html", "<table class=\"dijit dijitReset dijitSlider dijitSliderH\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" rules=\"none\" dojoAttachEvent=\"onkeypress:_onKeyPress,onkeyup:_onKeyUp\"\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"topDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationT dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderDecrementIconH\" style=\"display:none\" dojoAttachPoint=\"decrementButton\"><span class=\"dijitSliderButtonInner\">-</span></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderLeftBumper\" dojoAttachEvent=\"onmousedown:_onClkDecBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><input dojoAttachPoint=\"valueNode\" type=\"hidden\" ${!nameAttrSetting}\n\t\t\t/><div class=\"dijitReset dijitSliderBarContainerH\" role=\"presentation\" dojoAttachPoint=\"sliderBarContainer\"\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"progressBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderProgressBar dijitSliderProgressBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"\n\t\t\t\t\t><div class=\"dijitSliderMoveable dijitSliderMoveableH\"\n\t\t\t\t\t\t><div dojoAttachPoint=\"sliderHandle,focusNode\" class=\"dijitSliderImageHandle dijitSliderImageHandleH\" dojoAttachEvent=\"onmousedown:_onHandleClick\" role=\"slider\" valuemin=\"${minimum}\" valuemax=\"${maximum}\"></div\n\t\t\t\t\t></div\n\t\t\t\t></div\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"remainingBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderRemainingBar dijitSliderRemainingBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"></div\n\t\t\t></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderRightBumper\" dojoAttachEvent=\"onmousedown:_onClkIncBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderIncrementIconH\" style=\"display:none\" dojoAttachPoint=\"incrementButton\"><span class=\"dijitSliderButtonInner\">+</span></div\n\t\t></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"containerNode,bottomDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationB dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n></table>\n"),

	// Overrides FormValueWidget.value to indicate numeric value
	value: 0,

	// showButtons: [const] Boolean
	//		Show increment/decrement buttons at the ends of the slider?
	showButtons: true,

	// minimum:: [const] Integer
	//		The minimum value the slider can be set to.
	minimum: 0,

	// maximum: [const] Integer
	//		The maximum value the slider can be set to.
	maximum: 100,

	// discreteValues: Integer
	//		If specified, indicates that the slider handle has only 'discreteValues' possible positions,
	//		and that after dragging the handle, it will snap to the nearest possible position.
	//		Thus, the slider has only 'discreteValues' possible values.
	//
	//		For example, if minimum=10, maxiumum=30, and discreteValues=3, then the slider handle has
	//		three possible positions, representing values 10, 20, or 30.
	//
	//		If discreteValues is not specified or if it's value is higher than the number of pixels
	//		in the slider bar, then the slider handle can be moved freely, and the slider's value will be
	//		computed/reported based on pixel position (in this case it will likely be fractional,
	//		such as 123.456789).
	discreteValues: Infinity,

	// pageIncrement: Integer
	//		If discreteValues is also specified, this indicates the amount of clicks (ie, snap positions)
	//		that the slider handle is moved via pageup/pagedown keys.
	//		If discreteValues is not specified, it indicates the number of pixels.
	pageIncrement: 2,

	// clickSelect: Boolean
	//		If clicking the slider bar changes the value or not
	clickSelect: true,

	// slideDuration: Number
	//		The time in ms to take to animate the slider handle from 0% to 100%,
	//		when clicking the slider bar to make the handle move.
	slideDuration: dijit.defaultDuration,

	// Flag to _Templated  (TODO: why is this here?  I see no widgets in the template.)
	widgetsInTemplate: true,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		id: ""
	}),

	baseClass: "dijitSlider",

	// Apply CSS classes to up/down arrows and handle per mouse state
	cssStateNodes: {
		incrementButton: "dijitSliderIncrementButton",
		decrementButton: "dijitSliderDecrementButton",
		focusNode: "dijitSliderThumb"
	},

	_mousePixelCoord: "pageX",
	_pixelCount: "w",
	_startingPixelCoord: "x",
	_startingPixelCount: "l",
	_handleOffsetCoord: "left",
	_progressPixelSize: "width",

	_onKeyUp: function(/*Event*/ e){
		if(this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey){ return; }
		this._setValueAttr(this.value, true);
	},

	_onKeyPress: function(/*Event*/ e){
		if(this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey){ return; }
		switch(e.charOrCode){
			case dojo.keys.HOME:
				this._setValueAttr(this.minimum, false);
				break;
			case dojo.keys.END:
				this._setValueAttr(this.maximum, false);
				break;
			// this._descending === false: if ascending vertical (min on top)
			// (this._descending || this.isLeftToRight()): if left-to-right horizontal or descending vertical
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.RIGHT_ARROW : dojo.keys.LEFT_ARROW):
			case (this._descending === false ? dojo.keys.DOWN_ARROW : dojo.keys.UP_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_DOWN : dojo.keys.PAGE_UP):
				this.increment(e);
				break;
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.LEFT_ARROW : dojo.keys.RIGHT_ARROW):
			case (this._descending === false ? dojo.keys.UP_ARROW : dojo.keys.DOWN_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_UP : dojo.keys.PAGE_DOWN):
				this.decrement(e);
				break;
			default:
				return;
		}
		dojo.stopEvent(e);
	},

	_onHandleClick: function(e){
		if(this.disabled || this.readOnly){ return; }
		if(!dojo.isIE){
			// make sure you get focus when dragging the handle
			// (but don't do on IE because it causes a flicker on mouse up (due to blur then focus)
			dijit.focus(this.sliderHandle);
		}
		dojo.stopEvent(e);
	},

	_isReversed: function(){
		// summary:
		//		Returns true if direction is from right to left
		// tags:
		//		protected extension
		return !this.isLeftToRight();
	},

	_onBarClick: function(e){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		dijit.focus(this.sliderHandle);
		dojo.stopEvent(e);
		var abspos = dojo.position(this.sliderBarContainer, true);
		var pixelValue = e[this._mousePixelCoord] - abspos[this._startingPixelCoord];
		this._setPixelValue(this._isReversed() ? (abspos[this._pixelCount] - pixelValue) : pixelValue, abspos[this._pixelCount], true);
		this._movable.onMouseDown(e);
	},

	_setPixelValue: function(/*Number*/ pixelValue, /*Number*/ maxPixels, /*Boolean?*/ priorityChange){
		if(this.disabled || this.readOnly){ return; }
		pixelValue = pixelValue < 0 ? 0 : maxPixels < pixelValue ? maxPixels : pixelValue;
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = maxPixels; }
		count--;
		var pixelsPerValue = maxPixels / count;
		var wholeIncrements = Math.round(pixelValue / pixelsPerValue);
		this._setValueAttr((this.maximum-this.minimum)*wholeIncrements/count + this.minimum, priorityChange);
	},

	_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
		// summary:
		//		Hook so set('value', value) works.
		this._set("value", value);
		this.valueNode.value = value;
		dijit.setWaiState(this.focusNode, "valuenow", value);
		this.inherited(arguments);
		var percent = (value - this.minimum) / (this.maximum - this.minimum);
		var progressBar = (this._descending === false) ? this.remainingBar : this.progressBar;
		var remainingBar = (this._descending === false) ? this.progressBar : this.remainingBar;
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		if(priorityChange && this.slideDuration > 0 && progressBar.style[this._progressPixelSize]){
			// animate the slider
			var _this = this;
			var props = {};
			var start = parseFloat(progressBar.style[this._progressPixelSize]);
			var duration = this.slideDuration * (percent-start/100);
			if(duration == 0){ return; }
			if(duration < 0){ duration = 0 - duration; }
			props[this._progressPixelSize] = { start: start, end: percent*100, units:"%" };
			this._inProgressAnim = dojo.animateProperty({ node: progressBar, duration: duration,
				onAnimate: function(v){ remainingBar.style[_this._progressPixelSize] = (100-parseFloat(v[_this._progressPixelSize])) + "%"; },
				onEnd: function(){ delete _this._inProgressAnim; },
				properties: props
			})
			this._inProgressAnim.play();
		}else{
			progressBar.style[this._progressPixelSize] = (percent*100) + "%";
			remainingBar.style[this._progressPixelSize] = ((1-percent)*100) + "%";
		}
	},

	_bumpValue: function(signedChange, /*Boolean?*/ priorityChange){
		if(this.disabled || this.readOnly){ return; }
		var s = dojo.getComputedStyle(this.sliderBarContainer);
		var c = dojo._getContentBox(this.sliderBarContainer, s);
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = c[this._pixelCount]; }
		count--;
		var value = (this.value - this.minimum) * count / (this.maximum - this.minimum) + signedChange;
		if(value < 0){ value = 0; }
		if(value > count){ value = count; }
		value = value * (this.maximum - this.minimum) / count + this.minimum;
		this._setValueAttr(value, priorityChange);
	},

	_onClkBumper: function(val){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		this._setValueAttr(val, true);
	},

	_onClkIncBumper: function(){
		this._onClkBumper(this._descending === false ? this.minimum : this.maximum);
	},

	_onClkDecBumper: function(){
		this._onClkBumper(this._descending === false ? this.maximum : this.minimum);
	},

	decrement: function(/*Event*/ e){
		// summary:
		//		Decrement slider
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_DOWN ? -this.pageIncrement : -1);
	},

	increment: function(/*Event*/ e){
		// summary:
		//		Increment slider
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_UP ? this.pageIncrement : 1);
	},

	_mouseWheeled: function(/*Event*/ evt){
		// summary:
		//		Event handler for mousewheel where supported
		dojo.stopEvent(evt);
		var janky = !dojo.isMozilla;
		var scroll = evt[(janky ? "wheelDelta" : "detail")] * (janky ? 1 : -1);
		this._bumpValue(scroll < 0 ? -1 : 1, true); // negative scroll acts like a decrement
	},

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){
			if(this[child.container] != this.containerNode){
				this[child.container].appendChild(child.domNode);
			}
		}, this);

		this.inherited(arguments);
	},

	_typematicCallback: function(/*Number*/ count, /*Object*/ button, /*Event*/ e){
		if(count == -1){
			this._setValueAttr(this.value, true);
		}else{
			this[(button == (this._descending? this.incrementButton : this.decrementButton)) ? "decrement" : "increment"](e);
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(this.showButtons){
			this.incrementButton.style.display="";
			this.decrementButton.style.display="";
		}

		// find any associated label element and add to slider focusnode.
		var label = dojo.query('label[for="'+this.id+'"]');
		if(label.length){
			label[0].id = (this.id+"_label");
			dijit.setWaiState(this.focusNode, "labelledby", label[0].id);
		}

		dijit.setWaiState(this.focusNode, "valuemin", this.minimum);
		dijit.setWaiState(this.focusNode, "valuemax", this.maximum);
	},

	postCreate: function(){
		this.inherited(arguments);

		if(this.showButtons){
			this._connects.push(dijit.typematic.addMouseListener(
				this.decrementButton, this, "_typematicCallback", 25, 500));
			this._connects.push(dijit.typematic.addMouseListener(
				this.incrementButton, this, "_typematicCallback", 25, 500));
		}
		this.connect(this.domNode, !dojo.isMozilla ? "onmousewheel" : "DOMMouseScroll", "_mouseWheeled");

		// define a custom constructor for a SliderMover that points back to me
		var mover = dojo.declare(dijit.form._SliderMover, {
			widget: this
		});
		this._movable = new dojo.dnd.Moveable(this.sliderHandle, {mover: mover});

		this._layoutHackIE7();
	},

	destroy: function(){
		this._movable.destroy();
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		this._supportingWidgets = dijit.findWidgets(this.domNode); // tells destroy about pseudo-child widgets (ruler/labels)
		this.inherited(arguments);
	}
});

dojo.declare("dijit.form._SliderMover",
	dojo.dnd.Mover,
{
	onMouseMove: function(e){
		var widget = this.widget;
		var abspos = widget._abspos;
		if(!abspos){
			abspos = widget._abspos = dojo.position(widget.sliderBarContainer, true);
			widget._setPixelValue_ = dojo.hitch(widget, "_setPixelValue");
			widget._isReversed_ = widget._isReversed();
		}
		var coordEvent = e.touches ? e.touches[0] : e, // if multitouch take first touch for coords
			pixelValue = coordEvent[widget._mousePixelCoord] - abspos[widget._startingPixelCoord];
		widget._setPixelValue_(widget._isReversed_ ? (abspos[widget._pixelCount]-pixelValue) : pixelValue, abspos[widget._pixelCount], false);
	},

	destroy: function(e){
		dojo.dnd.Mover.prototype.destroy.apply(this, arguments);
		var widget = this.widget;
		widget._abspos = null;
		widget._setValueAttr(widget.value, true);
	}
});

}

if(!dojo._hasResource["dijit._editor.selection"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.selection"] = true;
dojo.provide("dijit._editor.selection");


dojo.getObject("_editor.selection", true, dijit);

// FIXME:
//		all of these methods branch internally for IE. This is probably
//		sub-optimal in terms of runtime performance. We should investigate the
//		size difference for differentiating at definition time.

dojo.mixin(dijit._editor.selection, {
	getType: function(){
		// summary:
		//		Get the selection type (like dojo.doc.select.type in IE).
		if(dojo.isIE < 9){
			return dojo.doc.selection.type.toLowerCase();
		}else{
			var stype = "text";

			// Check if the actual selection is a CONTROL (IMG, TABLE, HR, etc...).
			var oSel;
			try{
				oSel = dojo.global.getSelection();
			}catch(e){ /*squelch*/ }

			if(oSel && oSel.rangeCount == 1){
				var oRange = oSel.getRangeAt(0);
				if(	(oRange.startContainer == oRange.endContainer) &&
					((oRange.endOffset - oRange.startOffset) == 1) &&
					(oRange.startContainer.nodeType != 3 /* text node*/)
				){
					stype = "control";
				}
			}
			return stype; //String
		}
	},

	getSelectedText: function(){
		// summary:
		//		Return the text (no html tags) included in the current selection or null if no text is selected
		if(dojo.isIE < 9){
			if(dijit._editor.selection.getType() == 'control'){
				return null;
			}
			return dojo.doc.selection.createRange().text;
		}else{
			var selection = dojo.global.getSelection();
			if(selection){
				return selection.toString(); //String
			}
		}
		return '';
	},

	getSelectedHtml: function(){
		// summary:
		//		Return the html text of the current selection or null if unavailable
		if(dojo.isIE < 9){
			if(dijit._editor.selection.getType() == 'control'){
				return null;
			}
			return dojo.doc.selection.createRange().htmlText;
		}else{
			var selection = dojo.global.getSelection();
			if(selection && selection.rangeCount){
				var i;
				var html = "";
				for(i = 0; i < selection.rangeCount; i++){
					//Handle selections spanning ranges, such as Opera
					var frag = selection.getRangeAt(i).cloneContents();
					var div = dojo.doc.createElement("div");
					div.appendChild(frag);
					html += div.innerHTML;
				}
				return html; //String
			}
			return null;
		}
	},

	getSelectedElement: function(){
		// summary:
		//		Retrieves the selected element (if any), just in the case that
		//		a single element (object like and image or a table) is
		//		selected.
		if(dijit._editor.selection.getType() == "control"){
			if(dojo.isIE < 9){
				var range = dojo.doc.selection.createRange();
				if(range && range.item){
					return dojo.doc.selection.createRange().item(0);
				}
			}else{
				var selection = dojo.global.getSelection();
				return selection.anchorNode.childNodes[ selection.anchorOffset ];
			}
		}
		return null;
	},

	getParentElement: function(){
		// summary:
		//		Get the parent element of the current selection
		if(dijit._editor.selection.getType() == "control"){
			var p = this.getSelectedElement();
			if(p){ return p.parentNode; }
		}else{
			if(dojo.isIE < 9){
				var r = dojo.doc.selection.createRange();
				r.collapse(true);
				return r.parentElement();
			}else{
				var selection = dojo.global.getSelection();
				if(selection){
					var node = selection.anchorNode;
					while(node && (node.nodeType != 1)){ // not an element
						node = node.parentNode;
					}
					return node;
				}
			}
		}
		return null;
	},

	hasAncestorElement: function(/*String*/tagName /* ... */){
		// summary:
		// 		Check whether current selection has a  parent element which is
		// 		of type tagName (or one of the other specified tagName)
		// tagName: String
		//		The tag name to determine if it has an ancestor of.
		return this.getAncestorElement.apply(this, arguments) != null; //Boolean
	},

	getAncestorElement: function(/*String*/tagName /* ... */){
		// summary:
		//		Return the parent element of the current selection which is of
		//		type tagName (or one of the other specified tagName)
		// tagName: String
		//		The tag name to determine if it has an ancestor of.
		var node = this.getSelectedElement() || this.getParentElement();
		return this.getParentOfType(node, arguments); //DOMNode
	},

	isTag: function(/*DomNode*/ node, /*String[]*/ tags){
		// summary:
		//		Function to determine if a node is one of an array of tags.
		// node:
		//		The node to inspect.
		// tags:
		//		An array of tag name strings to check to see if the node matches.
		if(node && node.tagName){
			var _nlc = node.tagName.toLowerCase();
			for(var i=0; i<tags.length; i++){
				var _tlc = String(tags[i]).toLowerCase();
				if(_nlc == _tlc){
					return _tlc; // String
				}
			}
		}
		return "";
	},

	getParentOfType: function(/*DomNode*/ node, /*String[]*/ tags){
		// summary:
		//		Function to locate a parent node that matches one of a set of tags
		// node:
		//		The node to inspect.
		// tags:
		//		An array of tag name strings to check to see if the node matches.
		while(node){
			if(this.isTag(node, tags).length){
				return node; // DOMNode
			}
			node = node.parentNode;
		}
		return null;
	},

	collapse: function(/*Boolean*/beginning){
		// summary:
		//		Function to collapse (clear), the current selection
		// beginning: Boolean
		//		Boolean to indicate whether to collapse the cursor to the beginning of the selection or end.
		if(window.getSelection){
			var selection = dojo.global.getSelection();
			if(selection.removeAllRanges){ // Mozilla
				if(beginning){
					selection.collapseToStart();
				}else{
					selection.collapseToEnd();
				}
			}else{ // Safari
				// pulled from WebCore/ecma/kjs_window.cpp, line 2536
				selection.collapse(beginning);
			}
		}else if(dojo.isIE){ // IE
			var range = dojo.doc.selection.createRange();
			range.collapse(beginning);
			range.select();
		}
	},

	remove: function(){
		// summary:
		//		Function to delete the currently selected content from the document.
		var sel = dojo.doc.selection;
		if(dojo.isIE < 9){
			if(sel.type.toLowerCase() != "none"){
				sel.clear();
			}
			return sel; //Selection
		}else{
			sel = dojo.global.getSelection();
			sel.deleteFromDocument();
			return sel; //Selection
		}
	},

	selectElementChildren: function(/*DomNode*/element,/*Boolean?*/nochangefocus){
		// summary:
		//		clear previous selection and select the content of the node
		//		(excluding the node itself)
		// element: DOMNode
		//		The element you wish to select the children content of.
		// nochangefocus: Boolean
		//		Boolean to indicate if the foxus should change or not.
		var win = dojo.global;
		var doc = dojo.doc;
		var range;
		element = dojo.byId(element);
		if(doc.selection && dojo.isIE < 9 && dojo.body().createTextRange){ // IE
			range = element.ownerDocument.body.createTextRange();
			range.moveToElementText(element);
			if(!nochangefocus){
				try{
					range.select(); // IE throws an exception here if the widget is hidden.  See #5439
				}catch(e){ /* squelch */}
			}
		}else if(win.getSelection){
			var selection = dojo.global.getSelection();
			if(dojo.isOpera){
				//Opera's selectAllChildren doesn't seem to work right
				//against <body> nodes and possibly others ... so
				//we use the W3C range API
				if(selection.rangeCount){
					range = selection.getRangeAt(0);
				}else{
					range = doc.createRange();
				}
				range.setStart(element, 0);
				range.setEnd(element,(element.nodeType == 3)?element.length:element.childNodes.length);
				selection.addRange(range);
			}else{
				selection.selectAllChildren(element);
			}
		}
	},

	selectElement: function(/*DomNode*/element,/*Boolean?*/nochangefocus){
		// summary:
		//		clear previous selection and select element (including all its children)
		// element:  DOMNode
		//		The element to select.
		// nochangefocus: Boolean
		//		Boolean indicating if the focus should be changed.  IE only.
		var range;
		var doc = dojo.doc;
		var win = dojo.global;
		element = dojo.byId(element);
		if(dojo.isIE < 9 && dojo.body().createTextRange){
			try{
				var tg = element.tagName ? element.tagName.toLowerCase() : "";
				if(tg === "img" || tg === "table"){
					range = dojo.body().createControlRange();
				}else{
					range = dojo.body().createRange();
				}
				range.addElement(element);
				if(!nochangefocus){
					range.select();
				}
			}catch(e){
				this.selectElementChildren(element,nochangefocus);
			}
		}else if(dojo.global.getSelection){
			var selection = win.getSelection();
			range = doc.createRange();
			if(selection.removeAllRanges){ // Mozilla
				// FIXME: does this work on Safari?
				if(dojo.isOpera){
					//Opera works if you use the current range on
					//the selection if present.
					if(selection.getRangeAt(0)){
						range = selection.getRangeAt(0);
					}
				}
				range.selectNode(element);
				selection.removeAllRanges();
				selection.addRange(range);
			}
		}
	},

	inSelection: function(node){
		// summary:
		//		This function determines if 'node' is
		//		in the current selection.
		// tags:
		//		public
		if(node){
			var newRange;
			var doc = dojo.doc;
			var range;

			if(dojo.global.getSelection){
				//WC3
				var sel = dojo.global.getSelection();
				if(sel && sel.rangeCount > 0){
					range = sel.getRangeAt(0);
				}
				if(range && range.compareBoundaryPoints && doc.createRange){
					try{
						newRange = doc.createRange();
						newRange.setStart(node, 0);
						if(range.compareBoundaryPoints(range.START_TO_END, newRange) === 1){
							return true;
						}
					}catch(e){ /* squelch */}
				}
			}else if(doc.selection){
				// Probably IE, so we can't use the range object as the pseudo
				// range doesn't implement the boundry checking, we have to
				// use IE specific crud.
				range = doc.selection.createRange();
				try{
					newRange = node.ownerDocument.body.createControlRange();
					if(newRange){
						newRange.addElement(node);
					}
				}catch(e1){
					try{
						newRange = node.ownerDocument.body.createTextRange();
						newRange.moveToElementText(node);
					}catch(e2){/* squelch */}
				}
				if(range && newRange){
					// We can finally compare similar to W3C
					if(range.compareEndPoints("EndToStart", newRange) === 1){
						return true;
					}
				}
			}
		}
		return false; // boolean
	}

});

}

if(!dojo._hasResource["dijit._editor.range"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.range"] = true;
dojo.provide("dijit._editor.range");


dijit.range={};

dijit.range.getIndex=function(/*DomNode*/node, /*DomNode*/parent){
//	dojo.profile.start("dijit.range.getIndex");
	var ret=[], retR=[];
	var stop = parent;
	var onode = node;

	var pnode, n;
	while(node != stop){
		var i = 0;
		pnode = node.parentNode;
		while((n=pnode.childNodes[i++])){
			if(n === node){
				--i;
				break;
			}
		}
		//if(i>=pnode.childNodes.length){
			//dojo.debug("Error finding index of a node in dijit.range.getIndex");
		//}
		ret.unshift(i);
		retR.unshift(i-pnode.childNodes.length);
		node = pnode;
	}

	//normalized() can not be called so often to prevent
	//invalidating selection/range, so we have to detect
	//here that any text nodes in a row
	if(ret.length > 0 && onode.nodeType == 3){
		n = onode.previousSibling;
		while(n && n.nodeType == 3){
			ret[ret.length-1]--;
			n = n.previousSibling;
		}
		n = onode.nextSibling;
		while(n && n.nodeType == 3){
			retR[retR.length-1]++;
			n = n.nextSibling;
		}
	}
//	dojo.profile.end("dijit.range.getIndex");
	return {o: ret, r:retR};
}

dijit.range.getNode = function(/*Array*/index, /*DomNode*/parent){
	if(!dojo.isArray(index) || index.length == 0){
		return parent;
	}
	var node = parent;
//	if(!node)debugger
	dojo.every(index, function(i){
		if(i >= 0 && i < node.childNodes.length){
			node = node.childNodes[i];
		}else{
			node = null;
			//console.debug('Error: can not find node with index',index,'under parent node',parent );
			return false; //terminate dojo.every
		}
		return true; //carry on the every loop
	});

	return node;
}

dijit.range.getCommonAncestor = function(n1,n2,root){
	root = root||n1.ownerDocument.body;
	var getAncestors = function(n){
		var as=[];
		while(n){
			as.unshift(n);
			if(n !== root){
				n = n.parentNode;
			}else{
				break;
			}
		}
		return as;
	};
	var n1as = getAncestors(n1);
	var n2as = getAncestors(n2);

	var m = Math.min(n1as.length,n2as.length);
	var com = n1as[0]; //at least, one element should be in the array: the root (BODY by default)
	for(var i=1;i<m;i++){
		if(n1as[i] === n2as[i]){
			com = n1as[i]
		}else{
			break;
		}
	}
	return com;
}

dijit.range.getAncestor = function(/*DomNode*/node, /*RegEx?*/regex, /*DomNode?*/root){
	root = root || node.ownerDocument.body;
	while(node && node !== root){
		var name = node.nodeName.toUpperCase() ;
		if(regex.test(name)){
			return node;
		}

		node = node.parentNode;
	}
	return null;
}

dijit.range.BlockTagNames = /^(?:P|DIV|H1|H2|H3|H4|H5|H6|ADDRESS|PRE|OL|UL|LI|DT|DE)$/;
dijit.range.getBlockAncestor = function(/*DomNode*/node, /*RegEx?*/regex, /*DomNode?*/root){
	root = root || node.ownerDocument.body;
	regex = regex || dijit.range.BlockTagNames;
	var block=null, blockContainer;
	while(node && node !== root){
		var name = node.nodeName.toUpperCase() ;
		if(!block && regex.test(name)){
			block = node;
		}
		if(!blockContainer && (/^(?:BODY|TD|TH|CAPTION)$/).test(name)){
			blockContainer = node;
		}

		node = node.parentNode;
	}
	return {blockNode:block, blockContainer:blockContainer || node.ownerDocument.body};
}

dijit.range.atBeginningOfContainer = function(/*DomNode*/container, /*DomNode*/node, /*Int*/offset){
	var atBeginning = false;
	var offsetAtBeginning = (offset == 0);
	if(!offsetAtBeginning && node.nodeType == 3){ //if this is a text node, check whether the left part is all space
		if(/^[\s\xA0]+$/.test(node.nodeValue.substr(0,offset))){
			offsetAtBeginning = true;
		}
	}
	if(offsetAtBeginning){
		var cnode = node;
		atBeginning = true;
		while(cnode && cnode !== container){
			if(cnode.previousSibling){
				atBeginning = false;
				break;
			}
			cnode = cnode.parentNode;
		}
	}
	return atBeginning;
}

dijit.range.atEndOfContainer = function(/*DomNode*/container, /*DomNode*/node, /*Int*/offset){
	var atEnd = false;
	var offsetAtEnd = (offset == (node.length || node.childNodes.length));
	if(!offsetAtEnd && node.nodeType == 3){ //if this is a text node, check whether the right part is all space
		if(/^[\s\xA0]+$/.test(node.nodeValue.substr(offset))){
			offsetAtEnd = true;
		}
	}
	if(offsetAtEnd){
		var cnode = node;
		atEnd = true;
		while(cnode && cnode !== container){
			if(cnode.nextSibling){
				atEnd = false;
				break;
			}
			cnode = cnode.parentNode;
		}
	}
	return atEnd;
}

dijit.range.adjacentNoneTextNode=function(startnode, next){
	var node = startnode;
	var len = (0-startnode.length) || 0;
	var prop = next?'nextSibling':'previousSibling';
	while(node){
		if(node.nodeType!=3){
			break;
		}
		len += node.length
		node = node[prop];
	}
	return [node,len];
}

dijit.range._w3c = Boolean(window['getSelection']);
dijit.range.create = function(/*Window?*/win){
	if(dijit.range._w3c){
		return (win || dojo.global).document.createRange();
	}else{//IE
		return new dijit.range.W3CRange;
	}
}

dijit.range.getSelection = function(/*Window*/win, /*Boolean?*/ignoreUpdate){
	if(dijit.range._w3c){
		return win.getSelection();
	}else{//IE
		var s = new dijit.range.ie.selection(win);
		if(!ignoreUpdate){
			s._getCurrentSelection();
		}
		return s;
	}
}

if(!dijit.range._w3c){
	dijit.range.ie={
		cachedSelection: {},
		selection: function(win){
			this._ranges = [];
			this.addRange = function(r, /*boolean*/internal){
				this._ranges.push(r);
				if(!internal){
					r._select();
				}
				this.rangeCount = this._ranges.length;
			};
			this.removeAllRanges = function(){
				//don't detach, the range may be used later
//				for(var i=0;i<this._ranges.length;i++){
//					this._ranges[i].detach();
//				}
				this._ranges = [];
				this.rangeCount = 0;
			};
			var _initCurrentRange = function(){
				var r = win.document.selection.createRange();
				var type=win.document.selection.type.toUpperCase();
				if(type == "CONTROL"){
					//TODO: multiple range selection(?)
					return new dijit.range.W3CRange(dijit.range.ie.decomposeControlRange(r));
				}else{
					return new dijit.range.W3CRange(dijit.range.ie.decomposeTextRange(r));
				}
			};
			this.getRangeAt = function(i){
				return this._ranges[i];
			};
			this._getCurrentSelection = function(){
				this.removeAllRanges();
				var r=_initCurrentRange();
				if(r){
					this.addRange(r, true);
				}
			};
		},
		decomposeControlRange: function(range){
			var firstnode = range.item(0), lastnode = range.item(range.length-1);
			var startContainer = firstnode.parentNode, endContainer = lastnode.parentNode;
			var startOffset = dijit.range.getIndex(firstnode, startContainer).o;
			var endOffset = dijit.range.getIndex(lastnode, endContainer).o+1;
			return [startContainer, startOffset,endContainer, endOffset];
		},
		getEndPoint: function(range, end){
			var atmrange = range.duplicate();
			atmrange.collapse(!end);
			var cmpstr = 'EndTo' + (end?'End':'Start');
			var parentNode = atmrange.parentElement();

			var startnode, startOffset, lastNode;
			if(parentNode.childNodes.length>0){
				dojo.every(parentNode.childNodes, function(node,i){
					var calOffset;
					if(node.nodeType != 3){
						atmrange.moveToElementText(node);

						if(atmrange.compareEndPoints(cmpstr,range) > 0){
							//startnode = node.previousSibling;
							if(lastNode && lastNode.nodeType == 3){
								//where shall we put the start? in the text node or after?
								startnode = lastNode;
								calOffset = true;
							}else{
								startnode = parentNode;
								startOffset = i;
								return false;
							}
						}else{
							if(i == parentNode.childNodes.length-1){
								startnode = parentNode;
								startOffset = parentNode.childNodes.length;
								return false;
							}
						}
					}else{
						if(i == parentNode.childNodes.length-1){//at the end of this node
							startnode = node;
							calOffset = true;
						}
					}
		//			try{
						if(calOffset && startnode){
							var prevnode = dijit.range.adjacentNoneTextNode(startnode)[0];
							if(prevnode){
								startnode = prevnode.nextSibling;
							}else{
								startnode = parentNode.firstChild; //firstChild must be a text node
							}
							var prevnodeobj = dijit.range.adjacentNoneTextNode(startnode);
							prevnode = prevnodeobj[0];
							var lenoffset = prevnodeobj[1];
							if(prevnode){
								atmrange.moveToElementText(prevnode);
								atmrange.collapse(false);
							}else{
								atmrange.moveToElementText(parentNode);
							}
							atmrange.setEndPoint(cmpstr, range);
							startOffset = atmrange.text.length-lenoffset;

							return false;
						}
		//			}catch(e){ debugger }
					lastNode = node;
					return true;
				});
			}else{
				startnode = parentNode;
				startOffset = 0;
			}

			//if at the end of startnode and we are dealing with start container, then
			//move the startnode to nextSibling if it is a text node
			//TODO: do this for end container?
			if(!end && startnode.nodeType == 1 && startOffset == startnode.childNodes.length){
				var nextnode=startnode.nextSibling;
				if(nextnode && nextnode.nodeType == 3){
					startnode = nextnode;
					startOffset = 0;
				}
			}
			return [startnode, startOffset];
		},
		setEndPoint: function(range, container, offset){
			//text node
			var atmrange = range.duplicate(), node, len;
			if(container.nodeType!=3){ //normal node
				if(offset > 0){
					node = container.childNodes[offset-1];
					if(node){
						if(node.nodeType == 3){
							container = node;
							offset = node.length;
							//pass through
						}else{
							if(node.nextSibling && node.nextSibling.nodeType == 3){
								container=node.nextSibling;
								offset=0;
								//pass through
							}else{
								atmrange.moveToElementText(node.nextSibling?node:container);
								var parent = node.parentNode;
								var tempNode = parent.insertBefore(node.ownerDocument.createTextNode(' '), node.nextSibling);
								atmrange.collapse(false);
								parent.removeChild(tempNode);
							}
						}
					}
				}else{
					atmrange.moveToElementText(container);
					atmrange.collapse(true);
				}
			}
			if(container.nodeType == 3){
				var prevnodeobj = dijit.range.adjacentNoneTextNode(container);
				var prevnode = prevnodeobj[0];
				len = prevnodeobj[1];
				if(prevnode){
					atmrange.moveToElementText(prevnode);
					atmrange.collapse(false);
					//if contentEditable is not inherit, the above collapse won't make the end point
					//in the correctly position: it always has a -1 offset, so compensate it
					if(prevnode.contentEditable!='inherit'){
						len++;
					}
				}else{
					atmrange.moveToElementText(container.parentNode);
					atmrange.collapse(true);
				}

				offset += len;
				if(offset>0){
					if(atmrange.move('character',offset) != offset){
						console.error('Error when moving!');
					}
				}
			}

			return atmrange;
		},
		decomposeTextRange: function(range){
			var tmpary = dijit.range.ie.getEndPoint(range);
			var startContainer = tmpary[0], startOffset = tmpary[1];
			var endContainer = tmpary[0], endOffset = tmpary[1];

			if(range.htmlText.length){
				if(range.htmlText == range.text){ //in the same text node
					endOffset = startOffset+range.text.length;
				}else{
					tmpary = dijit.range.ie.getEndPoint(range,true);
					endContainer = tmpary[0], endOffset = tmpary[1];
//					if(startContainer.tagName == "BODY"){
//						startContainer = startContainer.firstChild;
//					}
				}
			}
			return [startContainer, startOffset, endContainer, endOffset];
		},
		setRange: function(range, startContainer,
			startOffset, endContainer, endOffset, collapsed){
			var start=dijit.range.ie.setEndPoint(range, startContainer, startOffset);

			range.setEndPoint('StartToStart',start);
			if(!collapsed){
				var end=dijit.range.ie.setEndPoint(range, endContainer, endOffset);
			}
			range.setEndPoint('EndToEnd',end || start);

			return range;
		}
	}

dojo.declare("dijit.range.W3CRange",null, {
	constructor: function(){
		if(arguments.length>0){
			this.setStart(arguments[0][0],arguments[0][1]);
			this.setEnd(arguments[0][2],arguments[0][3]);
		}else{
			this.commonAncestorContainer = null;
			this.startContainer = null;
			this.startOffset = 0;
			this.endContainer = null;
			this.endOffset = 0;
			this.collapsed = true;
		}
	},
	_updateInternal: function(){
		if(this.startContainer !== this.endContainer){
			this.commonAncestorContainer = dijit.range.getCommonAncestor(this.startContainer, this.endContainer);
		}else{
			this.commonAncestorContainer = this.startContainer;
		}
		this.collapsed = (this.startContainer === this.endContainer) && (this.startOffset == this.endOffset);
	},
	setStart: function(node, offset){
		offset=parseInt(offset);
		if(this.startContainer === node && this.startOffset == offset){
			return;
		}
		delete this._cachedBookmark;

		this.startContainer = node;
		this.startOffset = offset;
		if(!this.endContainer){
			this.setEnd(node, offset);
		}else{
			this._updateInternal();
		}
	},
	setEnd: function(node, offset){
		offset=parseInt(offset);
		if(this.endContainer === node && this.endOffset == offset){
			return;
		}
		delete this._cachedBookmark;

		this.endContainer = node;
		this.endOffset = offset;
		if(!this.startContainer){
			this.setStart(node, offset);
		}else{
			this._updateInternal();
		}
	},
	setStartAfter: function(node, offset){
		this._setPoint('setStart', node, offset, 1);
	},
	setStartBefore: function(node, offset){
		this._setPoint('setStart', node, offset, 0);
	},
	setEndAfter: function(node, offset){
		this._setPoint('setEnd', node, offset, 1);
	},
	setEndBefore: function(node, offset){
		this._setPoint('setEnd', node, offset, 0);
	},
	_setPoint: function(what, node, offset, ext){
		var index = dijit.range.getIndex(node, node.parentNode).o;
		this[what](node.parentNode, index.pop()+ext);
	},
	_getIERange: function(){
		var r = (this._body || this.endContainer.ownerDocument.body).createTextRange();
		dijit.range.ie.setRange(r, this.startContainer, this.startOffset, this.endContainer, this.endOffset, this.collapsed);
		return r;
	},
	getBookmark: function(body){
		this._getIERange();
		return this._cachedBookmark;
	},
	_select: function(){
		var r = this._getIERange();
		r.select();
	},
	deleteContents: function(){
		var r = this._getIERange();
		r.pasteHTML('');
		this.endContainer = this.startContainer;
		this.endOffset = this.startOffset;
		this.collapsed = true;
	},
	cloneRange: function(){
		var r = new dijit.range.W3CRange([this.startContainer,this.startOffset,
			this.endContainer,this.endOffset]);
		r._body = this._body;
		return r;
	},
	detach: function(){
		this._body = null;
		this.commonAncestorContainer = null;
		this.startContainer = null;
		this.startOffset = 0;
		this.endContainer = null;
		this.endOffset = 0;
		this.collapsed = true;
}
});
} //if(!dijit.range._w3c)

}

if(!dojo._hasResource["dijit._editor.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.html"] = true;
dojo.provide("dijit._editor.html");

dojo.getObject("_editor", true, dijit);

dijit._editor.escapeXml=function(/*String*/str, /*Boolean?*/noSingleQuotes){
	// summary:
	//		Adds escape sequences for special characters in XML: &<>"'
	//		Optionally skips escapes for single quotes
	str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
	if(!noSingleQuotes){
		str = str.replace(/'/gm, "&#39;");
	}
	return str; // string
};

dijit._editor.getNodeHtml=function(/* DomNode */node){
	var output;
	switch(node.nodeType){
		case 1: //element node
			var lName = node.nodeName.toLowerCase();
			if(!lName || lName.charAt(0) == "/"){
				// IE does some strange things with malformed HTML input, like
				// treating a close tag </span> without an open tag <span>, as
				// a new tag with tagName of /span.  Corrupts output HTML, remove
				// them.  Other browsers don't prefix tags that way, so will
				// never show up.
				return "";
			}
			output = '<' + lName;

			//store the list of attributes and sort it to have the
			//attributes appear in the dictionary order
			var attrarray = [];
			var attr;
			if(dojo.isIE && node.outerHTML){
				var s = node.outerHTML;
				s = s.substr(0, s.indexOf('>'))
					.replace(/(['"])[^"']*\1/g, ''); //to make the following regexp safe
				var reg = /(\b\w+)\s?=/g;
				var m, key;
				while((m = reg.exec(s))){
					key = m[1];
					if(key.substr(0,3) != '_dj'){
						if(key == 'src' || key == 'href'){
							if(node.getAttribute('_djrealurl')){
								attrarray.push([key,node.getAttribute('_djrealurl')]);
								continue;
							}
						}
						var val, match;
						switch(key){
							case 'style':
								val = node.style.cssText.toLowerCase();
								break;
							case 'class':
								val = node.className;
								break;
							case 'width':
								if(lName === "img"){
									// This somehow gets lost on IE for IMG tags and the like
									// and we have to find it in outerHTML, known IE oddity.
									match=/width=(\S+)/i.exec(s);
									if(match){
										val = match[1];
									}
									break;
								}
							case 'height':
								if(lName === "img"){
									// This somehow gets lost on IE for IMG tags and the like
									// and we have to find it in outerHTML, known IE oddity.
									match=/height=(\S+)/i.exec(s);
									if(match){
										val = match[1];
									}
									break;
								}
							default:
								val = node.getAttribute(key);
						}
						if(val != null){
							attrarray.push([key, val.toString()]);
						}
					}
				}
			}else{
				var i = 0;
				while((attr = node.attributes[i++])){
					//ignore all attributes starting with _dj which are
					//internal temporary attributes used by the editor
					var n = attr.name;
					if(n.substr(0,3) != '_dj' /*&&
						(attr.specified == undefined || attr.specified)*/){
						var v = attr.value;
						if(n == 'src' || n == 'href'){
							if(node.getAttribute('_djrealurl')){
								v = node.getAttribute('_djrealurl');
							}
						}
						attrarray.push([n,v]);
					}
				}
			}
			attrarray.sort(function(a,b){
				return a[0] < b[0] ? -1 : (a[0] == b[0] ? 0 : 1);
			});
			var j = 0;
			while((attr = attrarray[j++])){
				output += ' ' + attr[0] + '="' +
					(dojo.isString(attr[1]) ? dijit._editor.escapeXml(attr[1], true) : attr[1]) + '"';
			}
			if(lName === "script"){
				// Browsers handle script tags differently in how you get content,
				// but innerHTML always seems to work, so insert its content that way
				// Yes, it's bad to allow script tags in the editor code, but some people
				// seem to want to do it, so we need to at least return them right.
				// other plugins/filters can strip them.
				output += '>' + node.innerHTML +'</' + lName + '>';
			}else{
				if(node.childNodes.length){
					output += '>' + dijit._editor.getChildrenHtml(node)+'</' + lName +'>';
				}else{
					switch(lName){
						case 'br':
						case 'hr':
						case 'img':
						case 'input':
						case 'base':
						case 'meta':
						case 'area':
						case 'basefont':
							// These should all be singly closed
							output += ' />';
							break;
						default:
							// Assume XML style separate closure for everything else.
							output += '></' + lName + '>';
					}
				}
			}
			break;
		case 4: // cdata
		case 3: // text
			// FIXME:
			output = dijit._editor.escapeXml(node.nodeValue, true);
			break;
		case 8: //comment
			// FIXME:
			output = '<!--' + dijit._editor.escapeXml(node.nodeValue, true) + '-->';
			break;
		default:
			output = "<!-- Element not recognized - Type: " + node.nodeType + " Name: " + node.nodeName + "-->";
	}
	return output;
};

dijit._editor.getChildrenHtml = function(/* DomNode */dom){
	// summary:
	//		Returns the html content of a DomNode and children
	var out = "";
	if(!dom){ return out; }
	var nodes = dom["childNodes"] || dom;

	//IE issue.
	//If we have an actual node we can check parent relationships on for IE,
	//We should check, as IE sometimes builds invalid DOMS.  If no parent, we can't check
	//And should just process it and hope for the best.
	var checkParent = !dojo.isIE || nodes !== dom;

	var node, i = 0;
	while((node = nodes[i++])){
		//IE is broken.  DOMs are supposed to be a tree.  But in the case of malformed HTML, IE generates a graph
		//meaning one node ends up with multiple references (multiple parents).  This is totally wrong and invalid, but
		//such is what it is.  We have to keep track and check for this because otherise the source output HTML will have dups.
		//No other browser generates a graph.  Leave it to IE to break a fundamental DOM rule.  So, we check the parent if we can
		//If we can't, nothing more we can do other than walk it.
		if(!checkParent || node.parentNode == dom){
			out += dijit._editor.getNodeHtml(node);
		}
	}
	return out; // String
};

}

if(!dojo._hasResource["dijit._editor.RichText"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.RichText"] = true;
dojo.provide("dijit._editor.RichText");







// used to restore content when user leaves this page then comes back
// but do not try doing dojo.doc.write if we are using xd loading.
// dojo.doc.write will only work if RichText.js is included in the dojo.js
// file. If it is included in dojo.js and you want to allow rich text saving
// for back/forward actions, then set dojo.config.allowXdRichTextSave = true.
if(!dojo.config["useXDomain"] || dojo.config["allowXdRichTextSave"]){
	if(dojo._postLoad){
		(function(){
			var savetextarea = dojo.doc.createElement('textarea');
			savetextarea.id = dijit._scopeName + "._editor.RichText.value";
			dojo.style(savetextarea, {
				display:'none',
				position:'absolute',
				top:"-100px",
				height:"3px",
				width:"3px"
			});
			dojo.body().appendChild(savetextarea);
		})();
	}else{
		//dojo.body() is not available before onLoad is fired
		try{
			dojo.doc.write('<textarea id="' + dijit._scopeName + '._editor.RichText.value" ' +
				'style="display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;"></textarea>');
		}catch(e){ }
	}
}

dojo.declare("dijit._editor.RichText", [dijit._Widget, dijit._CssStateMixin], {
	constructor: function(params){
		// summary:
		//		dijit._editor.RichText is the core of dijit.Editor, which provides basic
		//		WYSIWYG editing features.
		//
		// description:
		//		dijit._editor.RichText is the core of dijit.Editor, which provides basic
		//		WYSIWYG editing features. It also encapsulates the differences
		//		of different js engines for various browsers.  Do not use this widget
		//		with an HTML &lt;TEXTAREA&gt; tag, since the browser unescapes XML escape characters,
		//		like &lt;.  This can have unexpected behavior and lead to security issues
		//		such as scripting attacks.
		//
		// tags:
		//		private

		// contentPreFilters: Function(String)[]
		//		Pre content filter function register array.
		//		these filters will be executed before the actual
		//		editing area gets the html content.
		this.contentPreFilters = [];

		// contentPostFilters: Function(String)[]
		//		post content filter function register array.
		//		These will be used on the resulting html
		//		from contentDomPostFilters. The resulting
		//		content is the final html (returned by getValue()).
		this.contentPostFilters = [];

		// contentDomPreFilters: Function(DomNode)[]
		//		Pre content dom filter function register array.
		//		These filters are applied after the result from
		//		contentPreFilters are set to the editing area.
		this.contentDomPreFilters = [];

		// contentDomPostFilters: Function(DomNode)[]
		//		Post content dom filter function register array.
		//		These filters are executed on the editing area dom.
		//		The result from these will be passed to contentPostFilters.
		this.contentDomPostFilters = [];

		// editingAreaStyleSheets: dojo._URL[]
		//		array to store all the stylesheets applied to the editing area
		this.editingAreaStyleSheets = [];

		// Make a copy of this.events before we start writing into it, otherwise we
		// will modify the prototype which leads to bad things on pages w/multiple editors
		this.events = [].concat(this.events);

		this._keyHandlers = {};

		if(params && dojo.isString(params.value)){
			this.value = params.value;
		}

		this.onLoadDeferred = new dojo.Deferred();
	},

	baseClass: "dijitEditor",

	// inheritWidth: Boolean
	//		whether to inherit the parent's width or simply use 100%
	inheritWidth: false,

	// focusOnLoad: [deprecated] Boolean
	//		Focus into this widget when the page is loaded
	focusOnLoad: false,

	// name: String?
	//		Specifies the name of a (hidden) <textarea> node on the page that's used to save
	//		the editor content on page leave.   Used to restore editor contents after navigating
	//		to a new page and then hitting the back button.
	name: "",

	// styleSheets: [const] String
	//		semicolon (";") separated list of css files for the editing area
	styleSheets: "",

	// height: String
	//		Set height to fix the editor at a specific height, with scrolling.
	//		By default, this is 300px.  If you want to have the editor always
	//		resizes to accommodate the content, use AlwaysShowToolbar plugin
	//		and set height="".  If this editor is used within a layout widget,
	//		set height="100%".
	height: "300px",

	// minHeight: String
	//		The minimum height that the editor should have.
	minHeight: "1em",

	// isClosed: [private] Boolean
	isClosed: true,

	// isLoaded: [private] Boolean
	isLoaded: false,

	// _SEPARATOR: [private] String
	//		Used to concat contents from multiple editors into a single string,
	//		so they can be saved into a single <textarea> node.  See "name" attribute.
	_SEPARATOR: "@@**%%__RICHTEXTBOUNDRY__%%**@@",

	// _NAME_CONTENT_SEP: [private] String
	//		USed to separate name from content.  Just a colon isn't safe.
	_NAME_CONTENT_SEP: "@@**%%:%%**@@",

	// onLoadDeferred: [readonly] dojo.Deferred
	//		Deferred which is fired when the editor finishes loading.
	//		Call myEditor.onLoadDeferred.then(callback) it to be informed
	//		when the rich-text area initialization is finalized.
	onLoadDeferred: null,

	// isTabIndent: Boolean
	//		Make tab key and shift-tab indent and outdent rather than navigating.
	//		Caution: sing this makes web pages inaccessible to users unable to use a mouse.
	isTabIndent: false,

	// disableSpellCheck: [const] Boolean
	//		When true, disables the browser's native spell checking, if supported.
	//		Works only in Firefox.
	disableSpellCheck: false,

	postCreate: function(){
		if("textarea" == this.domNode.tagName.toLowerCase()){
			console.warn("RichText should not be used with the TEXTAREA tag.  See dijit._editor.RichText docs.");
		}

		// Push in the builtin filters now, making them the first executed, but not over-riding anything
		// users passed in.  See: #6062
		this.contentPreFilters = [dojo.hitch(this, "_preFixUrlAttributes")].concat(this.contentPreFilters);
		if(dojo.isMoz){
			this.contentPreFilters = [this._normalizeFontStyle].concat(this.contentPreFilters);
			this.contentPostFilters = [this._removeMozBogus].concat(this.contentPostFilters);
		}
		if(dojo.isWebKit){
			// Try to clean up WebKit bogus artifacts.  The inserted classes
			// made by WebKit sometimes messes things up.
			this.contentPreFilters = [this._removeWebkitBogus].concat(this.contentPreFilters);
			this.contentPostFilters = [this._removeWebkitBogus].concat(this.contentPostFilters);
		}
		if(dojo.isIE){
			// IE generates <strong> and <em> but we want to normalize to <b> and <i>
			this.contentPostFilters = [this._normalizeFontStyle].concat(this.contentPostFilters);
		}
		this.inherited(arguments);

		dojo.publish(dijit._scopeName + "._editor.RichText::init", [this]);
		this.open();
		this.setupDefaultShortcuts();
	},

	setupDefaultShortcuts: function(){
		// summary:
		//		Add some default key handlers
		// description:
		// 		Overwrite this to setup your own handlers. The default
		// 		implementation does not use Editor commands, but directly
		//		executes the builtin commands within the underlying browser
		//		support.
		// tags:
		//		protected
		var exec = dojo.hitch(this, function(cmd, arg){
			return function(){
				return !this.execCommand(cmd,arg);
			};
		});

		var ctrlKeyHandlers = {
			b: exec("bold"),
			i: exec("italic"),
			u: exec("underline"),
			a: exec("selectall"),
			s: function(){ this.save(true); },
			m: function(){ this.isTabIndent = !this.isTabIndent; },

			"1": exec("formatblock", "h1"),
			"2": exec("formatblock", "h2"),
			"3": exec("formatblock", "h3"),
			"4": exec("formatblock", "h4"),

			"\\": exec("insertunorderedlist")
		};

		if(!dojo.isIE){
			ctrlKeyHandlers.Z = exec("redo"); //FIXME: undo?
		}

		for(var key in ctrlKeyHandlers){
			this.addKeyHandler(key, true, false, ctrlKeyHandlers[key]);
		}
	},

	// events: [private] String[]
	//		 events which should be connected to the underlying editing area
	events: ["onKeyPress", "onKeyDown", "onKeyUp"], // onClick handled specially

	// captureEvents: [deprecated] String[]
	//		 Events which should be connected to the underlying editing
	//		 area, events in this array will be addListener with
	//		 capture=true.
	// TODO: looking at the code I don't see any distinction between events and captureEvents,
	// so get rid of this for 2.0 if not sooner
	captureEvents: [],

	_editorCommandsLocalized: false,
	_localizeEditorCommands: function(){
		// summary:
		//		When IE is running in a non-English locale, the API actually changes,
		//		so that we have to say (for example) danraku instead of p (for paragraph).
		//		Handle that here.
		// tags:
		//		private
		if(dijit._editor._editorCommandsLocalized){
			// Use the already generate cache of mappings.  
			this._local2NativeFormatNames = dijit._editor._local2NativeFormatNames;
			this._native2LocalFormatNames = dijit._editor._native2LocalFormatNames;
			return;
		}
		dijit._editor._editorCommandsLocalized = true;
		dijit._editor._local2NativeFormatNames = {};
		dijit._editor._native2LocalFormatNames = {};
		this._local2NativeFormatNames = dijit._editor._local2NativeFormatNames;
		this._native2LocalFormatNames = dijit._editor._native2LocalFormatNames;
		//in IE, names for blockformat is locale dependent, so we cache the values here

		//put p after div, so if IE returns Normal, we show it as paragraph
		//We can distinguish p and div if IE returns Normal, however, in order to detect that,
		//we have to call this.document.selection.createRange().parentElement() or such, which
		//could slow things down. Leave it as it is for now
		var formats = ['div', 'p', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'ul', 'address'];
		var localhtml = "", format, i=0;
		while((format=formats[i++])){
			//append a <br> after each element to separate the elements more reliably
			if(format.charAt(1) !== 'l'){
				localhtml += "<"+format+"><span>content</span></"+format+"><br/>";
			}else{
				localhtml += "<"+format+"><li>content</li></"+format+"><br/>";
			}
		}
		// queryCommandValue returns empty if we hide editNode, so move it out of screen temporary
		// Also, IE9 does weird stuff unless we do it inside the editor iframe.
		var style = { position: "absolute", top: "0px", zIndex: 10, opacity: 0.01 };
		var div = dojo.create('div', {style: style, innerHTML: localhtml});
		dojo.body().appendChild(div);

		// IE9 has a timing issue with doing this right after setting
		// the inner HTML, so put a delay in.
		var inject = dojo.hitch(this, function(){
			var node = div.firstChild;
			while(node){
				try{
					dijit._editor.selection.selectElement(node.firstChild);
					var nativename = node.tagName.toLowerCase();
					this._local2NativeFormatNames[nativename] = document.queryCommandValue("formatblock");
					this._native2LocalFormatNames[this._local2NativeFormatNames[nativename]] = nativename;
					node = node.nextSibling.nextSibling;
					//console.log("Mapped: ", nativename, " to: ", this._local2NativeFormatNames[nativename]);
				}catch(e) { /*Sqelch the occasional IE9 error */ }
			}
			div.parentNode.removeChild(div);
			div.innerHTML = "";
		});
		setTimeout(inject, 0);
	},

	open: function(/*DomNode?*/ element){
		// summary:
		//		Transforms the node referenced in this.domNode into a rich text editing
		//		node.
		// description:
		//		Sets up the editing area asynchronously. This will result in
		//		the creation and replacement with an iframe.
		// tags:
		//		private

		if(!this.onLoadDeferred || this.onLoadDeferred.fired >= 0){
			this.onLoadDeferred = new dojo.Deferred();
		}

		if(!this.isClosed){ this.close(); }
		dojo.publish(dijit._scopeName + "._editor.RichText::open", [ this ]);

		if(arguments.length == 1 && element.nodeName){ // else unchanged
			this.domNode = element;
		}

		var dn = this.domNode;

		// "html" will hold the innerHTML of the srcNodeRef and will be used to
		// initialize the editor.
		var html;

		if(dojo.isString(this.value)){
			// Allow setting the editor content programmatically instead of
			// relying on the initial content being contained within the target
			// domNode.
			html = this.value;
			delete this.value;
			dn.innerHTML = "";
		}else if(dn.nodeName && dn.nodeName.toLowerCase() == "textarea"){
			// if we were created from a textarea, then we need to create a
			// new editing harness node.
			var ta = (this.textarea = dn);
			this.name = ta.name;
			html = ta.value;
			dn = this.domNode = dojo.doc.createElement("div");
			dn.setAttribute('widgetId', this.id);
			ta.removeAttribute('widgetId');
			dn.cssText = ta.cssText;
			dn.className += " " + ta.className;
			dojo.place(dn, ta, "before");
			var tmpFunc = dojo.hitch(this, function(){
				//some browsers refuse to submit display=none textarea, so
				//move the textarea off screen instead
				dojo.style(ta, {
					display: "block",
					position: "absolute",
					top: "-1000px"
				});

				if(dojo.isIE){ //nasty IE bug: abnormal formatting if overflow is not hidden
					var s = ta.style;
					this.__overflow = s.overflow;
					s.overflow = "hidden";
				}
			});
			if(dojo.isIE){
				setTimeout(tmpFunc, 10);
			}else{
				tmpFunc();
			}

			if(ta.form){
				var resetValue = ta.value;
				this.reset = function(){
					var current = this.getValue();
					if(current != resetValue){
						this.replaceValue(resetValue);
					}
				};
				dojo.connect(ta.form, "onsubmit", this, function(){
					// Copy value to the <textarea> so it gets submitted along with form.
					// FIXME: should we be calling close() here instead?
					dojo.attr(ta, 'disabled', this.disabled); // don't submit the value if disabled
					ta.value = this.getValue();
				});
			}
		}else{
			html = dijit._editor.getChildrenHtml(dn);
			dn.innerHTML = "";
		}

		var content = dojo.contentBox(dn);
		this._oldHeight = content.h;
		this._oldWidth = content.w;

		this.value = html;

		// If we're a list item we have to put in a blank line to force the
		// bullet to nicely align at the top of text
		if(dn.nodeName && dn.nodeName == "LI"){
			dn.innerHTML = " <br>";
		}
	
		// Construct the editor div structure.
		this.header = dn.ownerDocument.createElement("div");
		dn.appendChild(this.header);
		this.editingArea = dn.ownerDocument.createElement("div");
		dn.appendChild(this.editingArea);
		this.footer = dn.ownerDocument.createElement("div");
		dn.appendChild(this.footer);

		if(!this.name){
			this.name = this.id + "_AUTOGEN";
		}

		// User has pressed back/forward button so we lost the text in the editor, but it's saved
		// in a hidden <textarea> (which contains the data for all the editors on this page),
		// so get editor value from there
		if(this.name !== "" && (!dojo.config["useXDomain"] || dojo.config["allowXdRichTextSave"])){
			var saveTextarea = dojo.byId(dijit._scopeName + "._editor.RichText.value");
			if(saveTextarea && saveTextarea.value !== ""){
				var datas = saveTextarea.value.split(this._SEPARATOR), i=0, dat;
				while((dat=datas[i++])){
					var data = dat.split(this._NAME_CONTENT_SEP);
					if(data[0] == this.name){
						html = data[1];
						datas = datas.splice(i, 1);
						saveTextarea.value = datas.join(this._SEPARATOR);
						break;
					}
				}
			}

			if(!dijit._editor._globalSaveHandler){
				dijit._editor._globalSaveHandler = {};
				dojo.addOnUnload(function() {
					var id;
					for(id in dijit._editor._globalSaveHandler){
						var f = dijit._editor._globalSaveHandler[id];
						if(dojo.isFunction(f)){
							f();
						}
					}
				});
			}
			dijit._editor._globalSaveHandler[this.id] = dojo.hitch(this, "_saveContent");
		}

		this.isClosed = false;

		var ifr = (this.editorObject = this.iframe = dojo.doc.createElement('iframe'));
		ifr.id = this.id+"_iframe";
		this._iframeSrc = this._getIframeDocTxt();
		ifr.style.border = "none";
		ifr.style.width = "100%";
		if(this._layoutMode){
			// iframe should be 100% height, thus getting it's height from surrounding
			// <div> (which has the correct height set by Editor)
			ifr.style.height = "100%";
		}else{
			if(dojo.isIE >= 7){
				if(this.height){
					ifr.style.height = this.height;
				}
				if(this.minHeight){
					ifr.style.minHeight = this.minHeight;
				}
			}else{
				ifr.style.height = this.height ? this.height : this.minHeight;
			}
		}
		ifr.frameBorder = 0;
		ifr._loadFunc = dojo.hitch( this, function(win){
			this.window = win;
			this.document = this.window.document;

			if(dojo.isIE){
				this._localizeEditorCommands();
			}
			
			// Do final setup and set initial contents of editor
			this.onLoad(html);
		});

		// Set the iframe's initial (blank) content.
		var s = 'javascript:parent.' + dijit._scopeName + '.byId("'+this.id+'")._iframeSrc';
		ifr.setAttribute('src', s);
		this.editingArea.appendChild(ifr);

		if(dojo.isSafari <= 4){
			var src = ifr.getAttribute("src");
			if(!src || src.indexOf("javascript") == -1){
				// Safari 4 and earlier sometimes act oddly
				// So we have to set it again.
				setTimeout(function(){ifr.setAttribute('src', s);},0);
			}
		}

		// TODO: this is a guess at the default line-height, kinda works
		if(dn.nodeName == "LI"){
			dn.lastChild.style.marginTop = "-1.2em";
		}

		dojo.addClass(this.domNode, this.baseClass);
	},

	//static cache variables shared among all instance of this class
	_local2NativeFormatNames: {},
	_native2LocalFormatNames: {},

	_getIframeDocTxt: function(){
		// summary:
		//		Generates the boilerplate text of the document inside the iframe (ie, <html><head>...</head><body/></html>).
		//		Editor content (if not blank) should be added afterwards.
		// tags:
		//		private
		var _cs = dojo.getComputedStyle(this.domNode);

		// The contents inside of <body>.  The real contents are set later via a call to setValue().
		var html = "";
		var setBodyId = true;
		if(dojo.isIE || dojo.isWebKit || (!this.height && !dojo.isMoz)){
			// In auto-expand mode, need a wrapper div for AlwaysShowToolbar plugin to correctly
			// expand/contract the editor as the content changes.
			html = "<div id='dijitEditorBody'></div>";
			setBodyId = false;
		}else if(dojo.isMoz){
			// workaround bug where can't select then delete text (until user types something
			// into the editor)... and/or issue where typing doesn't erase selected text
			this._cursorToStart = true;
			html = "&nbsp;";
		}

		var font = [ _cs.fontWeight, _cs.fontSize, _cs.fontFamily ].join(" ");

		// line height is tricky - applying a units value will mess things up.
		// if we can't get a non-units value, bail out.
		var lineHeight = _cs.lineHeight;
		if(lineHeight.indexOf("px") >= 0){
			lineHeight = parseFloat(lineHeight)/parseFloat(_cs.fontSize);
			// console.debug(lineHeight);
		}else if(lineHeight.indexOf("em")>=0){
			lineHeight = parseFloat(lineHeight);
		}else{
			// If we can't get a non-units value, just default
			// it to the CSS spec default of 'normal'.  Seems to
			// work better, esp on IE, than '1.0'
			lineHeight = "normal";
		}
		var userStyle = "";
		var self = this;
		this.style.replace(/(^|;)\s*(line-|font-?)[^;]+/ig, function(match){
			match = match.replace(/^;/ig,"") + ';';
			var s = match.split(":")[0];
			if(s){
				s = dojo.trim(s);
				s = s.toLowerCase();
				var i;
				var sC = "";
				for(i = 0; i < s.length; i++){
					var c = s.charAt(i);
					switch(c){
						case "-":
							i++;
							c = s.charAt(i).toUpperCase();
						default:
							sC += c;
					}
				}
				dojo.style(self.domNode, sC, "");
			}
			userStyle += match + ';';
		});


		// need to find any associated label element and update iframe document title
		var label=dojo.query('label[for="'+this.id+'"]');

		return [
			this.isLeftToRight() ? "<html>\n<head>\n" : "<html dir='rtl'>\n<head>\n",
			(dojo.isMoz && label.length ? "<title>" + label[0].innerHTML + "</title>\n" : ""),
			"<meta http-equiv='Content-Type' content='text/html'>\n",
			"<style>\n",
			"\tbody,html {\n",
			"\t\tbackground:transparent;\n",
			"\t\tpadding: 1px 0 0 0;\n",
			"\t\tmargin: -1px 0 0 0;\n", // remove extraneous vertical scrollbar on safari and firefox

			// Set the html/body sizing.  Webkit always needs this, other browsers
			// only set it when height is defined (not auto-expanding), otherwise
			// scrollers do not appear.
			((dojo.isWebKit)?"\t\twidth: 100%;\n":""),
			((dojo.isWebKit)?"\t\theight: 100%;\n":""),
			"\t}\n",
			
			// TODO: left positioning will cause contents to disappear out of view
			//	   if it gets too wide for the visible area
			"\tbody{\n",
			"\t\ttop:0px;\n",
			"\t\tleft:0px;\n",
			"\t\tright:0px;\n",
			"\t\tfont:", font, ";\n",
				((this.height||dojo.isOpera) ? "" : "\t\tposition: fixed;\n"),
			// FIXME: IE 6 won't understand min-height?
			"\t\tmin-height:", this.minHeight, ";\n",
			"\t\tline-height:", lineHeight,";\n",
			"\t}\n",
			"\tp{ margin: 1em 0; }\n",
			
			// Determine how scrollers should be applied.  In autoexpand mode (height = "") no scrollers on y at all.
			// But in fixed height mode we want both x/y scrollers.  Also, if it's using wrapping div and in auto-expand
			// (Mainly IE) we need to kill the y scroller on body and html.
			(!setBodyId && !this.height ? "\tbody,html {overflow-y: hidden;}\n" : ""),
			"\t#dijitEditorBody{overflow-x: auto; overflow-y:" + (this.height ? "auto;" : "hidden;") + " outline: 0px;}\n",
			"\tli > ul:-moz-first-node, li > ol:-moz-first-node{ padding-top: 1.2em; }\n",
			// Can't set min-height in IE9, it puts layout on li, which puts move/resize handles.
			(!dojo.isIE ? "\tli{ min-height:1.2em; }\n" : ""), 
			"</style>\n",
			this._applyEditingAreaStyleSheets(),"\n",
			"</head>\n<body ",
			(setBodyId?"id='dijitEditorBody' ":""),
			"onload='frameElement._loadFunc(window,document)' style='"+userStyle+"'>", html, "</body>\n</html>"
		].join(""); // String
	},

	_applyEditingAreaStyleSheets: function(){
		// summary:
		//		apply the specified css files in styleSheets
		// tags:
		//		private
		var files = [];
		if(this.styleSheets){
			files = this.styleSheets.split(';');
			this.styleSheets = '';
		}

		//empty this.editingAreaStyleSheets here, as it will be filled in addStyleSheet
		files = files.concat(this.editingAreaStyleSheets);
		this.editingAreaStyleSheets = [];

		var text='', i=0, url;
		while((url=files[i++])){
			var abstring = (new dojo._Url(dojo.global.location, url)).toString();
			this.editingAreaStyleSheets.push(abstring);
			text += '<link rel="stylesheet" type="text/css" href="'+abstring+'"/>';
		}
		return text;
	},

	addStyleSheet: function(/*dojo._Url*/ uri){
		// summary:
		//		add an external stylesheet for the editing area
		// uri:
		//		A dojo.uri.Uri pointing to the url of the external css file
		var url=uri.toString();

		//if uri is relative, then convert it to absolute so that it can be resolved correctly in iframe
		if(url.charAt(0) == '.' || (url.charAt(0) != '/' && !uri.host)){
			url = (new dojo._Url(dojo.global.location, url)).toString();
		}

		if(dojo.indexOf(this.editingAreaStyleSheets, url) > -1){
//			console.debug("dijit._editor.RichText.addStyleSheet: Style sheet "+url+" is already applied");
			return;
		}

		this.editingAreaStyleSheets.push(url);
		this.onLoadDeferred.addCallback(dojo.hitch(this, function(){
			if(this.document.createStyleSheet){ //IE
				this.document.createStyleSheet(url);
			}else{ //other browser
				var head = this.document.getElementsByTagName("head")[0];
				var stylesheet = this.document.createElement("link");
				stylesheet.rel="stylesheet";
				stylesheet.type="text/css";
				stylesheet.href=url;
				head.appendChild(stylesheet);
			}
		}));
	},

	removeStyleSheet: function(/*dojo._Url*/ uri){
		// summary:
		//		remove an external stylesheet for the editing area
		var url=uri.toString();
		//if uri is relative, then convert it to absolute so that it can be resolved correctly in iframe
		if(url.charAt(0) == '.' || (url.charAt(0) != '/' && !uri.host)){
			url = (new dojo._Url(dojo.global.location, url)).toString();
		}
		var index = dojo.indexOf(this.editingAreaStyleSheets, url);
		if(index == -1){
//			console.debug("dijit._editor.RichText.removeStyleSheet: Style sheet "+url+" has not been applied");
			return;
		}
		delete this.editingAreaStyleSheets[index];
		dojo.withGlobal(this.window,'query', dojo, ['link:[href="'+url+'"]']).orphan();
	},

	// disabled: Boolean
	//		The editor is disabled; the text cannot be changed.
	disabled: false,

	_mozSettingProps: {'styleWithCSS':false},
	_setDisabledAttr: function(/*Boolean*/ value){
		value = !!value;
		this._set("disabled", value);
		if(!this.isLoaded){ return; } // this method requires init to be complete
		if(dojo.isIE || dojo.isWebKit || dojo.isOpera){
			var preventIEfocus = dojo.isIE && (this.isLoaded || !this.focusOnLoad);
			if(preventIEfocus){ this.editNode.unselectable = "on"; }
			this.editNode.contentEditable = !value;
			if(preventIEfocus){
				var _this = this;
				setTimeout(function(){ _this.editNode.unselectable = "off"; }, 0);
			}
		}else{ //moz
			try{
				this.document.designMode=(value?'off':'on');
			}catch(e){ return; } // ! _disabledOK
			if(!value && this._mozSettingProps){
				var ps = this._mozSettingProps;
				for(var n in ps){
					if(ps.hasOwnProperty(n)){
						try{
							this.document.execCommand(n,false,ps[n]);
						}catch(e2){}
					}
				}
			}
//			this.document.execCommand('contentReadOnly', false, value);
//				if(value){
//					this.blur(); //to remove the blinking caret
//				}
		}
		this._disabledOK = true;
	},

/* Event handlers
 *****************/

	onLoad: function(/*String*/ html){
		// summary:
		//		Handler after the iframe finishes loading.
		// html: String
		//		Editor contents should be set to this value
		// tags:
		//		protected

		// TODO: rename this to _onLoad, make empty public onLoad() method, deprecate/make protected onLoadDeferred handler?

		if(!this.window.__registeredWindow){
			this.window.__registeredWindow = true;
			this._iframeRegHandle = dijit.registerIframe(this.iframe);
		}
		if(!dojo.isIE && !dojo.isWebKit && (this.height || dojo.isMoz)){
			this.editNode=this.document.body;
		}else{
			// there's a wrapper div around the content, see _getIframeDocTxt().
			this.editNode=this.document.body.firstChild;
			var _this = this;
			if(dojo.isIE){ // #4996 IE wants to focus the BODY tag
				this.tabStop = dojo.create('div', { tabIndex: -1 }, this.editingArea);
				this.iframe.onfocus = function(){ _this.editNode.setActive(); };
			}
		}
		this.focusNode = this.editNode; // for InlineEditBox


		var events = this.events.concat(this.captureEvents);
		var ap = this.iframe ? this.document : this.editNode;
		dojo.forEach(events, function(item){
			this.connect(ap, item.toLowerCase(), item);
		}, this);

		this.connect(ap, "onmouseup", "onClick"); // mouseup in the margin does not generate an onclick event

		if(dojo.isIE){ // IE contentEditable
			this.connect(this.document, "onmousedown", "_onIEMouseDown"); // #4996 fix focus

			// give the node Layout on IE
			// TODO: this may no longer be needed, since we've reverted IE to using an iframe,
			// not contentEditable.   Removing it would also probably remove the need for creating
			// the extra <div> in _getIframeDocTxt()
			this.editNode.style.zoom = 1.0;
		}else{
			this.connect(this.document, "onmousedown", function(){
				// Clear the moveToStart focus, as mouse
				// down will set cursor point.  Required to properly
				// work with selection/position driven plugins and clicks in
				// the window. refs: #10678
				delete this._cursorToStart;
			});
		}
		
		if(dojo.isWebKit){
			//WebKit sometimes doesn't fire right on selections, so the toolbar
			//doesn't update right.  Therefore, help it out a bit with an additional
			//listener.  A mouse up will typically indicate a display change, so fire this
			//and get the toolbar to adapt.  Reference: #9532
			this._webkitListener = this.connect(this.document, "onmouseup", "onDisplayChanged");
			this.connect(this.document, "onmousedown", function(e){
				var t = e.target;
				if(t && (t === this.document.body || t === this.document)){
					// Since WebKit uses the inner DIV, we need to check and set position.
					// See: #12024 as to why the change was made.
					setTimeout(dojo.hitch(this, "placeCursorAtEnd"), 0);
				}
			});
		}
		
		if(dojo.isIE){
			// Try to make sure 'hidden' elements aren't visible in edit mode (like browsers other than IE
			// do).  See #9103
			try{
				this.document.execCommand('RespectVisibilityInDesign', true, null);
			}catch(e){/* squelch */}
		}

		this.isLoaded = true;

		this.set('disabled', this.disabled); // initialize content to editable (or not)

		// Note that setValue() call will only work after isLoaded is set to true (above)

		// Set up a function to allow delaying the setValue until a callback is fired
		// This ensures extensions like dijit.Editor have a way to hold the value set
		// until plugins load (and do things like register filters).
		var setContent = dojo.hitch(this, function(){
			this.setValue(html);
			if(this.onLoadDeferred){
				this.onLoadDeferred.callback(true);
			}
			this.onDisplayChanged();
			if(this.focusOnLoad){
				// after the document loads, then set focus after updateInterval expires so that
				// onNormalizedDisplayChanged has run to avoid input caret issues
				dojo.addOnLoad(dojo.hitch(this, function(){ setTimeout(dojo.hitch(this, "focus"), this.updateInterval); }));
			}
			// Save off the initial content now
			this.value = this.getValue(true);
		});
		if(this.setValueDeferred){
			this.setValueDeferred.addCallback(setContent);
		}else{
			setContent();
		}
	},

	onKeyDown: function(/* Event */ e){
		// summary:
		//		Handler for onkeydown event
		// tags:
		//		protected

		// we need this event at the moment to get the events from control keys
		// such as the backspace. It might be possible to add this to Dojo, so that
		// keyPress events can be emulated by the keyDown and keyUp detection.

		if(e.keyCode === dojo.keys.TAB && this.isTabIndent ){
			dojo.stopEvent(e); //prevent tab from moving focus out of editor

			// FIXME: this is a poor-man's indent/outdent. It would be
			// better if it added 4 "&nbsp;" chars in an undoable way.
			// Unfortunately pasteHTML does not prove to be undoable
			if(this.queryCommandEnabled((e.shiftKey ? "outdent" : "indent"))){
				this.execCommand((e.shiftKey ? "outdent" : "indent"));
			}
		}
		if(dojo.isIE){
			if(e.keyCode == dojo.keys.TAB && !this.isTabIndent){
				if(e.shiftKey && !e.ctrlKey && !e.altKey){
					// focus the BODY so the browser will tab away from it instead
					this.iframe.focus();
				}else if(!e.shiftKey && !e.ctrlKey && !e.altKey){
					// focus the BODY so the browser will tab away from it instead
					this.tabStop.focus();
				}
			}else if(e.keyCode === dojo.keys.BACKSPACE && this.document.selection.type === "Control"){
				// IE has a bug where if a non-text object is selected in the editor,
				// hitting backspace would act as if the browser's back button was
				// clicked instead of deleting the object. see #1069
				dojo.stopEvent(e);
				this.execCommand("delete");
			}else if((65 <= e.keyCode && e.keyCode <= 90) ||
				(e.keyCode>=37 && e.keyCode<=40) // FIXME: get this from connect() instead!
			){ //arrow keys
				e.charCode = e.keyCode;
				this.onKeyPress(e);
			}
		}
		return true;
	},

	onKeyUp: function(e){
		// summary:
		//		Handler for onkeyup event
		// tags:
		//      callback
		return;
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated, use set('disabled', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated('dijit.Editor::setDisabled is deprecated','use dijit.Editor::attr("disabled",boolean) instead', 2.0);
		this.set('disabled',disabled);
	},
	_setValueAttr: function(/*String*/ value){
		// summary:
		//      Registers that attr("value", foo) should call setValue(foo)
		this.setValue(value);
	},
	_setDisableSpellCheckAttr: function(/*Boolean*/ disabled){
		if(this.document){
			dojo.attr(this.document.body, "spellcheck", !disabled);
		}else{
			// try again after the editor is finished loading
			this.onLoadDeferred.addCallback(dojo.hitch(this, function(){
				dojo.attr(this.document.body, "spellcheck", !disabled);
			}));
		}
		this._set("disableSpellCheck", disabled);
	},

	onKeyPress: function(e){
		// summary:
		//		Handle the various key events
		// tags:
		//		protected

		var c = (e.keyChar && e.keyChar.toLowerCase()) || e.keyCode,
			handlers = this._keyHandlers[c],
			args = arguments;

		if(handlers && !e.altKey){
			dojo.some(handlers, function(h){
				// treat meta- same as ctrl-, for benefit of mac users
				if(!(h.shift ^ e.shiftKey) && !(h.ctrl ^ (e.ctrlKey||e.metaKey))){
					if(!h.handler.apply(this, args)){
						e.preventDefault();
					}
					return true;
				}
			}, this);
		}

		// function call after the character has been inserted
		if(!this._onKeyHitch){
			this._onKeyHitch = dojo.hitch(this, "onKeyPressed");
		}
		setTimeout(this._onKeyHitch, 1);
		return true;
	},

	addKeyHandler: function(/*String*/ key, /*Boolean*/ ctrl, /*Boolean*/ shift, /*Function*/ handler){
		// summary:
		//		Add a handler for a keyboard shortcut
		// description:
		//		The key argument should be in lowercase if it is a letter character
		// tags:
		//		protected
		if(!dojo.isArray(this._keyHandlers[key])){
			this._keyHandlers[key] = [];
		}
		//TODO: would be nice to make this a hash instead of an array for quick lookups
		this._keyHandlers[key].push({
			shift: shift || false,
			ctrl: ctrl || false,
			handler: handler
		});
	},

	onKeyPressed: function(){
		// summary:
		//		Handler for after the user has pressed a key, and the display has been updated.
		//		(Runs on a timer so that it runs after the display is updated)
		// tags:
		//		private
		this.onDisplayChanged(/*e*/); // can't pass in e
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Handler for when the user clicks.
		// tags:
		//		private

		// console.info('onClick',this._tryDesignModeOn);
		this.onDisplayChanged(e);
	},

	_onIEMouseDown: function(/*Event*/ e){
		// summary:
		//		IE only to prevent 2 clicks to focus
		// tags:
		//		protected

		if(!this._focused && !this.disabled){
			this.focus();
		}
	},

	_onBlur: function(e){
		// summary:
		//		Called from focus manager when focus has moved away from this editor
		// tags:
		//		protected

		// console.info('_onBlur')

		this.inherited(arguments);

		var newValue = this.getValue(true);
		if(newValue != this.value){
			this.onChange(newValue);
		}
		this._set("value", newValue);
	},

	_onFocus: function(/*Event*/ e){
		// summary:
		//		Called from focus manager when focus has moved into this editor
		// tags:
		//		protected

		// console.info('_onFocus')
		if(!this.disabled){
			if(!this._disabledOK){
				this.set('disabled', false);
			}
			this.inherited(arguments);
		}
	},

	// TODO: remove in 2.0
	blur: function(){
		// summary:
		//		Remove focus from this instance.
		// tags:
		//		deprecated
		if(!dojo.isIE && this.window.document.documentElement && this.window.document.documentElement.focus){
			this.window.document.documentElement.focus();
		}else if(dojo.doc.body.focus){
			dojo.doc.body.focus();
		}
	},

	focus: function(){
		// summary:
		//		Move focus to this editor
		if(!this.isLoaded){
			this.focusOnLoad = true;
			return;
		}
		if(this._cursorToStart){
			delete this._cursorToStart;
			if(this.editNode.childNodes){
				this.placeCursorAtStart(); // this calls focus() so return
				return;
			}
		}
		if(!dojo.isIE){
			dijit.focus(this.iframe);
		}else if(this.editNode && this.editNode.focus){
			// editNode may be hidden in display:none div, lets just punt in this case
			//this.editNode.focus(); -> causes IE to scroll always (strict and quirks mode) to the top the Iframe
			// if we fire the event manually and let the browser handle the focusing, the latest
			// cursor position is focused like in FF
			this.iframe.fireEvent('onfocus', document.createEventObject()); // createEventObject only in IE
		//	}else{
		// TODO: should we throw here?
		// console.debug("Have no idea how to focus into the editor!");
		}
	},

	// _lastUpdate: 0,
	updateInterval: 200,
	_updateTimer: null,
	onDisplayChanged: function(/*Event*/ e){
		// summary:
		//		This event will be fired everytime the display context
		//		changes and the result needs to be reflected in the UI.
		// description:
		//		If you don't want to have update too often,
		//		onNormalizedDisplayChanged should be used instead
		// tags:
		//		private

		// var _t=new Date();
		if(this._updateTimer){
			clearTimeout(this._updateTimer);
		}
		if(!this._updateHandler){
			this._updateHandler = dojo.hitch(this,"onNormalizedDisplayChanged");
		}
		this._updateTimer = setTimeout(this._updateHandler, this.updateInterval);
		
		// Technically this should trigger a call to watch("value", ...) registered handlers,
		// but getValue() is too slow to call on every keystroke so we don't.
	},
	onNormalizedDisplayChanged: function(){
		// summary:
		//		This event is fired every updateInterval ms or more
		// description:
		//		If something needs to happen immediately after a
		//		user change, please use onDisplayChanged instead.
		// tags:
		//		private
		delete this._updateTimer;
	},
	onChange: function(newContent){
		// summary:
		//		This is fired if and only if the editor loses focus and
		//		the content is changed.
	},
	_normalizeCommand: function(/*String*/ cmd, /*Anything?*/argument){
		// summary:
		//		Used as the advice function by dojo.connect to map our
		//		normalized set of commands to those supported by the target
		//		browser.
		// tags:
		//		private

		var command = cmd.toLowerCase();
		if(command == "formatblock"){
			if(dojo.isSafari && argument === undefined){ command = "heading"; }
		}else if(command == "hilitecolor" && !dojo.isMoz){
			command = "backcolor";
		}

		return command;
	},

	_qcaCache: {},
	queryCommandAvailable: function(/*String*/ command){
		// summary:
		//		Tests whether a command is supported by the host. Clients
		//		SHOULD check whether a command is supported before attempting
		//		to use it, behaviour for unsupported commands is undefined.
		// command:
		//		The command to test for
		// tags:
		//		private

		// memoizing version. See _queryCommandAvailable for computing version
		var ca = this._qcaCache[command];
		if(ca !== undefined){ return ca; }
		return (this._qcaCache[command] = this._queryCommandAvailable(command));
	},

	_queryCommandAvailable: function(/*String*/ command){
		// summary:
		//		See queryCommandAvailable().
		// tags:
		//		private

		var ie = 1;
		var mozilla = 1 << 1;
		var webkit = 1 << 2;
		var opera = 1 << 3;

		function isSupportedBy(browsers){
			return {
				ie: Boolean(browsers & ie),
				mozilla: Boolean(browsers & mozilla),
				webkit: Boolean(browsers & webkit),
				opera: Boolean(browsers & opera)
			};
		}

		var supportedBy = null;

		switch(command.toLowerCase()){
			case "bold": case "italic": case "underline":
			case "subscript": case "superscript":
			case "fontname": case "fontsize":
			case "forecolor": case "hilitecolor":
			case "justifycenter": case "justifyfull": case "justifyleft":
			case "justifyright": case "delete": case "selectall": case "toggledir":
				supportedBy = isSupportedBy(mozilla | ie | webkit | opera);
				break;

			case "createlink": case "unlink": case "removeformat":
			case "inserthorizontalrule": case "insertimage":
			case "insertorderedlist": case "insertunorderedlist":
			case "indent": case "outdent": case "formatblock":
			case "inserthtml": case "undo": case "redo": case "strikethrough": case "tabindent":
				supportedBy = isSupportedBy(mozilla | ie | opera | webkit);
				break;

			case "blockdirltr": case "blockdirrtl":
			case "dirltr": case "dirrtl":
			case "inlinedirltr": case "inlinedirrtl":
				supportedBy = isSupportedBy(ie);
				break;
			case "cut": case "copy": case "paste":
				supportedBy = isSupportedBy( ie | mozilla | webkit);
				break;

			case "inserttable":
				supportedBy = isSupportedBy(mozilla | ie);
				break;

			case "insertcell": case "insertcol": case "insertrow":
			case "deletecells": case "deletecols": case "deleterows":
			case "mergecells": case "splitcell":
				supportedBy = isSupportedBy(ie | mozilla);
				break;

			default: return false;
		}

		return (dojo.isIE && supportedBy.ie) ||
			(dojo.isMoz && supportedBy.mozilla) ||
			(dojo.isWebKit && supportedBy.webkit) ||
			(dojo.isOpera && supportedBy.opera);	// Boolean return true if the command is supported, false otherwise
	},

	execCommand: function(/*String*/ command, argument){
		// summary:
		//		Executes a command in the Rich Text area
		// command:
		//		The command to execute
		// argument:
		//		An optional argument to the command
		// tags:
		//		protected
		var returnValue;

		//focus() is required for IE to work
		//In addition, focus() makes sure after the execution of
		//the command, the editor receives the focus as expected
		this.focus();

		command = this._normalizeCommand(command, argument);

		if(argument !== undefined){
			if(command == "heading"){
				throw new Error("unimplemented");
			}else if((command == "formatblock") && dojo.isIE){
				argument = '<'+argument+'>';
			}
		}

		//Check to see if we have any over-rides for commands, they will be functions on this
		//widget of the form _commandImpl.  If we don't, fall through to the basic native
		//exec command of the browser.
		var implFunc = "_" + command + "Impl";
		if(this[implFunc]){
			returnValue = this[implFunc](argument);
		}else{
			argument = arguments.length > 1 ? argument : null;
			if(argument || command!="createlink"){
				returnValue = this.document.execCommand(command, false, argument);
			}
		}

		this.onDisplayChanged();
		return returnValue;
	},

	queryCommandEnabled: function(/*String*/ command){
		// summary:
		//		Check whether a command is enabled or not.
		// tags:
		//		protected
		if(this.disabled || !this._disabledOK){ return false; }
		command = this._normalizeCommand(command);
		if(dojo.isMoz || dojo.isWebKit){
			if(command == "unlink"){ // mozilla returns true always
				// console.debug(this._sCall("hasAncestorElement", ['a']));
				return this._sCall("hasAncestorElement", ["a"]);
			}else if(command == "inserttable"){
				return true;
			}
		}
		//see #4109
		if(dojo.isWebKit){
			if(command == "cut" || command == "copy") {
				// WebKit deems clipboard activity as a security threat and natively would return false
				var sel = this.window.getSelection();
				if(sel){ sel = sel.toString(); }
				return !!sel;
			}else if(command == "paste"){
				return true;
			}
		}

		var elem = dojo.isIE ? this.document.selection.createRange() : this.document;
		try{
			return elem.queryCommandEnabled(command);
		}catch(e){
			//Squelch, occurs if editor is hidden on FF 3 (and maybe others.)
			return false;
		}

	},

	queryCommandState: function(command){
		// summary:
		//		Check the state of a given command and returns true or false.
		// tags:
		//		protected

		if(this.disabled || !this._disabledOK){ return false; }
		command = this._normalizeCommand(command);
		try{
			return this.document.queryCommandState(command);
		}catch(e){
			//Squelch, occurs if editor is hidden on FF 3 (and maybe others.)
			return false;
		}
	},

	queryCommandValue: function(command){
		// summary:
		//		Check the value of a given command. This matters most for
		//		custom selections and complex values like font value setting.
		// tags:
		//		protected

		if(this.disabled || !this._disabledOK){ return false; }
		var r;
		command = this._normalizeCommand(command);
		if(dojo.isIE && command == "formatblock"){
			r = this._native2LocalFormatNames[this.document.queryCommandValue(command)];
		}else if(dojo.isMoz && command === "hilitecolor"){
			var oldValue;
			try{
				oldValue = this.document.queryCommandValue("styleWithCSS");
			}catch(e){
				oldValue = false;
			}
			this.document.execCommand("styleWithCSS", false, true);
			r = this.document.queryCommandValue(command);
			this.document.execCommand("styleWithCSS", false, oldValue);
		}else{
			r = this.document.queryCommandValue(command);
		}
		return r;
	},

	// Misc.

	_sCall: function(name, args){
		// summary:
		//		Run the named method of dijit._editor.selection over the
		//		current editor instance's window, with the passed args.
		// tags:
		//		private
		return dojo.withGlobal(this.window, name, dijit._editor.selection, args);
	},

	// FIXME: this is a TON of code duplication. Why?

	placeCursorAtStart: function(){
		// summary:
		//		Place the cursor at the start of the editing area.
		// tags:
		//		private

		this.focus();

		//see comments in placeCursorAtEnd
		var isvalid=false;
		if(dojo.isMoz){
			// TODO:  Is this branch even necessary?
			var first=this.editNode.firstChild;
			while(first){
				if(first.nodeType == 3){
					if(first.nodeValue.replace(/^\s+|\s+$/g, "").length>0){
						isvalid=true;
						this._sCall("selectElement", [ first ]);
						break;
					}
				}else if(first.nodeType == 1){
					isvalid=true;
					var tg = first.tagName ? first.tagName.toLowerCase() : "";
					// Collapse before childless tags.
					if(/br|input|img|base|meta|area|basefont|hr|link/.test(tg)){
						this._sCall("selectElement", [ first ]);
					}else{
						// Collapse inside tags with children.
						this._sCall("selectElementChildren", [ first ]);
					}
					break;
				}
				first = first.nextSibling;
			}
		}else{
			isvalid=true;
			this._sCall("selectElementChildren", [ this.editNode ]);
		}
		if(isvalid){
			this._sCall("collapse", [ true ]);
		}
	},

	placeCursorAtEnd: function(){
		// summary:
		//		Place the cursor at the end of the editing area.
		// tags:
		//		private

		this.focus();

		//In mozilla, if last child is not a text node, we have to use
		// selectElementChildren on this.editNode.lastChild otherwise the
		// cursor would be placed at the end of the closing tag of
		//this.editNode.lastChild
		var isvalid=false;
		if(dojo.isMoz){
			var last=this.editNode.lastChild;
			while(last){
				if(last.nodeType == 3){
					if(last.nodeValue.replace(/^\s+|\s+$/g, "").length>0){
						isvalid=true;
						this._sCall("selectElement", [ last ]);
						break;
					}
				}else if(last.nodeType == 1){
					isvalid=true;
					if(last.lastChild){
						this._sCall("selectElement", [ last.lastChild ]);
					}else{
						this._sCall("selectElement", [ last ]);
					}
					break;
				}
				last = last.previousSibling;
			}
		}else{
			isvalid=true;
			this._sCall("selectElementChildren", [ this.editNode ]);
		}
		if(isvalid){
			this._sCall("collapse", [ false ]);
		}
	},

	getValue: function(/*Boolean?*/ nonDestructive){
		// summary:
		//		Return the current content of the editing area (post filters
		//		are applied).  Users should call get('value') instead.
		//	nonDestructive:
		//		defaults to false. Should the post-filtering be run over a copy
		//		of the live DOM? Most users should pass "true" here unless they
		//		*really* know that none of the installed filters are going to
		//		mess up the editing session.
		// tags:
		//		private
		if(this.textarea){
			if(this.isClosed || !this.isLoaded){
				return this.textarea.value;
			}
		}

		return this._postFilterContent(null, nonDestructive);
	},
	_getValueAttr: function(){
		// summary:
		//		Hook to make attr("value") work
		return this.getValue(true);
	},

	setValue: function(/*String*/ html){
		// summary:
		//		This function sets the content. No undo history is preserved.
		//		Users should use set('value', ...) instead.
		// tags:
		//		deprecated

		// TODO: remove this and getValue() for 2.0, and move code to _setValueAttr()

		if(!this.isLoaded){
			// try again after the editor is finished loading
			this.onLoadDeferred.addCallback(dojo.hitch(this, function(){
				this.setValue(html);
			}));
			return;
		}
		this._cursorToStart = true;
		if(this.textarea && (this.isClosed || !this.isLoaded)){
			this.textarea.value=html;
		}else{
			html = this._preFilterContent(html);
			var node = this.isClosed ? this.domNode : this.editNode;
			if(html && dojo.isMoz && html.toLowerCase() == "<p></p>"){
				html = "<p>&nbsp;</p>";
			}

			// Use &nbsp; to avoid webkit problems where editor is disabled until the user clicks it
			if(!html && dojo.isWebKit){
				html = "&nbsp;";
			}
			node.innerHTML = html;
			this._preDomFilterContent(node);
		}

		this.onDisplayChanged();
		this._set("value", this.getValue(true));
	},

	replaceValue: function(/*String*/ html){
		// summary:
		//		This function set the content while trying to maintain the undo stack
		//		(now only works fine with Moz, this is identical to setValue in all
		//		other browsers)
		// tags:
		//		protected

		if(this.isClosed){
			this.setValue(html);
		}else if(this.window && this.window.getSelection && !dojo.isMoz){ // Safari
			// look ma! it's a totally f'd browser!
			this.setValue(html);
		}else if(this.window && this.window.getSelection){ // Moz
			html = this._preFilterContent(html);
			this.execCommand("selectall");
			if(!html){
				this._cursorToStart = true;
				html = "&nbsp;";
			}
			this.execCommand("inserthtml", html);
			this._preDomFilterContent(this.editNode);
		}else if(this.document && this.document.selection){//IE
			//In IE, when the first element is not a text node, say
			//an <a> tag, when replacing the content of the editing
			//area, the <a> tag will be around all the content
			//so for now, use setValue for IE too
			this.setValue(html);
		}

		this._set("value", this.getValue(true));
	},

	_preFilterContent: function(/*String*/ html){
		// summary:
		//		Filter the input before setting the content of the editing
		//		area. DOM pre-filtering may happen after this
		//		string-based filtering takes place but as of 1.2, this is not
		//		guaranteed for operations such as the inserthtml command.
		// tags:
		//		private

		var ec = html;
		dojo.forEach(this.contentPreFilters, function(ef){ if(ef){ ec = ef(ec); } });
		return ec;
	},
	_preDomFilterContent: function(/*DomNode*/ dom){
		// summary:
		//		filter the input's live DOM. All filter operations should be
		//		considered to be "live" and operating on the DOM that the user
		//		will be interacting with in their editing session.
		// tags:
		//		private
		dom = dom || this.editNode;
		dojo.forEach(this.contentDomPreFilters, function(ef){
			if(ef && dojo.isFunction(ef)){
				ef(dom);
			}
		}, this);
	},

	_postFilterContent: function(
		/*DomNode|DomNode[]|String?*/ dom,
		/*Boolean?*/ nonDestructive){
		// summary:
		//		filter the output after getting the content of the editing area
		//
		// description:
		//		post-filtering allows plug-ins and users to specify any number
		//		of transforms over the editor's content, enabling many common
		//		use-cases such as transforming absolute to relative URLs (and
		//		vice-versa), ensuring conformance with a particular DTD, etc.
		//		The filters are registered in the contentDomPostFilters and
		//		contentPostFilters arrays. Each item in the
		//		contentDomPostFilters array is a function which takes a DOM
		//		Node or array of nodes as its only argument and returns the
		//		same. It is then passed down the chain for further filtering.
		//		The contentPostFilters array behaves the same way, except each
		//		member operates on strings. Together, the DOM and string-based
		//		filtering allow the full range of post-processing that should
		//		be necessaray to enable even the most agressive of post-editing
		//		conversions to take place.
		//
		//		If nonDestructive is set to "true", the nodes are cloned before
		//		filtering proceeds to avoid potentially destructive transforms
		//		to the content which may still needed to be edited further.
		//		Once DOM filtering has taken place, the serialized version of
		//		the DOM which is passed is run through each of the
		//		contentPostFilters functions.
		//
		//	dom:
		//		a node, set of nodes, which to filter using each of the current
		//		members of the contentDomPostFilters and contentPostFilters arrays.
		//
		//	nonDestructive:
		//		defaults to "false". If true, ensures that filtering happens on
		//		a clone of the passed-in content and not the actual node
		//		itself.
		//
		// tags:
		//		private

		var ec;
		if(!dojo.isString(dom)){
			dom = dom || this.editNode;
			if(this.contentDomPostFilters.length){
				if(nonDestructive){
					dom = dojo.clone(dom);
				}
				dojo.forEach(this.contentDomPostFilters, function(ef){
					dom = ef(dom);
				});
			}
			ec = dijit._editor.getChildrenHtml(dom);
		}else{
			ec = dom;
		}

		if(!dojo.trim(ec.replace(/^\xA0\xA0*/, '').replace(/\xA0\xA0*$/, '')).length){
			ec = "";
		}

		//	if(dojo.isIE){
		//		//removing appended <P>&nbsp;</P> for IE
		//		ec = ec.replace(/(?:<p>&nbsp;</p>[\n\r]*)+$/i,"");
		//	}
		dojo.forEach(this.contentPostFilters, function(ef){
			ec = ef(ec);
		});

		return ec;
	},

	_saveContent: function(/*Event*/ e){
		// summary:
		//		Saves the content in an onunload event if the editor has not been closed
		// tags:
		//		private

		var saveTextarea = dojo.byId(dijit._scopeName + "._editor.RichText.value");
		if(saveTextarea.value){
			saveTextarea.value += this._SEPARATOR;
		}
		saveTextarea.value += this.name + this._NAME_CONTENT_SEP + this.getValue(true);
	},


	escapeXml: function(/*String*/ str, /*Boolean*/ noSingleQuotes){
		// summary:
		//		Adds escape sequences for special characters in XML.
		//		Optionally skips escapes for single quotes
		// tags:
		//		private

		str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
		if(!noSingleQuotes){
			str = str.replace(/'/gm, "&#39;");
		}
		return str; // string
	},

	getNodeHtml: function(/* DomNode */ node){
		// summary:
		//		Deprecated.   Use dijit._editor._getNodeHtml() instead.
		// tags:
		//		deprecated
		dojo.deprecated('dijit.Editor::getNodeHtml is deprecated','use dijit._editor.getNodeHtml instead', 2);
		return dijit._editor.getNodeHtml(node); // String
	},

	getNodeChildrenHtml: function(/* DomNode */ dom){
		// summary:
		//		Deprecated.   Use dijit._editor.getChildrenHtml() instead.
		// tags:
		//		deprecated
		dojo.deprecated('dijit.Editor::getNodeChildrenHtml is deprecated','use dijit._editor.getChildrenHtml instead', 2);
		return dijit._editor.getChildrenHtml(dom);
	},

	close: function(/*Boolean?*/ save){
		// summary:
		//		Kills the editor and optionally writes back the modified contents to the
		//		element from which it originated.
		// save:
		//		Whether or not to save the changes. If false, the changes are discarded.
		// tags:
		//		private

		if(this.isClosed){ return; }

		if(!arguments.length){ save = true; }
		if(save){
			this._set("value", this.getValue(true));
		}

		// line height is squashed for iframes
		// FIXME: why was this here? if (this.iframe){ this.domNode.style.lineHeight = null; }

		if(this.interval){ clearInterval(this.interval); }

		if(this._webkitListener){
			//Cleaup of WebKit fix: #9532
			this.disconnect(this._webkitListener);
			delete this._webkitListener;
		}

		// Guard against memory leaks on IE (see #9268)
		if(dojo.isIE){
			 this.iframe.onfocus = null;
		}
		this.iframe._loadFunc = null;

		if(this._iframeRegHandle){
			dijit.unregisterIframe(this._iframeRegHandle);
			delete this._iframeRegHandle;
		}

		if(this.textarea){
			var s = this.textarea.style;
			s.position = "";
			s.left = s.top = "";
			if(dojo.isIE){
				s.overflow = this.__overflow;
				this.__overflow = null;
			}
			this.textarea.value = this.value;
			dojo.destroy(this.domNode);
			this.domNode = this.textarea;
		}else{
			// Note that this destroys the iframe
			this.domNode.innerHTML = this.value;
		}
		delete this.iframe;

		dojo.removeClass(this.domNode, this.baseClass);
		this.isClosed = true;
		this.isLoaded = false;

		delete this.editNode;
		delete this.focusNode;

		if(this.window && this.window._frameElement){
			this.window._frameElement = null;
		}

		this.window = null;
		this.document = null;
		this.editingArea = null;
		this.editorObject = null;
	},

	destroy: function(){
		if(!this.isClosed){ this.close(false); }
		this.inherited(arguments);
		if(dijit._editor._globalSaveHandler){
			delete dijit._editor._globalSaveHandler[this.id];
		}
	},

	_removeMozBogus: function(/* String */ html){
		// summary:
		//		Post filter to remove unwanted HTML attributes generated by mozilla
		// tags:
		//		private
		return html.replace(/\stype="_moz"/gi, '').replace(/\s_moz_dirty=""/gi, '').replace(/_moz_resizing="(true|false)"/gi,''); // String
	},
	_removeWebkitBogus: function(/* String */ html){
		// summary:
		//		Post filter to remove unwanted HTML attributes generated by webkit
		// tags:
		//		private
		html = html.replace(/\sclass="webkit-block-placeholder"/gi, '');
		html = html.replace(/\sclass="apple-style-span"/gi, '');
		// For some reason copy/paste sometime adds extra meta tags for charset on
		// webkit (chrome) on mac.They need to be removed.  See: #12007"
		html = html.replace(/<meta charset=\"utf-8\" \/>/gi, '');
		return html; // String
	},
	_normalizeFontStyle: function(/* String */ html){
		// summary:
		//		Convert 'strong' and 'em' to 'b' and 'i'.
		// description:
		//		Moz can not handle strong/em tags correctly, so to help
		//		mozilla and also to normalize output, convert them to 'b' and 'i'.
		//
		//		Note the IE generates 'strong' and 'em' rather than 'b' and 'i'
		// tags:
		//		private
		return html.replace(/<(\/)?strong([ \>])/gi, '<$1b$2')
			.replace(/<(\/)?em([ \>])/gi, '<$1i$2' ); // String
	},

	_preFixUrlAttributes: function(/* String */ html){
		// summary:
		//		Pre-filter to do fixing to href attributes on <a> and <img> tags
		// tags:
		//		private
		return html.replace(/(?:(<a(?=\s).*?\shref=)("|')(.*?)\2)|(?:(<a\s.*?href=)([^"'][^ >]+))/gi,
				'$1$4$2$3$5$2 _djrealurl=$2$3$5$2')
			.replace(/(?:(<img(?=\s).*?\ssrc=)("|')(.*?)\2)|(?:(<img\s.*?src=)([^"'][^ >]+))/gi,
				'$1$4$2$3$5$2 _djrealurl=$2$3$5$2'); // String
	},

	/*****************************************************************************
		The following functions implement HTML manipulation commands for various
		browser/contentEditable implementations.  The goal of them is to enforce
		standard behaviors of them.
	******************************************************************************/

	_inserthorizontalruleImpl: function(argument){
		// summary:
		//		This function implements the insertion of HTML 'HR' tags.
		//		into a point on the page.  IE doesn't to it right, so
		//		we have to use an alternate form
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if(dojo.isIE){
			return this._inserthtmlImpl("<hr>");
		}
		return this.document.execCommand("inserthorizontalrule", false, argument);
	},

	_unlinkImpl: function(argument){
		// summary:
		//		This function implements the unlink of an 'a' tag.
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if((this.queryCommandEnabled("unlink")) && (dojo.isMoz || dojo.isWebKit)){
			var a = this._sCall("getAncestorElement", [ "a" ]);
			this._sCall("selectElement", [ a ]);
			return this.document.execCommand("unlink", false, null);
		}
		return this.document.execCommand("unlink", false, argument);
	},

	_hilitecolorImpl: function(argument){
		// summary:
		//		This function implements the hilitecolor command
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		var returnValue;
		if(dojo.isMoz){
			// mozilla doesn't support hilitecolor properly when useCSS is
			// set to false (bugzilla #279330)
			this.document.execCommand("styleWithCSS", false, true);
			returnValue = this.document.execCommand("hilitecolor", false, argument);
			this.document.execCommand("styleWithCSS", false, false);
		}else{
			returnValue = this.document.execCommand("hilitecolor", false, argument);
		}
		return returnValue;
	},

	_backcolorImpl: function(argument){
		// summary:
		//		This function implements the backcolor command
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if(dojo.isIE){
			// Tested under IE 6 XP2, no problem here, comment out
			// IE weirdly collapses ranges when we exec these commands, so prevent it
			//	var tr = this.document.selection.createRange();
			argument = argument ? argument : null;
		}
		return this.document.execCommand("backcolor", false, argument);
	},

	_forecolorImpl: function(argument){
		// summary:
		//		This function implements the forecolor command
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if(dojo.isIE){
			// Tested under IE 6 XP2, no problem here, comment out
			// IE weirdly collapses ranges when we exec these commands, so prevent it
			//	var tr = this.document.selection.createRange();
			argument = argument? argument : null;
		}
		return this.document.execCommand("forecolor", false, argument);
	},

	_inserthtmlImpl: function(argument){
		// summary:
		//		This function implements the insertion of HTML content into
		//		a point on the page.
		// argument:
		//		The content to insert, if any.
		// tags:
		//		protected
		argument = this._preFilterContent(argument);
		var rv = true;
		if(dojo.isIE){
			var insertRange = this.document.selection.createRange();
			if(this.document.selection.type.toUpperCase() == 'CONTROL'){
				var n=insertRange.item(0);
				while(insertRange.length){
					insertRange.remove(insertRange.item(0));
				}
				n.outerHTML=argument;
			}else{
				insertRange.pasteHTML(argument);
			}
			insertRange.select();
			//insertRange.collapse(true);
		}else if(dojo.isMoz && !argument.length){
			//mozilla can not inserthtml an empty html to delete current selection
			//so we delete the selection instead in this case
			this._sCall("remove"); // FIXME
		}else{
			rv = this.document.execCommand("inserthtml", false, argument);
		}
		return rv;
	},

	_boldImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the bold command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("bold", false, argument);
	},
	
	_italicImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the italic command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("italic", false, argument);
	},

	_underlineImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the underline command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("underline", false, argument);
	},
	
	_strikethroughImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the strikethrough command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("strikethrough", false, argument);
	},

	getHeaderHeight: function(){
		// summary:
		//		A function for obtaining the height of the header node
		return this._getNodeChildrenHeight(this.header); // Number
	},

	getFooterHeight: function(){
		// summary:
		//		A function for obtaining the height of the footer node
		return this._getNodeChildrenHeight(this.footer); // Number
	},

	_getNodeChildrenHeight: function(node){
		// summary:
		//		An internal function for computing the cumulative height of all child nodes of 'node'
		// node:
		//		The node to process the children of;
		var h = 0;
		if(node && node.childNodes){
			// IE didn't compute it right when position was obtained on the node directly is some cases,
			// so we have to walk over all the children manually.
			var i;
			for(i = 0; i < node.childNodes.length; i++){
				var size = dojo.position(node.childNodes[i]);
				h += size.h;
			}
		}
		return h; // Number
	},
	
	_isNodeEmpty: function(node, startOffset){
		// summary:
		//		Function to test if a node is devoid of real content.
		// node:
		//		The node to check.
		// tags:
		//		private.
		if(node.nodeType == 1/*element*/){
			if(node.childNodes.length > 0){
				return this._isNodeEmpty(node.childNodes[0], startOffset);
	}
			return true;
		}else if(node.nodeType == 3/*text*/){
			return (node.nodeValue.substring(startOffset) == "");
		}
		return false;
	},
	
	_removeStartingRangeFromRange: function(node, range){
		// summary:
		//		Function to adjust selection range by removing the current
		//		start node.
		// node:
		//		The node to remove from the starting range.
		// range:
		//		The range to adapt.
		// tags:
		//		private
		if(node.nextSibling){
			range.setStart(node.nextSibling,0);
		}else{
			var parent = node.parentNode;
			while(parent && parent.nextSibling == null){
				//move up the tree until we find a parent that has another node, that node will be the next node
				parent = parent.parentNode;
			}
			if(parent){
				range.setStart(parent.nextSibling,0);
			}
		}
		return range;
	},
	
	_adaptIESelection: function(){
		// summary:
		//		Function to adapt the IE range by removing leading 'newlines'
		//		Needed to fix issue with bold/italics/underline not working if
		//		range included leading 'newlines'.
		//		In IE, if a user starts a selection at the very end of a line,
		//		then the native browser commands will fail to execute correctly.
		//		To work around the issue,  we can remove all empty nodes from
		//		the start of the range selection.
		var selection = dijit.range.getSelection(this.window);
		if(selection && selection.rangeCount && !selection.isCollapsed){
			var range = selection.getRangeAt(0);
			var firstNode = range.startContainer;
			var startOffset = range.startOffset;

			while(firstNode.nodeType == 3/*text*/ && startOffset >= firstNode.length && firstNode.nextSibling){
				//traverse the text nodes until we get to the one that is actually highlighted
				startOffset = startOffset - firstNode.length;
				firstNode = firstNode.nextSibling;
			}

			//Remove the starting ranges until the range does not start with an empty node.
			var lastNode=null;
			while(this._isNodeEmpty(firstNode, startOffset) && firstNode != lastNode){
				lastNode =firstNode; //this will break the loop in case we can't find the next sibling
				range = this._removeStartingRangeFromRange(firstNode, range); //move the start container to the next node in the range
				firstNode = range.startContainer;
				startOffset = 0; //start at the beginning of the new starting range
			}
			selection.removeAllRanges();// this will work as long as users cannot select multiple ranges. I have not been able to do that in the editor.
			selection.addRange(range);
		}
	}
});

}

if(!dojo._hasResource["dijit._editor._Plugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor._Plugin"] = true;
dojo.provide("dijit._editor._Plugin");




dojo.declare("dijit._editor._Plugin", null, {
	// summary
	//		Base class for a "plugin" to the editor, which is usually
	//		a single button on the Toolbar and some associated code

	constructor: function(/*Object?*/args, /*DomNode?*/node){
		this.params = args || {};
		dojo.mixin(this, this.params);
		this._connects=[];
		this._attrPairNames = {};
	},

	// editor: [const] dijit.Editor
	//		Points to the parent editor
	editor: null,

	// iconClassPrefix: [const] String
	//		The CSS class name for the button node is formed from `iconClassPrefix` and `command`
	iconClassPrefix: "dijitEditorIcon",

	// button: dijit._Widget?
	//		Pointer to `dijit.form.Button` or other widget (ex: `dijit.form.FilteringSelect`)
	//		that is added to the toolbar to control this plugin.
	//		If not specified, will be created on initialization according to `buttonClass`
	button: null,

	// command: String
	//		String like "insertUnorderedList", "outdent", "justifyCenter", etc. that represents an editor command.
	//		Passed to editor.execCommand() if `useDefaultCommand` is true.
	command: "",

	// useDefaultCommand: Boolean
	//		If true, this plugin executes by calling Editor.execCommand() with the argument specified in `command`.
	useDefaultCommand: true,

	// buttonClass: Widget Class
	//		Class of widget (ex: dijit.form.Button or dijit.form.FilteringSelect)
	//		that is added to the toolbar to control this plugin.
	//		This is used to instantiate the button, unless `button` itself is specified directly.
	buttonClass: dijit.form.Button,

	// disabled: Boolean
	//		Flag to indicate if this plugin has been disabled and should do nothing
	//		helps control button state, among other things.  Set via the setter api.
	disabled: false,

	getLabel: function(/*String*/key){
		// summary:
		//		Returns the label to use for the button
		// tags:
		//		private
		return this.editor.commands[key];		// String
	},

	_initButton: function(){
		// summary:
		//		Initialize the button or other widget that will control this plugin.
		//		This code only works for plugins controlling built-in commands in the editor.
		// tags:
		//		protected extension
		if(this.command.length){
			var label = this.getLabel(this.command),
				editor = this.editor,
				className = this.iconClassPrefix+" "+this.iconClassPrefix + this.command.charAt(0).toUpperCase() + this.command.substr(1);
			if(!this.button){
				var props = dojo.mixin({
					label: label,
					dir: editor.dir,
					lang: editor.lang,
					showLabel: false,
					iconClass: className,
					dropDown: this.dropDown,
					tabIndex: "-1"
				}, this.params || {});
				this.button = new this.buttonClass(props);
			}
		}
		if(this.get("disabled") && this.button){
			this.button.set("disabled", this.get("disabled"));
		}
	},

	destroy: function(){
		// summary:
		//		Destroy this plugin

		dojo.forEach(this._connects, dojo.disconnect);
		if(this.dropDown){
			this.dropDown.destroyRecursive();
		}
	},

	connect: function(o, f, tf){
		// summary:
		//		Make a dojo.connect() that is automatically disconnected when this plugin is destroyed.
		//		Similar to `dijit._Widget.connect`.
		// tags:
		//		protected
		this._connects.push(dojo.connect(o, f, this, tf));
	},

	updateState: function(){
		// summary:
		//		Change state of the plugin to respond to events in the editor.
		// description:
		//		This is called on meaningful events in the editor, such as change of selection
		//		or caret position (but not simple typing of alphanumeric keys).   It gives the
		//		plugin a chance to update the CSS of its button.
		//
		//		For example, the "bold" plugin will highlight/unhighlight the bold button depending on whether the
		//		characters next to the caret are bold or not.
		//
		//		Only makes sense when `useDefaultCommand` is true, as it calls Editor.queryCommandEnabled(`command`).
		var e = this.editor,
			c = this.command,
			checked, enabled;
		if(!e || !e.isLoaded || !c.length){ return; }
		var disabled = this.get("disabled");
		if(this.button){
			try{
				enabled = !disabled && e.queryCommandEnabled(c);
				if(this.enabled !== enabled){
					this.enabled = enabled;
					this.button.set('disabled', !enabled);
				}
				if(typeof this.button.checked == 'boolean'){
					checked = e.queryCommandState(c);
					if(this.checked !== checked){
						this.checked = checked;
						this.button.set('checked', e.queryCommandState(c));
					}
				}
			}catch(e){
				console.log(e); // FIXME: we shouldn't have debug statements in our code.  Log as an error?
			}
		}
	},

	setEditor: function(/*dijit.Editor*/ editor){
		// summary:
		//		Tell the plugin which Editor it is associated with.

		// TODO: refactor code to just pass editor to constructor.

		// FIXME: detach from previous editor!!
		this.editor = editor;

		// FIXME: prevent creating this if we don't need to (i.e., editor can't handle our command)
		this._initButton();

		// Processing for buttons that execute by calling editor.execCommand()
		if(this.button && this.useDefaultCommand){
			if(this.editor.queryCommandAvailable(this.command)){
				this.connect(this.button, "onClick",
					dojo.hitch(this.editor, "execCommand", this.command, this.commandArg)
				);
			}else{
				// hide button because editor doesn't support command (due to browser limitations)
				this.button.domNode.style.display = "none";
			}
		}

		this.connect(this.editor, "onNormalizedDisplayChanged", "updateState");
	},

	setToolbar: function(/*dijit.Toolbar*/ toolbar){
		// summary:
		//		Tell the plugin to add it's controller widget (often a button)
		//		to the toolbar.  Does nothing if there is no controller widget.

		// TODO: refactor code to just pass toolbar to constructor.

		if(this.button){
			toolbar.addChild(this.button);
		}
		// console.debug("adding", this.button, "to:", toolbar);
	},
	
	set: function(/* attribute */ name, /* anything */ value){
		// summary:
		//		Set a property on a plugin
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a plugin which may potentially be handled by a
		// 		setter in the plugin.
		// 		For example, if the plugin has a properties "foo"
		//		and "bar" and a method named "_setFooAttr", calling:
		//	|	plugin.set("foo", "Howdy!");
		//		would be equivalent to writing:
		//	|	plugin._setFooAttr("Howdy!");
		//		and:
		//	|	plugin.set("bar", 3);
		//		would be equivalent to writing:
		//	|	plugin.bar = 3;
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	plugin.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
	}
			return this;
		}
		var names = this._getAttrNames(name);
		if(this[names.s]){
			// use the explicit setter
			var result = this[names.s].apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			this._set(name, value);
		}
		return result || this;
	},

	get: function(name){
		// summary:
		//		Get a property from a plugin.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property from a plugin. The property may
		//		potentially be retrieved via a getter method. If no getter is defined, this
		// 		just retrieves the object's property.
		// 		For example, if the plugin has a properties "foo"
		//		and "bar" and a method named "_getFooAttr", calling:
		//	|	plugin.get("foo");
		//		would be equivalent to writing:
		//	|	plugin._getFooAttr();
		//		and:
		//	|	plugin.get("bar");
		//		would be equivalent to writing:
		//	|	plugin.bar;
		var names = this._getAttrNames(name);
		return this[names.g] ? this[names.g]() : this[name];
	},

	_setDisabledAttr: function(disabled){
		// summary:
		//		Function to set the plugin state and call updateState to make sure the
		//		button is updated appropriately.
		this.disabled = disabled;
		this.updateState();
	},
	
	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.charAt(0).toUpperCase() + name.substr(1);
		return (apn[name] = {
			s: "_set"+uc+"Attr",
			g: "_get"+uc+"Attr"
		});
	},
	
	_set: function(/*String*/ name, /*anything*/ value){
		// summary:
		//		Helper function to set new value for specified attribute
		var oldValue = this[name];
		this[name] = value;
	}
});

}

if(!dojo._hasResource["dijit._editor.plugins.EnterKeyHandling"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.plugins.EnterKeyHandling"] = true;
dojo.provide("dijit._editor.plugins.EnterKeyHandling");





dojo.declare("dijit._editor.plugins.EnterKeyHandling", dijit._editor._Plugin, {
	// summary:
	//		This plugin tries to make all browsers behave consistently with regard to
	//		how ENTER behaves in the editor window.  It traps the ENTER key and alters
	//		the way DOM is constructed in certain cases to try to commonize the generated
	//		DOM and behaviors across browsers.
	//
	// description:
	//		This plugin has three modes:
	//
	//			* blockModeForEnter=BR
	//			* blockModeForEnter=DIV
	//			* blockModeForEnter=P
	//
	//		In blockModeForEnter=P, the ENTER key starts a new
	//		paragraph, and shift-ENTER starts a new line in the current paragraph.
	//		For example, the input:
	//
	//		|	first paragraph <shift-ENTER>
	//		|	second line of first paragraph <ENTER>
	//		|	second paragraph
	//
	//		will generate:
	//
	//		|	<p>
	//		|		first paragraph
	//		|		<br/>
	//		|		second line of first paragraph
	//		|	</p>
	//		|	<p>
	//		|		second paragraph
	//		|	</p>
	//
	//		In BR and DIV mode, the ENTER key conceptually goes to a new line in the
	//		current paragraph, and users conceptually create a new paragraph by pressing ENTER twice.
	//		For example, if the user enters text into an editor like this:
	//
	//		|		one <ENTER>
	//		|		two <ENTER>
	//		|		three <ENTER>
	//		|		<ENTER>
	//		|		four <ENTER>
	//		|		five <ENTER>
	//		|		six <ENTER>
	//
	//		It will appear on the screen as two 'paragraphs' of three lines each.  Markupwise, this generates:
	//
	//		BR:
	//		|		one<br/>
	//		|		two<br/>
	//		|		three<br/>
	//		|		<br/>
	//		|		four<br/>
	//		|		five<br/>
	//		|		six<br/>
	//
	//		DIV:
	//		|		<div>one</div>
	//		|		<div>two</div>
	//		|		<div>three</div>
	//		|		<div>&nbsp;</div>
	//		|		<div>four</div>
	//		|		<div>five</div>
	//		|		<div>six</div>

	// blockNodeForEnter: String
	//		This property decides the behavior of Enter key. It can be either P,
	//		DIV, BR, or empty (which means disable this feature). Anything else
	//		will trigger errors.  The default is 'BR'
	//
	//		See class description for more details.
	blockNodeForEnter: 'BR',

	constructor: function(args){
		if(args){
			if("blockNodeForEnter" in args){
				args.blockNodeForEnter = args.blockNodeForEnter.toUpperCase();
			}
			dojo.mixin(this,args);
		}
	},

	setEditor: function(editor){
		// Overrides _Plugin.setEditor().
		if(this.editor === editor) { return; }
		this.editor = editor;
		if(this.blockNodeForEnter == 'BR'){
			// While Moz has a mode tht mostly works, it's still a little different,
			// So, try to just have a common mode and be consistent.  Which means
			// we need to enable customUndo, if not already enabled.
			this.editor.customUndo = true;
				editor.onLoadDeferred.addCallback(dojo.hitch(this,function(d){
				this.connect(editor.document, "onkeypress", function(e){
					if(e.charOrCode == dojo.keys.ENTER){
						// Just do it manually.  The handleEnterKey has a shift mode that
						// Always acts like <br>, so just use it.
						var ne = dojo.mixin({},e);
						ne.shiftKey = true;
						if(!this.handleEnterKey(ne)){
							dojo.stopEvent(e);
						}
					}
				});
					return d;
				}));
		}else if(this.blockNodeForEnter){
			// add enter key handler
			// FIXME: need to port to the new event code!!
			var h = dojo.hitch(this,this.handleEnterKey);
			editor.addKeyHandler(13, 0, 0, h); //enter
			editor.addKeyHandler(13, 0, 1, h); //shift+enter
			this.connect(this.editor,'onKeyPressed','onKeyPressed');
		}
	},
	onKeyPressed: function(e){
		// summary:
		//		Handler for keypress events.
		// tags:
		//		private
		if(this._checkListLater){
			if(dojo.withGlobal(this.editor.window, 'isCollapsed', dijit)){
				var liparent=dojo.withGlobal(this.editor.window, 'getAncestorElement', dijit._editor.selection, ['LI']);
				if(!liparent){
					// circulate the undo detection code by calling RichText::execCommand directly
					dijit._editor.RichText.prototype.execCommand.call(this.editor, 'formatblock',this.blockNodeForEnter);
					// set the innerHTML of the new block node
					var block = dojo.withGlobal(this.editor.window, 'getAncestorElement', dijit._editor.selection, [this.blockNodeForEnter]);
					if(block){
						block.innerHTML=this.bogusHtmlContent;
						if(dojo.isIE){
							// move to the start by moving backwards one char
							var r = this.editor.document.selection.createRange();
							r.move('character',-1);
							r.select();
						}
					}else{
						console.error('onKeyPressed: Cannot find the new block node'); // FIXME
					}
				}else{
					if(dojo.isMoz){
						if(liparent.parentNode.parentNode.nodeName == 'LI'){
							liparent=liparent.parentNode.parentNode;
						}
					}
					var fc=liparent.firstChild;
					if(fc && fc.nodeType == 1 && (fc.nodeName == 'UL' || fc.nodeName == 'OL')){
						liparent.insertBefore(fc.ownerDocument.createTextNode('\xA0'),fc);
						var newrange = dijit.range.create(this.editor.window);
						newrange.setStart(liparent.firstChild,0);
						var selection = dijit.range.getSelection(this.editor.window, true);
						selection.removeAllRanges();
						selection.addRange(newrange);
					}
				}
			}
			this._checkListLater = false;
		}
		if(this._pressedEnterInBlock){
			// the new created is the original current P, so we have previousSibling below
			if(this._pressedEnterInBlock.previousSibling){
				this.removeTrailingBr(this._pressedEnterInBlock.previousSibling);
			}
			delete this._pressedEnterInBlock;
		}
	},

	// bogusHtmlContent: [private] String
	//		HTML to stick into a new empty block
	bogusHtmlContent: '&nbsp;',

	// blockNodes: [private] Regex
	//		Regex for testing if a given tag is a block level (display:block) tag
	blockNodes: /^(?:P|H1|H2|H3|H4|H5|H6|LI)$/,

	handleEnterKey: function(e){
		// summary:
		//		Handler for enter key events when blockModeForEnter is DIV or P.
		// description:
		//		Manually handle enter key event to make the behavior consistent across
		//		all supported browsers. See class description for details.
		// tags:
		//		private

		var selection, range, newrange, startNode, endNode, brNode, doc=this.editor.document,br,rs,txt;
		if(e.shiftKey){		// shift+enter always generates <br>
			var parent = dojo.withGlobal(this.editor.window, "getParentElement", dijit._editor.selection);
			var header = dijit.range.getAncestor(parent,this.blockNodes);
			if(header){
				if(header.tagName == 'LI'){
					return true; // let browser handle
				}
				selection = dijit.range.getSelection(this.editor.window);
				range = selection.getRangeAt(0);
				if(!range.collapsed){
					range.deleteContents();
					selection = dijit.range.getSelection(this.editor.window);
					range = selection.getRangeAt(0);
				}
				if(dijit.range.atBeginningOfContainer(header, range.startContainer, range.startOffset)){
						br=doc.createElement('br');
						newrange = dijit.range.create(this.editor.window);
						header.insertBefore(br,header.firstChild);
						newrange.setStartBefore(br.nextSibling);
						selection.removeAllRanges();
						selection.addRange(newrange);
				}else if(dijit.range.atEndOfContainer(header, range.startContainer, range.startOffset)){
					newrange = dijit.range.create(this.editor.window);
					br=doc.createElement('br');
						header.appendChild(br);
						header.appendChild(doc.createTextNode('\xA0'));
						newrange.setStart(header.lastChild,0);
					selection.removeAllRanges();
					selection.addRange(newrange);
				}else{
					rs = range.startContainer;
					if(rs && rs.nodeType == 3){
						// Text node, we have to split it.
						txt = rs.nodeValue;
						dojo.withGlobal(this.editor.window, function(){
							startNode = doc.createTextNode(txt.substring(0, range.startOffset));
							endNode = doc.createTextNode(txt.substring(range.startOffset));
							brNode = doc.createElement("br");
							
							if(endNode.nodeValue == "" && dojo.isWebKit){
								endNode = doc.createTextNode('\xA0')
							}
							dojo.place(startNode, rs, "after");
							dojo.place(brNode, startNode, "after");
							dojo.place(endNode, brNode, "after");
							dojo.destroy(rs);
							newrange = dijit.range.create(dojo.gobal);
							newrange.setStart(endNode,0);
							selection.removeAllRanges();
							selection.addRange(newrange);
						});
						return false;
					}
					return true; // let browser handle
				}
			}else{
				selection = dijit.range.getSelection(this.editor.window);
				if(selection.rangeCount){
					range = selection.getRangeAt(0);
					if(range && range.startContainer){
						if(!range.collapsed){
							range.deleteContents();
							selection = dijit.range.getSelection(this.editor.window);
							range = selection.getRangeAt(0);
						}
						rs = range.startContainer;
						if(rs && rs.nodeType == 3){
							// Text node, we have to split it.
							dojo.withGlobal(this.editor.window, dojo.hitch(this, function(){
								var endEmpty = false;
							
								var offset = range.startOffset;
								if(rs.length < offset){
									//We are not splitting the right node, try to locate the correct one
									ret = this._adjustNodeAndOffset(rs, offset);
									rs = ret.node;
									offset = ret.offset;
								}
								txt = rs.nodeValue;
				
								startNode = doc.createTextNode(txt.substring(0, offset));
								endNode = doc.createTextNode(txt.substring(offset));
								brNode = doc.createElement("br");
								
								if(!endNode.length){
									endNode = doc.createTextNode('\xA0');
									endEmpty = true;
								}
								
								if(startNode.length){
									dojo.place(startNode, rs, "after");
								}else{
									startNode = rs;
								}
								dojo.place(brNode, startNode, "after");
								dojo.place(endNode, brNode, "after");
								dojo.destroy(rs);
								newrange = dijit.range.create(dojo.gobal);
								newrange.setStart(endNode,0);
								newrange.setEnd(endNode, endNode.length);
								selection.removeAllRanges();
								selection.addRange(newrange);
								if(endEmpty && !dojo.isWebKit){
									dijit._editor.selection.remove();
								}else{
									dijit._editor.selection.collapse(true);
								}
							}));
						}else{
							dojo.withGlobal(this.editor.window, dojo.hitch(this, function(){
								var brNode = doc.createElement("br");
								rs.appendChild(brNode);
								var endNode = doc.createTextNode('\xA0');
								rs.appendChild(endNode);
								newrange = dijit.range.create(dojo.global);
								newrange.setStart(endNode,0);
								newrange.setEnd(endNode, endNode.length);
								selection.removeAllRanges();
								selection.addRange(newrange);
								dijit._editor.selection.collapse(true);
							}));
						}
					}
				}else{
					// don't change this: do not call this.execCommand, as that may have other logic in subclass
					dijit._editor.RichText.prototype.execCommand.call(this.editor, 'inserthtml', '<br>');
				}
			}
			return false;
		}
		var _letBrowserHandle = true;

		// first remove selection
		selection = dijit.range.getSelection(this.editor.window);
		range = selection.getRangeAt(0);
		if(!range.collapsed){
			range.deleteContents();
			selection = dijit.range.getSelection(this.editor.window);
			range = selection.getRangeAt(0);
		}

		var block = dijit.range.getBlockAncestor(range.endContainer, null, this.editor.editNode);
		var blockNode = block.blockNode;

		// if this is under a LI or the parent of the blockNode is LI, just let browser to handle it
		if((this._checkListLater = (blockNode && (blockNode.nodeName == 'LI' || blockNode.parentNode.nodeName == 'LI')))){
			if(dojo.isMoz){
				// press enter in middle of P may leave a trailing <br/>, let's remove it later
				this._pressedEnterInBlock = blockNode;
			}
			// if this li only contains spaces, set the content to empty so the browser will outdent this item
			if(/^(\s|&nbsp;|\xA0|<span\b[^>]*\bclass=['"]Apple-style-span['"][^>]*>(\s|&nbsp;|\xA0)<\/span>)?(<br>)?$/.test(blockNode.innerHTML)){
				// empty LI node
				blockNode.innerHTML = '';
				if(dojo.isWebKit){ // WebKit tosses the range when innerHTML is reset
					newrange = dijit.range.create(this.editor.window);
					newrange.setStart(blockNode, 0);
					selection.removeAllRanges();
					selection.addRange(newrange);
				}
				this._checkListLater = false; // nothing to check since the browser handles outdent
			}
			return true;
		}

		// text node directly under body, let's wrap them in a node
		if(!block.blockNode || block.blockNode===this.editor.editNode){
			try{
				dijit._editor.RichText.prototype.execCommand.call(this.editor, 'formatblock',this.blockNodeForEnter);
			}catch(e2){ /*squelch FF3 exception bug when editor content is a single BR*/ }
			// get the newly created block node
			// FIXME
			block = {blockNode:dojo.withGlobal(this.editor.window, "getAncestorElement", dijit._editor.selection, [this.blockNodeForEnter]),
					blockContainer: this.editor.editNode};
			if(block.blockNode){
				if(block.blockNode != this.editor.editNode &&
					(!(block.blockNode.textContent || block.blockNode.innerHTML).replace(/^\s+|\s+$/g, "").length)){
					this.removeTrailingBr(block.blockNode);
					return false;
				}
			}else{	// we shouldn't be here if formatblock worked
				block.blockNode = this.editor.editNode;
			}
			selection = dijit.range.getSelection(this.editor.window);
			range = selection.getRangeAt(0);
		}

		var newblock = doc.createElement(this.blockNodeForEnter);
		newblock.innerHTML=this.bogusHtmlContent;
		this.removeTrailingBr(block.blockNode);
		var endOffset = range.endOffset;
		var node = range.endContainer;
		if(node.length < endOffset){
			//We are not checking the right node, try to locate the correct one
			var ret = this._adjustNodeAndOffset(node, endOffset);
			node = ret.node;
			endOffset = ret.offset;
		}
		if(dijit.range.atEndOfContainer(block.blockNode, node, endOffset)){
			if(block.blockNode === block.blockContainer){
				block.blockNode.appendChild(newblock);
			}else{
				dojo.place(newblock, block.blockNode, "after");
			}
			_letBrowserHandle = false;
			// lets move caret to the newly created block
			newrange = dijit.range.create(this.editor.window);
			newrange.setStart(newblock, 0);
			selection.removeAllRanges();
			selection.addRange(newrange);
			if(this.editor.height){
				dojo.window.scrollIntoView(newblock);
			}
		}else if(dijit.range.atBeginningOfContainer(block.blockNode,
				range.startContainer, range.startOffset)){
			dojo.place(newblock, block.blockNode, block.blockNode === block.blockContainer ? "first" : "before");
			if(newblock.nextSibling && this.editor.height){
				// position input caret - mostly WebKit needs this
				newrange = dijit.range.create(this.editor.window);
				newrange.setStart(newblock.nextSibling, 0);
				selection.removeAllRanges();
				selection.addRange(newrange);
				// browser does not scroll the caret position into view, do it manually
				dojo.window.scrollIntoView(newblock.nextSibling);
			}
			_letBrowserHandle = false;
		}else{ //press enter in the middle of P/DIV/Whatever/
			if(block.blockNode === block.blockContainer){
				block.blockNode.appendChild(newblock);
			}else{
				dojo.place(newblock, block.blockNode, "after");
			}
			_letBrowserHandle = false;

			// Clone any block level styles.
			if(block.blockNode.style){
				if(newblock.style){
					if(block.blockNode.style.cssText){
						newblock.style.cssText = block.blockNode.style.cssText;
					}
				}
			}
			
			// Okay, we probably have to split.
			rs = range.startContainer;
			var firstNodeMoved;
			if(rs && rs.nodeType == 3){ 
				// Text node, we have to split it.
				var nodeToMove, tNode;
				endOffset = range.endOffset;
				if(rs.length < endOffset){
					//We are not splitting the right node, try to locate the correct one
					ret = this._adjustNodeAndOffset(rs, endOffset);
					rs = ret.node;
					endOffset = ret.offset;
				}
				
				txt = rs.nodeValue;
				startNode = doc.createTextNode(txt.substring(0, endOffset));
				endNode = doc.createTextNode(txt.substring(endOffset, txt.length));

				// Place the split, then remove original nodes.
				dojo.place(startNode, rs, "before");
				dojo.place(endNode, rs, "after");
				dojo.destroy(rs);

				// Okay, we split the text.  Now we need to see if we're
				// parented to the block element we're splitting and if
				// not, we have to split all the way up.  Ugh.
				var parentC = startNode.parentNode;
				while(parentC !== block.blockNode){
					var tg = parentC.tagName;
					var newTg = doc.createElement(tg);
					// Clone over any 'style' data.
					if(parentC.style){
						if(newTg.style){
							if(parentC.style.cssText){
								newTg.style.cssText = parentC.style.cssText;
							}
						}
					}
					// If font also need to clone over any font data. 
					if(parentC.tagName === "FONT"){
						if(parentC.color){
							newTg.color = parentC.color;
						}
						if(parentC.face){
							newTg.face = parentC.face;
						}
						if(parentC.size){  // this check was necessary on IE
							newTg.size = parentC.size;
						}
					}
					
					nodeToMove = endNode;
					while(nodeToMove){
						tNode = nodeToMove.nextSibling;
						newTg.appendChild(nodeToMove);
						nodeToMove = tNode;
					}
					dojo.place(newTg, parentC, "after");
					startNode = parentC;
					endNode = newTg;
					parentC = parentC.parentNode;
				}

				// Lastly, move the split out tags to the new block.
				// as they should now be split properly.
				nodeToMove = endNode;
				if(nodeToMove.nodeType == 1 || (nodeToMove.nodeType == 3 && nodeToMove.nodeValue)){
					// Non-blank text and non-text nodes need to clear out that blank space
					// before moving the contents.
					newblock.innerHTML = "";
				}
				firstNodeMoved = nodeToMove;
				while(nodeToMove){
					tNode = nodeToMove.nextSibling;
					newblock.appendChild(nodeToMove);
					nodeToMove = tNode;
				}
			}
			
			//lets move caret to the newly created block
			newrange = dijit.range.create(this.editor.window);
			var nodeForCursor;
			var innerMostFirstNodeMoved = firstNodeMoved;
			if(this.blockNodeForEnter !== 'BR'){
				while(innerMostFirstNodeMoved){
					nodeForCursor = innerMostFirstNodeMoved;
					tNode = innerMostFirstNodeMoved.firstChild;
					innerMostFirstNodeMoved = tNode;
				}
				if(nodeForCursor && nodeForCursor.parentNode){
					newblock = nodeForCursor.parentNode;
					newrange.setStart(newblock, 0);
					selection.removeAllRanges();
					selection.addRange(newrange);
					if(this.editor.height){
						dijit.scrollIntoView(newblock);
					}
					if(dojo.isMoz){
						// press enter in middle of P may leave a trailing <br/>, let's remove it later
						this._pressedEnterInBlock = block.blockNode;
					}					
				}else{
					_letBrowserHandle = true;
				}
			}else{
				newrange.setStart(newblock, 0);
				selection.removeAllRanges();
				selection.addRange(newrange);
				if(this.editor.height){
					dijit.scrollIntoView(newblock);
				}
				if(dojo.isMoz){
					// press enter in middle of P may leave a trailing <br/>, let's remove it later
					this._pressedEnterInBlock = block.blockNode;
				}
			}
		}
		return _letBrowserHandle;
	},

	_adjustNodeAndOffset: function(/*DomNode*/node, /*Int*/offset){
		// summary:
		//              In the case there are multiple text nodes in a row the offset may not be within the node.  If the offset is larger than the node length, it will attempt to find
		//              the next text sibling until it locates the text node in which the offset refers to
		// node:
		//              The node to check.
		// offset:
		//              The position to find within the text node
		// tags:
		//              private.
		while(node.length < offset && node.nextSibling && node.nextSibling.nodeType==3){
			//Adjust the offset and node in the case of multiple text nodes in a row
			offset = offset - node.length;
			node = node.nextSibling;
		}
		var ret = {"node": node, "offset": offset};
		return ret;
	},

	removeTrailingBr: function(container){
		// summary:
		//		If last child of container is a <br>, then remove it.
		// tags:
		//		private
		var para = /P|DIV|LI/i.test(container.tagName) ?
			container : dijit._editor.selection.getParentOfType(container,['P','DIV','LI']);

		if(!para){ return; }
		if(para.lastChild){
			if((para.childNodes.length > 1 && para.lastChild.nodeType == 3 && /^[\s\xAD]*$/.test(para.lastChild.nodeValue)) ||
				para.lastChild.tagName=='BR'){

				dojo.destroy(para.lastChild);
			}
		}
		if(!para.childNodes.length){
			para.innerHTML=this.bogusHtmlContent;
		}
	}
});

}

if(!dojo._hasResource["dijit.Editor"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Editor"] = true;
dojo.provide("dijit.Editor");












dojo.declare(
	"dijit.Editor",
	dijit._editor.RichText,
	{
		// summary:
		//		A rich text Editing widget
		//
		// description:
		//		This widget provides basic WYSIWYG editing features, based on the browser's
		//		underlying rich text editing capability, accompanied by a toolbar (`dijit.Toolbar`).
		//		A plugin model is available to extend the editor's capabilities as well as the
		//		the options available in the toolbar.  Content generation may vary across
		//		browsers, and clipboard operations may have different results, to name
		//		a few limitations.  Note: this widget should not be used with the HTML
		//		&lt;TEXTAREA&gt; tag -- see dijit._editor.RichText for details.

		// plugins: [const] Object[]
		//		A list of plugin names (as strings) or instances (as objects)
		//		for this widget.
		//
		//		When declared in markup, it might look like:
		//	|	plugins="['bold',{name:'dijit._editor.plugins.FontChoice', command:'fontName', generic:true}]"
		plugins: null,

		// extraPlugins: [const] Object[]
		//		A list of extra plugin names which will be appended to plugins array
		extraPlugins: null,

		constructor: function(){
			// summary:
			//		Runs on widget initialization to setup arrays etc.
			// tags:
			//		private

			if(!dojo.isArray(this.plugins)){
				this.plugins=["undo","redo","|","cut","copy","paste","|","bold","italic","underline","strikethrough","|",
				"insertOrderedList","insertUnorderedList","indent","outdent","|","justifyLeft","justifyRight","justifyCenter","justifyFull",
				"dijit._editor.plugins.EnterKeyHandling" /*, "createLink"*/];
			}

			this._plugins=[];
			this._editInterval = this.editActionInterval * 1000;

			//IE will always lose focus when other element gets focus, while for FF and safari,
			//when no iframe is used, focus will be lost whenever another element gets focus.
			//For IE, we can connect to onBeforeDeactivate, which will be called right before
			//the focus is lost, so we can obtain the selected range. For other browsers,
			//no equivelent of onBeforeDeactivate, so we need to do two things to make sure
			//selection is properly saved before focus is lost: 1) when user clicks another
			//element in the page, in which case we listen to mousedown on the entire page and
			//see whether user clicks out of a focus editor, if so, save selection (focus will
			//only lost after onmousedown event is fired, so we can obtain correct caret pos.)
			//2) when user tabs away from the editor, which is handled in onKeyDown below.
			if(dojo.isIE){
				this.events.push("onBeforeDeactivate");
				this.events.push("onBeforeActivate");
			}
		},

		postMixInProperties: function() {
			// summary:
			//	Extension to make sure a deferred is in place before certain functions
			//	execute, like making sure all the plugins are properly inserted.

			// Set up a deferred so that the value isn't applied to the editor
			// until all the plugins load, needed to avoid timing condition
			// reported in #10537.
			this.setValueDeferred = new dojo.Deferred();
			this.inherited(arguments);
		},
	
		postCreate: function(){
			//for custom undo/redo, if enabled.
			this._steps=this._steps.slice(0);
			this._undoedSteps=this._undoedSteps.slice(0);

			if(dojo.isArray(this.extraPlugins)){
				this.plugins=this.plugins.concat(this.extraPlugins);
			}

			this.inherited(arguments);

			this.commands = dojo.i18n.getLocalization("dijit._editor", "commands", this.lang);

			if(!this.toolbar){
				// if we haven't been assigned a toolbar, create one
				this.toolbar = new dijit.Toolbar({
					dir: this.dir,
					lang: this.lang
				});
				this.header.appendChild(this.toolbar.domNode);
			}

			dojo.forEach(this.plugins, this.addPlugin, this);

			// Okay, denote the value can now be set.
			this.setValueDeferred.callback(true);

			dojo.addClass(this.iframe.parentNode, "dijitEditorIFrameContainer");
			dojo.addClass(this.iframe, "dijitEditorIFrame");
			dojo.attr(this.iframe, "allowTransparency", true);

			if(dojo.isWebKit){
				// Disable selecting the entire editor by inadvertant double-clicks.
				// on buttons, title bar, etc.  Otherwise clicking too fast on
				// a button such as undo/redo selects the entire editor.
				dojo.style(this.domNode, "KhtmlUserSelect", "none");
			}
			this.toolbar.startup();
			this.onNormalizedDisplayChanged(); //update toolbar button status
		},
		destroy: function(){
			dojo.forEach(this._plugins, function(p){
				if(p && p.destroy){
					p.destroy();
				}
			});
			this._plugins=[];
			this.toolbar.destroyRecursive();
			delete this.toolbar;
			this.inherited(arguments);
		},
		addPlugin: function(/*String||Object*/plugin, /*Integer?*/index){
			// summary:
			//		takes a plugin name as a string or a plugin instance and
			//		adds it to the toolbar and associates it with this editor
			//		instance. The resulting plugin is added to the Editor's
			//		plugins array. If index is passed, it's placed in the plugins
			//		array at that index. No big magic, but a nice helper for
			//		passing in plugin names via markup.
			//
			// plugin: String, args object or plugin instance
			//
			// args:
			//		This object will be passed to the plugin constructor
			//
			// index: Integer
			//		Used when creating an instance from
			//		something already in this.plugins. Ensures that the new
			//		instance is assigned to this.plugins at that index.
			var args=dojo.isString(plugin)?{name:plugin}:plugin;
			if(!args.setEditor){
				var o={"args":args,"plugin":null,"editor":this};
				dojo.publish(dijit._scopeName + ".Editor.getPlugin",[o]);
				if(!o.plugin){
					var pc = dojo.getObject(args.name);
					if(pc){
						o.plugin=new pc(args);
					}
				}
				if(!o.plugin){
					console.warn('Cannot find plugin',plugin);
					return;
				}
				plugin=o.plugin;
			}
			if(arguments.length > 1){
				this._plugins[index] = plugin;
			}else{
				this._plugins.push(plugin);
			}
			plugin.setEditor(this);
			if(dojo.isFunction(plugin.setToolbar)){
				plugin.setToolbar(this.toolbar);
			}
		},
		//the following 3 functions are required to make the editor play nice under a layout widget, see #4070
		startup: function(){
			// summary:
			//		Exists to make Editor work as a child of a layout widget.
			//		Developers don't need to call this method.
			// tags:
			//		protected
			//console.log('startup',arguments);
		},
		resize: function(size){
			// summary:
			//		Resize the editor to the specified size, see `dijit.layout._LayoutWidget.resize`
			if(size){
				// we've been given a height/width for the entire editor (toolbar + contents), calls layout()
				// to split the allocated size between the toolbar and the contents
				dijit.layout._LayoutWidget.prototype.resize.apply(this, arguments);
			}
			/*
			else{
				// do nothing, the editor is already laid out correctly.   The user has probably specified
				// the height parameter, which was used to set a size on the iframe
			}
			*/
		},
		layout: function(){
			// summary:
			//		Called from `dijit.layout._LayoutWidget.resize`.  This shouldn't be called directly
			// tags:
			//		protected

			// Converts the iframe (or rather the <div> surrounding it) to take all the available space
			// except what's needed for the header (toolbars) and footer (breadcrumbs, etc).
			// A class was added to the iframe container and some themes style it, so we have to
			// calc off the added margins and padding too. See tracker: #10662
			var areaHeight = (this._contentBox.h -
				(this.getHeaderHeight() + this.getFooterHeight() +
				 dojo._getPadBorderExtents(this.iframe.parentNode).h +
				 dojo._getMarginExtents(this.iframe.parentNode).h));
			this.editingArea.style.height = areaHeight + "px";
			if(this.iframe){
				this.iframe.style.height="100%";
			}
			this._layoutMode = true;
		},
		_onIEMouseDown: function(/*Event*/ e){
			// summary:
			//		IE only to prevent 2 clicks to focus
			// tags:
			//		private
			var outsideClientArea;
			// IE 8's componentFromPoint is broken, which is a shame since it
			// was smaller code, but oh well.  We have to do this brute force
			// to detect if the click was scroller or not.
			var b = this.document.body;
			var clientWidth = b.clientWidth;
			var clientHeight = b.clientHeight;
			var clientLeft = b.clientLeft;
			var offsetWidth = b.offsetWidth;
			var offsetHeight = b.offsetHeight;
			var offsetLeft = b.offsetLeft;

			//Check for vertical scroller click.
			bodyDir = b.dir ? b.dir.toLowerCase() : "";
			if(bodyDir != "rtl"){
				if(clientWidth < offsetWidth && e.x > clientWidth && e.x < offsetWidth){
					// Check the click was between width and offset width, if so, scroller
					outsideClientArea = true;
				}
			}else{
				// RTL mode, we have to go by the left offsets.
				if(e.x < clientLeft && e.x > offsetLeft){
					// Check the click was between width and offset width, if so, scroller
					outsideClientArea = true;
				}
			}
			if(!outsideClientArea){
				// Okay, might be horiz scroller, check that.
				if(clientHeight < offsetHeight && e.y > clientHeight && e.y < offsetHeight){
					// Horizontal scroller.
					outsideClientArea = true;
				}
			}
			if(!outsideClientArea){
				delete this._cursorToStart; // Remove the force to cursor to start position.
				delete this._savedSelection; // new mouse position overrides old selection
				if(e.target.tagName == "BODY"){
					setTimeout(dojo.hitch(this, "placeCursorAtEnd"), 0);
				}
				this.inherited(arguments);
			}
		},
		onBeforeActivate: function(e){
			this._restoreSelection();
		},
		onBeforeDeactivate: function(e){
			// summary:
			//		Called on IE right before focus is lost.   Saves the selected range.
			// tags:
			//		private
			if(this.customUndo){
				this.endEditing(true);
			}
			//in IE, the selection will be lost when other elements get focus,
			//let's save focus before the editor is deactivated
			if(e.target.tagName != "BODY"){
				this._saveSelection();
			}
			//console.log('onBeforeDeactivate',this);
		},

		/* beginning of custom undo/redo support */

		// customUndo: Boolean
		//		Whether we shall use custom undo/redo support instead of the native
		//		browser support. By default, we now use custom undo.  It works better
		//		than native browser support and provides a consistent behavior across
		//		browsers with a minimal performance hit.  We already had the hit on
		//		the slowest browser, IE, anyway.
		customUndo: true,

		// editActionInterval: Integer
		//		When using customUndo, not every keystroke will be saved as a step.
		//		Instead typing (including delete) will be grouped together: after
		//		a user stops typing for editActionInterval seconds, a step will be
		//		saved; if a user resume typing within editActionInterval seconds,
		//		the timeout will be restarted. By default, editActionInterval is 3
		//		seconds.
		editActionInterval: 3,

		beginEditing: function(cmd){
			// summary:
			//		Called to note that the user has started typing alphanumeric characters, if it's not already noted.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			if(!this._inEditing){
				this._inEditing=true;
				this._beginEditing(cmd);
			}
			if(this.editActionInterval>0){
				if(this._editTimer){
					clearTimeout(this._editTimer);
				}
				this._editTimer = setTimeout(dojo.hitch(this, this.endEditing), this._editInterval);
			}
		},

		// TODO: declaring these in the prototype is meaningless, just create in the constructor/postCreate
		_steps:[],
		_undoedSteps:[],

		execCommand: function(cmd){
			// summary:
			//		Main handler for executing any commands to the editor, like paste, bold, etc.
			//      Called by plugins, but not meant to be called by end users.
			// tags:
			//		protected
			if(this.customUndo && (cmd == 'undo' || cmd == 'redo')){
				return this[cmd]();
			}else{
				if(this.customUndo){
					this.endEditing();
					this._beginEditing();
				}
				var r;
				var isClipboard = /copy|cut|paste/.test(cmd);
				try{
					r = this.inherited(arguments);
					if(dojo.isWebKit && isClipboard && !r){ //see #4598: webkit does not guarantee clipboard support from js
						throw { code: 1011 }; // throw an object like Mozilla's error
					}
				}catch(e){
					//TODO: when else might we get an exception?  Do we need the Mozilla test below?
					if(e.code == 1011 /* Mozilla: service denied */ && isClipboard){
						// Warn user of platform limitation.  Cannot programmatically access clipboard. See ticket #4136
						var sub = dojo.string.substitute,
							accel = {cut:'X', copy:'C', paste:'V'};
						alert(sub(this.commands.systemShortcut,
							[this.commands[cmd], sub(this.commands[dojo.isMac ? 'appleKey' : 'ctrlKey'], [accel[cmd]])]));
					}
					r = false;
				}
				if(this.customUndo){
					this._endEditing();
				}
				return r;
			}
		},
		queryCommandEnabled: function(cmd){
			// summary:
			//		Returns true if specified editor command is enabled.
			//      Used by the plugins to know when to highlight/not highlight buttons.
			// tags:
			//		protected
			if(this.customUndo && (cmd == 'undo' || cmd == 'redo')){
				return cmd == 'undo' ? (this._steps.length > 1) : (this._undoedSteps.length > 0);
			}else{
				return this.inherited(arguments);
			}
		},
		_moveToBookmark: function(b){
			// summary:
			//		Selects the text specified in bookmark b
			// tags:
			//		private
			var bookmark = b.mark;
			var mark = b.mark;
			var col = b.isCollapsed;
			var r, sNode, eNode, sel;
			if(mark){
				if(dojo.isIE < 9){
					if(dojo.isArray(mark)){
						//IE CONTROL, have to use the native bookmark.
						bookmark = [];
						dojo.forEach(mark,function(n){
							bookmark.push(dijit.range.getNode(n,this.editNode));
						},this);
						dojo.withGlobal(this.window,'moveToBookmark',dijit,[{mark: bookmark, isCollapsed: col}]);
					}else{
						if(mark.startContainer && mark.endContainer){
							// Use the pseudo WC3 range API.  This works better for positions
							// than the IE native bookmark code.
							sel = dijit.range.getSelection(this.window);
							if(sel && sel.removeAllRanges){
								sel.removeAllRanges();
								r = dijit.range.create(this.window);
								sNode = dijit.range.getNode(mark.startContainer,this.editNode);
								eNode = dijit.range.getNode(mark.endContainer,this.editNode);
								if(sNode && eNode){
									// Okay, we believe we found the position, so add it into the selection
									// There are cases where it may not be found, particularly in undo/redo, when
									// IE changes the underlying DOM on us (wraps text in a <p> tag or similar.
									// So, in those cases, don't bother restoring selection.
									r.setStart(sNode,mark.startOffset);
									r.setEnd(eNode,mark.endOffset);
									sel.addRange(r);
								}
							}
						}
					}
				}else{//w3c range
					sel = dijit.range.getSelection(this.window);
					if(sel && sel.removeAllRanges){
						sel.removeAllRanges();
						r = dijit.range.create(this.window);
						sNode = dijit.range.getNode(mark.startContainer,this.editNode);
						eNode = dijit.range.getNode(mark.endContainer,this.editNode);
						if(sNode && eNode){
							// Okay, we believe we found the position, so add it into the selection
							// There are cases where it may not be found, particularly in undo/redo, when
							// formatting as been done and so on, so don't restore selection then.
							r.setStart(sNode,mark.startOffset);
							r.setEnd(eNode,mark.endOffset);
							sel.addRange(r);
						}
					}
				}
			}
		},
		_changeToStep: function(from, to){
			// summary:
			//		Reverts editor to "to" setting, from the undo stack.
			// tags:
			//		private
			this.setValue(to.text);
			var b=to.bookmark;
			if(!b){ return; }
			this._moveToBookmark(b);
		},
		undo: function(){
			// summary:
			//		Handler for editor undo (ex: ctrl-z) operation
			// tags:
			//		private
			//console.log('undo');
			var ret = false;
			if(!this._undoRedoActive){
				this._undoRedoActive = true;
				this.endEditing(true);
				var s=this._steps.pop();
				if(s && this._steps.length>0){
					this.focus();
					this._changeToStep(s,this._steps[this._steps.length-1]);
					this._undoedSteps.push(s);
					this.onDisplayChanged();
					delete this._undoRedoActive;
					ret = true;
				}
				delete this._undoRedoActive;
			}
			return ret;
		},
		redo: function(){
			// summary:
			//		Handler for editor redo (ex: ctrl-y) operation
			// tags:
			//		private
			//console.log('redo');
			var ret = false;
			if(!this._undoRedoActive){
				this._undoRedoActive = true;
				this.endEditing(true);
				var s=this._undoedSteps.pop();
				if(s && this._steps.length>0){
					this.focus();
					this._changeToStep(this._steps[this._steps.length-1],s);
					this._steps.push(s);
					this.onDisplayChanged();
					ret = true;
				}
				delete this._undoRedoActive;
			}
			return ret;
		},
		endEditing: function(ignore_caret){
			// summary:
			//		Called to note that the user has stopped typing alphanumeric characters, if it's not already noted.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			if(this._editTimer){
				clearTimeout(this._editTimer);
			}
			if(this._inEditing){
				this._endEditing(ignore_caret);
				this._inEditing=false;
			}
		},

		_getBookmark: function(){
			// summary:
			//		Get the currently selected text
			// tags:
			//		protected
			var b=dojo.withGlobal(this.window,dijit.getBookmark);
			var tmp=[];
			if(b && b.mark){
				var mark = b.mark;
				if(dojo.isIE < 9){
					// Try to use the pseudo range API on IE for better accuracy.
					var sel = dijit.range.getSelection(this.window);
					if(!dojo.isArray(mark)){
						if(sel){
							var range;
							if(sel.rangeCount){
								range = sel.getRangeAt(0);
							}
							if(range){
								b.mark = range.cloneRange();
							}else{
								b.mark = dojo.withGlobal(this.window,dijit.getBookmark);
							}
						}
					}else{
						// Control ranges (img, table, etc), handle differently.
						dojo.forEach(b.mark,function(n){
							tmp.push(dijit.range.getIndex(n,this.editNode).o);
						},this);
						b.mark = tmp;
					}
				}
				try{
					if(b.mark && b.mark.startContainer){
						tmp=dijit.range.getIndex(b.mark.startContainer,this.editNode).o;
						b.mark={startContainer:tmp,
							startOffset:b.mark.startOffset,
							endContainer:b.mark.endContainer===b.mark.startContainer?tmp:dijit.range.getIndex(b.mark.endContainer,this.editNode).o,
							endOffset:b.mark.endOffset};
					}
				}catch(e){
					b.mark = null;
				}
			}
			return b;
		},
		_beginEditing: function(cmd){
			// summary:
			//		Called when the user starts typing alphanumeric characters.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			if(this._steps.length === 0){
				// You want to use the editor content without post filtering
				// to make sure selection restores right for the 'initial' state.
				// and undo is called.  So not using this.value, as it was 'processed'
				// and the line-up for selections may have been altered.
				this._steps.push({'text':dijit._editor.getChildrenHtml(this.editNode),'bookmark':this._getBookmark()});
			}
		},
		_endEditing: function(ignore_caret){
			// summary:
			//		Called when the user stops typing alphanumeric characters.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			// Avoid filtering to make sure selections restore.
			var v = dijit._editor.getChildrenHtml(this.editNode);

			this._undoedSteps=[];//clear undoed steps
			this._steps.push({text: v, bookmark: this._getBookmark()});
		},
		onKeyDown: function(e){
			// summary:
			//		Handler for onkeydown event.
			// tags:
			//		private

			//We need to save selection if the user TAB away from this editor
			//no need to call _saveSelection for IE, as that will be taken care of in onBeforeDeactivate
			if(!dojo.isIE && !this.iframe && e.keyCode == dojo.keys.TAB && !this.tabIndent){
				this._saveSelection();
			}
			if(!this.customUndo){
				this.inherited(arguments);
				return;
			}
			var k = e.keyCode, ks = dojo.keys;
			if(e.ctrlKey && !e.altKey){//undo and redo only if the special right Alt + z/y are not pressed #5892
				if(k == 90 || k == 122){ //z
					dojo.stopEvent(e);
					this.undo();
					return;
				}else if(k == 89 || k == 121){ //y
					dojo.stopEvent(e);
					this.redo();
					return;
				}
			}
			this.inherited(arguments);

			switch(k){
					case ks.ENTER:
					case ks.BACKSPACE:
					case ks.DELETE:
						this.beginEditing();
						break;
					case 88: //x
					case 86: //v
						if(e.ctrlKey && !e.altKey && !e.metaKey){
							this.endEditing();//end current typing step if any
							if(e.keyCode == 88){
								this.beginEditing('cut');
								//use timeout to trigger after the cut is complete
								setTimeout(dojo.hitch(this, this.endEditing), 1);
							}else{
								this.beginEditing('paste');
								//use timeout to trigger after the paste is complete
								setTimeout(dojo.hitch(this, this.endEditing), 1);
							}
							break;
						}
						//pass through
					default:
						if(!e.ctrlKey && !e.altKey && !e.metaKey && (e.keyCode<dojo.keys.F1 || e.keyCode>dojo.keys.F15)){
							this.beginEditing();
							break;
						}
						//pass through
					case ks.ALT:
						this.endEditing();
						break;
					case ks.UP_ARROW:
					case ks.DOWN_ARROW:
					case ks.LEFT_ARROW:
					case ks.RIGHT_ARROW:
					case ks.HOME:
					case ks.END:
					case ks.PAGE_UP:
					case ks.PAGE_DOWN:
						this.endEditing(true);
						break;
					//maybe ctrl+backspace/delete, so don't endEditing when ctrl is pressed
					case ks.CTRL:
					case ks.SHIFT:
					case ks.TAB:
						break;
				}
		},
		_onBlur: function(){
			// summary:
			//		Called from focus manager when focus has moved away from this editor
			// tags:
			//		protected

			//this._saveSelection();
			this.inherited(arguments);
			this.endEditing(true);
		},
		_saveSelection: function(){
			// summary:
			//		Save the currently selected text in _savedSelection attribute
			// tags:
			//		private
			try{
				this._savedSelection=this._getBookmark();
			}catch(e){ /* Squelch any errors that occur if selection save occurs due to being hidden simultaniously. */}
		},
		_restoreSelection: function(){
			// summary:
			//		Re-select the text specified in _savedSelection attribute;
			//		see _saveSelection().
			// tags:
			//		private
			if(this._savedSelection){
				// Clear off cursor to start, we're deliberately going to a selection.
				delete this._cursorToStart;
				// only restore the selection if the current range is collapsed
				// if not collapsed, then it means the editor does not lose
				// selection and there is no need to restore it
				if(dojo.withGlobal(this.window,'isCollapsed',dijit)){
					this._moveToBookmark(this._savedSelection);
				}
				delete this._savedSelection;
			}
		},

		onClick: function(){
			// summary:
			//		Handler for when editor is clicked
			// tags:
			//		protected
			this.endEditing(true);
			this.inherited(arguments);
		},

		replaceValue: function(/*String*/ html){
			// summary:
			//		over-ride of replaceValue to support custom undo and stack maintainence.
			// tags:
			//		protected
			if(!this.customUndo){
				this.inherited(arguments);
			}else{
				if(this.isClosed){
					this.setValue(html);
				}else{
					this.beginEditing();
					if(!html){
						html = "&nbsp;"
					}
					this.setValue(html);
					this.endEditing();
				}
			}
		},
		
		_setDisabledAttr: function(/*Boolean*/ value){
			var disableFunc = dojo.hitch(this, function(){
				if((!this.disabled && value) || (!this._buttonEnabledPlugins && value)){
				// Disable editor: disable all enabled buttons and remember that list
					dojo.forEach(this._plugins, function(p){
						p.set("disabled", true);
				});
			}else if(this.disabled && !value){
					// Restore plugins to being active.
					dojo.forEach(this._plugins, function(p){
						p.set("disabled", false);
				});
			}
			});
			this.setValueDeferred.addCallback(disableFunc);
			this.inherited(arguments);
		},
		
		_setStateClass: function(){
			try{
				this.inherited(arguments);
			
				// Let theme set the editor's text color based on editor enabled/disabled state.
				// We need to jump through hoops because the main document (where the theme CSS is)
				// is separate from the iframe's document.
				if(this.document && this.document.body){
					dojo.style(this.document.body, "color", dojo.style(this.iframe, "color"));
				}
			}catch(e){ /* Squelch any errors caused by focus change if hidden during a state change */}
		}
	}
);

// Register the "default plugins", ie, the built-in editor commands
dojo.subscribe(dijit._scopeName + ".Editor.getPlugin",null,function(o){
	if(o.plugin){ return; }
	var args = o.args, p;
	var _p = dijit._editor._Plugin;
	var name = args.name;
	switch(name){
		case "undo": case "redo": case "cut": case "copy": case "paste": case "insertOrderedList":
		case "insertUnorderedList": case "indent": case "outdent": case "justifyCenter":
		case "justifyFull": case "justifyLeft": case "justifyRight": case "delete":
		case "selectAll": case "removeFormat": case "unlink":
		case "insertHorizontalRule":
			p = new _p({ command: name });
			break;

		case "bold": case "italic": case "underline": case "strikethrough":
		case "subscript": case "superscript":
			p = new _p({ buttonClass: dijit.form.ToggleButton, command: name });
			break;
		case "|":
			p = new _p({ button: new dijit.ToolbarSeparator(), setEditor: function(editor) {this.editor = editor;} });
	}
//	console.log('name',name,p);
	o.plugin=p;
});

}

if(!dojo._hasResource["dojox.grid.cells.dijit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.cells.dijit"] = true;
dojo.provide("dojox.grid.cells.dijit");



// TODO: shouldn't it be the test file's job to require these modules,
// if it is using them?  Most of these modules aren't referenced by this file.













(function(){
	var dgc = dojox.grid.cells;
	dojo.declare("dojox.grid.cells._Widget", dgc._Base, {
		widgetClass: dijit.form.TextBox,
		constructor: function(inCell){
			this.widget = null;
			if(typeof this.widgetClass == "string"){
				dojo.deprecated("Passing a string to widgetClass is deprecated", "pass the widget class object instead", "2.0");
				this.widgetClass = dojo.getObject(this.widgetClass);
			}
		},
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			return "<div></div>";
		},
		getValue: function(inRowIndex){
			return this.widget.get('value');
		},
		setValue: function(inRowIndex, inValue){
			if(this.widget&&this.widget.set){
				//Look for lazy-loading editor and handle it via its deferred.
				if(this.widget.onLoadDeferred){
					var self = this;
					this.widget.onLoadDeferred.addCallback(function(){
						self.widget.set("value",inValue===null?"":inValue);
					});
				}else{
					this.widget.set("value", inValue);
				}
			}else{
				this.inherited(arguments);
			}
		},
		getWidgetProps: function(inDatum){
			return dojo.mixin(
				{
					dir: this.dir,
					lang: this.lang
				},
				this.widgetProps||{},
				{
					constraints: dojo.mixin({}, this.constraint) || {}, //TODO: really just for ValidationTextBoxes
					value: inDatum
				}
			);
		},
		createWidget: function(inNode, inDatum, inRowIndex){
			return new this.widgetClass(this.getWidgetProps(inDatum), inNode);
		},
		attachWidget: function(inNode, inDatum, inRowIndex){
			inNode.appendChild(this.widget.domNode);
			this.setValue(inRowIndex, inDatum);
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			if(!this.widgetClass){
				return inDatum;
			}
			if(!this.widget){
				this.widget = this.createWidget.apply(this, arguments);
			}else{
				this.attachWidget.apply(this, arguments);
			}
			this.sizeWidget.apply(this, arguments);
			this.grid.views.renormalizeRow(inRowIndex);
			this.grid.scroller.rowHeightChanged(inRowIndex, true/*fix #11101*/);
			this.focus();
			return undefined;
		},
		sizeWidget: function(inNode, inDatum, inRowIndex){
			var
				p = this.getNode(inRowIndex),
				box = dojo.contentBox(p);
			dojo.marginBox(this.widget.domNode, {w: box.w});
		},
		focus: function(inRowIndex, inNode){
			if(this.widget){
				setTimeout(dojo.hitch(this.widget, function(){
					dojox.grid.util.fire(this, "focus");
				}), 0);
			}
		},
		_finish: function(inRowIndex){
			this.inherited(arguments);
			dojox.grid.util.removeNode(this.widget.domNode);
			if(dojo.isIE){
				dojo.setSelectable(this.widget.domNode, true);
			}
		}
	});
	dgc._Widget.markupFactory = function(node, cell){
		dgc._Base.markupFactory(node, cell);
		var d = dojo;
		var widgetProps = d.trim(d.attr(node, "widgetProps")||"");
		var constraint = d.trim(d.attr(node, "constraint")||"");
		var widgetClass = d.trim(d.attr(node, "widgetClass")||"");
		if(widgetProps){
			cell.widgetProps = d.fromJson(widgetProps);
		}
		if(constraint){
			cell.constraint = d.fromJson(constraint);
		}
		if(widgetClass){
			cell.widgetClass = d.getObject(widgetClass);
		}
	};

	dojo.declare("dojox.grid.cells.ComboBox", dgc._Widget, {
		widgetClass: dijit.form.ComboBox,
		getWidgetProps: function(inDatum){
			var items=[];
			dojo.forEach(this.options, function(o){
				items.push({name: o, value: o});
			});
			var store = new dojo.data.ItemFileReadStore({data: {identifier:"name", items: items}});
			return dojo.mixin({}, this.widgetProps||{}, {
				value: inDatum,
				store: store
			});
		},
		getValue: function(){
			var e = this.widget;
			// make sure to apply the displayed value
			e.set('displayedValue', e.get('displayedValue'));
			return e.get('value');
		}
	});
	dgc.ComboBox.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
		var d=dojo;
		var options = d.trim(d.attr(node, "options")||"");
		if(options){
			var o = options.split(',');
			if(o[0] != options){
				cell.options = o;
			}
		}
	};

	dojo.declare("dojox.grid.cells.DateTextBox", dgc._Widget, {
		widgetClass: dijit.form.DateTextBox,
		setValue: function(inRowIndex, inValue){
			if(this.widget){
				this.widget.set('value', new Date(inValue));
			}else{
				this.inherited(arguments);
			}
		},
		getWidgetProps: function(inDatum){
			return dojo.mixin(this.inherited(arguments), {
				value: new Date(inDatum)
			});
		}
	});
	dgc.DateTextBox.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
	};

	dojo.declare("dojox.grid.cells.CheckBox", dgc._Widget, {
		widgetClass: dijit.form.CheckBox,
		getValue: function(){
			return this.widget.checked;
		},
		setValue: function(inRowIndex, inValue){
			if(this.widget&&this.widget.attributeMap.checked){
				this.widget.set("checked", inValue);
			}else{
				this.inherited(arguments);
			}
		},
		sizeWidget: function(inNode, inDatum, inRowIndex){
			return;
		}
	});
	dgc.CheckBox.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
	};

	dojo.declare("dojox.grid.cells.Editor", dgc._Widget, {
		widgetClass: dijit.Editor,
		getWidgetProps: function(inDatum){
			return dojo.mixin({}, this.widgetProps||{}, {
				height: this.widgetHeight || "100px"
			});
		},
		createWidget: function(inNode, inDatum, inRowIndex){
			// widget needs its value set after creation
			var widget = new this.widgetClass(this.getWidgetProps(inDatum), inNode);
			dojo.connect(widget, 'onLoad', dojo.hitch(this, 'populateEditor'));
			return widget;
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			this.content = inDatum;
			this.inherited(arguments);
			if(dojo.isMoz){
				// FIXME: seem to need to reopen the editor and display the toolbar
				var e = this.widget;
				e.open();
				if(this.widgetToolbar){
					dojo.place(e.toolbar.domNode, e.editingArea, "before");
				}
			}
		},
		populateEditor: function(){
			this.widget.set('value', this.content);
			this.widget.placeCursorAtEnd();
		}
	});
	dgc.Editor.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
		var d = dojo;
		var h = dojo.trim(dojo.attr(node, "widgetHeight")||"");
		if(h){
			if((h != "auto")&&(h.substr(-2) != "em")){
				h = parseInt(h, 10)+"px";
			}
			cell.widgetHeight = h;
		}
	};
})();

}

if(!dojo._hasResource['bfree.widget.acl.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.acl.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 12/10/11
 * Time: 10:47 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.acl.Grid');







dojo.declare('bfree.widget.acl.Grid', [bfree.widget._Grid], {

    _defaultRole: null,

    _hndls: [],

    activeItem: null,
    zone: null,

    _canEdit: function(cell, rowIndex){
        var item = this.getItem(rowIndex);
        var name = this.store.getValue(item, 'grantee_name');
        return ((name != 'Administrators') && (name != 'Admin'));
    },

	_canSort: function(columnIndex){
        return (columnIndex < 3);
    },

    _formatRole: function(data, rowIndex){
        var role = this.zone.getRoles().fetchById({
            id: data
        });
        return role.name;
    },
    _generateIcon: function(data, rowIndex){
        return dojo.replace('<img src="/images/icons/16/{0}.png" height="16" width="16" />', [data.toLowerCase()]);
    },

    _generateStore: function(){

        for(var i = 0; i < this._hndls.length; i++){
            dojo.disconnect(this._hndls[i]);
            this._hndls[i] = null
        }

        var entries = [];

        dojo.forEach(this.activeItem.acl_entries, function(acl_entry){

            //Retrieve user/group of the entry
            var grantee = (acl_entry.grantee_type.toLowerCase() == 'group') ?
                                this.zone.getGroups().fetchById({id: acl_entry.grantee_id}) :
                                this.zone.getUsers().fetchById({id: acl_entry.grantee_id});

            var role = this.zone.getRoles().fetchById({id: acl_entry.role_id});

            //Don't display if it is admin
            if((grantee.isInstanceOf(bfree.api.Group)) && (grantee.is_admin || grantee.is_everyone)){
                return;
            }

            var name = grantee.isInstanceOf(bfree.api.User) ?
                            grantee.getFullName() :
                            grantee.name;

            entries.push({
                grantee_id: acl_entry.grantee_id,
                grantee_type: acl_entry.grantee_type,
                grantee_name: name,
                role_id: acl_entry.role_id,
                permissions: role.permissions
            });

        }, this);

        var storeData = {
            items: entries
        };

       var store = new dojo.data.ItemFileWriteStore({
           data: storeData
       });

        this._hndls[0] = dojo.connect(store, 'onSet', this, this._onStoreChange);
        this._hndls[1] = dojo.connect(store, 'onNew', this, this._onStoreChange);
        this._hndls[2] = dojo.connect(store, 'onDelete', this, this._onStoreChange);

        return store;
    },

    _generateView: function(){
        var roleOptions = [];

        this.zone.getRoles().forEach(function(itm, idx){
            roleOptions.push(itm.name);
        });

        return [
            {
                cells: [
                    {
                        field: 'grantee_type',
                        name: '&nbsp;',
                        width: '16px',
                        formatter: this._generateIcon
                    },
                    {
                        field: 'grantee_name',
                        name:  'Grantee',
                        width: 'auto'
                    },
                    {
                        field: 'role_id',
                        name: 'Role',
                        width: '128px',
                        editable: true,
                        cellType: dojox.grid.cells._Widget,
                        widgetClass: dijit.form.FilteringSelect,
                        widgetProps: {
                            scrollOnFocus: false,
                            store: this.zone.getRoles().store,
                            searchAttr: 'name',
                            onChange: dojo.hitch(this, this._onRoleChange)
                        }
                        ,formatter: this._formatRole
                    }
                ],
                width: 'auto'
            }
           ];

    },

    _onRoleChange: function(value){

        if((this.selection.getSelectedCount() < 1) || String.isBlank(value))
            return;

        var item = this.selection.getFirstSelected();
        var roleId = this.store.getValue(item, 'role_id');

        if(value == roleId)
            return;

        var rowIndex = this.getItemIndex(item);
        this.doApplyCellEdit(value, rowIndex, 'role_id');
        this.onChange();
    },

    _onStoreChange: function(){
        this.onChange();
    },

    _setActiveItemAttr: function(value){
        this.activeItem = value;
        this.setStore(this._generateStore());
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

        this.editable = true;
        this.singleClickEdit = true;

		this.query = 0;
		this.queryOptions = {cache: false};
		this.selectionMode = 'single';

		this.clientSort = true;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Permission entries found';

        this.rowHeight = 24;

	},

    clear: function(){

        while(this.rowCount > 0){
            var item = this.getItem(0);
            this.store.deleteItem(item);
        }

    },

    newItem: function(id, name, type){
        var granteeExists = false;

        var queryResults = this.store.fetch({
            query: {grantee_id: id, grantee_type: type},
            queryOptions: { cache: false },
            onComplete: function(items){
                granteeExists = (items.length > 0);
            }
        });

        if(granteeExists){
            console.log(dojo.replace('ACL entry exists for grantee \'{0}\', aborting.', [name]))
            return;
        }

        var item = this.store.newItem({
            grantee_id: id,
            grantee_name: name,
            grantee_type: type,
            role_id: this._defaultRole.id
        });

        this.refresh();
        this.selectItem(item);
    },

    removeItem: function(item){
        var idx = this.getItemIndex(item);
        this.store.deleteItem(item);
        this.setSelectedIndex(idx);

    },

    onApplyCellEdit: function(value, rowIndex, fieldIndex){
        this.inherited('onApplyCellEdit', arguments);

        var item = this.getItem(rowIndex);
        var roleId = this.store.getValue(item, 'role_id');
        var role = this.zone.getRoles().fetchById({
            id: roleId
        });

        this.store.setValue(item, 'permissions', role.permissions)
        this.updateRow(rowIndex);

    },

    onBlur: function(){

        var item = this.selection.getFirstSelected();
        var idx = this.getItemIndex(item);

        this.focus.setFocusCell(this.getCell(1), idx);
        this.inherited('onBlur', arguments);
    },

    onChange: function(){
    },

    onCommand: function(cmdId, item){
    },

    onSelectedItem: function(item){
        var idx = this.getItemIndex(item);
        this.focus.setFocusCell(this.getCell(2), idx);
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        var roles = this.zone.getRoles();
        roles.fetch();

        this._defaultRole = roles.fetchByName('Viewer');

        this.set('structure', this._generateView());
        this.set('sortInfo', 1);
        this.startup();

	}

});

}

if(!dojo._hasResource['bfree.widget.acl.grantee.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.acl.grantee.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 18/10/11
 * Time: 10:15 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.acl.grantee.Grid');




dojo.declare('bfree.widget.acl.grantee.Grid', bfree.widget._Grid, {

    groupFilter: [],
    userFilter: [],
    zone: null,

	_canSort: function(columnIndex){
        return (columnIndex > 1);
    },

    _generateStore: function(){

        var grantees = [];

        this.zone.getUsers().forEach(function(grantee){

            if(grantee.is_admin)
                return;

            grantees.push({
                grantee_id: grantee.id,
                grantee_name: grantee.getFullName(),
                grantee_type: 'user',
                filter: dojo.has(this.userFilter, grantee.id)
            });

        }, this);

        this.zone.getGroups().forEach(function(grantee){

            if((grantee.is_admin) || (grantee.is_everyone))
                return;

            grantees.push({
                grantee_id: grantee.id,
                grantee_name: grantee.name,
                grantee_type: 'group',
                filter: dojo.has(this.groupFilter, grantee.id)
            });
        }, this);

        var storeData = {
            label: 'grantee_name',
            items: grantees
        };

        return new dojo.data.ItemFileWriteStore({
                    data: storeData
                });
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = { };
		this.queryOptions = {cache: false};
		//this.selectionMode = 'multiple';

		this.clientSort = true;
		this.canSort = this._canSort;
		this.noDataMessage = 'No User/Groups entries available';

	},

    getSelected: function(){
        var selected = []

        dojo.forEach(this.selection.getSelected(), function(item){
            selected.push({
                id: this.store.getValue(item, 'grantee_id'),
                type: this.store.getValue(item, 'grantee_type'),
                name: this.store.getValue(item, 'grantee_name')
            })
        }, this);

        return selected;
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this.set('structure', bfree.widget.acl.grantee.Grid.view);
        this.set('sortInfo', 2);
        this.startup();

        this.setStore(this._generateStore());
        this.filter({filter: false});
	}

});


bfree.widget.acl.grantee._generateIcon =
    function(data, rowIndex){
        return dojo.replace('<img src="/images/icons/16/{0}.png" height="16" width="16" />', [data]);
    }

bfree.widget.acl.grantee.Grid.view = [
    {
        cells: [
            {
                field: 'grantee_type',
                name: '&nbsp;',
                width: '16px',
                formatter: bfree.widget.acl.grantee._generateIcon
            },
            {
                field: 'grantee_name',
                name: 'User/Group',
                width: 'auto'
            },
            {
                field: 'filter',
                name: 'Filter',
                width: '64px',
                hidden: true
            }
        ],
        width: 'auto'
    }
]

}

if(!dojo._hasResource['bfree.widget.acl.grantee.List']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.acl.grantee.List'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 18/10/11
 * Time: 10:16 AM
 * To change this template use File | Settings | File Templates.
 */
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 12/10/11
 * Time: 9:22 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.acl.grantee.List');











dojo.declare('bfree.widget.acl.grantee.List', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/acl/grantee", "template/List.html", "<div style=\"height:100%;width:100%\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            style=\"height:100%;width:100%;\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                region=\"top\"\n                splitter=\"false\"\n                style=\"overflow:hidden;height:16px;\">\n\n            <span class=\"bfree dijitDarkLabel\" style=\"padding-right:8px;vertical-align:middle\">Show Only:</span>\n            <span class=\"bfree dijitDarkLabel boldLabel\" style=\"padding-right:8px;vertical-align:middle\"><input dojoAttachPoint=\"chkUsers\"/><label for=\"chkUsers\">Users</label></span>\n            <span class=\"bfree dijitDarkLabel boldLabel\" style=\"padding-right:8px;vertical-align:middle\"><input dojoAttachPoint=\"chkGroups\"/><label for=\"chkGroups\">Groups</label></span>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                region=\"center\"\n                splitter=\"false\"\n                style=\"padding-top:0\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _chkGroups: null,
    _chkUsers: null,
    _filter: [],
    _grdGrantees: null,

    groupFilter: [],
    userFilter: [],
    zone: null,

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onFilter: function(type, evt){
        var filter = 'none';

        if((this._chkUsers.checked) && (this._chkGroups.checked))
            filter = '*';
        else if(this._chkUsers.checked)
            filter = 'user';
        else if(this._chkGroups.checked)
            filter = 'group'

        this._grdGrantees.filter({grantee_type: filter});

    },

    _onSelectedItems: function(items){
        this.onValueChange();
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._grdGrantees != null){
            this._grdGrantees.destroyRecursive(false);
            this._grdGrantees = null;
        }

        if(this._chkGroups != null){
            this._chkGroups.destroyRecursive(false);
            this._chkGroups = null;
        }

        if(this._chkUsers != null){
            this._chkUsers.destroyRecursive(false);
            this._chkUsers = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._grdGrantees.domNode.focus();
    },

    isValid: function(){
        return (this._grdGrantees.selection.getSelectedCount() > 0);
    },

    onDialogClosing: function(dlgResult){

        if(dlgResult == bfree.widget.Dialog.dialogResult.cancel){
            this.returnValue = null;
        }
        else{
            this.returnValue = this._grdGrantees.getSelected();
        }

        return true;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._chkUsers = new dijit.form.CheckBox({
            id: 'chkUsers',
            checked: true,
            scrollOnFocus: false,
            onChange: dojo.hitch(this, this._onFilter)
        }, this.chkUsers);

        this._chkGroups = new dijit.form.CheckBox({
            id: 'chkGroups',
            checked: true,
            scrollOnFocus: false,
            onChange: dojo.hitch(this, this._onFilter)
        }, this.chkGroups);

        this._grdGrantees = new bfree.widget.acl.grantee.Grid({
            'class': 'versaGridOutline',
            autoSelect: false,
            groupFilter: this.groupFilter,
            userFilter: this.userFilter,
            zone: this.zone,
            onSelectedItems: dojo.hitch(this, this._onSelectedItems)
        }, this.gridNode);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._grdGrantees.resize();

        setTimeout(bfree.widget.acl.grantee.List._loadFnRef(this), 10);
    }

});

bfree.widget.acl.grantee.List._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

}

if(!dojo._hasResource['bfree.widget.FilteringSelect']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.FilteringSelect'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 18/11/11
 * Time: 4:04 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.FilteringSelect');


dojo.declare('bfree.widget.FilteringSelect', [dijit.form.FilteringSelect],
{

	postCreate: function(){
		this.inherited('postCreate', arguments);
	},

    reset: function(){
        this.inherited('reset', arguments);
        this._hasBeenBlurred = true;
    },

    startup: function(){
        this._hasBeenBlurred = true;
        this.inherited('startup', arguments);
        this.validate();
    },

    _openResultList: function(/*Object*/ results, /*Object*/ dataObject){
        this.focusNode.focus();
        this.inherited('_openResultList', arguments);
    }



});

}

if(!dojo._hasResource['bfree.widget.acl.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.acl.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 12/10/11
 * Time: 9:22 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.acl.Editor');















dojo.declare('bfree.widget.acl.Editor', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/acl", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            style=\"height:100%;width:100%;\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                dojoAttachPoint=\"inheritNode\"\n                region=\"top\"\n                splitter=\"false\"\n                style=\"overflow:hidden;height:16px;\">\n\n            <div id=\"chkInherit\" dojoAttachPoint=\"chkInherit\"></div>\n            <span class=\"bfree dijitDarkLabel boldLabel\" style=\"vertical-align:middle\">\n                <label for=\"chkInherit\" dojoAttachPoint=\"lblInheritNode\"></label>\n            </span>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.BorderContainer\"\n                design=\"headline\"\n                gutters=\"false\"\n                region=\"center\"\n                splitter=\"false\"\n                style=\"\">\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    region=\"top\"\n                    splitter=\"false\"\n                    style=\"overflow: hidden;height:16px\">\n\n                <span class=\"bfree dijitDarkLabel boldLabel\" style=\"padding-right:8px;vertical-align:middle\">Everyone:</span><div dojoAttachPoint=\"cmbEveryone\"></div>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    region=\"center\"\n                    splitter=\"false\"\n                    style=\"\">\n\n                <div dojoAttachPoint=\"gridNode\"></div>\n\n            </div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                region=\"bottom\"\n                splitter=\"false\"\n                style=\"height:36px;padding-top:0\">\n\n            <div dojoAttachPoint=\"btnAddNode\"></div>\n            <div dojoAttachPoint=\"btnRemoveNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _acl: null,
    _parentAcl: null,
    _btnAdd: null,
    _btnRemove: null,
    _chkInherit: null,
    _cmbEveryone: null,
    _grdAcl: null,
    _groups: {},
    _roles: {},

    activeUser: null,
    activeGroup: null,
    item: null,
    library: null,
    zone: null,
    type: null,

    __doCancel: function(){
        var canClose = false;

        try{

            canClose = true;
        }
        catch(e){

        }

        return canClose;
    },

    __doSave: function(){
        var canClose = false;

        try{
            //Set inherits flag
            this._acl.inherits = this._chkInherit.checked;
            this._acl.acl_entries = [];

            if(!this._acl.inherits){
                //Always 'Adminstrators' group
                this._acl.acl_entries.push({
                    grantee_id: this._groups.admin.id,
                    grantee_type: 'group',
                    role_id: this._roles.admin.id

                });

                //Add 'Everyone' group selection
                var role = this.zone.getRoles().fetchById({id: this._cmbEveryone.value});
                this._acl.acl_entries.push({
                    grantee_id: this._groups.everyone.id,
                    grantee_type: 'group',
                    role_id: role.id
                });

                for(var i = 0; i < this._grdAcl.rowCount; i++){
                    var item = this._grdAcl.getItem(i);
                    var grantee_id = this._grdAcl.store.getValue(item, 'grantee_id');
                    var grantee_type = this._grdAcl.store.getValue(item, 'grantee_type');
                    var role_id = this._grdAcl.store.getValue(item, 'role_id');

                    this._acl.acl_entries.push({
                        grantee_id: grantee_id,
                        grantee_type: grantee_type,
                        role_id: role_id
                    })
                }
            }

            var hasAccess = (this._acl.inherits) ?
                                this._parentAcl.hasAccess(this.zone, this.activeUser, this.activeGroup) :
                                this._acl.hasAccess(this.zone, this.activeUser, this.activeGroup);
            if(!hasAccess){
                var msg = 'Cannot update permissions: The current permissions are set so that you will no longer have access to the item.';
                throw new Error(msg);
            }

            this.item.setAcl(this.zone, this._acl);
            canClose = true;

        }
        catch(e){
            var err = new bfree.api.Error('Failed to save permissions', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    __loadItem: function(){
        var parentItem = null;

        try{

            if(this.item.isInstanceOf(bfree.api.Reference)){
                parentItem = (this.item.folder_id) ?
                                    this.library.getFolders().fetchById({id: this.item.folder_id}) :
                                    this.library;
            }
            else if(this.item.isInstanceOf(bfree.api.Folder)){
                parentItem = (this.item.parent_id) ?
                                    this.library.getFolders().fetchById({id: this.item.parent_id}) :
                                    this.library;
            }

            this._acl = this.item.getAcl(this.zone);
            this._parentAcl = (parentItem) ?
                                    parentItem.getAcl(this.zone) :
                                    null;

            this._roles['admin'] = this.zone.getRoles().fetchByName('Admin');
            this._groups['admin'] = this.zone.getGroups().getAdmin();
            this._groups['everyone'] = this.zone.getGroups().getEveryone();

            this._chkInherit.set('checked', this._acl.inherits);
            this._cmbEveryone.set('value', this._acl.getEveryone(this.zone).role_id);
            this._grdAcl.set('activeItem', this._acl);
            this._grdAcl.resize();

        }
        finally{
            this.onWidgetLoaded();
            this._isLoaded = true;
            this._setState();
        }

    },

    _btnAdd_onClick: function(evt){

        try{

            function __onClose(dlgResult, retValue){

                if(dlgResult == bfree.widget.Dialog.dialogResult.ok){

                    dojo.forEach(retValue, function(item){
                        this._grdAcl.newItem(item.id, item.name, item.type);
                    }, this);

                    this._grdAcl.resize();
                    this.set('isDirty', true);
                    this.onValueChange();

                }

                return true;
            }

            //get current entries to filter the selection grid:
            var userFilter = [];
            var groupFilter = [];
            for(var i = 0; i < this._grdAcl.rowCount; i++){
                var item = this._grdAcl.getItem(i);
                var grantee_id = this._grdAcl.store.getValue(item, 'grantee_id');
                var grantee_type = this._grdAcl.store.getValue(item, 'grantee_type');

                if(grantee_type == 'Group'){
                    groupFilter.push(grantee_id);
                }
                else{
                    userFilter.push(grantee_id);
                }
            }

            var dlg = new bfree.widget.Dialog({
                id: 'dlgGrantees',
                title: 'Add Users/Groups',
                widgetConstructor: bfree.widget.acl.grantee.List,
                widgetParams: {
                    zone: this.zone,
                    groupFilter: groupFilter,
                    userFilter: userFilter
                },
                noResize: true,
                height: 320,
                width: 320,
                zIndex: 2048,
                buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
                onClose: dojo.hitch(this, __onClose)
            });
            dlg.startup();
            dlg.show();
        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Edit Permissions\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _btnRemove_onClick: function(evt){

        dojo.forEach(this._grdAcl.selection.getSelected(), function(item){
            this._grdAcl.removeItem(item);
        }, this);

    },

    _chkInherit_onChange: function(is_checked){

        if(!this._grdAcl){
            return;
        }

        if(is_checked){
            this._cmbEveryone.set('value', this._parentAcl.getEveryone(this.zone).role_id);
            this._grdAcl.set('activeItem', this._parentAcl);
            this._grdAcl.selection.clear();
        }
        else{
            this._grdAcl.set('activeItem', this._acl);
            this._grdAcl.setSelectedIndex(0);
        }

        if(this._acl.inherits != is_checked)
            this.set('isDirty', true);
        this.onValueChange();

        this._setState();
    },

    _cmbEveryone_onChange: function(value){
        if(this._acl.getEveryone(this.zone).role_id != value)
            this.set('isDirty', true);
        this.onValueChange();
    },

    _grdAcl_onChange: function(item, attr, oldValue, newValue){
        if(this._isLoaded) this.set('isDirty', true);
        this.onValueChange();
    },

    _grdAcl_onSelectedItems: function(items){
        var item = null;

        if((dojo.isArray(items)) && (items.length > 0))
            item = items[0];

        this._setState();
    },

    _setState: function(){

        var count = this._grdAcl.selection.getSelectedCount();
        this._cmbEveryone.set('disabled', this._chkInherit.checked);

        this._btnAdd.set('disabled', this._chkInherit.checked);
        this._btnRemove.set('disabled', (this._chkInherit.checked || (count < 1)));

    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._btnRemove != null){
            this._btnRemove.destroyRecursive(false);
            this._btnRemove = null;
        }

        if(this._btnAdd != null){
            this._btnAdd.destroyRecursive(false);
            this._btnAdd = null;
        }

        if(this._grdAcl != null){
            this._grdAcl.destroyRecursive(false);
            this._grdAcl = null;
        }

        if(this._cmbEveryone != null){
            this._cmbEveryone.destroyRecursive(false);
            this._cmbEveryone = null;
        }

        if(this._chkInherit != null){
            this._chkInherit.destroyRecursive(false);
            this._chkInherit = null;
        }

    },

    isValid: function(){
        return (this.isDirty);
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            this.returnValue = [this.item];
            canClose = (dlgResult == bfree.widget.Dialog.dialogResult.ok) ?
                            this.__doSave() :
                            this.__doCancel();

        }
        catch(e){
           var err = new bfree.api.Error('Failed to save permissions', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        if(this.item.isInstanceOf(bfree.api.Folder)){
            this.type = 'Folder';
            this.lblInheritNode.innerHTML = 'Inherit from Parent';
            if(this.item.isRoot() || this.item.isShare()){
                dojo.style(this.inheritNode.domNode, {display: 'none'});
            }
        }
        else if(this.item.isInstanceOf(bfree.api.Reference)){
            this.type = 'Reference';
            this.lblInheritNode.innerHTML = (this.item.isShare()) ? 'Inherit for Share' : 'Inherit from Folder';
        }

        this._chkInherit = new dijit.form.CheckBox({
            id: 'chkInherit',
            checked: false,
            scrollOnFocus: false,
            onChange: dojo.hitch(this, this._chkInherit_onChange)
        }, this.chkInherit);

        var roles = this.zone.getRoles().query({query: '?type=' + this.type});
        var roleData = new Array();
        for(var i = 0; i < roles.length; i++){
            var item = new Object();
            item[roles[i].id] = roles[i].name;
            roleData.push(item);
        }
        var roleStore = new dojox.data.KeyValueStore({
            dataVar: roleData
        });
        this._cmbEveryone = new bfree.widget.FilteringSelect({
            store: roleStore,
            searchAttr: 'name',
            value: roles[0].id,
            onChange: dojo.hitch(this, this._cmbEveryone_onChange)
        }, this.cmbEveryone);

        this._grdAcl = new bfree.widget.acl.Grid({
            'class': 'versaGridOutlineNoPad',
            zone: this.zone,
            autoSelect:false,
            onChange: dojo.hitch(this, this._grdAcl_onChange),
            onSelectedItems: dojo.hitch(this, this._grdAcl_onSelectedItems)
        }, this.gridNode);

        this._btnAdd = new bfree.widget.Button({
            'class': 'versaButton',
            iconClass: 'buttonIcon bfreeIconAdd',
            disabledIconClass: 'buttonIcon bfreeIconAddD',
            label: 'Add...',
            disabled: true,
            onClick: dojo.hitch(this, this._btnAdd_onClick)
        }, this.btnAddNode);

        this._btnRemove = new bfree.widget.Button({
            'class': 'versaButtonLarge',
            iconClass: 'buttonIcon bfreeIconRemove',
            disabledIconClass: 'buttonIcon bfreeIconRemoveD',
            label: 'Remove',
            disabled: true,
            onClick: dojo.hitch(this, this._btnRemove_onClick)
        }, this.btnRemoveNode);

    },

    startup: function(){
        this.inherited('startup', arguments);
        setTimeout(bfree.widget.acl.Editor._loadFnRef(this), 10);
    }

});

bfree.widget.acl.Editor._loadFnRef = function(that){
    return ( function() {
       that.__loadItem();
    });
}

bfree.widget.acl.Editor.show = function(args){

    //Not great: attempt to only allow one item to be edited.
    var item = (args.item) ?
                    args.item :
                    ((args.items) && dojo.isArray(args.items)) ?
                            args.items[0] :
                            args.items;


    var dlg = new bfree.widget.Dialog({
        id: 'dlgEditPermissions',
        title: dojo.replace('Edit Permissions - {name}', item),
        widgetConstructor: bfree.widget.acl.Editor,
        widgetParams: {
            activeUser: args.user,
            activeGroup: args.group,
            library: args.library,
            zone: args.zone,
            item: item
        },
        noResize: true,
        height: 360,
        width: 480,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['bfree.api.ChoiceValue']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ChoiceValue'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.ChoiceValue');



dojo.declare('bfree.api.ChoiceValue', [bfree.api._Object],{

	constructor: function(/* Object */args){
        dojo.safeMixin(this, ((!args) ? { } : args));
	}

});

bfree.api.ChoiceValue.compare = function(item1, item2){
    return item1.sort_order-item2.sort_order;
};

bfree.api.ChoiceValue.schema = {
	type: 'object',
	properties: {
		'id': {
			type: 'integer'
		},
		'name': {
			type: 'string'
		},
		'value': {
			type: 'string'
		},
		'choice_list_id': {
			type: 'integer'
		},
		'sort_order': {
			type: 'integer',
			'default': 1
		}
	},
    prototype: new bfree.api.ChoiceValue()
};

}

if(!dojo._hasResource['bfree.api.ChoiceValues']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ChoiceValues'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.api.ChoiceValues');




dojo.declare('bfree.api.ChoiceValues', [bfree.api._Collection],{

	choiceList: null,
	library:    null,
    zone:       null,

	constructor: function(/* Object */args){
		this.zone=args.zone;
        this.library=args.library;
        this.choiceList=args.choiceList;
        if(this.choiceList){
            this.target = dojo.replace(bfree.api.ChoiceValues.TRGT, [this.zone.subdomain, this.library.id, this.choiceList.id]);
        }else{
            this.target = dojo.replace(bfree.api.ChoiceValues.TRGT_NO_LIST, [this.zone.subdomain, this.library.id]);
        }
        this.schema = bfree.api.ChoiceValue.schema;
        this.cache=true;

        this._initialize();
	}
});

bfree.api.ChoiceValues.TRGT="/zones/{0}/libraries/{1}/choice_lists/{2}/choice_values";
bfree.api.ChoiceValues.TRGT_NO_LIST="/zones/{0}/libraries/{1}/choice_values";

}

if(!dojo._hasResource['bfree.GridHelper']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.GridHelper'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.GridHelper');

dojo.declare('bfree.GridHelper', null,{
});

bfree.GridHelper.hideHeader = function(grid){
	
	var headerNode = grid.viewsHeaderNode.firstChild;
	dojo.addClass(headerNode, 'bfreeNoHeader');
}

bfree.GridHelper.moveItemDown = function(grid, attr){
	var itemDown = grid.selection.getFirstSelected();

	if(itemDown == null)
		return;
		
	var idx = grid.getItemIndex(itemDown) + 1;
	if(idx >= grid.rowCount);
	
	var itemUp = grid.getItem(idx); 	
			
	bfree.GridHelper.swapItemOrder(grid, attr, itemDown, itemUp);
				
	idx = grid.getItemIndex(itemDown);			
	bfree.GridHelper.setSelectedIndex(grid, idx);
}

bfree.GridHelper.moveItemUp = function(grid, attr){
	
	var itemUp = grid.selection.getFirstSelected();

	if(itemUp == null)
		return;
		
	var idx = grid.getItemIndex(itemUp) - 1;
	if(idx < 0 ) return;
	
	var itemDown = grid.getItem(idx); 	
			
	bfree.GridHelper.swapItemOrder(grid, attr, itemDown, itemUp);

	idx = grid.getItemIndex(itemUp);			
	bfree.GridHelper.setSelectedIndex(grid, idx);
	
}

bfree.GridHelper.setSelectedIndex = function(grid, idx){
		
	if(!grid) return;		
		
	grid.selection.clear();
		
	while(idx >= grid.rowCount)
		idx--;
		
	if((idx < 0) && (grid.rowCount <= 0))
		return;
		
	if(idx < 1) idx = 0;
	
	grid.selection.select(idx);
    if(grid.selection.getFirstSelected()){
        grid.updateRow(idx);
        grid.scrollToRow(idx);
    }
    //grid helper isn't used in the document grid anymore
    //keeping for reference
//	if(!grid.isInstanceOf(bfree.widget.library.DocumentGrid)) grid.scrollToRow(idx);
}

bfree.GridHelper.swapItemOrder = function(grid, attr, item1, item2){
	
	grid.beginUpdate();
	
	var order1 = grid.store.getValue(item1, attr);
	var order2 = grid.store.getValue(item2, attr);
	
	grid.store.setValue(item1, attr, order2);
	grid.store.setValue(item2, attr, order1);
	
	grid.endUpdate();
	
	grid.sort();
	grid.resize();
	
}



}

if(!dojo._hasResource["dijit.form.RadioButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.RadioButton"] = true;
dojo.provide("dijit.form.RadioButton");



// TODO: for 2.0, move the RadioButton code into this file

}

if(!dojo._hasResource['bfree.widget.DataTypeSelector']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.DataTypeSelector'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.DataTypeSelector');








dojo.declare('bfree.widget.DataTypeSelector', [dijit._Widget, dijit._Templated],{
	templateString: null,
	templateString: dojo.cache("bfree/widget", "template/DataTypeSelector.html", "<div style=\"height:100%;position:relative;width:100%\">\t\n\n\t<table style=\"width:100%\">\n\t\t<tr>\t\t\t\n\t\t\t<td style=\"text-align:left;vertical-align:top;white-space:nowrap;;width:96px;\">\n\t\t\t\t<input dojoAttachPoint=\"rdoDataTypeStrNode\" type=\"radio\"></input>\n\t\t\t\t<label dojoAttachPoint=\"lblDataTypeStrNode\" class=\"mediumLabel darkLabel\">String</label>\n\t\t\t</td>\n\t\t</tr>\t\t\n\t\t<tr>\t\t\n\t\t\t<td style=\"text-align:left;vertical-align:top;white-space:nowrap;\">\n\t\t\t\t<input dojoAttachPoint=\"rdoDataTypeDttNode\" type=\"radio\"></input>\n\t\t\t\t<label dojoAttachPoint=\"lblDataTypeDttNode\" class=\"mediumLabel darkLabel\">Date</label>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\t\t\n\t\t\t<td style=\"text-align:left;vertical-align:top;white-space:nowrap;\">\n\t\t\t\t<input dojoAttachPoint=\"rdoDataTypeIntNode\" type=\"radio\"></input>\n\t\t\t\t<label dojoAttachPoint=\"lblDataTypeIntNode\" class=\"mediumLabel darkLabel\">Integer</label>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\t\t\n\t\t\t<td style=\"text-align:left;vertical-align:top;white-space:nowrap;\">\n\t\t\t\t<input dojoAttachPoint=\"rdoDataTypeFltNode\" type=\"radio\"></input>\n\t\t\t\t<label dojoAttachPoint=\"lblDataTypeFltNode\" class=\"mediumLabel darkLabel\">Decimal</label>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\t\t\n\t\t\t<td style=\"text-align:left;vertical-align:top;white-space:nowrap;\">\n\t\t\t\t<input dojoAttachPoint=\"rdoDataTypeBlnNode\" type=\"radio\"></input>\n\t\t\t\t<label dojoAttachPoint=\"lblDataTypeBlnNode\" class=\"mediumLabel darkLabel\">Boolean</label>\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\t\t\n\t\t\t<td style=\"text-align:left;vertical-align:top;white-space:nowrap;\">\n\t\t\t\t<input dojoAttachPoint=\"rdoDataTypeTxtNode\" type=\"radio\"></input>\n\t\t\t\t<label dojoAttachPoint=\"lblDataTypeTxtNode\" class=\"mediumLabel darkLabel\">Text</label>\n\t\t\t</td>\n\t\t</tr>\n\t\t\t\t\n\t</table>\n\n</div>\n"),
	widgetsInTemplate: true,
	
	disabled: false,
	_rdoDataTypes: null,
    _dataTypes: null,

	_getDisabledAttr: function(){
		return _rdoDataTypes[1].attr('disabled');
	},

	_getValueAttr: function(){
		
		for(var dataType in bfree.api.DataTypes.Types){
			var dataTypeId = bfree.api.DataTypes.Types[dataType];
			var rdo = this._rdoDataTypes[dataTypeId];
			if((rdo) && (rdo.attr('checked'))){
				return dataTypeId;
			}
		}	
		
		return bfree.api.DataTypes.Types._void;
	},
	
	_setDisabledAttr: function(value){
		
		if(this._rdoDataTypes == null)
			return;
						
		for(var dataType in bfree.api.DataTypes.Types){
			var dataTypeId = bfree.api.DataTypes.Types[dataType];
			var rdo = this._rdoDataTypes[dataTypeId];
			if(rdo){
				rdo.attr('disabled', value);				
			}
		}	
		
	},
	
	_setValueAttr: function(value){	
		
		for(var dataType in bfree.api.DataTypes.Types){
			var dataTypeId = bfree.api.DataTypes.Types[dataType];
			var rdo = this._rdoDataTypes[dataTypeId];
			if(rdo){
				rdo.attr('checked', (dataTypeId == value));
			}
		}	
		
	},
	
	_rdoDataTypes_onChange: function(newValue){
		
		var dataTypeId = bfree.api.DataTypes.Types._string;
		
		dojo.forEach(this._rdoDataTypes, function(rdo){
			if(!rdo) return;			
			if(rdo.attr('checked')) 
				dataTypeId = rdo.attr('value');
		}, this);
		
		this.onChange(dataTypeId);
	},

	clear: function(){
		for(var dataType in bfree.api.DataTypes.Types){
			var dataTypeId = bfree.api.DataTypes.Types[dataType];
			var rdo = this._rdoDataTypes[dataTypeId];
			if(rdo){
				rdo.attr('checked', false);
			}
		}
	},	
		
	onChange: function(newValue){	
	},
	
	postCreate: function(){
		this.inherited('postCreate', arguments);

         this._dataTypes = bfree.api.Application.getDataTypes();

        /*
		this._rdoDataTypes = new Array(bfree.api.DataTypes.Types.length);
		*/

        /*

		this._rdoDataTypes[bfree.api.DataTypes.Types._void] = null;
		
		this._rdoDataTypes[bfree.api.DataTypes.Types._boolean] = new dijit.form.RadioButton({			
			name: 'rdoDataTypes',
			labelNode: this.lblDataTypeBlnNode,
			value: bfree.api.DataTypes.Types._boolean,
			disabled: this.disabled,
			onChange: dojo.hitch(this, this._rdoDataTypes_onChange)
		}, this.rdoDataTypeBlnNode);
		this.lblDataTypeBlnNode.htmlFor = this._rdoDataTypes[bfree.api.DataTypes.Types._boolean].id;
		
		this._rdoDataTypes[bfree.api.DataTypes.Types._integer] = new dijit.form.RadioButton({			
			name: 'rdoDataTypes',
			labelNode: this.lblDataTypeIntNode,
			value: bfree.api.DataTypes.Types._integer,
			disabled: this.disabled,
			onChange: dojo.hitch(this, this._rdoDataTypes_onChange)
		}, this.rdoDataTypeIntNode);
		this.lblDataTypeIntNode.htmlFor = this._rdoDataTypes[bfree.api.DataTypes.Types._integer].id;
		
		this._rdoDataTypes[bfree.api.DataTypes.Types._float] = new dijit.form.RadioButton({			
			name: 'rdoDataTypes',
			labelNode: this.lblDataTypeFltNode,
			value: bfree.api.DataTypes.Types._float,
			disabled: this.disabled,
			onChange: dojo.hitch(this, this._rdoDataTypes_onChange)
		}, this.rdoDataTypeFltNode);
		this.lblDataTypeFltNode.htmlFor = this._rdoDataTypes[bfree.api.DataTypes.Types._float].id;
		
		this._rdoDataTypes[bfree.api.DataTypes.Types._datetime] = new dijit.form.RadioButton({			
			name: 'rdoDataTypes',
			labelNode: this.lblDataTypeDttNode,
			value: bfree.api.DataTypes.Types._datetime,
			disabled: this.disabled,
			onChange: dojo.hitch(this, this._rdoDataTypes_onChange)
		}, this.rdoDataTypeDttNode);
		this.lblDataTypeDttNode.htmlFor = this._rdoDataTypes[bfree.api.DataTypes.Types._datetime].id;			
			
		this._rdoDataTypes[bfree.api.DataTypes.Types._string] = new dijit.form.RadioButton({			
			name: 'rdoDataTypes',
			labelNode: this.lblDataTypeStrNode,
			value: bfree.api.DataTypes.Types._string,
			disabled: this.disabled,
			onChange: dojo.hitch(this, this._rdoDataTypes_onChange)
		}, this.rdoDataTypeStrNode);
		this.lblDataTypeStrNode.htmlFor = this._rdoDataTypes[bfree.api.DataTypes.Types._string].id;
		
		this._rdoDataTypes[bfree.api.DataTypes.Types._text] = new dijit.form.RadioButton({			
			name: 'rdoDataTypes',
			labelNode: this.lblDataTypeTxtNode,
			value: bfree.api.DataTypes.Types._text,
			disabled: this.disabled,
			onChange: dojo.hitch(this, this._rdoDataTypes_onChange)
		}, this.rdoDataTypeTxtNode);
		this.lblDataTypeTxtNode.htmlFor = this._rdoDataTypes[bfree.api.DataTypes.Types._text].id;
	    */
	}
	
});

}

if(!dojo._hasResource['bfree.widget.choiceList.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.choiceList.CommandBar'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.choiceList.CommandBar');






dojo.declare('bfree.widget.choiceList.CommandBar', dijit.Toolbar,
{
    _btnSave: null,
    _btnUndo: null,
    _btnNew: null,
    _btnEdit: null,
    _btnDelete: null,
    _btnHelp: null,

    activeItem: null,
    choiceLists: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;
        this._setState();
    },

    constructor: function(args){

    },

    destroy: function(){
        this.destroyDescendants();
    },

    onCommand: function(cmdId){

    },



	_setState: function(){

        var isDirty = this.choiceLists.isDirty();
        var isNull = (this.activeItem == null);

        this._btnSave.set('disabled', !isDirty);
        this._btnUndo.set('disabled', !isDirty);
        this._btnEdit.set('disabled', isNull);
        this._btnDelete.set('disabled', isNull);

	},

    destroy: function(){

        this.destroyDescendants();

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this._btnSave = new bfree.widget.Button({
                id: 'btnPropDefsSave',
                label: 'Save Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconSave',
                disabledIconClass:'commandIcon bfreeIconSaveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.SAVE)
            });
        this.addChild(this._btnSave);

        this._btnUndo = new bfree.widget.Button({
                label: 'Undo Unsaved Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconUndo',
                disabledIconClass: 'commandIcon bfreeIconUndoD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.UNDO)
            });
        this.addChild(this._btnUndo);

        this.addChild(new dijit.ToolbarSeparator());

        this._btnNew = new bfree.widget.Button({
                label: 'New Choice List...',
                showLabel: false,
                disabled: false,
                iconClass: 'commandIcon bfreeIconChoiceList',
                disabledIconClass: 'commandIcon bfreeIconAdminD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.NEW)
            });
        this.addChild(this._btnNew);

        this._btnEdit = new bfree.widget.Button({
                label: 'Edit selected Property Definition...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconEdit',
                disabledIconClass: 'commandIcon bfreeIconEditD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT)
            });
        this.addChild(this._btnEdit);

        this._btnDelete = new bfree.widget.Button({
                label: 'Delete selected Property Definition',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconDelete',
                disabledIconClass: 'commandIcon bfreeIconDeleteD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.DELETE)
            });
        this.addChild(this._btnDelete);

        this.addChild(new dijit.ToolbarSeparator());

        /*
        this._btnHelp =  new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconHelp',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            });
        this.addChild(this._btnHelp);
        */
    },

	refresh: function(args){
		this._setState();
	},

    startup: function(){
        this.inherited('startup', arguments);

    }
	
});


}

if(!dojo._hasResource['bfree.widget.choiceList.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.choiceList.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 19/11/11
 * Time: 6:14 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.choiceList.Grid');



dojo.declare('bfree.widget.choiceList.Grid', [bfree.widget._Grid], {

    selectionMode: 'single',
    choiceLists: null,

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};

		this.clientSort = false;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Choice Lists found';
        this.sortInfo = 3;

	},

	postCreate: function(){
		this.inherited('postCreate', arguments);
        this.set('structure', bfree.widget.choiceList.Grid.view);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this.choiceLists.store, {}, {cache: true});
    }

});

bfree.widget.choiceList.Grid.getState = function(idx, item){

    if(!item)
        return 0;

    if((item.hasOwnProperty('isValid')) && (!item.isValid()))
        return -1;

    if(this.grid.choiceLists.isNew({item: item}))
        return 1;
    if(this.grid.choiceLists.isDirty({item: item}))
        return 2;

    return 0;
}

bfree.widget.choiceList.Grid.formatState = function(data, rowIndex){

    var iconClass = '';
    switch(data){
        case -1:
            iconClass = 'statusIcon bfreeIconInvalid';
            break;
        case 1:
            iconClass = 'statusIcon bfreeIconNew';
            break;
        case 2:
            iconClass = 'statusIcon bfreeIconEdit';
            break;
    }

    return dojo.replace('<img src="/images/icons/16/blank.png" width="16" height="16" class="{0}"/>', [iconClass]);
}

bfree.widget.choiceList.Grid.view = [
    {
        cells: [
            {
                field: 'state',
                name: '&nbsp;',
                width: '16px',
                get: bfree.widget.choiceList.Grid.getState,
                formatter: bfree.widget.choiceList.Grid.formatState
            },
            {
                field: 'name',
                name: 'Name',
                width: 'auto'
            },
            {
                field: 'sort_id',
                name: 'Sort',
                hidden: true
            }
        ],
        width: 'auto'
    }
];


}

if(!dojo._hasResource["dojox.layout.TableContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.TableContainer"] = true;
dojo.experimental("dojox.layout.TableContainer");
dojo.provide("dojox.layout.TableContainer");


dojo.declare("dojox.layout.TableContainer",
	dijit.layout._LayoutWidget,
	{
	// summary:
	//		A container that lays out its child widgets in a table layout.
	//
	// description:
	//		The TableContainer lays out child widgets in a Table layout.
	//		Each widget can specify a "label" or a "title" parameter.
	//		This label is displayed either above or to the left of
	//		a widget depending on whether the "orientation" attribute
	//		is "horiz" or "vert", for horizontal and vertical respectively.
	//		The number of columns is configured using the "cols" attribute.
	//		The width of labels can be configured using the "labelWidth" parameter.
	//
	// example:
	// |	<div dojoType="dojox.layout.TableContainer" orientation="vert" cols="3>
	// |		<div dojoType="dijit.form.TextInput" value="John" label="First Name:"></div>
	// |		<div dojoType="dijit.form.CheckBox" label="Is Student?:"></div>
	// |		<div dojoType="dojox.form.DateTextBox" label="Date Of Birth:"></div>
	// |	</div>
	//

	cols: 1,
	
	// labelWidth: Number|String
	//		Defines the width of a label.  If the value is a number, it is
	//		treated as a pixel value.  The other valid value is a percentage,
	//		e.g. "50%"
	labelWidth: "100",

	// showLabels: Boolean
	//		True if labels should be displayed, false otherwise.
	showLabels: true,

	// orientation: String
	//		Either "horiz" or "vert" for label orientation.
	orientation: "horiz",
	
	// spacing: Number
	//		The cell spacing to apply to the table.
	spacing: 1,

	// customClass: String
	//		A CSS class that will be applied to child elements.  For example, if
	//		the class is "myClass", the table will have "myClass-table" applied to it,
	//		each label TD will have "myClass-labelCell" applied, and each
	//		widget TD will have "myClass-valueCell" applied.
	customClass: "",

	postCreate: function(){
		this.inherited(arguments);
		this._children = [];
		
		// If the orientation, customClass or cols attributes are changed,
		// layout the widgets again.
		this.connect(this, "set", function(name, value){
			if(value && (name == "orientation" || name == "customClass" || name == "cols")) {
				this.layout();
			}
		})
	},

	startup: function() {
		if(this._started) {
			return;
		}
		this.inherited(arguments);
		if(this._initialized) {
			return;
		}
		var children = this.getChildren();
		if(children.length < 1) {
			return;
		}
		this._initialized = true;

		dojo.addClass(this.domNode, "dijitTableLayout");

		// Call startup on all child widgets
		dojo.forEach(children, function(child){
			if(!child.started && !child._started) {
				child.startup();
			}
		});
		this.resize();
		this.layout();
	},

	resize: function(){
		// summary:
		//		Resizes all children.  This widget itself
		//		does not resize, as it takes up 100% of the
		//		available width.
		dojo.forEach(this.getChildren(), function(child){
			if(typeof child.resize == "function") {
				child.resize();
			}
		});
	},

	layout: function(){
		// summary:
		//		Lays out the child widgets.
		if(!this._initialized){
			return;
		}

		var children = this.getChildren();

		var childIds = {};
		var _this = this;

		function addCustomClass(node, type, count) {
			if(_this.customClass != "") {
				var clazz = _this.customClass+ "-" + (type || node.tagName.toLowerCase());
				dojo.addClass(node, clazz);

				if(arguments.length > 2) {
					dojo.addClass(node, clazz + "-" + count);
				}
			}
		}

		// Find any new children that have been added since the last layout() call
		dojo.forEach(this._children, dojo.hitch(this, function(child){
			childIds[child.id] = child;
		}));

		dojo.forEach(children, dojo.hitch(this, function(child, index){
			if(!childIds[child.id]) {
				// Add pre-existing children to the start of the array
				this._children.push(child);
			}
		}));

		// Create the table.  It fills the width of it's container.
		var table = dojo.create("table", {
			"width": "100%",
			 "class": "tableContainer-table tableContainer-table-" + this.orientation,
			 "cellspacing" : this.spacing
			},
			this.domNode);

		var tbody = dojo.create("tbody");
		table.appendChild(tbody);

		addCustomClass(table, "table", this.orientation);

		var width = Math.floor(100 / this.cols) + "%";

		var labelRow = dojo.create("tr", {}, tbody);
		var childRow = (!this.showLabels || this.orientation == "horiz")
											? labelRow : dojo.create("tr", {}, tbody);
		var maxCols = this.cols * (this.showLabels ? 2 : 1);
		var numCols = 0;

		// Iterate over the children, adding them to the table.
		dojo.forEach(this._children, dojo.hitch(this, function(child, index){
			
			var colspan = child.colspan || 1;
			
			if(colspan > 1) {
				colspan = this.showLabels ?
					Math.min(maxCols - 1, colspan * 2 -1): Math.min(maxCols, colspan);
			}

			// Create a new row if we need one
			if(numCols + colspan - 1 + (this.showLabels ? 1 : 0)>= maxCols) {
				numCols = 0;
				labelRow = dojo.create("tr", {}, tbody);
				childRow = this.orientation == "horiz" ? labelRow : dojo.create("tr", {}, tbody);
			}
			var labelCell;
			
			// If labels should be visible, add them
			if(this.showLabels) {
				labelCell = dojo.create("td", {"class": "tableContainer-labelCell"}, labelRow);

				// If the widget should take up both the label and value,
				// then just set the class on it.
				if(child.spanLabel) {
					dojo.attr(labelCell, this.orientation == "vert" ? "rowspan" : "colspan", 2);
				}
				else {
					// Add the custom label class to the label cell
					addCustomClass(labelCell, "labelCell");
					var labelProps = {"for": child.get("id")};
					var label = dojo.create("label", labelProps, labelCell);

					if(Number(this.labelWidth) > -1 ||
						String(this.labelWidth).indexOf("%") > -1) {
							
						// Set the width of the label cell with either a pixel or percentage value
						dojo.style(labelCell, "width",
							String(this.labelWidth).indexOf("%") < 0
								? this.labelWidth + "px" : this.labelWidth);
					}

					label.innerHTML = child.get("label") || child.get("title");
				}
			}
			var childCell;

			if(child.spanLabel && labelCell) {
				childCell = labelCell;
			} else {
				 childCell = dojo.create("td", {
				 	"class" : "tableContainer-valueCell"
				}, childRow);
			}
			if(colspan > 1) {
				dojo.attr(childCell, "colspan", colspan);
			}
			
			// Add the widget cell's custom class, if one exists.
			addCustomClass(childCell, "valueCell", index);

			childCell.appendChild(child.domNode);
			numCols += colspan + (this.showLabels ? 1 : 0);
		}));

		if(this.table)	 {
			this.table.parentNode.removeChild(this.table);
		}
		// Refresh the layout of any child widgets, allowing them to resize
		// to their new parent.
		dojo.forEach(children, function(child){
			if(typeof child.layout == "function") {
				child.layout();
			}
		});
		this.table = table;
		this.resize();
	},
	
	destroyDescendants: function(/*Boolean*/ preserveDom){
		// summary:
		//      Destroys all the widgets inside this.containerNode,
		//      but not this widget itself
		dojo.forEach(this._children, function(child){ child.destroyRecursive(preserveDom); });
	},
	
	_setSpacingAttr: function(value) {
		// summary:
		//		Sets the spacing attribute.
		this.spacing = value;
		if(this.table) {
			this.table.cellspacing = Number(value);
		}
	}
});

// Extend the default widget with both label and title elements, as
// well as a "spanLabel" attribute.  If a widget
dojo.extend(dijit._Widget, {
	// label: String
	//		The label to display for a given widget
	label: "",
	
	// title: String
	//		The label to display for a given widget.  This is interchangeable
	//		with the 'label' parameter, as some widgets already have a use
	//		for the 'label', and this can be used instead to avoid conflicts.
	title: "",
	
	// spanLabel: Boolean
	//		Setting spanLabel to true makes the widget take up both the
	//		label and value cells. Defaults to false.
	spanLabel: false,
	
	// colspan: Number
	//		The number of columns this widget should span.
	colspan: 1
});

}

if(!dojo._hasResource['bfree.widget.PropertyTable']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.PropertyTable'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/12/11
 * Time: 11:15 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.PropertyTable');



dojo.declare('bfree.widget.PropertyTable', [dojox.layout.TableContainer], {

    refresh: function(){
        this._initialized = false;
        this._started = false;
        this.startup();
    }

});

}

if(!dojo._hasResource['bfree.widget.ObjectInfo']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.ObjectInfo'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/12/11
 * Time: 8:55 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.ObjectInfo');









dojo.declare('bfree.widget.ObjectInfo', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget", "template/ObjectInfo.html", "<div style=\"width:100%;height:100%\">\n\n     <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    _form: null,
    _lblId: null,
    _lblCreatedBy: null,
    _lblCreatedAt: null,
    _lblUpdatedBy: null,
    _lblUpdatedAt: null,
    _tblProperties: null,

    activeItem: null,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        if(item){
            this._lblId.set('value', this.activeItem.id);
            this._lblCreatedBy.set('value', this.activeItem.created_by);
            this._lblCreatedAt.set('value', (this.activeItem.created_at) ? dojo.date.locale.format(this.activeItem.created_at, {formatLength: 'medium'}) : '');
            this._lblUpdatedBy.set('value', this.activeItem.updated_by);
            this._lblUpdatedAt.set('value', (this.activeItem.updated_at) ? dojo.date.locale.format(this.activeItem.updated_at, {formatLength: 'medium'}) : '');
        }
        else{
            this._lblId.reset();
            this._lblCreatedBy.reset();
            this._lblCreatedAt.reset();
            this._lblUpdatedBy.reset();
            this._lblUpdatedAt.reset();
        }

        this._tblProperties.refresh();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants()

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'infoObjForm'
        }, this.formNode);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblObjInfo1',
            customClass: 'versainfo',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._lblId = new bfree.widget.Label({
               id: 'lblId',
               label: 'ID'
            });
        this._tblProperties.addChild(this._lblId);

        this._lblCreatedBy = new bfree.widget.Label({
               id: 'lblCreatedBy',
               label: 'Created By:'
            });
        this._tblProperties.addChild(this._lblCreatedBy);

        this._lblCreatedAt = new bfree.widget.Label({
               id: 'lblCreatedAt',
               label: 'Create Date:'
            });
        this._tblProperties.addChild(this._lblCreatedAt);

        this._lblUpdatedBy = new bfree.widget.Label({
               id: 'lblUpdatedBy',
               label: 'Last Modified By:'
            });
        this._tblProperties.addChild(this._lblUpdatedBy);

        this._lblUpdatedAt = new bfree.widget.Label({
               id: 'lblUpdatedAt',
               label: 'Last Modified Date:'
            });
        this._tblProperties.addChild(this._lblUpdatedAt);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.choiceList.ValueBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.choiceList.ValueBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/12/11
 * Time: 2:21 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.choiceList.ValueBar');





dojo.declare('bfree.widget.choiceList.ValueBar', [dijit.Toolbar], {

    _btnAdd: null,
    _btnDown:null,
    _btnRemove: null,
    _btnUp: null,

    activeChoiceList: null,
    activeValue: null,
    disabled: false,
    grid: null,
    valueStore: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveChoiceListAttr: function(item){
        this.activeChoiceList = item;
        this._setState();
    },

    _setActiveValueAttr: function(item){
        this.activeValue = item;
        this._setState();
    },

    _setDisabledAttr: function(value){
        this.disabled = value;
        this._setState();
    },

    _setState: function(){

        if(this.disabled){
            this._btnAdd.set('disabled', this.disabled);
            this._btnUp.set('disabled', this.disabled);
            this._btnDown.set('disabled', this.disabled);
            this._btnRemove.set('disabled', this.disabled);
        }
        else{
            var isClNull = (this.activeChoiceList == null);
            var isVlNull = (this.activeValue == null);

            var idx = (this.activeValue) ?
                    this.activeValue.sort[0] :
                    0;

            var canAdd = true;
            var canMoveUp = (idx > 0);
            var canMoveDown = (idx < (this.grid.rowCount - 1));
            var canRemove = !(isClNull || isVlNull);

            this._btnAdd.set('disabled', !canAdd);
            this._btnUp.set('disabled', !canMoveUp);
            this._btnDown.set('disabled', !canMoveDown);
            this._btnRemove.set('disabled', !canRemove);
        }

    },


    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnAdd = new bfree.widget.Button({
            id: 'btnAddValue',
            label: 'Add Value to Choice List...',
            showLabel: false,
            disabled: true,
            iconClass: 'sidebarIcon bfreeIconAdd',
            disabledIconClass:'sidebarIcon bfreeIconAddD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.ADD)
        });
        this.addChild(this._btnAdd);

        this._btnUp = new bfree.widget.Button({
            id: 'btnValueUp',
            //'class': 'sidebarButton',
            label: 'Move Value up...',
            showLabel: false,
            disabled: true,
            iconClass: 'sidebarIcon bfreeIconUp',
            disabledIconClass:'sidebarIcon bfreeIconUpD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.MOVE_UP)
        });
        this.addChild(this._btnUp);

        this._btnDown = new bfree.widget.Button({
            id: 'btnValueDown',
            label: 'Move Value down...',
            showLabel: false,
            disabled: true,
            iconClass: 'sidebarIcon bfreeIconDown',
            disabledIconClass:'sidebarIcon bfreeIconDownD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.MOVE_DOWN)
        });
        this.addChild(this._btnDown);

        this._btnRemove = new bfree.widget.Button({
                id: 'btnRemoveValue',
                //'class': 'sidebarButton',
                label: 'Remove Value from Choice List...',
                showLabel: false,
                disabled: true,
                iconClass: 'sidebarIcon bfreeIconRemove',
                disabledIconClass: 'sidebarIcon bfreeIconRemoveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.REMOVE)
            });
        this.addChild(this._btnRemove);

    },

    startup: function(){
        this.inherited('startup', arguments);
        console.log('choicelist.ValuerBar > startup');

    }
});

}

if(!dojo._hasResource['bfree.widget.choiceList.values.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.choiceList.values.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/11/11
 * Time: 4:23 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.choiceList.values.Editor');










dojo.declare('bfree.widget.choiceList.values.Editor', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/choiceList/values", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoType=\"dijit.layout.ContentPane\"\n        style=\"padding:8px;overflow:hidden;\">\n\n<div dojoAttachPoint=\"formNode\">\n\n    <div dojoAttachPoint=\"tableNode\"></div>\n\n</div>\n\n</div>\n\n\n</div>\n"),
    widgetsInTemplate: true,

    valueStore: null,

    _form: null,
    _txtDisplay: null,
    _txtPrevious: null,
    _txtValue: null,

    _tblProperties: null,

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _txtDisplay_onChange: function(newValue){

        var display = this._txtPrevious.get('value');
        var value = this._txtValue.get('value');

        if(display == value && !this.dataType.isDateTime()){
            this._txtValue.set('value', newValue);
        }

        this._txtPrevious.set('value', newValue);
        this.onValueChange();
    },

    _txtValue_onChange: function(newValue){
        this.onValueChange();
    },

    constructor: function(args){

    },

    destroy: function(){
        this.destroyDescendants();

        if(this._txtPrevious){
            this._txtPrevious.destroy();
            this._txtPrevious = null;
        }

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._txtDisplay.setFocus();
    },

    isValid: function(){
        return this._form.isValid();
    },

    onDialogClosing: function(dlgResult){

        if(dlgResult == bfree.widget.Dialog.dialogResult.cancel){
            this.returnValue = null;
        }
        else{
            for(var i=0;i<this.valueStore._arrayOfAllItems.length;i++){
                if(this.valueStore._arrayOfAllItems[i]){
                    if(this.valueStore._arrayOfAllItems[i].id[0].toLowerCase().trim()==this._txtDisplay.get('value').toLowerCase().trim()){
                        alert("Display names must be unique");
                        return false;
                    }
                }
            }
            this.returnValue = new Object();
            this.returnValue['display'] = this._txtDisplay.get('value');
            this.returnValue['value'] = this._txtValue.get('value');
        }

        return true;
    },

    _txtDisplayValidator: function(newValue){
        if(this._txtDisplay){
            if(newValue==""){
                this._txtDisplay.set('invalidMessage', 'Display name cannot be blank');
                return false;
            }
            for(var i=0;i<this.valueStore._arrayOfAllItems.length;i++){
                if(this.valueStore._arrayOfAllItems[i]){
                    if(this.valueStore._arrayOfAllItems[i].id[0].toLowerCase().trim()==newValue.toLowerCase().trim()){
                        this._txtDisplay.set('invalidMessage', 'Display name must be unique');
                        return false;
                    }
                }
            }
        }
        return true;
    },

    onLoaded: function(){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'valueForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblValueProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._txtDisplay = new bfree.widget.ValidationTextBox({
            id: 'txtDisplay',
            label: 'Display Name',
            required: true,
            selectOnClick: true,
            intermediateChanges: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._txtDisplayValidator),
            onChange: dojo.hitch(this, this._txtDisplay_onChange)
        });
        this._tblProperties.addChild(this._txtDisplay);

        if(this.dataType.isDateTime()){
            this._txtValue = new bfree.widget.DateTextBox({
                id: 'txtValue',
                label: 'Value',
                required: true,
                selectOnClick: true,
                intermediateChanges: true,
                style: 'width:100%',
                onChange: dojo.hitch(this, this._txtValue_onChange)
            })
        }else{
            this._txtValue = new bfree.widget.ValidationTextBox({
                id: 'txtValue',
                label: 'Value',
                required: true,
                selectOnClick: true,
                intermediateChanges: true,
                style: 'width:100%',
                onChange: dojo.hitch(this, this._txtValue_onChange)
            });
        }
        this._tblProperties.addChild(this._txtValue);


        this._txtPrevious = new bfree.widget.ValidationTextBox({
            id: 'txtPrevious'
        });

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
        setTimeout(bfree.widget.choiceList.values.Editor._loadFnRef(this), 10);
    }


});

bfree.widget.choiceList.values.Editor._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.choiceList.values.Editor.show = function(args){

    var dlg = new bfree.widget.Dialog({
        id: 'dlgChoiceValues',
        title: 'Choice List Value...',
        widgetConstructor: bfree.widget.choiceList.values.Editor,
        widgetParams: {
            choiceList: args.choiceList,
            dataType: args.dataType,
            valueStore: args.valueStore
        },
        noResize: true,
        height: 128,
        width: 320,
        zIndex: 2048,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['bfree.widget.choiceList.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.choiceList.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/11/11
 * Time: 10:15 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.choiceList.Editor');















dojo.declare('bfree.widget.choiceList.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/choiceList", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        liveSplitters=\"true\"\n        style=\"width:100%;height:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"top\"\n            style=\"overflow:hidden;padding:0;height: 112px;\">\n\n         <div dojoAttachPoint=\"formNode\">\n\n            <div dojoAttachPoint=\"tableNode\"></div>\n\n        </div>\n\n        Users:\n    </div>\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            splitter=\"false\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"width:100%;height:100%\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\">\n\n            <div dojoAttachPoint=\"valueListNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"right\"\n                style=\"overflow:hidden;padding:16px 0 0 0;width:24px\">\n\n            <div dojoAttachPoint=\"valueBarNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"bottom\"\n            style=\"padding:0 8px 0 8px;height: 80px;\">\n\n        <div dojoAttachPoint=\"infoNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    activeItem: null,
    choiceLists: null,

    _handles: [],
    _cmbDataTypes: null,
    _cmdBar: null,
    _dataTypes: null,
    _form: null,
    _grdValues: null,
    _tblProperties: null,
    _txtName: null,
    _valueStore: null,
    _wdgInfo: null,

    __onValueDlgClose: function(dlgResult, retValue){

        var item = null;

        if(dlgResult == bfree.widget.Dialog.dialogResult.ok){

            try{
                this._grdValues.beginUpdate();
                item = this._valueStore.newItem({
                    sort: this._grdValues.rowCount,
                    id: retValue.display,
                    display: retValue.display,
                    value: retValue.value
                });

            }
            finally{
                this._grdValues.endUpdate();
            }

            if(item)
                this._grdValues.selectItem(item);

        }

        return true;
    },

    _cmbDataTypes_onChange: function(newValue){

         if((newValue == null) || newValue == '')
            return;

        var data_type_id = (newValue == null) ? -1 : parseInt(newValue);
        if(this.activeItem.data_type_id != data_type_id){
            this.choiceLists.setValue(this.activeItem, 'data_type_id', data_type_id);
            this.activeItem.choice_values = [];
            this._setStore();
        }

    },

    _grdValues_onSelectedItems: function(items){
        var item = null;
        if(dojo.isArray(items) && items.length > 0)
            item = items[0];

        this._cmdBar.set('activeValue', item);
    },

    _onValueChange: function(property, newValue){

        if(!this.activeItem)
            return;

        var oldValue = this.choiceLists.getValue(this.activeItem, property);
        if(oldValue != newValue){
            this.choiceLists.store.setValue(this.activeItem, property, newValue);
            this.onValueChange(this.activeItem, property, oldValue, newValue);
        }

    },

    _onValueCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.ADD:
                this._onValueAdd();
                break;
            case bfree.widget.Bfree.Commands.MOVE_UP:
                this._onValueUp();
                break;
            case bfree.widget.Bfree.Commands.MOVE_DOWN:
                this._onValueDown() ;
                break;
            case bfree.widget.Bfree.Commands.REMOVE:
                this._onValueRemove();
                break;
        }
    },

    _onValueAdd: function(){
        try{

            bfree.widget.choiceList.values.Editor.show({
                choiceList: this.activeItem,
                dataType: this._dataTypes.fetchById({id: this.activeItem.data_type_id}),
                valueStore: this._valueStore,
                onClose: dojo.hitch(this, this.__onValueDlgClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Choice List Values\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onValueCreated: function(newItem, parentInfo){

        this.activeItem.choice_values.push({
            sort_order: this._valueStore.getValue(newItem, 'sort'),
            name: this._valueStore.getValue(newItem, 'display'),
            value: this._valueStore.getValue(newItem, 'value')
        });
        this.onValueChange(this.activeItem, 'choice_values', [], this.activeItem.choice_values);

    },

    _onValueDeleted: function(deletedItem){

        for(var idx = 0; idx < this.activeItem.choice_values.length; idx++){
            var name =  this._valueStore.getIdentity(deletedItem);
            if(this.activeItem.choice_values[idx].name == name){
                this.activeItem.choice_values.splice(idx, 1);
                break;
            }
        }

        this.activeItem.choice_values.sort(bfree.api.ChoiceValue.compare);

        for(var i=0;i<this.activeItem.choice_values.length;i++){
            this.activeItem.choice_values[i].sort_order=i;
        }

        this.onValueChange(this.activeItem, 'choice_values', [], this.activeItem.choice_values);

    },

    _onValueDown: function(){
        var item = this._grdValues.selection.getFirstSelected();
        if(item){
            this._grdValues.moveItem(item, bfree.widget.SortGrid.move.DOWN);
        }
    },

    _onValueUp: function(){
        var item = this._grdValues.selection.getFirstSelected();
        if(item){
            this._grdValues.moveItem(item, bfree.widget.SortGrid.move.UP);
        }
    },

    _onValueRemove: function(){

        var idx = 0;

        try{

            this._grdValues.beginUpdate();
            var item = this._grdValues.selection.getFirstSelected();
            idx = this._grdValues.getItemIndex(item);
            this._valueStore.deleteItem(item);

            var props=this._valueStore._arrayOfTopLevelItems;
            props.sort(function(item1, item2){
                return item1.sort[0]-item2.sort[0];
            });

            for(var i=0;i<props.length;i++){
                if(props[i]){
                    this._valueStore.setValue(props[i], 'sort', i);
                }
            }

            this._valueStore.save();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to remove Value', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this._grdValues.endUpdate();
        }

        this._grdValues.setSelectedIndex(idx);
    },

    _onValueUpdated: function(item, property, oldValue, newValue){

        property = (property == 'sort') ? 'sort_order' : property;

        var name = this._valueStore.getIdentity(item);
        for(var i = 0; i < this.activeItem.choice_values.length; i++){
            //find item based on propdef id
            if(this.activeItem.choice_values[i].name == name){
                //update property
                if(this.activeItem.choice_values[i].hasOwnProperty(property)){
                    if(this.activeItem.choice_values[i][property] != newValue)
                        this.activeItem.choice_values[i][property] = newValue;
                }

            }
        }
        this.onValueChange(this.activeItem, 'choice_values', [], this.activeItem.choice_values);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        if(this.activeItem){
            this._txtName.set('value', this.activeItem.name);
            this._txtDescription.set('value', this.activeItem.description);
            this._cmbDataTypes.set('value', this.activeItem.data_type_id);
        }
        else{
            this._txtName.reset();
            this._txtDescription.reset();
            this._cmbDataTypes.reset();
        }

        this._cmdBar.set('activeChoiceList', this.activeItem);
        this._wdgInfo.set('activeItem', this.activeItem);

        this._setStore();
        this._setState();

    },


    _setState: function(){

        var isDirty = false;
        var isNew = false;

        if(this.activeItem ){
            isDirty = this.choiceLists.isDirty({item: this.activeItem});
            isNew = this.activeItem.isNew();
        }

        this._txtName.set('disabled', !isDirty);
        this._txtDescription.set('disabled', !isDirty);
        this._cmbDataTypes.set('disabled', !(isDirty && isNew));
        this._cmdBar.set('disabled', !isDirty);


    },

    _setStore: function(){

        var items = [];

        if(this.activeItem){
            dojo.forEach(this.activeItem.choice_values, function(item, idx){

                items.push({
                    sort: item.sort_order,
                    id: item.name,
                    display: item.name,
                    value: item.value
                });

            }, this);
        }

        dojo.forEach(this._handles, function(hndl, idx){
            dojo.disconnect(hndl);
            delete this._handles[idx];
        }, this);


        this._valueStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'display',
                items: items
            }
        });

        this._handles[0] = dojo.connect(this._valueStore, 'onNew', this, this._onValueCreated);
        this._handles[1] = dojo.connect(this._valueStore, 'onDelete', this, this._onValueDeleted);
        this._handles[2] = dojo.connect(this._valueStore, 'onSet', this, this._onValueUpdated);

        this._grdValues.setStore(this._valueStore);
        this._grdValues.resize();
        this._grdValues.setSelectedIndex(0);

    },

    _updateValues: function(){

        if(!this.activeItem)
            return;

        var choices = [];

        for(var i = 0; i < this._grdValues.rowCount; i++){
            var valueItem = this._grdValues.getItem(i);
            choices.push({
                sort_order: this._valueStore.getValue(valueItem, 'sort'),
                name: this._valueStore.getValue(valueItem, 'display'),
                value: this._valueStore.getValue(valueItem, 'value')
            });
        }


        this.choiceLists.store.setValue(this.activeItem, 'choice_values', choices);
        this.onValueChange(this.activeItem, 'choice_values', [], this.activeItem.choice_values);
    },

    constructor: function(args){

        this._valueStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'display',
                items: []
            }
        });

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._txtName.setFocus(true);
    },

    onValueChange: function(item, property, oldValue, newValue){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._dataTypes = bfree.api.Application.getDataTypes();

        this._form = new dijit.form.Form({
            id: 'propDefForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._txtName = new bfree.widget.ValidationTextBox({
            id: 'txtName',
            label: 'Name',
            selectOnClick: true,
            intermediateChanges: true,
            disabled: true,
            required: true,
            trim: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._txtNameValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'name')
        });
        this._tblProperties.addChild(this._txtName);

        this._txtDescription = new dijit.form.SimpleTextarea({
            label: 'Description',
            'class': 'bfree',
            disabled: true,
            rows: 2,
            style: 'resize:none;width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'description')
        });
        this._tblProperties.addChild(this._txtDescription);

        this._cmbDataTypes = new bfree.widget.FilteringSelect({
            label: 'Data Type',
            query: {allow_choice_list: true},
            disabled: true,
            required: true,
            style: 'width:100%',
            store: this._dataTypes.store,
            onChange: dojo.hitch(this, this._cmbDataTypes_onChange)
        });
        this._tblProperties.addChild(this._cmbDataTypes);

         this._grdValues = new bfree.widget.SortGrid({
             id: 'grdValues',
             'class': 'versaGridOutlineNoPad',
            query: {},
            noDataMessage: 'No Values Defined',
            store: this._valueStore,
            sort_field: 'sort',
            structure: bfree.widget.choiceList.Editor.view1,
            formatterScope: this,
            rowsPerPage: 1000,
            style: 'width:100%;height:100%',
            onSelectedItems: dojo.hitch(this, this._grdValues_onSelectedItems)
        }, this.valueListNode);

        this._cmdBar = new bfree.widget.choiceList.ValueBar({
            id: 'wdgValueBar',
            'class': 'versaSidebar',
            valueStore: this._valueStore,
            grid: this._grdValues,
            onCommand: dojo.hitch(this, this._onValueCommand)
        }, this.valueBarNode);

        this._wdgInfo = new bfree.widget.ObjectInfo({
            id: 'wdgChoiceListInfo1'
        }, this.infoNode);

        this._grdValues.startup();
    },

    _txtNameValidator: function(newValue){
        if(this._txtName){
            if(newValue.trim()==''){
                this._txtName.set('invalidMessage', 'Choice list name cannot be blank');
                return false;
            }
            var items=this.choiceLists.fetch();
            for(var i=0;i<items.length;i++){
                if(items[i].name&&
                   items[i].name.toLowerCase().trim()==newValue.toLowerCase().trim()&&
                   items[i].__id!=this.activeItem.__id){
                    this._txtName.set('invalidMessage', 'Duplicate choice list');
                    return false;
                }
            }
        }
        return true;
    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

bfree.widget.choiceList.Editor.valueFormatter=function(value){
    console.log(value);
    if(value instanceof Date){
        return bfree.api.Utilities.formatDate(value);
    }
    return value;
};

bfree.widget.choiceList.Editor.view1 = [
    {
        cells: [
            {
                field: 'sort',
                name: '&nbsp',
                width: '16px',
                hidden: true
            },
            {
                field: 'display',
                name: 'Displayed Value',
                width: '128px'
            },
            {
                field: 'value',
                name: 'Value',
                width: 'auto',
                formatter: bfree.widget.choiceList.Editor.valueFormatter
            }
        ],
        width: 'auto'
    }
];

}

if(!dojo._hasResource['bfree.widget.choiceList.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.choiceList.Administration'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.choiceList.Administration');





















dojo.declare('bfree.widget.choiceList.Administration', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget], {
    templateString: null,
    templateString: dojo.cache("bfree/widget/choiceList", "template/Administration.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n     <!-- Command Bar -->\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;height:27px\">\n\n        <div dojoAttachPoint=\"commandBarNode\"></div>\n\n    </div>\n\n     <div   dojoType=\"dijit.layout.BorderContainer\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"padding:8px;height:100%;width:100%\">\n\n\n         <div   dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"leading\"\n                style=\"padding:0 8px 0 0;width: 256px;\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"true\"\n                region=\"center\"\n                class=\"highlightPane\"\n                style=\"padding:8px\">\n\n            <div dojoAttachPoint=\"editorNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    activeUser: null,
    library: null,
    zone: null,

    _choiceLists: null,
    _cmdBar: null,
    _dataTypes: null,
    _editor: null,
    _grdChoiceLists: null,

    _grdChoiceLists_onSelectedItems: function(items){
        var item = null;

        if((items) && (items.length > 0))
            item = items[0];

        this._cmdBar.set('activeItem', item);
        this._editor.set('activeItem', item);
    },

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onCommand: function(cmdId, item){
        switch(cmdId){
            case bfree.widget.Bfree.Commands.NEW:
                this.createItem();
                break;
            case bfree.widget.Bfree.Commands.EDIT:
                this.editItem();
                break;
            case bfree.widget.Bfree.Commands.DELETE:
                this.deleteItem();
                break;
            case bfree.widget.Bfree.Commands.SAVE:
                this.save();
                break;
            case bfree.widget.Bfree.Commands.UNDO:
                this.undo();
                break;

        }
    },

    _onValueChange: function(item, property, oldValue, newValue){
        var idx = this._grdChoiceLists.getItemIndex(item);
        this._grdChoiceLists.updateRow(idx);
    },

    _validateItems: function(active){
        var valid = true;

		for(var idx = 0; idx < this._grdChoiceLists.rowCount; idx++){
            var item = this._grdChoiceLists.getItem(idx);
            if(this._choiceLists.isDirty({item: item})){
                if(!active||(active&&active.__id!=item.__id)){
                    var items=this._choiceLists.fetch();
                    for(var i=0;i<items.length;i++){
                        if(items[i].name&&
                           items[i].name.toLowerCase().trim()==item.name.toLowerCase().trim()&&
                           items[i].__id!=item.__id){
                            return false;
                        }
                    }
                    valid &= item.isValid();
                }
            }
		}

		return valid;
	},

    constructor: function(args){

    },

    createItem: function(){

        try{

            var uniqueName = this._choiceLists.generateUniqueName({base_name: 'Choice List'});
            var item = this._choiceLists.create({
                name: uniqueName,
                description: '',
                data_type_id: bfree.api.DataTypes.types.STRING,
                choice_values: [],
                created_by: this.activeUser.name,
                created_at: new Date(),
                updated_by: this.activeUser.name,
                updated_at: new Date()
            });
            this._grdChoiceLists.selectItem(item);
            this._editor.focus();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to create Choice List', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    deleteItem: function(){

        try{

            var item = this._grdChoiceLists.selection.getFirstSelected();
            if(item){
                if(!this._validateItems(item)){
                    var msg = 'Cannot delete Choice List: One or more Choice Lists contain invalid data';
                    alert(msg);
                    return;
                }

                var msg = dojo.replace('Are you sure you want to delete the Choice List: \'{0}\'?', [item.name]);
                if (!confirm(msg))
                    return;

                var idx = this._grdChoiceLists.getItemIndex(item);
                this._choiceLists.destroy({item: item});
                this._grdChoiceLists.setSelectedIndex(idx);
                this._editor.focus();
            }

        }
        catch(e){
           var err = new bfree.api.Error('Failed to delete Choice List', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    destroy: function(){

        this.destroyDescendants();

        if(this._editor){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    editItem: function(){

        try{

            var item = this._grdChoiceLists.selection.getFirstSelected();
            if(item){
                var idx = this._grdChoiceLists.getItemIndex(item);
                this._choiceLists.clone({item: item});
                this._grdChoiceLists.updateRow(idx);
                this._grdChoiceLists.setSelectedIndex(idx);
                this._editor.focus();
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to edit Choice List', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(this._choiceLists.isDirty()){
                var msg = 'You have unsaved changes that will be lost. Do you wish to continue?';
                if(confirm(msg)){
                    if(this._choiceLists != null)
                        this._choiceLists.revert();
                    canClose = true;
                }
            }
            else{
                canClose = true;
            }
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close Choice List Administration dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
		this.inherited('postCreate', arguments);

        this._dataTypes = bfree.api.Application.getDataTypes();

        //Retrieve choice lists and clear cache so grid retrieves latest from server
        this._choiceLists = this.library.getChoiceLists();
        this._choiceLists.clearCache();

		this._cmdBar = new bfree.widget.choiceList.CommandBar({
			choiceLists: this._choiceLists,
            onCommand: dojo.hitch(this, this._onCommand)
		}, this.commandBarNode);

        this._grdChoiceLists = new bfree.widget.choiceList.Grid({
            id: 'grdChoiceLists',
            'class': 'versaGridOutline versaNoHeader',
            noHeader: true,
            choiceLists: this._choiceLists,
            onSelectedItems: dojo.hitch(this, this._grdChoiceLists_onSelectedItems)
        }, this.gridNode);

        this._editor = new bfree.widget.choiceList.Editor({
            id: 'edtChoiceList',
            choiceLists: this._choiceLists,
            onValueChange: dojo.hitch(this, this._onValueChange)
        }, this.editorNode);

	},

    save: function(){
        try{

            if(!this._validateItems()){
                var msg = 'Cannot save Choice List changes: One or more Choice Lists contain invalid data';
                alert(msg);
                return;
            }

            var item = this._grdChoiceLists.selection.getFirstSelected();
            this._choiceLists.save({onComplete: dojo.hitch(this, this.saveOnComplete, item)});
        }
        catch(e){
            var err = new bfree.api.Error('Failed to save Choice List changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    saveOnComplete: function(item){
        this._choiceLists.clearCache();
        this._grdChoiceLists.sort();
        this._grdChoiceLists.selectItem(item);
    },

    startup: function(){
		this.inherited(arguments);

        this._grdChoiceLists.startup();
        this._grdChoiceLists.setSelectedIndex(0);

        setTimeout(bfree.widget.choiceList.Administration._loadFnRef(this), 10);
	},

    undo: function(){
        try{

            var item = this._grdChoiceLists.selection.getFirstSelected();
            this._choiceLists.clearCache();
            this._choiceLists.revert();

            if(item){
                var idx = this._grdChoiceLists.getItemIndex(item);
                this._grdChoiceLists.setSelectedIndex(idx);
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    }
	
});

bfree.widget.choiceList.Administration._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.choiceList.Administration.show = function(args){

     var dlg = new bfree.widget.Dialog({
        id: 'dlgChoiceLists',
        title:'Choice List',
        widgetConstructor: bfree.widget.choiceList.Administration,
        widgetParams: {
            activeUser: args.user,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 480,
        width: 640,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}


bfree.widget.choiceList.Administration.choiceValueGridLayout = [{
    cells: [
		{field: 'name', name: 'Displayed Value', width: '128px'},
		{field: 'value', name: 'Value', width: 'auto'},
		{field: 'sort_order', name: ' ', width: '64px', hidden: true}
	],
    noscroll: false,
    width: 'auto'
}];

}

if(!dojo._hasResource['bfree.widget.document.Accessor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.Accessor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/12/11
 * Time: 11:38 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.Accessor');

dojo.declare('bfree.widget.document.Accessor', null,{

    library: null,
    zone: null,

    constructor: function(args){
        this.library = args.library;
        this.zone = args.zone;
    },

    doCancelCheckout: function(document){
        try{
            document.cancelCheckout({zone: this.zone, library: this.library});
        }
        finally{
            // Tell the store to refresh item, NOT the best way to do this
            // OPTIONS:
            // - Incorporate actions into custom ServiceStore
            // - Use store 'EDIT' methods to automatically update store
            this.library.getDocuments().refreshItem(document.getId());
        }

    },

    doCheckout: function(document){
        try{
            document.checkout({zone: this.zone, library: this.library});
        }
        finally{
            // SEE notes in 'doCancelCheckout' on this.
            this.library.getDocuments().refreshItem(document.getId());
        }
    },

    doCopyLocal: function(document){
        document.copyLocal({zone: this.zone, library: this.library});
    },


    doRestore: function(document, save){

        try{
            //had to change back to this function because rails 'update' only works on non-deleted items
            document.restore({zone: this.zone, library: this.library});
            this.library.getDocuments().store.onDelete(document);
        }
        finally{
            // SEE notes in 'doCancelCheckout' on this.
            this.library.getDocuments().refreshItem(document.getId());
        }

    },

    doView: function(document){
        var box = bfree.api.Utilities.getBox({scale: 0.75});

        document.view({zone: this.zone, library: this.library, windowBox: box});
    }

});


}

if(!dojo._hasResource['bfree.widget.document.version.Accessor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.version.Accessor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/12/11
 * Time: 11:38 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.version.Accessor');

dojo.declare('bfree.widget.document.version.Accessor', null,{

    library: null,
    zone: null,

    constructor: function(args){
        this.library = args.library;
        this.zone = args.zone;
    },

    doCopyLocal: function(document, version){
        version.copyLocal({zone: this.zone, library: this.library, document: document});
    },

    doView: function(document, version){
        var box = bfree.api.Utilities.getBox({scale: 0.75});

        version.view({zone: this.zone, library: this.library, document: document, windowBox: box});
    }

});


}

if(!dojo._hasResource['bfree.api.ItemFileWriteStore']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.ItemFileWriteStore'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 10/11/11
 * Time: 3:35 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.ItemFileWriteStore');


dojo.declare('bfree.api.ItemFileWriteStore', [dojo.data.ItemFileWriteStore],{

    fetchItemById: function(id){
        var item = null;

         this.fetchItemByIdentity({
           identity: id,
           onItem: function(fndItem){ item = fndItem; }
        });

        return item;
    },

    generateUniqueId: function(){

        var _id = null;
        var isDup = true;

        do{
            _id = (new Date()).getTime();
            this.fetchItemByIdentity({
               identity: _id,
               onItem: function(item){ isDup = (item != null); }
           });
        }while(isDup);

        return _id;
    }

});

}

if(!dojo._hasResource['bfree.widget.BooleanSelect']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.BooleanSelect'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 22/11/11
 * Time: 11:15 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.BooleanSelect');




dojo.declare('bfree.widget.BooleanSelect', [bfree.widget.FilteringSelect],
{

	constructor: function(/*Object*/args){
        this.store = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: [
                    { id: 0, name: 'false' },
                    {id: 1, name: 'true' }
                ]
            }
        });
	},

	postCreate: function(){
		this.inherited('postCreate', arguments);
		this._setDisabledAttr(this.disabled);
	},

	_setDisabledAttr: function(val){
		this.inherited(arguments);

		var newClass = ((this.disabledIconClass != null) && (val)) ? this.disabledIconClass : this._iconClass;
		this.set('iconClass', newClass)
	}

});

}

if(!dojo._hasResource['bfree.widget.DateTextBox']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.DateTextBox'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 18/11/11
 * Time: 4:24 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.DateTextBox');


dojo.declare('bfree.widget.DateTextBox', [dijit.form.DateTextBox],
{

    postCreate: function(){
		this.inherited('postCreate', arguments);
	},

    reset: function(){
        this.inherited('reset', arguments);
        this._hasBeenBlurred = true;
    },

    startup: function(){
        this._hasBeenBlurred = true;
        this.inherited('startup', arguments);
        this.validate();
    }

});

}

if(!dojo._hasResource['bfree.widget.NumberSpinner']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.NumberSpinner'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 18/11/11
 * Time: 4:31 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.NumberSpinner');


dojo.declare('bfree.widget.NumberSpinner', [dijit.form.NumberSpinner],
{


    adjust: function(val, delta){
        var tc = this.constraints,
			v = isNaN(val),
			gotMax = !isNaN(tc.max),
			gotMin = !isNaN(tc.min)
		;
		if(v && delta != 0){ // blank or invalid value and they want to spin, so create defaults
			val = 0;
		}
		var newval = val + delta;
		if(v || isNaN(newval)){ return val; }
		if(gotMax && (newval > tc.max)){
			newval = tc.max;
		}
		if(gotMin && (newval < tc.min)){
			newval = tc.min;
		}
		return newval;
    },


    constructor: function(args){

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);
	},

    reset: function(){
        this.inherited('reset', arguments);
        this._hasBeenBlurred = true;
    },

    startup: function(){
        this._hasBeenBlurred = true;
        this.inherited('startup', arguments);
        this.validate();
    }

});

}

if(!dojo._hasResource["dijit.form.SimpleTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.SimpleTextarea"] = true;
dojo.provide("dijit.form.SimpleTextarea");



dojo.declare("dijit.form.SimpleTextarea",
	dijit.form.TextBox,
	{
	// summary:
	//		A simple textarea that degrades, and responds to
	// 		minimal LayoutContainer usage, and works with dijit.form.Form.
	//		Doesn't automatically size according to input, like Textarea.
	//
	// example:
	//	|	<textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
	//
	// example:
	//	|	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");

	baseClass: "dijitTextBox dijitTextArea",

	attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
		rows:"textbox", cols: "textbox"
	}),

	// rows: Number
	//		The number of rows of text.
	rows: "3",

	// rows: Number
	//		The number of characters per line.
	cols: "20",

	templateString: "<textarea ${!nameAttrSetting} dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

	postMixInProperties: function(){
		// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
		// TODO: parser will handle this in 2.0
		if(!this.value && this.srcNodeRef){
			this.value = this.srcNodeRef.value;
		}
		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(dojo.isIE && this.cols){ // attribute selectors is not supported in IE6
			dojo.addClass(this.textbox, "dijitTextAreaCols");
		}
	},

	filter: function(/*String*/ value){
		// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
		// as \r\n instead of just \n
		if(value){
			value = value.replace(/\r/g,"");
		}
		return this.inherited(arguments);
	},

	_previousValue: "",
	_onInput: function(/*Event?*/ e){
		// Override TextBox._onInput() to enforce maxLength restriction
		if(this.maxLength){
			var maxLength = parseInt(this.maxLength);
			var value = this.textbox.value.replace(/\r/g,'');
			var overflow = value.length - maxLength;
			if(overflow > 0){
				if(e){ dojo.stopEvent(e); }
				var textarea = this.textbox;
				if(textarea.selectionStart){
					var pos = textarea.selectionStart;
					var cr = 0;
					if(dojo.isOpera){
						cr = (this.textbox.value.substring(0,pos).match(/\r/g) || []).length;
					}
					this.textbox.value = value.substring(0,pos-overflow-cr)+value.substring(pos-cr);
					textarea.setSelectionRange(pos-overflow, pos-overflow);
				}else if(dojo.doc.selection){ //IE
					textarea.focus();
					var range = dojo.doc.selection.createRange();
					// delete overflow characters
					range.moveStart("character", -overflow);
					range.text = '';
					// show cursor
					range.select();
				}
			}
			this._previousValue = this.textbox.value;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource['bfree.widget.propdef.Widget']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.Widget'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/11/11
 * Time: 4:54 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.Widget');










dojo.declare('bfree.widget.propdef.Widget', null,{
});

bfree.widget.propdef.Widget.generateWdgName = function(name){
    return dojo.replace('wdg_{0}', [name]);
};
bfree.widget.propdef.Widget.resolveWdgName = function(wdgName){
    return wdgName.replace('wdg_', '');
};

bfree.widget.propdef.Widget.formats = {'SHORT': 0x00, 'LONG': 0x01}
bfree.widget.propdef.Widget.getWidget = function(dataType, wdgId, label, format, defaultValue, maxLength){
    var wdg = null;

    if(dataType.isString() || ((dataType.isText()) && (format == bfree.widget.propdef.Widget.formats.SHORT))){
        wdg = new bfree.widget.ValidationTextBox({
            id: wdgId,
            intermediateChanges: true,
            label: label,
            scrollOnFocus: false,
            selectOnClick: true,
            style: 'width:100%',
            value: defaultValue,
            maxLength: maxLength
        });
    }
    else if(dataType.isDateTime()){
        wdg = new bfree.widget.DateTextBox({
            id: wdgId,
            label: label,
            scrollOnFocus: false,
            selectOnClick: true,
            style: 'width:100%',
            value: defaultValue
        });
    }
    else if(dataType.isText()){
        wdg = new dijit.form.SimpleTextarea({
            id: wdgId,
            intermediateChanges: true,
            label: label,
            'class': 'bfree',
            scrollOnFocus: false,
            selectOnClick: true,
            style: 'resize:none;width:100%',
            value: defaultValue,
            maxLength: maxLength
        });

    }
    else if((dataType.isBoolean()) && ((!format) || (format == bfree.widget.propdef.Widget.formats.SHORT))){

        wdg = new dijit.form.CheckBox({
            id: wdgId,
            label: label,
            scrollOnFocus: false,
            checked: defaultValue
        });
    }
    else if((dataType.isBoolean()) && (format == bfree.widget.propdef.Widget.formats.LONG)){
        wdg = new bfree.widget.BooleanSelect({
            id: wdgId,
            label: label,
            scrollOnFocus: false,
            style: 'width:100%',
            value: defaultValue
        });
    }
    else if(dataType.isInteger()){
        wdg = new bfree.widget.NumberSpinner({
            id: wdgId,
            label: label,
            smallDelta: 1,
            largeDelta:10,
            constraints: { fractional: false, min: -2147483648, max: 2147483647 },
            scrollOnFocus: false,
            selectOnClick: true,
            style: 'width:100%',
            value: defaultValue?defaultValue:0
        });
    }
    else if(dataType.isFloat()){
        wdg = new bfree.widget.NumberSpinner({
            id: wdgId,
            label: label,
            smallDelta: 1,
            largeDelta:10,
            constraints: { places: '0,4' },
            scrollOnFocus: false,
            selectOnClick: true,
            style: 'width:100%',
            value: defaultValue?defaultValue:0
        });
    }

    return wdg;
}

bfree.widget.propdef.Widget.getChoiceListWidget = function(wdgId, label, choiceList, showNone){
    var wdg = null;
    var valueStore = bfree.widget.propdef.Widget.generateStore(choiceList, showNone);

    wdg = new bfree.widget.FilteringSelect({
        id: wdgId,
        label: label,
        query: {},
        store: valueStore,
        scrollOnFocus: false,
        searchAttr: 'display'
    });

    return wdg;
}

bfree.widget.propdef.Widget.generate = function(propertyMapping, propertyDefinition, choiceList){

    var wdg = null;
    var dataTypes = bfree.api.Application.getDataTypes();
    var dataType = dataTypes.fetchById({id: propertyDefinition.data_type_id});
    var id = bfree.widget.propdef.Widget.generateWdgName(propertyDefinition.getDbName());

    if(choiceList){
        wdg = bfree.widget.propdef.Widget.getChoiceListWidget(id, propertyDefinition.name, choiceList);
    }
    else{
        wdg = bfree.widget.propdef.Widget.getWidget(dataType, id, propertyDefinition.name, bfree.widget.propdef.Widget.formats.LONG, propertyMapping.default_value, propertyDefinition.max_length);
    }

    wdg.set('required', propertyMapping.is_required);
//    if(dataType.isFloat()||dataType.isInteger()){
//        wdg.set('value', propertyMapping.default_value?propertyMapping.default_value:0);
//    }


    return wdg;
}

bfree.widget.propdef.Widget.generateStore = function(choiceList, showNone){
    var items = [];

    if(showNone){
        items.push({
            id: null,
            display: 'None'
        });
    }

    dojo.forEach(choiceList.choice_values, function(item, idx){
        items.push({
            id: item.value,
            display: item.name
        });
    }, this);

    return new bfree.api.ItemFileWriteStore({
        data: {
            identifier: 'id',
            label: 'display',
            items: items
        }
    });
}

}

if(!dojo._hasResource['bfree.widget.doctype.properties.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.properties.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/11/11
 * Time: 2:00 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.properties.Editor');









dojo.declare('bfree.widget.doctype.properties.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/doctype/properties", "template/Editor.html", "<div style=\"padding:0 8px 0 0;height:100%;width:100%\">\n\n    <div dojoAttachPoint=\"tableNode\"></div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _tblProperties: null,

    activeItem: null,
    choiceLists: null,
    propertyDefinitions: null,

    _onChange: function(id, newValue){
        this.onValueChange(bfree.widget.propdef.Widget.resolveWdgName(id), newValue);
    },

    _setActiveItemAttr: function(item){

        this.activeItem = item;

        dojo.forEach(this.activeItem.property_mappings, function(item, idx){

            var propertyDefinition = this.propertyDefinitions.fetchById({id: item.property_definition_id});
            var wdg = null;
            var choiceList = null;
            if(item.choice_list_id){
                choiceList = this.choiceLists.fetchById({id: item.choice_list_id });
            }
            wdg = bfree.widget.propdef.Widget.generate(item, propertyDefinition, choiceList);

            if(wdg){
                this._tblProperties.addChild(wdg);
                wdg.onChange = dojo.hitch(this, this._onChange, wdg.id);
            }

        }, this);

       this._tblProperties.refresh();
       this.onLoaded();
    },

    _setDisabledAttr: function(is_disabled){
        this._tblProperties.set('disabled', is_disabled);

        var widgets = this._tblProperties.getChildren();
        dojo.forEach(widgets, function(widget,idx){
            widget.set('disabled', is_disabled)
        }, this);

    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._tblProperties){
            this._tblProperties.destroyDescendants();
            this._tblProperties.destroy();
            this._tblProperties = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){

    },

    onLoaded: function(){
    },

    onValueChange: function(id, value){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 88,
            style: 'width:100%'
        }, this.tableNode);

    },


    setValue: function(property, value){

        var wdgName = bfree.widget.propdef.Widget.generateWdgName(property);
        var wdg = dijit.byId(wdgName);
        if(wdg){
            if(wdg.declaredClass=="bfree.widget.NumberSpinner"){
                wdg.set('value', value?value:0);
            }else{
                wdg.set('value', value);
            }
        }

    },

    setValues: function(item){
        for(var propName in item){
            var uniqueName = dojo.replace('documents.{0}', [propName]);
            this.setValue(uniqueName, item[propName]);
        }
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }

});

}

if(!dojo._hasResource['bfree.widget.doctype.InstanceEditor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.InstanceEditor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/11/11
 * Time: 11:08 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.InstanceEditor');








dojo.declare('bfree.widget.doctype.InstanceEditor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/doctype", "template/InstanceEditor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        liveSplitters=\"true\"\n        style=\"height:100%;width:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"top\"\n            style=\"padding:8px 0 8px 0;height:24px;\">\n\n        <div dojoAttachPoint=\"tableNode\"></div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"center\"\n            class=\"highlightPane\">\n\n        <div dojoAttachPoint=\"editorNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _cmbDocTypes:  null,
    _propertyEditor: null,

    activeItem: null,
    choiceLists: null,
    disabled: false,
    documentTypes: null,
    propertyDefinitions: null,
    disableDocumentType: false,

    _onChange: function(newValue){

        if(String.isBlank(newValue)){
            this.activeItem = null;
        }
        else{
            this.activeItem = this.documentTypes.fetchById({id: newValue});
        }

        if(this._propertyEditor){
           this._propertyEditor.destroy();
           this._propertyEditor = null;
        }
        this._propertyEditor = new bfree.widget.doctype.properties.Editor({
            id: 'propertyEditor1',
            choiceLists: this.choiceLists,
            propertyDefinitions: this.propertyDefinitions,
            onLoaded: dojo.hitch(this, this._onLoaded),
            onValueChange: dojo.hitch(this, this._onValueChange)
        });

        this._propertyEditor.placeAt(this.editorNode);
        if(this.activeItem)
            this._propertyEditor.set('activeItem', this.activeItem);
        this._propertyEditor.set('disabled', this.disabled);

        this.onChange(this.activeItem);
    },

    _onLoaded: function(){
        this.onChange(this.activeItem);
    },

    _onValueChange: function(id, value){
        this.onValueChange(id, value);
    },

    _setActiveItemAttr: function(item){
        this._cmbDocTypes.reset();
        this.activeItem = item;
        this._cmbDocTypes.set('value', item.id);
        this._cmbDocTypes.set('disabled', (this.activeItem == null)||this.disableDocumentType);
    },

    _setDisabledAttr: function(value){
        this.disabled = value;

        this._cmbDocTypes.set('disabled', this.disabled||this.disableDocumentType);

        if(this._propertyEditor)
            this._propertyEditor.set('disabled', this.disabled);
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._tblProperties){
            this._tblProperties.destroyDescendants();
            this._tblProperties.destroy();
            this._tblProperties = null;
        }

        if(this._propertyEditor){
            this._propertyEditor.destroy();
            this._propertyEditor = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){

    },

    onChange: function(){

    },

    onValueChange: function(){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblDocTypes1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 88,
            style: 'width:100%'
        }, this.tableNode);

        this._cmbDocTypes = new dijit.form.FilteringSelect({
            id: 'cmbDocTypes',
            label: 'Document Type',
            store: this.documentTypes.store,
            searchAttr: 'name',
            disabled: true,
            onChange: dojo.hitch(this, this._onChange)
        });
        this._tblProperties.addChild(this._cmbDocTypes);

    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    setValues: function(item){
        this._propertyEditor.setValues(item);
    },

    startup: function(){
        this.inherited('startup', arguments);
    }

});

}

if(!dojo._hasResource['bfree.widget.document.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/11/11
 * Time: 11:02 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.Editor');









dojo.declare('bfree.widget.document.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/document", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"padding:0;height:100%;width:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"center\"\n            style=\"padding:0 8px 8px 8px\">\n\n        <div dojoAttachPoint=\"docTypeEditorNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,
    disableDocumentType: false,

    _choiceLists: null,
    _documentTypes: null,
    _docTypeEditor: null,
    _propertyDefinitions: null,

    activeItem: null,
    library: null,

    _btnAdd_onClick: function(evt){
        this.onSubmit();
    },

    _docTypeEditor_onChange: function(documentType){
        var state = this.activeItem.state;

        if(documentType){
            if(documentType.id != this.activeItem.document_type_id){
//                this.activeItem.document_type_id = documentType.id;
//                this.activeItem.document_type_name = documentType.name;
//                this.onValueChange('document_type_id', documentType.id);
//                this.onValueChange('document_type_name', documentType.name);

                this._docTypeEditor_onValueChange('document_type_id', documentType.id);
                this._docTypeEditor_onValueChange('document_type_name', documentType.name);

                dojo.forEach(documentType.property_mappings, function(item, idx){

                    var propertyDefinition = this._propertyDefinitions.fetchById({id: item.property_definition_id});
                    var def=bfree.api.PropertyMappings.getDefault(item, this._propertyDefinitions);

                    if(this.activeItem.isNew()){
                        if((propertyDefinition.isTypeAnyNumber())&&
                           !propertyDefinition.is_system){
                                this._docTypeEditor_onValueChange(propertyDefinition.column_name, 0);
                        }

                        //if item is not system
                        if(def){
                            this._docTypeEditor_onValueChange(propertyDefinition.column_name, def);
                        }
                    }else{
                        var value=this.library.getDocuments().getValue(this.activeItem);

                        if(!value&&item.default_value){
                            if(def){
                                this._docTypeEditor_onValueChange(propertyDefinition.column_name, def);
                            }
                        }
                    }

                    if(item.choice_list_id){
                        if(def){
                            this._docTypeEditor_onValueChange(propertyDefinition.column_name, def);
                        }else{
                            this._docTypeEditor_onValueChange(propertyDefinition.column_name, '');
                        }
                    }
                }, this);

                this.activeItem.validate({library: this.library});
            }

            this._docTypeEditor.setValues(this.activeItem);
        }else{
            this.activeItem.document_type_id = null;
            this.activeItem.validate({library: this.library});
        }

//        if(state != this.activeItem.state)
        this.onValidChange(this.activeItem);
    },

    _docTypeEditor_onValueChange: function(id, value){

        this.onValueChange(id, value);

    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        if(this.activeItem){

            var document_type = this._documentTypes.fetchById({id:item.document_type_id});

//            var isDisabled = this.activeItem.getState(bfree.api.Document.states.CHECKED_IN) ||

            var isDisabled = this.activeItem.getState(bfree.api.Document.states.ERROR);

            this._docTypeEditor.set('activeItem', document_type);
            this._docTypeEditor.set('disabled', isDisabled);
        }
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._docTypeEditor){
            this._docTypeEditor.destroy();
            this._docTypeEditor = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){

    },

    onSubmit: function(){

    },

    onValidChange: function(item){

    },

    onValueChange: function(id, value){
        var property_id = id.replace('documents.', '');
        if(this.activeItem[property_id] != value){
            var state = this.activeItem.state;
            this.activeItem[property_id] = value;
            this.onValueChange(property_id, value);

            this.activeItem.validate({library: this.library});
//            if(state != this.activeItem.state)
            this.onValidChange(this.activeItem);
        }
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._documentTypes = this.library.getDocumentTypes();
        this._documentTypes.refresh();

        this._propertyDefinitions = this.library.getPropertyDefinitions();
        this._propertyDefinitions.refresh();

        this._choiceLists = this.library.getChoiceLists();
        this._choiceLists.refresh();

        this._docTypeEditor = new bfree.widget.doctype.InstanceEditor({
            id: 'doctypeeditor1',
            choiceLists: this._choiceLists,
            documentTypes: this._documentTypes,
            propertyDefinitions: this._propertyDefinitions,
            disableDocumentType: this.disableDocumentType,
            onChange: dojo.hitch(this, this._docTypeEditor_onChange),
            onValueChange: dojo.hitch(this, this._docTypeEditor_onValueChange)
        }, this.docTypeEditorNode);

    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
    }

});

}

if(!dojo._hasResource["dojox.embed.Flash"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.embed.Flash"] = true;
dojo.provide("dojox.embed.Flash");

(function(){
	/*******************************************************
		dojox.embed.Flash

		Base functionality to insert a flash movie into
		a document on the fly.

		Usage:
		var movie=new dojox.embed.Flash({ args }, containerNode);
	 ******************************************************/
	var fMarkup, fVersion;
	var minimumVersion = 9; // anything below this will throw an error (may overwrite)
	var keyBase = "dojox-embed-flash-", keyCount=0;
	var _baseKwArgs = {
		expressInstall: false,
		width: 320,
		height: 240,
		swLiveConnect: "true",
		allowScriptAccess: "sameDomain",
		allowNetworking:"all",
		style: null,
		redirect: null
	};

	function prep(kwArgs){
		// console.warn("KWARGS:", kwArgs)
		kwArgs = dojo.delegate(_baseKwArgs, kwArgs);

		if(!("path" in kwArgs)){
			console.error("dojox.embed.Flash(ctor):: no path reference to a Flash movie was provided.");
			return null;
		}

		if(!("id" in kwArgs)){
			kwArgs.id = (keyBase + keyCount++);
		}
		return kwArgs;
	}

	if(dojo.isIE){
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }

			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(p + '=' + kwArgs.vars[p]);
				}
				kwArgs.params.FlashVars = a.join("&");
				delete kwArgs.vars;
			}
			// FIXME: really? +'s?
			var s = '<object id="' + kwArgs.id + '" '
				+ 'classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" '
				+ 'width="' + kwArgs.width + '" '
				+ 'height="' + kwArgs.height + '"'
				+ ((kwArgs.style)?' style="' + kwArgs.style + '"':'')
				+ '>'
				+ '<param name="movie" value="' + path + '" />';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += '<param name="' + p + '" value="' + kwArgs.params[p] + '" />';
				}
			}
			s += '</object>';
			return { id: kwArgs.id, markup: s };
		};

		fVersion = (function(){
			var testVersion = 10, testObj = null;
			while(!testObj && testVersion > 7){
				try {
					testObj = new ActiveXObject("ShockwaveFlash.ShockwaveFlash." + testVersion--);
				}catch(e){ }
			}
			if(testObj){
				var v = testObj.GetVariable("$version").split(" ")[1].split(",");
				return {
					major: (v[0]!=null) ? parseInt(v[0]) : 0,
					minor: (v[1]!=null) ? parseInt(v[1]) : 0,
					rev: (v[2]!=null) ? parseInt(v[2]) : 0
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();

		//	attach some cleanup for IE, thanks to deconcept :)
		dojo.addOnUnload(function(){
			var dummy = function(){};
			var objs = dojo.query("object").
				reverse().
				style("display", "none").
				forEach(function(i){
					for(var p in i){
						if((p != "FlashVars") && dojo.isFunction(i[p])){
							try{
								i[p] = dummy;
							}catch(e){}
						}
					}
				});
		});

		//	TODO: ...and double check this fix; is IE really firing onbeforeunload with any kind of href="#" link?
		/*
		var beforeUnloadHandle = dojo.connect(dojo.global, "onbeforeunload", function(){
			try{
				if(__flash_unloadHandler){ __flash_unloadHandler=function(){ }; }
				if(__flash_savedUnloadHandler){ __flash_savedUnloadHandler=function(){ }; }
			} catch(e){ }
			dojo.disconnect(beforeUnloadHandle);
		});
		*/
	} else {
		//	*** Sane browsers branch ******************************************************************
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }

			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(p + '=' + kwArgs.vars[p]);
				}
				kwArgs.params.flashVars = a.join("&");
				delete kwArgs.vars;
			}
			var s = '<embed type="application/x-shockwave-flash" '
				+ 'src="' + path + '" '
				+ 'id="' + kwArgs.id + '" '
				+ 'width="' + kwArgs.width + '" '
				+ 'height="' + kwArgs.height + '"'
				+ ((kwArgs.style)?' style="' + kwArgs.style + '" ':'')

				+ 'pluginspage="' + window.location.protocol + '//www.adobe.com/go/getflashplayer" ';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += ' ' + p + '="' + kwArgs.params[p] + '"';
				}
			}
			s += ' />';
			return { id: kwArgs.id, markup: s };
		};

		fVersion=(function(){
			var plugin = navigator.plugins["Shockwave Flash"];
			if(plugin && plugin.description){
				var v = plugin.description.replace(/([a-zA-Z]|\s)+/, "").replace(/(\s+r|\s+b[0-9]+)/, ".").split(".");
				return {
					major: (v[0]!=null) ? parseInt(v[0]) : 0,
					minor: (v[1]!=null) ? parseInt(v[1]) : 0,
					rev: (v[2]!=null) ? parseInt(v[2]) : 0
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();
	}


/*=====
dojox.embed.__flashArgs = function(path, id, width, height, style, params, vars, expressInstall, redirect){
	//	path: String
	//		The URL of the movie to embed.
	//	id: String?
	//		A unique key that will be used as the id of the created markup.  If you don't
	//		provide this, a unique key will be generated.
	//	width: Number?
	//		The width of the embedded movie; the default value is 320px.
	//	height: Number?
	//		The height of the embedded movie; the default value is 240px
	//	minimumVersion: Number ?
	//		The minimum targeted version of the Flash Player (defaults to 9)
	//	style: String?
	//		Any CSS style information (i.e. style="background-color:transparent") you want
	//		to define on the markup.
	//	params: Object?
	//		A set of key/value pairs that you want to define in the resultant markup.
	//	vars: Object?
	//		A set of key/value pairs that the Flash movie will interpret as FlashVars.
	//	expressInstall: Boolean?
	//		Whether or not to include any kind of expressInstall info. Default is false.
	//	redirect: String?
	//		A url to redirect the browser to if the current Flash version is not supported.
	this.id=id;
	this.path=path;
	this.width=width;
	this.minimumVersion=minimumVersion;
	this.height=height;
	this.style=style;
	this.params=params;
	this.vars=vars;
	this.expressInstall=expressInstall;
	this.redirect=redirect;
}
=====*/

	//	the main entry point
	dojox.embed.Flash = function(/*dojox.embed.__flashArgs*/ kwArgs, /*DOMNode*/ node){
		//	summary:
		//		Create a wrapper object around a Flash movie; this is the DojoX equivilent
		//		to SWFObject.
		//
		//	description:
		//		Creates a wrapper object around a Flash movie.  Wrapper object will
		//		insert the movie reference in node; when the browser first starts
		//		grabbing the movie, onReady will be fired; when the movie has finished
		//		loading, it will fire onLoad.
		//
		//		If your movie uses ExternalInterface, you should use the onLoad event
		//		to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
		//		to be the only consistent time calling EI methods are stable (since the
		//		Flash movie will shoot several methods into the window object before
		//		EI callbacks can be used properly).
		//
		//		*Important note*:  this code includes a workaround for the Eolas "fix" from
		//		Microsoft; in order to work around the "click to activate this control" message
		//		on any embedded Flash movie, this code will load a separate, non-dojo.require
		//		javascript file in order to write the Flash movie into the document.  As such
		//		it cannot be used with Dojo's scope map techniques for working with multiple
		//		versions of Dojo on the same page.
		//
		//	kwArgs: dojox.embed.__flashArgs
		//		The various arguments that will be used to help define the Flash movie.
		//	node: DomNode
		//		The node where the embed object will be placed
		//
		//	example:
		//		Embed a flash movie in a document using the new operator, and get a reference to it.
		//	|	var movie = new dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300
		//	|	}, myWrapperNode, "testLoaded");
		//
		//	example:
		//		Embed a flash movie in a document without using the new operator.
		//	|	var movie = dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300,
		//	|		style: "position:absolute;top:0;left:0"
		//	|	}, myWrapperNode, "testLoaded");
		//
		// File can only be run from a server, due to SWF dependency.
		if(location.href.toLowerCase().indexOf("file://")>-1){
			throw new Error("dojox.embed.Flash can't be run directly from a file. To instatiate the required SWF correctly it must be run from a server, like localHost.");
		}

		//	available: Number
		//		If there is a flash player available, and if so what version.
		this.available = dojox.embed.Flash.available;

		//	minimumVersion: Number
		//		The minimum version of Flash required to run this movie.
		this.minimumVersion = kwArgs.minimumVersion || minimumVersion;
		//console.log("AVAILABLE:", this);

		//	id: String
		//		The id of the DOMNode to be used for this movie.  Can be used with dojo.byId to get a reference.
		this.id = null;

		//	movie: FlashObject
		//		A reference to the movie itself.
		this.movie = null;

		//	domNode: DOMNode
		//		A reference to the DOMNode that contains this movie.
		this.domNode = null;
		if(node){
			node = dojo.byId(node);
		}
		// setTimeout Fixes #8743 - creating double SWFs
		// also allows time for code to attach to onError
		setTimeout(dojo.hitch(this, function(){
			if(kwArgs.expressInstall || this.available && this.available >= this.minimumVersion){
				if(kwArgs && node){
					this.init(kwArgs, node);
				}else{
					this.onError("embed.Flash was not provided with the proper arguments.");
				}
			}else{
				if(!this.available){
					this.onError("Flash is not installed.");
				}else{
					this.onError("Flash version detected: "+this.available+" is out of date. Minimum required: "+this.minimumVersion);
				}
			}
		}), 100);
	};

	dojo.extend(dojox.embed.Flash, {
		onReady: function(/*HTMLObject*/ movie){
			console.warn("embed.Flash.movie.onReady:", movie)
			//	summary:
			//		Stub function for you to attach to when the movie reference is first
			//		pushed into the document.
		},
		onLoad: function(/*HTMLObject*/ movie){
			console.warn("embed.Flash.movie.onLoad:", movie)
			//	summary:
			//		Stub function for you to attach to when the movie has finished downloading
			//		and is ready to be manipulated.
		},
		onError: function(msg){

		},
		_onload: function(){
			// summary:
			//	Internal. Cleans up before calling onLoad.
			clearInterval(this._poller);
			delete this._poller;
			delete this._pollCount;
			delete this._pollMax;
			this.onLoad(this.movie);
		},
		init: function(/*dojox.embed.__flashArgs*/ kwArgs, /*DOMNode?*/ node){
			console.log("embed.Flash.movie.init")
			//	summary
			//		Initialize (i.e. place and load) the movie based on kwArgs.
			this.destroy();		//	ensure we are clean first.
			node = dojo.byId(node || this.domNode);
			if(!node){ throw new Error("dojox.embed.Flash: no domNode reference has been passed."); }

			// vars to help determine load status
			var p = 0, testLoaded=false;
			this._poller = null; this._pollCount = 0; this._pollMax = 15; this.pollTime = 100;

			if(dojox.embed.Flash.initialized){

				this.id = dojox.embed.Flash.place(kwArgs, node);
				this.domNode = node;

				setTimeout(dojo.hitch(this, function(){
					this.movie = this.byId(this.id, kwArgs.doc);
					this.onReady(this.movie);

					this._poller = setInterval(dojo.hitch(this, function(){

						// catch errors if not quite ready.
						try{
							p = this.movie.PercentLoaded();
						}catch(e){
							/* squelch */
							console.warn("this.movie.PercentLoaded() failed");
						}

						if(p == 100){
							// if percent = 100, movie is fully loaded and we're communicating
							this._onload();

						}else if(p==0 && this._pollCount++ > this._pollMax){
							// after several attempts, we're not past zero.
							// FIXME: What if we get stuck on 33% or something?
							clearInterval(this._poller);
							throw new Error("Building SWF failed.");
						}
					}), this.pollTime);
				}), 1);
			}
		},
		_destroy: function(){
			//	summary
			//		Kill the movie and reset all the properties of this object.
			try{
				this.domNode.removeChild(this.movie);
			}catch(e){}
			this.id = this.movie = this.domNode = null;
		},
		destroy: function(){
			//	summary
			//		Public interface for destroying all the properties in this object.
			//		Will also clean all proxied methods.
			if(!this.movie){ return; }

			//	remove any proxy functions
			var test = dojo.delegate({
				id: true,
				movie: true,
				domNode: true,
				onReady: true,
				onLoad: true
			});
			for(var p in this){
				if(!test[p]){
					delete this[p];
				}
			}

			//	poll the movie
			if(this._poller){
				//	wait until onLoad to destroy
				dojo.connect(this, "onLoad", this, "_destroy");
			} else {
				this._destroy();
			}
		},
		byId: function (movieName, doc){
			// 	summary:
			//		Gets Flash movie by id.
			//	description:
			//		Probably includes methods for outdated
			//		browsers, but this should catch all cases.
			// arguments:
			//		movieName: String
			//			The name of the SWF
			//		doc: Object
			//			The document, if not current window
			//			(not fully supported)
			//	example:
			//	| var movie = dojox.embed.Flash.byId("myId");
			//
			doc = doc || document;
			if(doc.embeds[movieName]){
				return doc.embeds[movieName];
			}
			if(doc[movieName]){
				return doc[movieName];
			}
			if(window[movieName]){
				return window[movieName];
			}
			if(document[movieName]){
				return document[movieName];
			}
			return null;
		}
	});

	//	expose information through the constructor function itself.
	dojo.mixin(dojox.embed.Flash, {
		//	summary:
		//		A singleton object used internally to get information
		//		about the Flash player available in a browser, and
		//		as the factory for generating and placing markup in a
		//		document.
		//
		//	minSupported: Number
		//		The minimum supported version of the Flash Player, defaults to 8.
		//	available: Number
		//		Used as both a detection (i.e. if(dojox.embed.Flash.available){ })
		//		and as a variable holding the major version of the player installed.
		//	supported: Boolean
		//		Whether or not the Flash Player installed is supported by dojox.embed.
		//	version: Object
		//		The version of the installed Flash Player; takes the form of
		//		{ major, minor, rev }.  To get the major version, you'd do this:
		//		var v=dojox.embed.Flash.version.major;
		//	initialized: Boolean
		//		Whether or not the Flash engine is available for use.
		//	onInitialize: Function
		//		A stub you can connect to if you are looking to fire code when the
		//		engine becomes available.  A note: DO NOT use this event to
		//		place a movie in a document; it will usually fire before DOMContentLoaded
		//		is fired, and you will get an error.  Use dojo.addOnLoad instead.
		minSupported : 8,
		available: fVersion.major,
		supported: (fVersion.major >= fVersion.required),
		minimumRequired: fVersion.required,
		version: fVersion,
		initialized: false,
		onInitialize: function(){
			dojox.embed.Flash.initialized = true;
		},
		__ie_markup__: function(kwArgs){
			return fMarkup(kwArgs);
		},
		proxy: function(/*dojox.embed.Flash*/ obj, /*Array|String*/ methods){
			//	summary:
			//		Create the set of passed methods on the dojox.embed.Flash object
			//		so that you can call that object directly, as opposed to having to
			//		delve into the internal movie to do this.  Intended to make working
			//		with Flash movies that use ExternalInterface much easier to use.
			//
			//	example:
			//		Create "setMessage" and "getMessage" methods on foo.
			//	|	var foo = new dojox.embed.Flash(args, someNode);
			//	|	dojo.connect(foo, "onLoad", dojo.hitch(foo, function(){
			//	|		dojox.embed.Flash.proxy(this, [ "setMessage", "getMessage" ]);
			//	|		this.setMessage("dojox.embed.Flash.proxy is pretty cool...");
			//	|		console.log(this.getMessage());
			//	|	}));
			dojo.forEach((dojo.isArray(methods) ? methods : [ methods ]), function(item){
				this[item] = dojo.hitch(this, function(){
					return (function(){
						return eval(this.movie.CallFunction(
							'<invoke name="' + item + '" returntype="javascript">'
							+ '<arguments>'
							+ dojo.map(arguments, function(item){
								// FIXME:
								//		investigate if __flash__toXML will
								//		accept direct application via map()
								//		(e.g., does it ignore args past the
								//		first? or does it blow up?)
								return __flash__toXML(item);
							}).join("")
							+ '</arguments>'
							+ '</invoke>'
						));
					}).apply(this, arguments||[]);
				});
			}, obj);
		}
	});

	/*if(dojo.isIE){
		//	Ugh!
		if(dojo._initFired){
			var e = document.createElement("script");
			e.type = "text/javascript";
			e.src = dojo.moduleUrl("dojox", "embed/IE/flash.js");
			document.getElementsByTagName("head")[0].appendChild(e);
		}else{
			//	we can use document.write.  What a kludge.
			document.write('<scr'+'ipt type="text/javascript" src="' + dojo.moduleUrl("dojox", "embed/IE/flash.js") + '">'
				+ '</scr'+'ipt>');
		}
	}else{*/
		dojox.embed.Flash.place = function(kwArgs, node){
			var o = fMarkup(kwArgs);
			node = dojo.byId(node);
			if(!node){
				node = dojo.doc.createElement("div");
				node.id = o.id+"-container";
				dojo.body().appendChild(node);
			}
			if(o){
				node.innerHTML = o.markup;
				return o.id;
			}
			return null;
		}
		dojox.embed.Flash.onInitialize();
	//}
})();

}

if(!dojo._hasResource['bfree.api.Uploader']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.api.Uploader'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/12/11
 * Time: 11:20 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.api.Uploader');



dojo.declare('bfree.api.Uploader', null, {

});

bfree.api.Uploader.useFlash = function(){

    //Both HTML5/Flash uploaders fail with Opera so force IFrame
    if(dojo.isOpera)
        return false;

    return dojox.embed.Flash.available;
}

bfree.api.Uploader.CLEAN_TRGT  = '/zones/{0}/uploader/clean.json';
bfree.api.Uploader.PRV_TRGT = '/zones/{0}/uploader/preview?file={1}&authenticity_token={2}'
bfree.api.Uploader.DL_TRGT = '/zones/{0}/uploader/download?file={1}';
bfree.api.Uploader.UL_TRGT = '/zones/{0}/uploader/upload?pkg={1}';

bfree.api.Uploader.getDownloadUrl = function(args){
    return dojo.replace(bfree.api.Uploader.DL_TRGT, [args.zone.subdomain, encodeURIComponent(args.item.file)])
}

bfree.api.Uploader.getPreviewUrl = function(args){
    var file_name = (args.item) ? args.item.binary_file_name : '';
    return dojo.replace(bfree.api.Uploader.PRV_TRGT, [args.zone.subdomain, encodeURIComponent(file_name), bfree.api.XhrHelper.authenticity_token])
}

bfree.api.Uploader.getUploadUrl = function(args){
    return dojo.replace(bfree.api.Uploader.UL_TRGT, [args.zone.subdomain, args.isPackage])
}

bfree.api.Uploader.clean = function(args){

    var url = dojo.replace(bfree.api.Uploader.CLEAN_TRGT, [args.zone.subdomain]);

    var postData = {
    };

    var results = bfree.api.XhrHelper.doPostAction({
        target: url,
        postData: postData
    });

}

}

if(!dojo._hasResource["dojox.form.uploader.Base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.uploader.Base"] = true;
dojo.provide("dojox.form.uploader.Base");




dojo.declare("dojox.form.uploader.Base", [dijit._Widget, dijit._Templated], {
	//
	// Version: 1.6
	//
	// summary:
	// 		The Base class used for dojox.form.Uploader and dojox.form.uploader.FileList.
	//
	// 	description:
	// 		Should not be used as a standalone. To be mixed in with other classes.
	//

	getForm: function(){
		// summary:
		// 		Finds the parent form of the Uploader, if it exists.
		//
		if(!this.form){
			var n = this.domNode;
			while(n && n.tagName && n !== document.body){
				if(n.tagName.toLowerCase() == "form"){
					this.form = n;
					break;
				}
				n = n.parentNode;
			}
		}
		return this.form // Node;
	},

	getUrl: function(){
		// summary:
		// 		Finds the URL to upload to, whether it be the action in the parent form, this.url or
		// 		this.uploadUrl
		//
		if(this.uploadUrl) this.url = this.uploadUrl;
		if(this.url) return this.url;
		if(this.getForm()) this.url = this.form.action;
		return this.url; // String
	},


	connectForm: function(){
		//console.log("connectForm...", this.url, !!this.uploadUrl, !!this.getForm())

		this.url = this.getUrl();

		if(!this._fcon && !!this.getForm()){
			this._fcon = true;
			this.connect(this.form, "onsubmit", function(evt){
				dojo.stopEvent(evt);
				this.submit(dojo.formToObject(this.form));
			});
			//console.log("----------------form connected:", this.url)
		}
		//console.log("form:", this.form, this.url);
	},

	supports: function(what){
		//	summary:
		// 		Does feature testing for uploader capabilities. (No browser sniffing - yay)
		//
		if(!this._hascache){
			this._hascache = {
				testDiv: dojo.create("div"),
				testInput: dojo.create("input", {type:"file"}),
				xhr:!!window.XMLHttpRequest ? new XMLHttpRequest() : {}
			};
			dojo.style(this._hascache.testDiv, "opacity", .7);
		}
		switch(what){
			case "FormData":
				return !!window.FormData;
			case "sendAsBinary":
				return !!this._hascache.xhr.sendAsBinary;
			case "opacity":
				return dojo.style(this._hascache.testDiv, "opacity") == .7;
			case "multiple":
				if(this.force == "flash" || this.force == "iframe") return false;
				var res = dojo.attr(this._hascache.testInput, "multiple");
				return res===true || res===false; // IE will be undefined
		}
		return false; // Boolean
	},
	getMimeType: function(){
		//	summary:
		//		Returns the mime type that should be used in an HTML5 upload form. Return result
		//		may change as the current use is very generic.
		//
		return "application/octet-stream"; //image/gif
	},
	getFileType: function(/* String */name){
		// summary:
		// 		Gets the extension of a file
		return name.substring(name.lastIndexOf(".")+1).toUpperCase(); // String
	},
	convertBytes: function(bytes){
		// summary:
		// 		Converts bytes. Returns an object with all conversions. The "value" property is
		// 		considered the most likely desired result.
		//
		var kb = Math.round(bytes/1024*100000)/100000;
		var mb = Math.round(bytes/1048576*100000)/100000;
		var gb = Math.round(bytes/1073741824*100000)/100000;
		var value = bytes;
		if(kb>1) value = kb.toFixed(1)+" kb";
		if(mb>1) value = mb.toFixed(1)+" mb";
		if(gb>1) value = gb.toFixed(1)+" gb";
		return {
			kb:kb,
			mb:mb,
			gb:gb,
			bytes:bytes,
			value: value
		}; // Object
	}
});

}

if(!dojo._hasResource["dojox.form.Uploader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.Uploader"] = true;
dojo.provide("dojox.form.Uploader");
dojo.experimental("dojox.form.Uploader");



	//
	// TODO:
	//		i18n
	//		label via innerHTML
	//		Doc and or test what can be extended.
	//		Doc custom file events
	//		Use new FileReader() for thumbnails
	//		flashFieldName should default to Flash
	//		get('value'); and set warning
	//

dojo.declare("dojox.form.Uploader", [dojox.form.uploader.Base], {
	//
	// Version: 1.6
	//
	// summary:
	//		A widget that creates a stylable file-input button, with optional multi-file selection,
	//		using only HTML elements. Non-HTML5 browsers have fallback options of Flash or an iframe.
	//
	//	description:
	//		A bare-bones, stylable file-input button, with optional multi-file selection. The list
	//		of files is not displayed, that is for you to handle by connecting to the onChange
	//		event, or use the dojox.form.uploader.FileList.
	//
	//		Uploader without plugins does not have any ability to upload - it is for use in forms
	//		where you handle the upload either by a standard POST or with Ajax using an iFrame. This
	//		class is for convenience of multiple files only. No progress events are available.
	//
	//		If the browser supports a file-input with the "multiple" attribute, that will be used.
	//		If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
	//		one for each selection.
	//
	//
	//	uploadOnSelect: Boolean
	//		If true, uploads imediately after a file has been selected. If false,
	//		waits for upload() to be called.
	uploadOnSelect:false,
	//	tabIndex: Number|String
	//		The tab order in the DOM.
	tabIndex:0,
	//	multiple: Boolean
	//		If true and flash mode, multiple files may be selected from the dialog.
	multiple:false,
	//
	//	label: String
	//		The text used in the button that when clicked, opens a system Browse Dialog.
	label:"Upload...",
	//
	// url: String
	//		The url targeted for upload. An absolute URL is preferred. Relative URLs are
	//		changed to absolute.
	url:"",
	//
	//	name: String
	//		The name attribute needs to end with square brackets: [] as this is the standard way
	//		of handling an attribute "array". This requires a slightly different technique on the
	//		server.
	name:"uploadedfile",
	//
	//	flashFieldName: String
	//		If set, this will be the name of the field of the flash uploaded files that the server
	//		is expecting. If not set, "Flash" is appended to the "name" property.
	flashFieldName:"",
	//
	//	uploadType: String [readonly]
	//		The type of uploader being used. As an alternative to determining the upload type on the
	//		server based on the fieldName, this property could be sent to the server to help
	//		determine what type of parsing should be used.
	uploadType:"form",
	//
	_nameIndex:0,
	widgetsInTemplate:true,
	templateString:'<div class="dojoxFileInput"><div dojoType="dijit.form.Button" dojoAttachPoint="button">${label}</div></div>',

	postMixInProperties: function(){
		this._inputs = [];
		this._getButtonStyle(this.srcNodeRef);
		this.inherited(arguments);
	},
	postCreate: function(){
		var restore = false;
		var parent = this.domNode.parentNode;
		var position = this._getNodePosition(this.domNode);
		if(!this.btnSize.w || !this.btnSize.h) {
			dojo.body().appendChild(this.domNode);
			this._getButtonStyle(this.domNode);
			restore = true;
		}
		this._setButtonStyle();
		if(restore){
			dojo.place(this.domNode, position.node, position.pos)
		}
		this.inherited(arguments);
	},

	/*************************
	 *	   Public Events	 *
	 *************************/

	onChange: function(/* Array */fileArray){
		//	summary:
		// 		stub to connect
		// 		Fires when files are selected
		// 		Event is an array of last files selected
	},

	onBegin: function(/* Array */dataArray){
		// summary:
		// 		Fires when upload begins
	},

	onProgress: function(/* Object */customEvent){
		// summary:
		// 		Stub to connect
		// 		Fires on upload progress. Event is a normalized object of common properties
		// 		from HTML5 uploaders and the Flash uploader. Will not fire for IFrame.
		// customEvent:
		// 		bytesLoaded: Number
		// 			Amount of bytes uploaded so far of entire payload (all files)
		//		bytesTotal: Number
		//			Amount of bytes of entire payload (all files)
		//		type: String
		//			Type of event (progress or load)
		//		timeStamp: Number
		//			Timestamp of when event occurred
	},

	onComplete: function(/* Object */customEvent){
		// summary:
		// 		stub to connect
		// 		Fires when all files have uploaded
		// 		Event is an array of all files
		this.reset();
	},

	onCancel: function(){
		// summary:
		// 		Stub to connect
		// 		Fires when dialog box has been closed
		//		without a file selection
	},

	onAbort: function(){
		// summary:
		// 		Stub to connect
		// 		Fires when upload in progress was canceled
	},

	onError: function(/* Object or String */evtObject){
		// summary:
		//		Fires on errors
		//
		//FIXME: Unsure of a standard form of error events
	},

	/*************************
	 *	   Public Methods	 *
	 *************************/

	upload: function(/*Object ? */formData){
		// summary:
		// 		When called, begins file upload. Only supported with plugins.
	},

	submit: function(/* form Node ? */form){
		// summary:
		//		If Uploader is in a form, and other data should be sent along with the files, use
		//		this instead of form submit. Only supported with plugins.
	},

	reset: function(){
		// summary
		// 		Resets entire input, clearing all files.
		// 		NOTE:
		// 		Removing individual files is not yet supported, because the HTML5 uploaders can't
		// 		be edited.
		// 		TODO:
		// 		Add this ability by effectively, not uploading them
		//
		this._disconnectButton();
		dojo.forEach(this._inputs, dojo.destroy, dojo);
		this._inputs = [];
		this._nameIndex = 0;
		this._createInput();
	},

	getFileList: function(){
		// summary:
		// 		Returns a list of selected files.
		//
		var fileArray = [];
		if(this.supports("multiple")){
			dojo.forEach(this.inputNode.files, function(f, i){
				fileArray.push({
					index:i,
					name:f.name,
					size:f.size,
					type:f.type
				});
			}, this);
		}else{
			dojo.forEach(this._inputs, function(n, i){
				fileArray.push({
					index:i,
					name:n.value.substring(n.value.lastIndexOf("\\")+1),
					size:0,
					type:n.value.substring(n.value.lastIndexOf(".")+1)
				});
			}, this)

		}
		return fileArray; // Array
	},

	/*********************************************
	 *	   Private Property. Get off my lawn.	 *
	 *********************************************/

	_getValueAttr: function(){
		// summary:
		//		Internal. To get disabled use: uploader.get("disabled");
		return this.getFileList();
	},

	_setValueAttr: function(disabled){
		console.error("Uploader value is read only");
	},

	_getDisabledAttr: function(){
		// summary:
		//		Internal. To get disabled use: uploader.get("disabled");
		return this._disabled;
	},

	_setDisabledAttr: function(disabled){
		// summary:
		//		Internal. To set disabled use: uploader.set("disabled", true);
		if(this._disabled == disabled){ return; }
		this.button.set('disabled', disabled);
		dojo.style(this.inputNode, "display", disabled ? "none" : "block");
	},

	_getNodePosition: function(node){
		if(node.previousSibling){
			return {
				node:node.previousSibling,
				pos:"after"
			}
		}
		return {
			node:node.nextSibling,
			pos:"before"
		}
	},

	_getButtonStyle: function(node){
		if(!node){
			// we don't want this to happen. But if it does, try and display *something*.
			this.btnSize = {
				w:200,
				h:25
			};
		}else{
			this.btnSize = dojo.marginBox(node);
		}
	},

	_setButtonStyle: function(){
		var hasParent = true;
		if(!this.domNode.parentNode || !this.domNode.parentNode.tagName){
			document.body.appendChild(this.domNode);
			hasParent = false;
		}

		dojo.style(this.domNode, {
			width:this.btnSize.w+"px",
			height:(this.btnSize.h+4)+"px",
			overflow:"hidden",
			position:"relative"
		});

		this.inputNodeFontSize = Math.max(2, Math.max(Math.ceil(this.btnSize.w / 60), Math.ceil(this.btnSize.h / 15)));
		this._createInput();

		dojo.style(this.button.domNode, {
			margin:"0px",
			display:"block",
			verticalAlign:"top" // IE fix

		});

		dojo.style(this.button.domNode.firstChild, {
			margin:"0px",
			display:"block"
			//height:this.btnSize.h+"px"
		});

		if(!hasParent){
			document.body.removeChild(this.domNode);
		}
	},

	_createInput: function(){

		if(this._inputs.length){
			dojo.style(this.inputNode, {
				top:"500px"
			});
			this._disconnectButton();
			this._nameIndex++;
		}

		var name;
		if(this.supports("multiple")){
			// FF3.5+, WebKit
			name = this.name+"s[]";
		}else{
			// <=IE8
			name = this.name + (this.multiple ? this._nameIndex : "");
		}
		this.inputNode = dojo.create("input", {type:"file", name:name, className:"dojoxInputNode"}, this.domNode, "first");
		if(this.supports("multiple") && this.multiple){
			dojo.attr(this.inputNode, "multiple", true);
		}
		this._inputs.push(this.inputNode);


		dojo.style(this.inputNode, {
			fontSize:this.inputNodeFontSize+"em"
		});
		var size = dojo.marginBox(this.inputNode);

		dojo.style(this.inputNode, {
			position:"absolute",
			top:"-2px",
			left:"-"+(size.w-this.btnSize.w-2)+"px",
			opacity:0
		});
		this._connectButton();
	},

	_connectButton: function(){
		this._cons = [];
		var cs = dojo.hitch(this, function(nm){
			this._cons.push(dojo.connect(this.inputNode, nm, this, function(evt){
				this.button._cssMouseEvent({type:nm})
			}));
		});
		cs("mouseover");
		cs("mouseout");
		cs("mousedown");
		this._cons.push(dojo.connect(this.inputNode, "change", this, function(evt){
			this.onChange(this.getFileList(evt));
			if(!this.supports("multiple") && this.multiple) this._createInput();
		}));

		this.button.set('tabIndex', -1);
		if(this.tabIndex > -1){
			this.inputNode.tabIndex = this.tabIndex;
			var restoreBorderStyle = dojo.style(this.button.domNode.firstChild, "border");
			this._cons.push(dojo.connect(this.inputNode, "focus", this, function(){
				dojo.style(this.button.domNode.firstChild, "border", "1px dashed #ccc");
			}));
			this._cons.push(dojo.connect(this.inputNode, "blur", this, function(){
				dojo.style(this.button.domNode.firstChild, "border", restoreBorderStyle);
			}));
		}
	},

	_disconnectButton: function(){
		dojo.forEach(this._cons, dojo.disconnect, dojo);
	}
});

(function(){
	dojox.form.UploaderOrg = dojox.form.Uploader;
	var extensions = [dojox.form.UploaderOrg];
	dojox.form.addUploaderPlugin = function(plug){
		// summary:
		// 		Handle Uploader plugins. When the dojox.form.addUploaderPlugin() function is called,
		// 		the dojox.form.Uploader is recreated using the new plugin (mixin).
		//
		extensions.push(plug);
		dojo.declare("dojox.form.Uploader", extensions, {});
	}
})();

}

if(!dojo._hasResource['bfree.widget.Uploader']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.Uploader'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/11/11
 * Time: 2:23 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.Uploader');





if(bfree.api.Uploader.useFlash()){
    dojo['require']('dojox.form.uploader.plugins.Flash');
}
else{
    dojo['require']('dojox.form.uploader.plugins.IFrame');
}

dojo.declare('bfree.widget.Uploader', dojox.form.Uploader,
{
    documents:0,
    maxDocuments:50,

    _createFlashUploader: function(){
		// summary:
		//		Internal. Creates Flash Uploader
		//
		var url = this.getUrl();
		if(url){
			if(url.toLowerCase().indexOf("http")<0 && url.indexOf("/")!=0){
				// Appears to be a relative path. Attempt to
				//	convert it to absolute, so it will better
				//target the SWF.
				//
				var loc = window.location.href.split("/");
				loc.pop();
				loc = loc.join("/")+"/";
				url = loc+url;
			}
		}else{
			console.warn("Warning: no uploadUrl provided.");
		}

		this.inputNode = dojo.create("div", {className:"dojoxFlashNode"}, this.domNode, "first");
		dojo.style(this.inputNode, {
			position:"absolute",
			top:"-2px",
			width:this.btnSize.w+"px",
			height:this.btnSize.h+"px",
			opacity:0
		});

		var w = this.btnSize.w + 8;
		var h = this.btnSize.h + 8;

		var args = {
			expressInstall:true,
			path: (this.swfPath.uri || this.swfPath) + "?cb_" + (new Date().getTime()),
			width: w,
			height: h,
			allowScriptAccess:"always",
			allowNetworking:"all",
			vars: {
				uploadDataFieldName: this.flashFieldName || this.name+"Flash",
				uploadUrl: url,
				uploadOnSelect: this.uploadOnSelect,
				deferredUploading:this.deferredUploading || 0,
				selectMultipleFiles: this.multiple,
				id: this.id,
				isDebug: this.isDebug,
				noReturnCheck: this.skipServerCheck,
				serverTimeout:this.serverTimeout
			},
			params: {
				scale:"noscale",
				wmode:"transparent",
				wmode:"opaque",
				allowScriptAccess:"always",
				allowNetworking:"all"
			}

		};

		this.flashObject = new dojox.embed.Flash(args, this.inputNode);
		this.flashObject.onError = dojo.hitch(function(msg){
			console.error("Flash Error: " + msg);
		});
		this.flashObject.onReady = dojo.hitch(this, function(){
			this.onReady(this);
		});
		this.flashObject.onLoad = dojo.hitch(this, function(mov){
			this.flashMovie = mov;
			this.flashReady = true;

			this.onLoad(this);
		});
		this._connectFlash();
	},


    _upload: function(evt){

        if((this.documents+evt.length)>this.maxDocuments){
            alert(dojo.replace('You can only upload {0} documents at once.', [this.maxDocuments]));
            return;
        }

        this.documents+=evt.length

        this.onBeforeUpload(evt);
        if(this.uploadType == 'iframe'){
            this.upload({
                preventDefault: function(){ },
                stopPropagation: function(){ }
            });
        }
        else{
            this.upload({
                authenticity_token: bfree.api.XhrHelper.authenticity_token,
                upload_type: this.uploadType
            });
        }

    },

    onAfterUpload: function(items){

    },

    onBeforeUpload: function(items){

    },

    constructor: function(args){
        this.documents=0;
        this.uploadOnSelect = false;
        if(dojo.isOpera){
            this.force = 'iframe';
        }
    },

    onChange: function(evt){
        var fnRef = bfree.widget.Uploader.buildUploadFnRef(this, evt);
		setTimeout(fnRef, 1000);
    },

    onComplete: function(evt){
        var uploaded_files = [];

        try{
            this.reset();

            if(evt.hasOwnProperty('uploadedfiles')){
                uploaded_files = evt.uploadedfiles;
            }
            else if(bfree.api.Utilities.isArray(evt)){
                for(var i = 0; i < evt.length; i++){
                    uploaded_files.push({
                        name: decodeURI(evt[i].name),
                        content_type:  evt[i].type,
                        size: evt[i].size,
                        error: evt[i].error
                    });
                }
            }
            else{
                uploaded_files.push({
                    name: decodeURI(evt.name),
                    content_type: evt.type,
                    size: evt.size,
                    error: evt.error
                });
            }
        }
        catch(e){
            console.log(e.message);
        }

        this.onAfterUpload(uploaded_files);
    },

    onProgress: function(evt){
        console.log((evt.decimal * 100) + '%');
    },

    beforeUpload: function(){

    },

    onUploadComplete: function(uploaded_files){

    },

    postCreate: function(){

        if(this.uploadType == 'html5'){

            var initValue = this.uploadOnSelect;
            this.connectForm();
            this.inherited('postCreate', arguments);

            this.uploadOnSelect = initValue;
            if(this.uploadOnSelect){
                dojo.connect(this, 'onChange', function(data){
                    this.upload(data[0])
                });
            }

        }
        else{
            this.inherited('postCreate', arguments);
        }

	},

    uploadFlash: function(formData){
        this.onBegin(this.getFileList());
		this.flashMovie.doUpload(formData);
    }

});

bfree.widget.Uploader.buildUploadFnRef = function(that, evt){
    return ( function(){
		that._upload(evt);
	});
}

}

if(!dojo._hasResource["dijit.ProgressBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ProgressBar"] = true;
dojo.provide("dijit.ProgressBar");






dojo.declare("dijit.ProgressBar", [dijit._Widget, dijit._Templated], {
	// summary:
	//		A progress indication widget, showing the amount completed
	//		(often the percentage completed) of a task.
	//
	// example:
	// |	<div dojoType="ProgressBar"
	// |		 places="0"
	// |		 value="..." maximum="...">
	// |	</div>

	// progress: [const] String (Percentage or Number)
	//		Number or percentage indicating amount of task completed.
	// 		Deprecated.   Use "value" instead.
	progress: "0",

	// value: String (Percentage or Number)
	//		Number or percentage indicating amount of task completed.
	// 		With "%": percentage value, 0% <= progress <= 100%, or
	// 		without "%": absolute value, 0 <= progress <= maximum.
	//		Infinity means that the progress bar is indeterminate.
	value: "",

	// maximum: [const] Float
	//		Max sample number
	maximum: 100,

	// places: [const] Number
	//		Number of places to show in values; 0 by default
	places: 0,

	// indeterminate: [const] Boolean
	// 		If false: show progress value (number or percentage).
	// 		If true: show that a process is underway but that the amount completed is unknown.
	// 		Deprecated.   Use "value" instead.
	indeterminate: false,

	// label: String?
	//		Label on progress bar.   Defaults to percentage for determinate progress bar and
	//		blank for indeterminate progress bar.
	label:"",

	// name: String
	//		this is the field name (for a form) if set. This needs to be set if you want to use
	//		this widget in a dijit.form.Form widget (such as dijit.Dialog)
	name: '',

	templateString: dojo.cache("dijit", "templates/ProgressBar.html", "<div class=\"dijitProgressBar dijitProgressBarEmpty\" role=\"progressbar\"\n\t><div  dojoAttachPoint=\"internalProgress\" class=\"dijitProgressBarFull\"\n\t\t><div class=\"dijitProgressBarTile\" role=\"presentation\"></div\n\t\t><span style=\"visibility:hidden\">&nbsp;</span\n\t></div\n\t><div dojoAttachPoint=\"labelNode\" class=\"dijitProgressBarLabel\" id=\"${id}_label\"></div\n\t><img dojoAttachPoint=\"indeterminateHighContrastImage\" class=\"dijitProgressBarIndeterminateHighContrastImage\" alt=\"\"\n/></div>\n"),

	// _indeterminateHighContrastImagePath: [private] dojo._URL
	//		URL to image to use for indeterminate progress bar when display is in high contrast mode
	_indeterminateHighContrastImagePath:
		dojo.moduleUrl("dijit", "themes/a11y/indeterminate_progress.gif"),

	postMixInProperties: function(){
		this.inherited(arguments);
		if(!("value" in this.params)){
			this.value = this.indeterminate ? Infinity : this.progress;
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		this.indeterminateHighContrastImage.setAttribute("src",
			this._indeterminateHighContrastImagePath.toString());
		this.update();
	},

	update: function(/*Object?*/attributes){
		// summary:
		//		Internal method to change attributes of ProgressBar, similar to set(hash).  Users should call
		//		set("value", ...) rather than calling this method directly.
		// attributes:
		//		May provide progress and/or maximum properties on this parameter;
		//		see attribute specs for details.
		// example:
		//	|	myProgressBar.update({'indeterminate': true});
		//	|	myProgressBar.update({'progress': 80});
		//	|	myProgressBar.update({'indeterminate': true, label:"Loading ..." })
		// tags:
		//		private

		// TODO: deprecate this method and use set() instead

		dojo.mixin(this, attributes || {});
		var tip = this.internalProgress, ap = this.domNode;
		var percent = 1;
		if(this.indeterminate){
			dijit.removeWaiState(ap, "valuenow");
			dijit.removeWaiState(ap, "valuemin");
			dijit.removeWaiState(ap, "valuemax");
		}else{
			if(String(this.progress).indexOf("%") != -1){
				percent = Math.min(parseFloat(this.progress)/100, 1);
				this.progress = percent * this.maximum;
			}else{
				this.progress = Math.min(this.progress, this.maximum);
				percent = this.progress / this.maximum;
			}

			dijit.setWaiState(ap, "describedby", this.labelNode.id);
			dijit.setWaiState(ap, "valuenow", this.progress);
			dijit.setWaiState(ap, "valuemin", 0);
			dijit.setWaiState(ap, "valuemax", this.maximum);
		}
		this.labelNode.innerHTML = this.report(percent);

		dojo.toggleClass(this.domNode, "dijitProgressBarIndeterminate", this.indeterminate);
		tip.style.width = (percent * 100) + "%";
		this.onChange();
	},

	_setValueAttr: function(v){
		this._set("value", v);
		if(v == Infinity){
			this.update({indeterminate:true});
		}else{
			this.update({indeterminate:false, progress:v});
		}
	},

	_setLabelAttr: function(label){
		this._set("label", label);
		this.update();
	},

	_setIndeterminateAttr: function(indeterminate){
		// Deprecated, use set("value", ...) instead
		this.indeterminate = indeterminate;
		this.update();
	},

	report: function(/*float*/percent){
		// summary:
		//		Generates message to show inside progress bar (normally indicating amount of task completed).
		//		May be overridden.
		// tags:
		//		extension

		return this.label ? this.label :
				(this.indeterminate ? "&nbsp;" : dojo.number.format(percent, { type: "percent", places: this.places, locale: this.lang }));
	},

	onChange: function(){
		// summary:
		//		Callback fired when progress updates.
		// tags:
		//		extension
	}
});

}

if(!dojo._hasResource['bfree.widget.file.MultiUploader']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.file.MultiUploader'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 10/11/11
 * Time: 9:53 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.file.MultiUploader');














dojo.declare('bfree.widget.file.MultiUploader', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/file", "template/MultiUploader.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"sidebar\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"leading\"\n            style=\"padding:4px 0 0 8px;width:120px;position:relative;overflow:hidden;\">\n\n        <div dojoAttachPoint=\"formNode\">\n            <input dojoAttachPoint=\"tokenNode\"></input>\n            <input dojoAttachPoint=\"uploadTypeNode\"></input>\n            <div dojoAttachPoint=\"uploaderNode\" style=\"width:118px;height:24px;\"></div>\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"center\"\n            style=\"overflow:hidden;padding:7px 12px 10px 4px\">\n\n        <div dojoAttachPoint=\"progressNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _frmUpload: null,
    _prgBar: null,
    _txtToken: null,
    _txtUploadType: null,
    _uploader: null,

    isPackage: false,
    multiple: true,
    scrollOnFocus: false,
    zone: null,

    _onBeforeUpload: function(items){

        dojo.forEach(items, function(item, idx){
            this.onFileSelect({
                name: item.name,
                size: item.size,
                type: item.type
            });
        }, this);
        this._prgBar.set('style', {opacity: 1});

    },

    _onAfterUpload: function(items){

        dojo.forEach(items, function(item, idx){
            if(String.isEmpty(item.error))
                this.onFileUploaded(item);
            else
                this.onError(item, new bfree.api.Error(item.error));
        }, this);

        dojo.fadeOut({
            node: this._prgBar.domNode,
            duration: 2000,
            onEnd: dojo.hitch(this,function() {
                this._prgBar.set('value', (this._uploader.uploadType == 'iframe') ? (Infinity) : 0);
            })
        }).play();

    },

    _onProgress: function(evt){
        this._prgBar.set('value', evt.decimal * 100);
    },

    _setUrlAttr: function(value){
        this._uploader.set('url', value);
    },

    clean: function(){
        bfree.api.Uploader.clean({zone: this.zone});
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._uploader != null){
            this._uploader.destroyRecursive();
            this._uploader = null;
        }

        this.inherited('destroy', arguments);
    },

    onError: function(fileItem, err){
    },

    onFileSelect: function(fileItem){
    },

    onFileUploaded: function(fileItem){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._frmUpload = new dijit.form.Form({
            method: 'POST',
            encType: 'multipart/form-data'
        }, this.formNode);

        this._txtToken = new dijit.form.TextBox({
            name: 'authenticity_token',
            type: 'hidden',
            value: bfree.api.XhrHelper.authenticity_token
        }, this.tokenNode);

        //if the browser is ie and the uploader is iframe multiple
        //has to be set to true for the uploader to function properly
        if(dojo.isIE&&!bfree.api.Uploader.useFlash()){
            this.multiple=true;
        }

        this._uploader = new bfree.widget.Uploader({
            label: (this.multiple ? 'Choose File(s)...' : 'Choose File...'),
            multiple: this.multiple,
            uploadOnSelect: false,
            url: bfree.api.Uploader.getUploadUrl({ zone: this.zone, isPackage: this.isPackage }),
            style: 'width:108px',
            maxDocuments: 50,
            onBeforeUpload: dojo.hitch(this, this._onBeforeUpload),
            onAfterUpload: dojo.hitch(this, this._onAfterUpload),
            onProgress: dojo.hitch(this, this._onProgress)
        },  this.uploaderNode);

        this._txtUploadType = new dijit.form.TextBox({
            name: 'upload_type',
            type: 'hidden',
            value: this._uploader.uploadType
        }, this.uploadTypeNode);

        this._prgBar = new dijit.ProgressBar({
            value: (this._uploader.uploadType == 'iframe') ? (Infinity) : 0,
            style: 'margin-right:32px;width:100%;opacity:0'
        }, this.progressNode);

    },

    redraw: function(){

        if(this.uploadType == 'flash'){
            if(this._uploader != null){
                this._uploader.destroy();
             this._uploader = null;
            }
        }

    },

    startup: function(){
        this.inherited('startup', arguments);
        this.mainNode.resize();
        this._uploader.set('scrollOnFocus', false);

        dojo.fadeOut({
            node: this._prgBar.domNode,
            duration: 10,
            onEnd: dojo.hitch(this,function() {
                this._prgBar.set('value', (this._uploader.uploadType == 'iframe') ? (Infinity) : 0);
            })
        }).play();

    }

});



}

if(!dojo._hasResource['bfree.widget.document.Checkin']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.Checkin'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/12/11
 * Time: 3:03 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.Checkin');












dojo.declare('bfree.widget.document.Checkin', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/document", "template/Checkin.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        dojoAttachPoint=\"mainContainer\"\n        design=\"sidebar\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n    <div   dojoType=\"dijit.layout.ContentPane\"\n           dojoAttachPoint=\"previewPane\"\n           splitter=\"false\"\n           region=\"center\"\n           style=\"display:none\">\n\n        <div dojoAttachPoint=\"previewNode\"></div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            region=\"right\"\n            splitter=\"false\"\n            style=\"width:480px\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                dojoAttachPoint=\"headerPane\"\n                region=\"top\"\n                splitter=\"false\"\n                class=\"versaTopHeader\"\n                style=\"height:12px;position:relative;\">\n\n            <span dojoAttachPoint=\"showPreviewNode\" style=\"position:absolute;left:8px;\">\n                <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onShowPreview\">Show Preview</a>\n            </span>\n\n            <span dojoAttachPoint=\"hidePreviewNode\" style=\"position:absolute;left:8px;opacity:0;display:none\">\n                <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onHidePreview\">Hide Preview</a>\n            </span>\n\n        </div>\n\n         <div   dojoType=\"dijit.layout.BorderContainer\"\n                design=\"headline\"\n                gutters=\"false\"\n                region=\"center\"\n                splitter=\"false\">\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    region=\"top\"\n                    splitter=\"false\"\n                    style=\"height:32px;padding:4px 0 4px 0\">\n\n                <div dojoAttachPoint=\"uploaderNode\"></div>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.BorderContainer\"\n                    design=\"headline\"\n                    gutters=\"false\"\n                    region=\"center\"\n                    splitter=\"false\">\n\n                <div    dojoType=\"dijit.layout.ContentPane\"\n                        region=\"top\"\n                        splitter=\"false\"\n                        style=\"height:28px;overflow:hidden;padding:0 8px 8px 8px\">\n\n                    <div class=\"versaGridOutline\">\n                        <div dojoAttachPoint=\"selectNode\" class=\"versafile dijitDarkLabel\" style=\"padding-top:3px;height:18px;text-align:center;width:100%\">\n                            Select a file to checkin\n                        </div>\n                        <table dojoAttachPoint=\"fileTableNode\" cellpadding=\"0\" cellspacing=\"0\" style=\"width:100%;opacity:0;display:none\">\n                            <tr>\n                                <td style=\"padding: 2px 0 0 2px;width:1px;\"><img dojoAttachPoint=\"stateIconNode\" src=\"/images/icons/states/none.16.png\" width=\"16\" height=\"16\"/></td>\n                                <td style=\"padding: 2px 4px 0 2px;width:1px\"><img dojoAttachPoint=\"typeIconNode\" src=\"/images/icons/states/none.16.png\" width=\"16\" height=\"16\"/></td>\n                                <td class=\"versafile dijitDarkLabel\" style=\"width:100%\"><span dojoAttachPoint=\"fileNameNode\"></span></td>\n                                <td class=\"versafile dijitDarkLabel\" style=\"width:56px;padding-right:4px;text-align:right;white-space:nowrap\"><span dojoAttachPoint=\"fileSizeNode\"></span></td>\n                            </tr>\n                        </table>\n                    </div>\n\n                </div>\n\n                <div    dojoType=\"dijit.layout.BorderContainer\"\n                        design=\"headline\"\n                        gutters=\"false\"\n                        region=\"center\"\n                        splitter=\"false\">\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            dojoAttachPoint=\"midTitlePane\"\n                            region=\"top\"\n                            splitter=\"false\"\n                            class=\"versaMidHeader\"\n                            style=\"height:16px;padding:4px 8px 4px 8px;position:relative;\">\n                        Custom Properties\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.BorderContainer\"\n                            design=\"headline\"\n                            gutters=\"false\"\n                            region=\"center\"\n                            splitter=\"false\"\n                            style=\"padding:0\">\n\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"center\"\n                                splitter=\"false\"\n                                style=\"padding:0;\">\n\n                            <div dojoAttachPoint=\"editorNode\"></div>\n\n                        </div>\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"bottom\"\n                                splitter=\"false\"\n                                style=\"height:0px;padding:0;position:relative;display:none\">\n\n                            <span style=\"position:absolute;top:0;left:16px\">\n                            <div dojoAttachPoint=\"addMinorNode\"></div>\n                            <span id=\"chkAddMinor\" class=\"bfree dijitDarkLabel boldLabel\" style=\"vertical-align:middle\">\n                                <label for=\"chkAddMinor\" dojoAttachPoint=\"lblInheritNode\">Add as Minor Version</label>\n                            </span>\n                            </span>\n\n                        </div>\n\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            region=\"bottom\"\n                            splitter=\"false\"\n                            style=\"height:16px;padding:0 8px 8px 8px;position:relative\">\n\n                        <span style=\"position:absolute;top:0;right:8px;\">\n                            <img dojoAttachPoint=\"statusIcnNode\" src=\"/images/icons/states/none.16.png\" width=\"16\" height=\"16\"/>\n                            <span dojoAttachPoint=\"statusMsgNode\" class=\"dijitMediumLabel dijitDarkLabel\" style=\"position:relative;top:-2px;white-space:nowrap;\"></span>\n                        </span>\n\n                    </div>\n\n                </div>\n\n            </div>\n\n        </div>\n\n    </div>\n\n</div>\n\n    <!-- div    dojoType=\"dijit.layout.BorderContainer\"\n            dojoAttachPoint=\"mainContainer\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            style=\"height:100%;width:100%;\">\n\n        <div   dojoType=\"dijit.layout.ContentPane\"\n               dojoAttachPoint=\"previewPane\"\n               splitter=\"false\"\n               region=\"center\"\n               style=\"display:none\">\n\n            <div dojoAttachPoint=\"previewNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.BorderContainer\"\n                design=\"headline\"\n                gutters=\"false\"\n                region=\"right\"\n                splitter=\"false\"\n                style=\"width:480px\">\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    dojoAttachPoint=\"headerPane\"\n                    region=\"top\"\n                    splitter=\"false\"\n                    class=\"versaTopHeader\"\n                    style=\"height:12px;position:relative;\">\n\n                <span dojoAttachPoint=\"showPreviewNode\" style=\"position:absolute;left:8px;\">\n                    <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onShowPreview\">Show Preview</a>\n                </span>\n\n                <span dojoAttachPoint=\"hidePreviewNode\" style=\"position:absolute;left:8px;opacity:0;display:none\">\n                    <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onHidePreview\">Hide Preview</a>\n                </span>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.BorderContainer\"\n                    design=\"headline\"\n                    gutters=\"false\"\n                    region=\"center\"\n                    splitter=\"false\">\n\n                <div    dojoType=\"dijit.layout.ContentPane\"\n                        region=\"top\"\n                        splitter=\"false\"\n                        style=\"height:32px;padding:4px 0 4px 0\">\n\n                    <div dojoAttachPoint=\"uploaderNode\"></div>\n\n                </div>\n\n                <div    dojoType=\"dijit.layout.BorderContainer\"\n                        design=\"headline\"\n                        gutters=\"false\"\n                        region=\"center\"\n                        splitter=\"false\">\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            region=\"top\"\n                            splitter=\"false\"\n                            style=\"height:28px;overflow:hidden;padding:0 8px 8px 8px\">\n\n                        <div class=\"versaGridOutline\">\n                            <div dojoAttachPoint=\"selectNode\" class=\"versafile dijitDarkLabel\" style=\"padding-top:3px;height:18px;text-align:center;width:100%\">\n                                Select a file to checkin\n                            </div>\n                            <table dojoAttachPoint=\"fileTableNode\" cellpadding=\"0\" cellspacing=\"0\" style=\"width:100%;opacity:0;display:none\">\n                                <tr>\n                                    <td style=\"padding: 2px 0 0 2px;width:1px;\"><img dojoAttachPoint=\"stateIconNode\" src=\"/images/icons/states/none.16.png\" width=\"16\" height=\"16\"/></td>\n                                    <td style=\"padding: 2px 4px 0 2px;width:1px\"><img dojoAttachPoint=\"typeIconNode\" src=\"/images/icons/states/none.16.png\" width=\"16\" height=\"16\"/></td>\n                                    <td class=\"versafile dijitDarkLabel\" style=\"width:100%\"><span dojoAttachPoint=\"fileNameNode\"></span></td>\n                                    <td class=\"versafile dijitDarkLabel\" style=\"width:56px;padding-right:4px;text-align:right;white-space:nowrap\"><span dojoAttachPoint=\"fileSizeNode\"></span></td>\n                                </tr>\n                            </table>\n                        </div>\n\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.BorderContainer\"\n                            design=\"headline\"\n                            gutters=\"false\"\n                            region=\"center\"\n                            splitter=\"false\">\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                dojoAttachPoint=\"midTitlePane\"\n                                region=\"top\"\n                                splitter=\"false\"\n                                class=\"versaMidHeader\"\n                                style=\"height:16px;padding:4px 8px 4px 8px;position:relative;\">\n                            Custom Properties\n                        </div>\n\n                        <div    dojoType=\"dijit.layout.BorderContainer\"\n                                design=\"headline\"\n                                gutters=\"false\"\n                                region=\"center\"\n                                splitter=\"false\"\n                                style=\"padding:0\">\n\n\n                            <div    dojoType=\"dijit.layout.ContentPane\"\n                                    region=\"center\"\n                                    splitter=\"false\"\n                                    style=\"padding:0;\">\n\n                                <div dojoAttachPoint=\"editorNode\"></div>\n\n                            </div>\n\n                            <div    dojoType=\"dijit.layout.ContentPane\"\n                                    region=\"bottom\"\n                                    splitter=\"false\"\n                                    style=\"height:0px;padding:0;position:relative;display:none\">\n\n                                <span style=\"position:absolute;top:0;left:16px\">\n                                <div dojoAttachPoint=\"addMinorNode\"></div>\n                                <span id=\"chkAddMinor\" class=\"bfree dijitDarkLabel boldLabel\" style=\"vertical-align:middle\">\n                                    <label for=\"chkAddMinor\" dojoAttachPoint=\"lblInheritNode\">Add as Minor Version</label>\n                                </span>\n                                </span>\n\n                            </div>\n\n                        </div>\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"bottom\"\n                                splitter=\"false\"\n                                style=\"height:16px;padding:0 8px 8px 8px;position:relative\">\n\n                            <span style=\"position:absolute;top:0;right:8px;\">\n                                <img dojoAttachPoint=\"statusIcnNode\" src=\"/images/icons/states/none.16.png\" width=\"16\" height=\"16\"/>\n                                <span dojoAttachPoint=\"statusMsgNode\" class=\"dijitMediumLabel dijitDarkLabel\" style=\"position:relative;top:-2px;white-space:nowrap;\"></span>\n                            </span>\n\n                    </div>\n\n                    </div>\n\n                </div>\n\n            </div>\n\n        </div>\n\n    </div -->\n\n</div>\n"),
    widgetsInTemplate: true,

    _chkAddMinor: null,
    _fileItem: null,
    _isPreviewShowing: false,
    _multiUploader: null,
    _wdgPreview: null,

    activeReference: null,
    references: null,
    library: null,
    zone: null,

    _chkAddMinor_onChange: function(newValue){
        this._document.isMinorVersion = newValue;
    },

    _doCancel: function(){
        var canClose = false;

        try{
            //nothing to do here now
            canClose = true;
        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert document', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    _doSave: function(){

        var canClose = false;

        try{

            if(!this._document.isValid({library: this.library})){
                throw new Error('One or more properties are missing or invalid');
            }

            this.activeReference.binary_file_name = this._fileItem.name;
            this.activeReference.binary_content_type = this._fileItem.content_type;
            this.activeReference.binary_file_size = this._fileItem.size;

            this.activeReference.checkin({zone: this.zone, library: this.library});
            this.library.getDocuments().invalidate(this.activeReference.document_id);

            canClose = true;
        }
        catch(e){

            var err = new bfree.api.Error('Failed to checkin document', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });

            //The store loses the "dirty" flag when item save fails and revert hasn't occurred
            this.library.getDocuments().clone({item: this.document});

            if(e.status == 404){
                canClose = this._doCancel();
                this.library.getDocuments().store.onDelete(this.document);
            }

        }

        return canClose;
    },

    _loadItem: function(){

        //Retrieve referenced document
        this.library.getDocuments().refreshAsync({
            scope: this,
            identity: this.activeReference.document_id,
            onItem: this._onItemLoaded,
            onError: this._onItemError
        });

    },

    _onFileSelect: function(fileItem){

        this._fileItem = fileItem;
        this._fileItem.content_type = fileItem.type;

        this._fileItem.state = bfree.api.Document.states.PENDING;
        this._setState();

        dojo.style(this.selectNode, {display: 'none'});
        dojo.style(this.fileTableNode, {display: 'block'});

        dojo.fadeIn({
            node: this.fileTableNode,
            duration: 1000
        }).play();

    },

    _onFileUploaded: function(fileItem){

        this._fileItem = fileItem;
        this._fileItem.state = bfree.api.Document.states.UPLOADED;
        this._setState();

        if(this._isPreviewShowing){
            var cloneDocument = {
                binary_file_name: this._fileItem.name,
                binary_content_type: this._fileItem.content_type,
                binary_file_size: this._fileItem.size

            }
            this._wdgPreview.set('activeItem', cloneDocument);
        }

        this.onValueChange();
    },

    _onHidePreview: function(e){

        try{
            this._wdgPreview.set('activeItem', null);

            dojo.style(this.showPreviewNode, {display: 'block'});
            dojox.fx.crossFade({
                nodes : [this.hidePreviewNode, this.showPreviewNode],
                duration:1000,
                onEnd: dojo.hitch(this, function(){ dojo.style(this.hidePreviewNode, {display: 'none'}); })
            }).play();

            dojo.style(this.previewPane.domNode, {display: 'none'});
            dojo.removeClass(this.headerPane.domNode, 'versaTopRightHeader');
            dojo.removeClass(this.midTitlePane.domNode, 'versaMidRightHeader');

            this.dialog.resize({w: 480});
            this.dialog._position();

        }
        finally{
            this._isPreviewShowing = false;
            dojo.stopEvent(e);
        }

    },

    _onItemError: function(e){
        try{
            var err = new bfree.api.Error('Failed to load document', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this.onWidgetLoaded();
        }
    },

    _onItemLoaded: function(item){
        try{

            this._document = item;
            this.library.getDocuments().clone({item: this._document});
            this._editor.set('activeItem', this._document);
        }
        finally{
            this.onWidgetLoaded();
        }
    },

    _onShowPreview: function(e){

        try{
            var v = dijit.getViewport();
            var width = (v.w > 1216) ? 1216 : v.w;

            dojo.style(this.hidePreviewNode, {display: 'block'});
            dojox.fx.crossFade({
                nodes : [this.showPreviewNode, this.hidePreviewNode],
                duration:1000,
                onEnd: dojo.hitch(this, function(){
                    dojo.style(this.showPreviewNode, {display: 'none'});
                })
            }).play();

            dojo.addClass(this.headerPane.domNode, 'versaTopRightHeader');
            dojo.addClass(this.midTitlePane.domNode, 'versaMidRightHeader');
            dojo.style(this.previewPane.domNode, {display: 'block'});

            this.dialog.resize({w: width - 16});
            this.dialog._position();

            if(this._fileItem){
                var cloneDocument = {
                    binary_file_name: this._fileItem.name,
                    binary_content_type: this._fileItem.content_type,
                    binary_file_size: this._fileItem.size
                };
                this._wdgPreview.set('activeItem', cloneDocument);
            }

        }
        finally{
            this._isPreviewShowing = true;
            dojo.stopEvent(e);
        }

    },

    _onUploadError: function(fileItem, err){

        var err = new bfree.api.Error(dojo.replace('Failed to upload file \'{0}\'', [fileItem.name]), err);
        bfree.widget.ErrorManager.handleError({
            error: err
        });

        this._fileItem = fileItem;
        this._fileItem.state = bfree.api.Document.states.ERROR;
        this._setState();

    },

    _onValidChange: function(documentItem){
        this.onValueChange();
    },

    _onValueChange: function(property_id, value){
        this.library.getReferences().setValue(this.activeReference, property_id, value);
    },

    _setState: function(){

        var icon = bfree.api.Document.getStateIcon(this._fileItem.state);
        var stateSrc = dojo.replace('/images/icons/states/{0}', [icon]);

        var typeSrc =  bfree.api.Document.getIconUrl(this._fileItem.content_type, 16);

        this.stateIconNode.src = stateSrc;
        this.typeIconNode.src = typeSrc;
        this.fileNameNode.innerHTML = this._fileItem.name;
        this.fileSizeNode.innerHTML = bfree.api.Utilities.readablizeBytes({ bytes: this._fileItem.size });

        var canAddMinor = false;
        this._chkAddMinor.set('disabled', !canAddMinor);

        var msg = bfree.api.Document.getStateMessage(this._fileItem.state);
        var icon = bfree.api.Document.getStateIcon(this._fileItem.state);

        this.statusMsgNode.innerHTML = msg;
        this.statusIcnNode.src = dojo.replace('/images/icons/states/{0}', [icon])

    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._multiUploader != null){
            this._multiUploader.destroy();
            this._multiUploader = null;
        }

        if(this._editor != null){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    isValid: function(){
        return (this._fileItem) && (!this._document.getState(bfree.api.Document.states.INVALID));
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            this.returnValue = this.references;
            canClose = (dlgResult == bfree.widget.Dialog.dialogResult.ok) ?
                            this._doSave() :
                            this._doCancel();

        }
        catch(e){
           var err = new bfree.api.Error('Failed to close \'Checkin Document\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            if(this._multiUploader) this._multiUploader.clean();
            this.library.getDocuments().revert();
            //this.library.getReferences().refreshItem(this.activeReference.getId());
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this.activeReference = this.references[0];

        this._multiUploader = new bfree.widget.file.MultiUploader({
            id: 'uploader1',
            multiple: false,
            zone: this.zone,
            onFileSelect: dojo.hitch(this, this._onFileSelect),
            onFileUploaded: dojo.hitch(this, this._onFileUploaded),
            onError: dojo.hitch(this, this._onUploadError)
        }, this.uploaderNode);

        this._editor = new bfree.widget.document.Editor({
            id: 'editor1',
            library: this.library,
            disableDocumentType: true,
            onValidChange: dojo.hitch(this, this._onValidChange),
            onValueChange: dojo.hitch(this, this._onValueChange)
            //onSubmit: dojo.hitch(this, this._onSubmit)
        }, this.editorNode);

        //Removed (for now)
        this._chkAddMinor = new dijit.form.CheckBox({
            id: 'chkAddMinor',
            checked: false,
            scrollOnFocus: false,
            disabled: true,
            onChange: dojo.hitch(this, this._chkAddMinor_onChange)
        }, this.addMinorNode);


        this._wdgPreview = new bfree.widget.file.Preview({
            zone: this.zone
        }, this.previewNode);

    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainContainer.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._multiUploader.startup();
        this._wdgPreview.startup();

        setTimeout(bfree.widget.document.Checkin._loadFnRef(this), 10);
    }

});

bfree.widget.document.Checkin._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.document.Checkin.show = function(args){

    if((!args.items) || (args.items.length < 1))
        throw new Error('No documents selected');

    var reference = args.items[0];;

    var dlg = new bfree.widget.Dialog({
        id: 'dlgCkiDocument',
        title: 'Checkin Document: ' + reference.name.display_limit(32),
        widgetConstructor: bfree.widget.document.Checkin,
        widgetParams: {
            user: args.user,
            references: args.items,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 480,
        width: 480,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['bfree.widget.document.FileGrid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.FileGrid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/11/11
 * Time: 9:20 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.FileGrid');





dojo.declare('bfree.widget.document.FileGrid', [bfree.widget._Grid], {

    selectionMode: 'single',

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },

    addFileItem: function(fileItem){

        var item = this._store.newItem(fileItem);

        if(this.selection.getSelectedCount() < 1)
            this.selectItem(item);

    },

	constructor: function(/* Object */args){

		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};
        this.selectionMode = 'single';

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'Select one or more files';

        this._store = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: []
            }
        });

	},

    destroy: function(){
        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);
        this.set('structure', bfree.widget.document.FileGrid.view1);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this._store, {}, {cache: true});
    },

    updateFileItem: function(id, state){

        this._store.fetchItemByIdentity({
            identity: id,
            onItem: function(item) { this._store.setValue(item, 'state', state); },
            scope: this
        });

    }

});

bfree.widget.document.FileGrid.formatContentType = function(data, rowIndex){

    if(String.isEmpty(data))
        return ''

    var imgSrc =  bfree.api.Document.getIconUrl(data, 16);
    var img = dojo.replace('<img src="{0}" width="16" height="16"/>', [imgSrc]);

    return img;

}

bfree.widget.document.FileGrid.formatState = function(data, rowIndex){
    var icon = bfree.api.Document.getStateIcon(data);
    return dojo.replace('<div style="padding-top:2px"><img src="/images/icons/states/{0}" width="16" height="16"/></div>', [icon]);
}

bfree.widget.document.FileGrid.getContentType = function(idx, item){
    var content_type = '';

    if(!item)
        return content_type;

    var documentItem = this.grid.store.getValue(item, 'document');
    if(documentItem){
        content_type = documentItem.binary_content_type;
    }

    return content_type;
}

bfree.widget.document.FileGrid.getSize = function(idx, item){
    var sizeBytes = 0;

    if(item){
        var documentItem = this.grid.store.getValue(item, 'document');
        if(documentItem)
            sizeBytes = documentItem.binary_file_size;
    }

    return bfree.api.Utilities.readablizeBytes({ bytes: sizeBytes });
}

bfree.widget.document.FileGrid.getState = function(idx, item){
    var state = 0;

    if(!item)
        return state;

    var documentItem = this.grid.store.getValue(item, 'document');
    if(documentItem){

        if(documentItem.getState(bfree.api.Document.states.INVALID)){
            state = bfree.api.Document.states.INVALID;
        }
        else if(documentItem.getState(bfree.api.Document.states.PENDING)){
            state = bfree.api.Document.states.PENDING;
        }
        else if(documentItem.getState(bfree.api.Document.states.UPLOADED)){
            state = bfree.api.Document.states.UPLOADED;
        }
        else if(documentItem.getState(bfree.api.Document.states.CHECKED_IN)){
            state = bfree.api.Document.states.CHECKED_IN;
        }
        else if(documentItem.getState(bfree.api.Document.states.ERROR)){
            state = bfree.api.Document.states.ERROR;
        }

    }

     return state;
}

bfree.widget.document.FileGrid.view1 = [{
    cells: [
        {
            field: 'state',
            name: '&nbsp;',
            width: '18px',
            get: bfree.widget.document.FileGrid.getState,
            formatter: bfree.widget.document.FileGrid.formatState
        },
        {
            field: 'content_type',
            name: '&nbsp;',
            width: '18px',
            get: bfree.widget.document.FileGrid.getContentType,
            formatter: bfree.widget.document.FileGrid.formatContentType
        },
        {
            field: 'name',
            name: '&nbsp;',
            width: 'auto'
        },
        {
            field: 'size',
            name: '&nbsp;',
            width: '56px',
            get: bfree.widget.document.FileGrid.getSize,
            cellStyles: 'text-align:right;white-space:nowrap'
        }
    ],
    width: 'auto'
}];


}

if(!dojo._hasResource['bfree.widget.file.Preview']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.file.Preview'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 12/01/12
 * Time: 4:12 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.file.Preview');







dojo.declare('bfree.widget.file.Preview', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree/widget/file", "template/Preview.html", "<div style=\"height:100%;width:100%;\">\n\n<div \tdojoType=\"dijit.layout.BorderContainer\"\n\t\tdojoAttachPoint=\"pneMain\"\n\t\tdesign=\"headline\"\n\t\tgutters=\"false\"\n        class=\"versaInfoPane\"\n\t\tstyle=\"height:100%;padding:8px;width:100%\">\n\n\t<div \tdojoType=\"dijit.layout.ContentPane\"\n\t\t\tdojoAttachPoint=\"pneContentNode\"\n\t\t\tregion=\"center\"\n\t\t\tsplitter=\"false\"\n\t\t\tstyle=\"padding: 0\">\n\n\t\t<div dojoAttachPoint=\"pnePreviewNode\" style=\"position:relative;width:100%;height:100%\">\n\n\t\t\t<iframe src=\"\"\n\t\t\t\t\tdojoAttachPoint=\"previewNode\"\n\t\t\t\t\tallowtransparency=\"true\"\n\t\t\t\t\tframeborder=\"0\"\n\t\t\t\t\theight=\"100%\"\n\t\t\t\t\twidth=\"100%\"\n\t\t\t\t\tmarginheight=\"0\"\n\t\t\t\t\tmarginwidth=\"0\"\n\t\t\t\t\tscrolling=\"no\"\n\t\t\t\t style=\"position:absolute;top:0;left:0;height:100%;width:100%\"></iframe>\n\n\n\t\t</div>\n\t\t<div dojoAttachPoint=\"stbPreviewNode\"></div>\n\n\t</div>\n\n</div>\n\n\n</div>\n"),
	widgetsInTemplate: true,

    _hndlOnLoad: null,
    _stbPreview: null,

    activeItem: null,
    zone: null,

    _onPreviewLoad: function(){
        this._stbPreview.hide();
        dojo.style(this.previewNode, 'visibility', 'visible');
    },

    _setActiveItemAttr: function(value){
        this.activeItem = value;

        dojo.style(this.previewNode, 'visibility', 'hidden');
        this._stbPreview.show();
		this.previewNode.src = bfree.api.Uploader.getPreviewUrl({zone: this.zone, item: this.activeItem });

    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._hndlOnLoad){
            dojo.unsubscribe(this._hndlOnLoad);
            this._hndlOnLoad = null;
        }

        this.inherited('destroy', arguments);

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this._stbPreview = new dojox.widget.Standby({
			target: this.pneContentNode.id,
            image: '/images/loading/loading64.gif',
			color: 'white',
			zIndex: 1024
		}, this.stbPreviewNode);

        this._hndlOnLoad = dojo.subscribe('rko/bfree/preview/onLoad', this, this._onPreviewLoad);
	},

    resize: function(){
        this.pneMain.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._stbPreview.startup();
    }

});

}

if(!dojo._hasResource["dojox.fx._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx._base"] = true;
dojo.provide("dojox.fx._base");
// summary: Experimental and extended Animations beyond Dojo Core / Base functionality.
//	Provides advanced Lines, Animations, and convenience aliases.


dojo.mixin(dojox.fx, {

	// anim: Function
	//	Alias of `dojo.anim` - the shorthand `dojo.animateProperty` with auto-play
	anim: dojo.anim,

	// animateProperty: Function
	//	Alias of `dojo.animateProperty` - animate any CSS property
	animateProperty: dojo.animateProperty,

	// fadeTo: Function
	//		Fade an element from an opacity to an opacity.
	//		Omit `start:` property to detect. `end:` property is required.
	//		Ultimately an alias to `dojo._fade`
	fadeTo: dojo._fade,

	// fadeIn: Function
	//	Alias of `dojo.fadeIn` - Fade a node in.
	fadeIn: dojo.fadeIn,
	
	// fadeOut: Function
	//	Alias of `dojo.fadeOut` - Fades a node out.
	fadeOut: dojo.fadeOut,

	// combine: Function
	//	Alias of `dojo.fx.combine` - Run an array of animations in parallel
	combine: dojo.fx.combine,

	// chain: Function
	//	Alias of `dojo.fx.chain` - Run an array of animations in sequence
	chain: dojo.fx.chain,

	// slideTo: Function
	//	Alias of `dojo.fx.slideTo` - Slide a node to a defined top/left coordinate
	slideTo: dojo.fx.slideTo,

	// wipeIn: Function
	//	Alias of `dojo.fx.wipeIn` - Wipe a node to visible
	wipeIn: dojo.fx.wipeIn,

	// wipeOut: Function
	//	Alias of `dojo.fx.wipeOut` - Wipe a node to non-visible
	wipeOut: dojo.fx.wipeOut

});

dojox.fx.sizeTo = function(/* Object */args){
	// summary:
	//		Creates an animation that will size a node
	//
	// description:
	//		Returns an animation that will size the target node
	//		defined in args Object about it's center to
	//		a width and height defined by (args.width, args.height),
	//		supporting an optional method: chain||combine mixin
	//		(defaults to chain).
	//
	//	- works best on absolutely or relatively positioned elements
	//
	// example:
	//	|	// size #myNode to 400px x 200px over 1 second
	//	|	dojo.fx.sizeTo({
	//	|		node:'myNode',
	//	|		duration: 1000,
	//	|		width: 400,
	//	|		height: 200,
	//	|		method: "combine"
	//	|	}).play();
	//

	var node = args.node = dojo.byId(args.node),
		abs = "absolute";

	var method = args.method || "chain";
	if(!args.duration){ args.duration = 500; } // default duration needed
	if(method == "chain"){ args.duration = Math.floor(args.duration / 2); }
	
	var top, newTop, left, newLeft, width, height = null;

	var init = (function(n){
		return function(){
			var cs = dojo.getComputedStyle(n),
				pos = cs.position,
				w = cs.width,
				h = cs.height
			;
			
			top = (pos == abs ? n.offsetTop : parseInt(cs.top) || 0);
			left = (pos == abs ? n.offsetLeft : parseInt(cs.left) || 0);
			width = (w == "auto" ? 0 : parseInt(w));
			height = (h == "auto" ? 0 : parseInt(h));
			
			newLeft = left - Math.floor((args.width - width) / 2);
			newTop = top - Math.floor((args.height - height) / 2);

			if(pos != abs && pos != 'relative'){
				var ret = dojo.coords(n, true);
				top = ret.y;
				left = ret.x;
				n.style.position = abs;
				n.style.top = top + "px";
				n.style.left = left + "px";
			}
		}
	})(node);

	var anim1 = dojo.animateProperty(dojo.mixin({
		properties: {
			height: function(){
				init();
				return { end: args.height || 0, start: height };
			},
			top: function(){
				return { start: top, end: newTop };
			}
		}
	}, args));
	var anim2 = dojo.animateProperty(dojo.mixin({
		properties: {
			width: function(){
				return { start: width, end: args.width || 0 }
			},
			left: function(){
				return { start: left, end: newLeft }
			}
		}
	}, args));

	var anim = dojo.fx[(args.method == "combine" ? "combine" : "chain")]([anim1, anim2]);
	return anim; // dojo.Animation

};

dojox.fx.slideBy = function(/* Object */args){
	// summary:
	//		Returns an animation to slide a node by a defined offset.
	//
	// description:
	//		Returns an animation that will slide a node (args.node) from it's
	//		current position to it's current posision plus the numbers defined
	//		in args.top and args.left. standard dojo.fx mixin's apply.
	//
	// example:
	//	|	// slide domNode 50px down, and 22px left
	//	|	dojox.fx.slideBy({
	//	|		node: domNode, duration:400,
	//	|		top: 50, left: -22
	//	|	}).play();

	var node = args.node = dojo.byId(args.node),
		top, left;

	var init = (function(n){
		return function(){
			var cs = dojo.getComputedStyle(n);
			var pos = cs.position;
			top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
			left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
			if(pos != 'absolute' && pos != 'relative'){
				var ret = dojo.coords(n, true);
				top = ret.y;
				left = ret.x;
				n.style.position = "absolute";
				n.style.top = top + "px";
				n.style.left = left + "px";
			}
		}
	})(node);
	init();
	
	var _anim = dojo.animateProperty(dojo.mixin({
		properties: {
			// FIXME: is there a way to update the _Line after creation?
			// null start values allow chaining to work, animateProperty will
			// determine them for us (except in ie6? -- ugh)
			top: top + (args.top || 0),
			left: left + (args.left || 0)
		}
	}, args));
	dojo.connect(_anim, "beforeBegin", _anim, init);
	return _anim; // dojo.Animation
};

dojox.fx.crossFade = function(/* Object */args){
	// summary:
	//		Returns an animation cross fading two element simultaneously
	//
	// args:
	//	args.nodes: Array - two element array of domNodes, or id's
	//
	//	all other standard animation args mixins apply. args.node ignored.
	//

	// simple check for which node is visible, maybe too simple?
	var node1 = args.nodes[0] = dojo.byId(args.nodes[0]),
		op1 = dojo.style(node1,"opacity"),
		node2 = args.nodes[1] = dojo.byId(args.nodes[1]),
		op2 = dojo.style(node2, "opacity")
	;
	
	var _anim = dojo.fx.combine([
		dojo[(op1 == 0 ? "fadeIn" : "fadeOut")](dojo.mixin({
			node: node1
		},args)),
		dojo[(op1 == 0 ? "fadeOut" : "fadeIn")](dojo.mixin({
			node: node2
		},args))
	]);
	return _anim; // dojo.Animation
};

dojox.fx.highlight = function(/*Object*/ args){
	// summary:
	//		Highlight a node
	//
	// description:
	//		Returns an animation that sets the node background to args.color
	//		then gradually fades back the original node background color
	//
	// example:
	//	|	dojox.fx.highlight({ node:"foo" }).play();

	var node = args.node = dojo.byId(args.node);

	args.duration = args.duration || 400;
	
	// Assign default color light yellow
	var startColor = args.color || '#ffff99',
		endColor = dojo.style(node, "backgroundColor")
	;

	// safari "fix"
	// safari reports rgba(0, 0, 0, 0) (black) as transparent color, while
	// other browsers return "transparent", rendered as white by default by
	// dojo.Color; now dojo.Color maps "transparent" to
	// djConfig.transparentColor ([r, g, b]), if present; so we can use
	// the color behind the effect node
	if(endColor == "rgba(0, 0, 0, 0)"){
		endColor = "transparent";
	}

	var anim = dojo.animateProperty(dojo.mixin({
		properties: {
			backgroundColor: { start: startColor, end: endColor }
		}
	}, args));

	if(endColor == "transparent"){
		dojo.connect(anim, "onEnd", anim, function(){
			node.style.backgroundColor = endColor;
		});
	}

	return anim; // dojo.Animation
};

 
dojox.fx.wipeTo = function(/*Object*/ args){
	// summary:
	//		Animate a node wiping to a specific width or height
	//
	// description:
	//		Returns an animation that will expand the
	//		node defined in 'args' object from it's current to
	//		the height or width value given by the args object.
	//
	//		default to height:, so leave height null and specify width:
	//		to wipeTo a width. note: this may be deprecated by a
	//
	//		Note that the final value should not include
	//		units and should be an integer.  Thus a valid args object
	//		would look something like this:
	//
	//		|	dojox.fx.wipeTo({ node: "nodeId", height: 200 }).play();
	//
	//		Node must have no margin/border/padding, so put another
	//		node inside your target node for additional styling.

	args.node = dojo.byId(args.node);
	var node = args.node, s = node.style;

	var dir = (args.width ? "width" : "height"),
		endVal = args[dir],
		props = {}
	;

	props[dir] = {
		// wrapped in functions so we wait till the last second to query (in case value has changed)
		start: function(){
			// start at current [computed] height, but use 1px rather than 0
			// because 0 causes IE to display the whole panel
			s.overflow = "hidden";
			if(s.visibility == "hidden" || s.display == "none"){
				s[dir] = "1px";
				s.display = "";
				s.visibility = "";
				return 1;
			}else{
				var now = dojo.style(node,dir);
				return Math.max(now, 1);
			}
		},
		end: endVal
	};

	var anim = dojo.animateProperty(dojo.mixin({ properties: props }, args));
	return anim; // dojo.Animation
};

}

if(!dojo._hasResource['bfree.widget.document.Creator']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.Creator'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/11/11
 * Time: 9:01 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.Creator');

















dojo.declare('bfree.widget.document.Creator', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/document", "template/Creator.html", "<div style=\"height:100%;width:100%;position:relative\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        dojoAttachPoint=\"mainContainer\"\n        design=\"sidebar\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n    <div   dojoType=\"dijit.layout.ContentPane\"\n           dojoAttachPoint=\"previewPane\"\n           splitter=\"false\"\n           region=\"center\"\n           style=\"display:none\">\n\n        <div dojoAttachPoint=\"previewNode\"></div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            region=\"right\"\n            splitter=\"false\"\n            style=\"width:480px\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                dojoAttachPoint=\"headerPane\"\n                region=\"top\"\n                splitter=\"false\"\n                class=\"versaTopHeader\"\n                style=\"height:12px;position:relative;\">\n\n            <span dojoAttachPoint=\"showPreviewNode\" style=\"position:absolute;left:8px;\">\n                <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onShowPreview\">Show Preview</a>\n            </span>\n\n            <span dojoAttachPoint=\"hidePreviewNode\" style=\"position:absolute;left:8px;opacity:0;display:none\">\n                <a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onHidePreview\">Hide Preview</a>\n            </span>\n\n            <span style=\"position:absolute;right:16px;\">\n                File in Folder: <span dojoAttachPoint=\"folderNameNode\" class=\"dijitBoldLabel\"></span>\n            </span>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.BorderContainer\"\n                design=\"headline\"\n                gutters=\"false\"\n                region=\"center\"\n                splitter=\"false\">\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    region=\"top\"\n                    splitter=\"false\"\n                    style=\"height:32px;padding:4px 0 4px 0\">\n\n                <div dojoAttachPoint=\"uploaderNode\"></div>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.BorderContainer\"\n                    design=\"headline\"\n                    gutters=\"false\"\n                    region=\"center\"\n                    splitter=\"false\">\n\n                <div    dojoType=\"dijit.layout.ContentPane\"\n                        region=\"top\"\n                        splitter=\"false\"\n                        style=\"height:96px;padding:0 8px 8px 8px\">\n\n                        <div dojoAttachPoint=\"fileGridNode\"></div>\n\n                    </div>\n\n                <div    dojoType=\"dijit.layout.BorderContainer\"\n                        design=\"headline\"\n                        gutters=\"false\"\n                        region=\"center\"\n                        splitter=\"false\">\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            dojoAttachPoint=\"midTitlePane\"\n                            region=\"top\"\n                            splitter=\"false\"\n                            class=\"versaMidHeader\"\n                            style=\"height:16px;padding:4px 8px 4px 8px;position:relative;\">\n                        Custom Properties\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.BorderContainer\"\n                            design=\"headline\"\n                            gutters=\"false\"\n                            region=\"center\"\n                            splitter=\"false\">\n\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"center\"\n                                splitter=\"false\"\n                                style=\"padding:0;\">\n\n                            <div dojoAttachPoint=\"editorNode\"></div>\n\n                        </div>\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"bottom\"\n                                splitter=\"false\"\n                                style=\"height:0;padding:0;position:relative;display:none\">\n\n                            <span style=\"position:absolute;top:0;left:8px\">\n                            <div dojoAttachPoint=\"addMinorNode\"></div>\n                            <span id=\"chkAddMinor\" class=\"bfree dijitDarkLabel boldLabel\" style=\"vertical-align:middle\">\n                                <label for=\"chkAddMinor\" dojoAttachPoint=\"lblInheritNode\">Add as Minor Version</label>\n                            </span>\n                            </span>\n\n                        </div>\n\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            region=\"bottom\"\n                            splitter=\"false\"\n                            style=\"height:32px;padding:0 8px 8px 8px;position:relative\">\n\n                        <div dojoAttachPoint=\"addButtonNode\"></div>\n\n                        <span style=\"position:absolute;top:0;right:8px;\">\n                            <img dojoAttachPoint=\"statusIcnNode\" src=\"/images/icons/states/none.16.png\" width=\"16\" height=\"16\"/>\n                            <span dojoAttachPoint=\"statusMsgNode\" class=\"dijitMediumLabel dijitDarkLabel\" style=\"position:relative;top:-2px;white-space:nowrap;\"></span>\n                        </span>\n\n                    </div>\n\n                </div>\n\n\n            </div>\n\n        </div>\n\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _activeItem: null,

    _btnAdd: null,
    _chkAddMinor: null,
    _documents: null,
    _editor: null,
    _fileGrid: null,
    _isPreviewShowing: false,
    _multiUploader: null,
    _uploading: false,

    folder: null,
    library: null,
    zone: null,
    filesLoaded: false,

    __setNextItem: function(startIdx, doWrap){

         //select next available item
        for(var i = startIdx; i < this._fileGrid.rowCount;i++){

            if((i + 1) >= this._fileGrid.rowCount){
                if(doWrap){
                    i = -1;
                    doWrap = false;
                }
                else{
                    break;
                }

            }

            var nextItem = this._fileGrid.getItem(i + 1);
            var documentItem = this._fileGrid.store.getValue(nextItem, 'document');
            if(documentItem.getState(bfree.api.Document.states.UPLOADED) && !(documentItem.getState(bfree.api.Document.states.PENDING))){
                this._fileGrid.setSelectedIndex(i + 1);
                this._fileGrid.scrollToRow(i + 1);
                break;
            }

        }
    },

    _btnAdd_onClick: function(evt){
        this._onSubmit();
        this.filesLoaded=false;
    },

    _chkAddMinor_onChange: function(newValue){

        var fileItem = this._fileGrid.selection.getFirstSelected();
        if(!fileItem) return;

        var documentItem = this._fileGrid.store.getValue(fileItem, 'document');
        documentItem.isMinorVersion = newValue;

    },

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onFileSelect: function(fileItem){
        //File is selected...

        //Check if file exists (by Name)
        var existingItem = null;
        this._fileGrid.store.fetchItemByIdentity({
            identity: fileItem.name,
            onItem: function(item){ existingItem = item; }
        });

        if(existingItem){
            console.log('File is already selected: ' + existingItem.name);
            return;
        }

        //Create Document
        //default to first 'System' document type...should be 'Document'
        var systemTypes = this._documentTypes.getSystem();
        var documentType = systemTypes[0];

        var documentItem = new bfree.api.Document({
            name: fileItem.name,
            document_type_id: documentType.id,
            folder_id: ((this.folder) ? this.folder.id : null),
            state: bfree.api.Document.states.PENDING,
            isMinorVersion: false,
            binary_file_name: fileItem.name,
            binary_content_type: fileItem.type,
            binary_file_size: fileItem.size
        });

        dojo.forEach(documentType.property_mappings, dojo.hitch(this, function(mapping, idx){
            var def=this.library.getPropertyDefinitions().fetchById({id: mapping.property_definition_id});
            var data=bfree.api.Application.getDataTypes().fetchById({id: def.data_type_id});
            if(data.isFloat()||data.isInteger()){
                this._documents.setValue(documentItem, def.column_name, 0);
            }
            var deflt=bfree.api.PropertyMappings.getDefault(mapping, this.library.getPropertyDefinitions());
            if(deflt){
                this._documents.setValue(documentItem, def.column_name, deflt);
            }
        }));

        //add file item to the list and mark as "Pending"
        this._fileGrid.addFileItem({
            id: fileItem.name,
            name: fileItem.name,
            document: documentItem,
            state: bfree.api.Document.states.PENDING
        });

        this.filesLoaded=true;

    },

    _onFileUploaded: function(tmpFileItem){

        var fileItem = this._fileGrid.store.fetchItemById(tmpFileItem.name);

        var documentItem = this._fileGrid.store.getValue(fileItem, 'document');
        documentItem.state =  bfree.api.Document.states.UPLOADED;

        //update info from server
        documentItem.binary_file_name = tmpFileItem.name;
        documentItem.binary_content_type = tmpFileItem.content_type;
        documentItem.binary_file_size = tmpFileItem.size;

        this._onValidChange(documentItem);

        if((this._isPreviewShowing) && (this._editor.activeItem == documentItem)){
            this._wdgPreview.set('activeItem', documentItem);
        }

        this._setState(this._activeItem);

    },

    _onHidePreview: function(e){

        try{
            this._wdgPreview.set('activeItem', null);

            dojo.style(this.showPreviewNode, {display: 'block'});
            dojox.fx.crossFade({
                nodes : [this.hidePreviewNode, this.showPreviewNode],
                duration:1000,
                onEnd: dojo.hitch(this, function(){ dojo.style(this.hidePreviewNode, {display: 'none'}); })
            }).play();

            dojo.style(this.previewPane.domNode, {display: 'none'});
            dojo.removeClass(this.headerPane.domNode, 'versaTopRightHeader');
            dojo.removeClass(this.midTitlePane.domNode, 'versaMidRightHeader');

            this.dialog.resize({w: 480});
            this.dialog._position();

        }
        finally{
            this._isPreviewShowing = false;
            dojo.stopEvent(e);
        }

    },

    _onSelectedFiles: function(items){

        this._activeItem = items[0];
        if(!this._activeItem)
            return;

        var documentItem = this._fileGrid.store.getValue(this._activeItem, 'document');
        this._editor.set('activeItem', documentItem);
        this._chkAddMinor.set('checked', documentItem.isMinorVersion);

        this._setState(this._activeItem);

        if((documentItem.getState(bfree.api.Document.states.UPLOADED) || (documentItem.getState(bfree.api.Document.states.CHECKED_IN))) && this._isPreviewShowing)
            this._wdgPreview.set('activeItem', documentItem);

    },

    _onShowPreview: function(e){

        try{
            var v = dijit.getViewport();
            var width = (v.w > 1216) ? 1216 : v.w;

            dojo.style(this.hidePreviewNode, {display: 'block'});
            dojox.fx.crossFade({
                nodes : [this.showPreviewNode, this.hidePreviewNode],
                duration:1000,
                onEnd: dojo.hitch(this, function(){
                    dojo.style(this.showPreviewNode, {display: 'none'});
                })
            }).play();

            dojo.addClass(this.headerPane.domNode, 'versaTopRightHeader');
            dojo.addClass(this.midTitlePane.domNode, 'versaMidRightHeader');
            dojo.style(this.previewPane.domNode, {display: 'block'});

            this.dialog.resize({w: width - 16});
            this.dialog._position()

            var fileItem = this._fileGrid.selection.getFirstSelected();
            if(!fileItem) return;

            var documentItem = this._fileGrid.store.getValue(fileItem, 'document');
            if(documentItem.getState(bfree.api.Document.states.UPLOADED) || (documentItem.getState(bfree.api.Document.states.CHECKED_IN)))
                this._wdgPreview.set('activeItem', documentItem);


        }
        finally{
            this._isPreviewShowing = true;
            dojo.stopEvent(e);
        }

    },

    _onSubmit: function(){

        var items = [];

        var idx = this._fileGrid.getItemIndex(this._activeItem);
        this._btnAdd.set('disabled', true);
        this._uploading = true;

        try{

            var documentItem = this._fileGrid.store.getValue(this._activeItem, 'document');

            //Check for upload complete.
            if(!documentItem.getState(bfree.api.Document.states.UPLOADED)){
                alert('The file has not completed uploading');
                return;
            }

            //Check for invalid properties.
            if(!documentItem.isValid({library: this.library})){
                throw new Error('One or more properties are missing or invalid');
            }

            //create document item in store and update state of grid item
            this._btnAdd.set('disabled', true);

            documentItem.state |= bfree.api.Document.states.PENDING;
            this._fileGrid.updateRow(idx);
            var newItem = this._documents.create(documentItem);
            this._editor.set('activeItem', documentItem);
            this._setState(this._activeItem);

            function __onComplete(args){
                //Set state after success
                this._fileGrid.store.setValue(this._activeItem, 'document', newItem);
                this._fileGrid.updateRow(idx);
                this._editor.set('activeItem', newItem);
                this._setState(this._activeItem);

                this.__setNextItem(idx, true);
            }

            //save valid documents to server
            this._documents.save({
                onComplete: __onComplete,
                scope: this
            });

        }
        catch(e){

            //Set state after error
            documentItem.state = bfree.api.Document.states.ERROR;
            this._fileGrid.updateRow(idx);
            this._documents.create(documentItem);
            this._editor.set('activeItem', documentItem);
            this._setState(this._activeItem);

            var err = new bfree.api.Error('Failed to add document to the library', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
            this._documents.revert();
        }
        finally{
            this._uploading = false;
        }

    },

    _onUploadError: function(tmpFileItem, err){

        var err = new bfree.api.Error(dojo.replace('Failed to upload file \'{0}\'', [tmpFileItem.name]), err);
        bfree.widget.ErrorManager.handleError({
            error: err
        });

        var fileItem = this._fileGrid.store.fetchItemById(tmpFileItem.name);

        var documentItem = this._fileGrid.store.getValue(fileItem, 'document');
        documentItem.state = bfree.api.Document.states.ERROR;

        this._onValidChange(documentItem);

        this._editor.set('activeItem', documentItem);
        this._setState(this._activeItem);
    },

    _onValidChange: function(documentItem){

        documentItem.validate({library: this.library});
        var fileItem = this._fileGrid.store.fetchItemById(documentItem.binary_file_name);
        if(fileItem){
            var idx = this._fileGrid.getItemIndex(fileItem);
            this._fileGrid.update(idx);
        }
        this._setState(this._activeItem);

    },

    _setState: function(fileItem){

        var canAdd = !this._uploading;

        var idx = this._fileGrid.getItemIndex(fileItem);
        this._fileGrid.updateRow(idx);

        var documentItem = this._fileGrid.store.getValue(fileItem, 'document');
        canAdd |= (documentItem.state == bfree.api.Document.states.UPLOADED);

        if(documentItem.getState(bfree.api.Document.states.CHECKED_IN))
            canAdd = false;

        this._btnAdd.set('disabled', !canAdd);

        var msg = '';
        var canAddMinor = false;
        var documentItem = (fileItem) ? this._fileGrid.store.getValue(fileItem, 'document') : null;

        var msg = bfree.api.Document.getStateMessage(documentItem.state);
        var icon = bfree.api.Document.getStateIcon(documentItem.state);

        this.statusMsgNode.innerHTML = msg;
        this.statusIcnNode.src = dojo.replace('/images/icons/states/{0}', [icon]);

    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._wdgPreview){
            this._wdgPreview.destroy();
            this._wdgPreview = null;
        }

        if(this._multiUploader != null){
            this._multiUploader.destroy();
            this._multiUploader = null;
        }

        if(this._fileGrid != null){
            this._fileGrid.destroy();
            this._fileGrid = null;
        }

        if(this._btnAdd){
            this._btnAdd.destroy();
            this._btnAdd = null;
        }

        if(this._editor != null){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._btnAdd.focus();
    },

    isValid: function(){
        return true;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(this.filesLoaded){
                if(!confirm("Files have not been added to VersaFile, closing this dialog will cause them to be lost.")){
                    return false;
                }
            }

            if(this._uploading){
                alert("You must wait until all files are uploaded before closing this dialog.");
                return false;
            }

            if(dlgResult == bfree.widget.Dialog.dialogResult.ok){

            }
            else{

            }

            if(this._multiUploader)
                this._multiUploader.clean();

            canClose = true;
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close \'Create Documents\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this.folderNameNode.innerHTML = this.folder.name.display_limit(32);

        this._documentTypes = this.library.getDocumentTypes();
        this._documents = this.library.getDocuments();

        this._multiUploader = new bfree.widget.file.MultiUploader({
            id: 'uploader1',
            zone: this.zone,
            onFileSelect: dojo.hitch(this, this._onFileSelect),
            onFileUploaded: dojo.hitch(this, this._onFileUploaded),
            onError: dojo.hitch(this, this._onUploadError),
            style: 'width:100%'
        }, this.uploaderNode);

        this._fileGrid = new bfree.widget.document.FileGrid({
            id: 'fileGrid1',
            'class': 'versaGridOutline versaNoHeader',
            onSelectedItems: dojo.hitch(this, this._onSelectedFiles)
        }, this.fileGridNode);

        this._editor = new bfree.widget.document.Editor({
            id: 'editor1',
            library: this.library,
            onValidChange: dojo.hitch(this, this._onValidChange),
            onSubmit: dojo.hitch(this, this._onSubmit)
        }, this.editorNode);

        this._chkAddMinor = new dijit.form.CheckBox({
            id: 'chkAddMinor',
            checked: false,
            scrollOnFocus: false,
            disabled: true,
            onChange: dojo.hitch(this, this._chkAddMinor_onChange)
        }, this.addMinorNode);

        this._btnAdd = new bfree.widget.Button({
            id: 'btnAdd',
            'class': 'versaButtonLarge',
            iconClass: 'buttonIcon bfreeIconAdd',
            disabledIconClass: 'buttonIcon bfreeIconAddD',
            label: 'Add Document',
            disabled: true,
            scrollOnFocus: false,
            onClick: dojo.hitch(this, this._btnAdd_onClick)
        }, this.addButtonNode);

        this._wdgPreview = new bfree.widget.file.Preview({
            zone: this.zone
        }, this.previewNode);

    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainContainer.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._multiUploader.startup();
        this._fileGrid.startup();
        this._wdgPreview.startup();

        setTimeout(bfree.widget.document.Creator._loadFnRef(this), 10);
    }


});

bfree.widget.document.Creator._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.document.Creator.show = function(args){

    var v = dijit.getViewport();
    var h = ((v.h > 800) ? 800 : v.h) - 32;

    var dlg = new bfree.widget.Dialog({
        id: 'dlgNewDocuments',
        title: 'Add New Document(s)',
        widgetConstructor: bfree.widget.document.Creator,
        widgetParams: {
            folder: args.folder,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: h,
        width: 480,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['bfree.widget.HeaderMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.HeaderMenu'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 24/01/12
 * Time: 2:20 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.HeaderMenu');


dojo.declare('bfree.widget.HeaderMenu', dijit.Menu, {
    menuLabel: 'Menu',
    closable: false,

    getChildren: function(){
        var c = this.inherited('getChildren', arguments);
        c.splice(0, 1);
        return c;
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        //Add "Heading" menu item
        this.addChild(
            new dijit.MenuItem({
                'class': 'dijitMenuHeader',
                label: this.menuLabel,
                disabled: false
            })
        );

	}



})

}

if(!dojo._hasResource['bfree.widget.folder.ContextMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.folder.ContextMenu'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 24/10/11
 * Time: 9:02 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.folder.ContextMenu');





dojo.declare('bfree.widget.folder.ContextMenu', bfree.widget.HeaderMenu,{

    _arrDivides: [],
    _buttons: {},

    menuLabel: 'Folder',
    activeLibrary: null,
    activeNode: null,
    activeUser: null,
    activeGroup: null,
    tree: null,

    _onCommand: function(cmdId, option){
        //Don't send folder if creating a new share
        ((cmdId == bfree.widget.Bfree.Commands.NEW) && (option ==  bfree.widget.Bfree.ObjectTypes.SHARE)) ?
            this.onCommand(cmdId, option, {folder: null}) :
            this.onCommand(cmdId, option, {folder: this.activeNode.item});
    },

    _openMyself: function(evt){

        if(this.activeNode.item.isSearch())
            return;

        this._setState();

        this.inherited('_openMyself', arguments);
    },

    _setActiveNodeAttr: function(node){
        this.activeNode = node;
    },

    _setState: function(){
        var hiddenItems = new Object()
        var hideDivs = this.activeNode.item.isSpecial();
        var folder = this.activeNode.item;

        hiddenItems.RENAME = folder.isSpecial();
        hiddenItems.EDIT = !folder.isShare();
        hiddenItems.DELETE = folder.isSpecial();
        hiddenItems.NEW = folder.isSpecial();
        hiddenItems.ACL = folder.isSpecial() && !folder.isShare();
        hiddenItems.EMPTY = !folder.isTrash();
        hiddenItems.SHARE = !folder.isShareRoot();
        hiddenItems.UNSHARE = !folder.isShare();
        hiddenItems.COPY  = !folder.isShare();

        dojo.forEach(this._arrDivides, function(divider, idx){
            dojo.toggleClass(divider.domNode, 'versaHide', hideDivs);
        }, this);

        dojo.toggleClass(this._buttons.RENAME.domNode, 'versaHide', hiddenItems.RENAME);
        dojo.toggleClass(this._buttons.EDIT.domNode, 'versaHide', hiddenItems.EDIT);
        dojo.toggleClass(this._buttons.DELETE.domNode, 'versaHide', hiddenItems.DELETE);
        dojo.toggleClass(this._buttons.NEW.domNode, 'versaHide', hiddenItems.NEW);
        dojo.toggleClass(this._buttons.ACL.domNode, 'versaHide', hiddenItems.ACL);
        dojo.toggleClass(this._buttons.EMPTY.domNode, 'versaHide', hiddenItems.EMPTY);
        dojo.toggleClass(this._buttons.SHARE.domNode, 'versaHide', hiddenItems.SHARE);
        dojo.toggleClass(this._buttons.UNSHARE.domNode, 'versaHide', hiddenItems.UNSHARE);
        dojo.toggleClass(this._buttons.COPY.domNode, 'versaHide', hiddenItems.COPY);

        var activePrmSet = folder.getPermissionSet(this.activeLibrary, this.activeUser);

        this._buttons.RENAME.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.EDIT)));
        this._buttons.EDIT.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.EDIT)));
        this._buttons.DELETE.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.DELETE)));
        this._buttons.FLD_CREATE.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.CREATE)));
        this._buttons.DOC_CREATE.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.FILE)));
        this._buttons.NEW.set('disabled', (this._buttons.FLD_CREATE.disabled && this._buttons.DOC_CREATE.disabled));
        this._buttons.ACL.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.SECURE)));
        this._buttons.EMPTY.set('disabled', ((!folder.isTrash()) || (!(this.activeUser.is_admin || this.activeGroup.is_admin))));
        this._buttons.SHARE.set('disabled', (!folder.isShareRoot()));
        this._buttons.UNSHARE.set('disabled', (!folder.isShare()));
        this._buttons.COPY.set('disabled', (!folder.isShare()));
    },

    constructor: function(args){

    },

    onCommand: function(cmdId, item){
    },

    onHide: function(){
        this.inherited('onHide', arguments);
        this.activeNode = null;

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._buttons.RENAME = new dijit.MenuItem({
            label: 'Rename',
            disabled: true,
            iconClass: 'menuIcon bfreeIconEditFolder',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.RENAME,
                bfree.widget.Bfree.ObjectTypes.FOLDER)
        });
        this.addChild(this._buttons.RENAME);

         this._buttons.EDIT = new dijit.MenuItem({
            label: 'Edit Properties...',
            disabled: true,
            iconClass: 'menuIcon bfreeIconEditFolder',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.EDIT,
                bfree.widget.Bfree.ObjectTypes.SHARE)
        });
        this.addChild(this._buttons.EDIT);

        this._buttons.DELETE = new dijit.MenuItem({
            label: 'Delete Folder',
            disabled: true,
            iconClass: 'menuIcon bfreeIconDeleteFolder',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.DESTROY,
                bfree.widget.Bfree.ObjectTypes.FOLDER
            )
        });
        this.addChild(this._buttons.DELETE);

        this._arrDivides[0] = new dijit.MenuSeparator();
		this.addChild(this._arrDivides[0]);

        var mnuCreate = new dijit.Menu({
        });

        this._buttons.FLD_CREATE = new dijit.MenuItem({
            label: 'Folder',
            disabled: true,
            iconClass: 'menuIcon bfreeIconNewFolder',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.FOLDER
            )
        });
		mnuCreate.addChild(this._buttons.FLD_CREATE);

        this._buttons.DOC_CREATE = new dijit.MenuItem({
            label: 'Document',
            disabled: true,
            iconClass: 'menuIcon bfreeIconNewDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
		mnuCreate.addChild(this._buttons.DOC_CREATE);

        this._buttons.NEW = new dijit.PopupMenuItem({
            label: 'New',
            disabled: true,
            popup: mnuCreate,
            iconClass: 'menuIcon bfreeIconNewSubFolder'
        });
		this.addChild(this._buttons.NEW);

        this._arrDivides[1] = new dijit.MenuSeparator();
		this.addChild(this._arrDivides[1]);

        this._buttons.ACL = new dijit.MenuItem({
            label: 'Permissions...',
            disabled: true,
            iconClass: 'menuIcon bfreeIconSecureFolder',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.SECURE,
                bfree.widget.Bfree.ObjectTypes.FOLDER)
        });
        this.addChild(this._buttons.ACL);

        this._buttons.EMPTY = new dijit.MenuItem({
            label: 'Empty Recycle Bin',
            disabled: false,
            iconClass: 'menuIcon bfreeTrashFolder',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EMPTY)
        });
        this.addChild(this._buttons.EMPTY);

        this._buttons.SHARE = new dijit.MenuItem({
            label: 'Create Share',
            disabled: false,
            iconClass: 'menuIcon bfreeShareFolderClosed',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.SHARE)
        });
        this.addChild( this._buttons.SHARE);

        this._buttons.UNSHARE = new dijit.MenuItem({
            label: 'Delete',
            disabled: false,
            iconClass: 'menuIcon bfreeIconDeleteFolder',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.DESTROY,
                bfree.widget.Bfree.ObjectTypes.SHARE)
        });
        this.addChild( this._buttons.UNSHARE);

        this._buttons.COPY = new dijit.MenuItem({
            label: 'Copy Link',
            disabled: true,
            iconClass: 'menuIcon bfreeIconDeleteDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.COPY,
                bfree.widget.Bfree.ObjectTypes.SHARE)
        });
        this.addChild(this._buttons.COPY);

    },

    startup: function(){
        this.inherited('startup', arguments);
    }

});

}

if(!dojo._hasResource["dijit.InlineEditBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.InlineEditBox"] = true;
dojo.provide("dijit.InlineEditBox");








dojo.declare("dijit.InlineEditBox",
	dijit._Widget,
	{
	// summary:
	//		An element with in-line edit capabilites
	//
	// description:
	//		Behavior for an existing node (`<p>`, `<div>`, `<span>`, etc.) so that
	// 		when you click it, an editor shows up in place of the original
	//		text.  Optionally, Save and Cancel button are displayed below the edit widget.
	//		When Save is clicked, the text is pulled from the edit
	//		widget and redisplayed and the edit widget is again hidden.
	//		By default a plain Textarea widget is used as the editor (or for
	//		inline values a TextBox), but you can specify an editor such as
	//		dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	//		An edit widget must support the following API to be used:
	//			- displayedValue or value as initialization parameter,
	//			and available through set('displayedValue') / set('value')
	//			- void focus()
	//			- DOM-node focusNode = node containing editable text

	// editing: [readonly] Boolean
	//		Is the node currently in edit mode?
	editing: false,

	// autoSave: Boolean
	//		Changing the value automatically saves it; don't have to push save button
	//		(and save button isn't even displayed)
	autoSave: true,

	// buttonSave: String
	//		Save button label
	buttonSave: "",

	// buttonCancel: String
	//		Cancel button label
	buttonCancel: "",

	// renderAsHtml: Boolean
	//		Set this to true if the specified Editor's value should be interpreted as HTML
	//		rather than plain text (ex: `dijit.Editor`)
	renderAsHtml: false,

	// editor: String|Function
	//		Class name (or reference to the Class) for Editor widget
	editor: "dijit.form.TextBox",

	// editorWrapper: String|Function
	//		Class name (or reference to the Class) for widget that wraps the editor widget, displaying save/cancel
	//		buttons.
	editorWrapper: "dijit._InlineEditor",

	// editorParams: Object
	//		Set of parameters for editor, like {required: true}
	editorParams: {},

	// disabled: Boolean
	//		If true, clicking the InlineEditBox to edit it will have no effect.
	disabled: false,

	onChange: function(value){
		// summary:
		//		Set this handler to be notified of changes to value.
		// tags:
		//		callback
	},

	onCancel: function(){
		// summary:
		//		Set this handler to be notified when editing is cancelled.
		// tags:
		//		callback
	},

	// width: String
	//		Width of editor.  By default it's width=100% (ie, block mode).
	width: "100%",

	// value: String
	//		The display value of the widget in read-only mode
	value: "",

	// noValueIndicator: [const] String
	//		The text that gets displayed when there is no value (so that the user has a place to click to edit)
	noValueIndicator: dojo.isIE <= 6 ?	// font-family needed on IE6 but it messes up IE8
		"<span style='font-family: wingdings; text-decoration: underline;'>&nbsp;&nbsp;&nbsp;&nbsp;&#x270d;&nbsp;&nbsp;&nbsp;&nbsp;</span>" :
		"<span style='text-decoration: underline;'>&nbsp;&nbsp;&nbsp;&nbsp;&#x270d;&nbsp;&nbsp;&nbsp;&nbsp;</span>",

	constructor: function(){
		// summary:
		//		Sets up private arrays etc.
		// tags:
		//		private
		this.editorParams = {};
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		// save pointer to original source node, since Widget nulls-out srcNodeRef
		this.displayNode = this.srcNodeRef;

		// connect handlers to the display node
		var events = {
			ondijitclick: "_onClick",
			onmouseover: "_onMouseOver",
			onmouseout: "_onMouseOut",
			onfocus: "_onMouseOver",
			onblur: "_onMouseOut"
		};
		for(var name in events){
			this.connect(this.displayNode, name, events[name]);
		}
		dijit.setWaiRole(this.displayNode, "button");
		if(!this.displayNode.getAttribute("tabIndex")){
			this.displayNode.setAttribute("tabIndex", 0);
		}

		if(!this.value && !("value" in this.params)){ // "" is a good value if specified directly so check params){
		   this.value = dojo.trim(this.renderAsHtml ? this.displayNode.innerHTML :
		      (this.displayNode.innerText||this.displayNode.textContent||""));
		}
		if(!this.value){
		    this.displayNode.innerHTML = this.noValueIndicator;
		}

		dojo.addClass(this.displayNode, 'dijitInlineEditBoxDisplayMode');
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use set('disabled', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
		this.set('disabled', disabled);
	},

	_setDisabledAttr: function(/*Boolean*/ disabled){
		// summary:
		//		Hook to make set("disabled", ...) work.
		//		Set disabled state of widget.
		dijit.setWaiState(this.domNode, "disabled", disabled);
		if(disabled){
			this.displayNode.removeAttribute("tabIndex");
		}else{
			this.displayNode.setAttribute("tabIndex", 0);
		}
		dojo.toggleClass(this.displayNode, "dijitInlineEditBoxDisplayModeDisabled", disabled);
		this._set("disabled", disabled);
	},

	_onMouseOver: function(){
		// summary:
		//		Handler for onmouseover and onfocus event.
		// tags:
		//		private
		if(!this.disabled){
			dojo.addClass(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
		}
	},

	_onMouseOut: function(){
		// summary:
		//		Handler for onmouseout and onblur event.
		// tags:
		//		private
		dojo.removeClass(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
	},

	_onClick: function(/*Event*/ e){
		// summary:
		//		Handler for onclick event.
		// tags:
		//		private
		if(this.disabled){ return; }
		if(e){ dojo.stopEvent(e); }
		this._onMouseOut();

		// Since FF gets upset if you move a node while in an event handler for that node...
		setTimeout(dojo.hitch(this, "edit"), 0);
	},

	edit: function(){
		// summary:
		//		Display the editor widget in place of the original (read only) markup.
		// tags:
		//		private

		if(this.disabled || this.editing){ return; }
		this.editing = true;

		// save some display node values that can be restored later
		this._savedPosition = dojo.style(this.displayNode, "position") || "static";
		this._savedOpacity = dojo.style(this.displayNode, "opacity") || "1";
		this._savedTabIndex = dojo.attr(this.displayNode, "tabIndex") || "0";

		if(this.wrapperWidget){
			var ew = this.wrapperWidget.editWidget;
			ew.set("displayedValue" in ew ? "displayedValue" : "value", this.value);
		}else{
			// Placeholder for edit widget
			// Put place holder (and eventually editWidget) before the display node so that it's positioned correctly
			// when Calendar dropdown appears, which happens automatically on focus.
			var placeholder = dojo.create("span", null, this.domNode, "before");

			// Create the editor wrapper (the thing that holds the editor widget and the save/cancel buttons)
			var ewc = typeof this.editorWrapper == "string" ? dojo.getObject(this.editorWrapper) : this.editorWrapper;
			this.wrapperWidget = new ewc({
				value: this.value,
				buttonSave: this.buttonSave,
				buttonCancel: this.buttonCancel,
				dir: this.dir,
				lang: this.lang,
				tabIndex: this._savedTabIndex,
				editor: this.editor,
				inlineEditBox: this,
				sourceStyle: dojo.getComputedStyle(this.displayNode),
				save: dojo.hitch(this, "save"),
				cancel: dojo.hitch(this, "cancel")
			}, placeholder);
			if(!this._started){
				this.startup();
			}
		}
		var ww = this.wrapperWidget;

		if(dojo.isIE){
			dijit.focus(dijit.getFocus()); // IE (at least 8) needs help with tab order changes
		}
		// to avoid screen jitter, we first create the editor with position:absolute, visibility:hidden,
		// and then when it's finished rendering, we switch from display mode to editor
		// position:absolute releases screen space allocated to the display node
		// opacity:0 is the same as visibility:hidden but is still focusable
		// visiblity:hidden removes focus outline

		dojo.style(this.displayNode, { position: "absolute", opacity: "0", display: "none" }); // makes display node invisible, display style used for focus-ability
		dojo.style(ww.domNode, { position: this._savedPosition, visibility: "visible", opacity: "1" });
		dojo.attr(this.displayNode, "tabIndex", "-1"); // needed by WebKit for TAB from editor to skip displayNode

		// Replace the display widget with edit widget, leaving them both displayed for a brief time so that
		// focus can be shifted without incident.  (browser may needs some time to render the editor.)
		setTimeout(dojo.hitch(this, function(){
			ww.focus(); // both nodes are showing, so we can switch focus safely
			ww._resetValue = ww.getValue();
		}), 0);
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the InlineEditBox.
		//		Performs garbage collection.
		// tags:
		//		private

		this.inherited(arguments);
		if(!this.editing){
			/* causes IE focus problems, see TooltipDialog_a11y.html...
			setTimeout(dojo.hitch(this, function(){
				if(this.wrapperWidget){
					this.wrapperWidget.destroy();
					delete this.wrapperWidget;
				}
			}), 0);
			*/
		}
	},

	destroy: function(){
		if(this.wrapperWidget && !this.wrapperWidget._destroyed){
			this.wrapperWidget.destroy();
			delete this.wrapperWidget;
		}
		this.inherited(arguments);
	},

	_showText: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, and optionally focus on display node
		// tags:
		//		private

		var ww = this.wrapperWidget;
		dojo.style(ww.domNode, { position: "absolute", visibility: "hidden", opacity: "0" }); // hide the editor from mouse/keyboard events
		dojo.style(this.displayNode, { position: this._savedPosition, opacity: this._savedOpacity, display: "" }); // make the original text visible
		dojo.attr(this.displayNode, "tabIndex", this._savedTabIndex);
		if(focus){
			dijit.focus(this.displayNode);
		}
	},

	save: function(/*Boolean*/ focus){
		// summary:
		//		Save the contents of the editor and revert to display mode.
		// focus: Boolean
		//		Focus on the display mode text
		// tags:
		//		private

		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		var ww = this.wrapperWidget;
		var value = ww.getValue();
		this.set('value', value); // display changed, formatted value

		this._showText(focus); // set focus as needed
	},

	setValue: function(/*String*/ val){
		// summary:
		//		Deprecated.   Use set('value', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
		return this.set("value", val);
	},

	_setValueAttr: function(/*String*/ val){
		// summary:
		// 		Hook to make set("value", ...) work.
		//		Inserts specified HTML value into this node, or an "input needed" character if node is blank.

		val = dojo.trim(val);
		var renderVal = this.renderAsHtml ? val : val.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/\n/g, "<br>");
		this.displayNode.innerHTML = renderVal || this.noValueIndicator;
		this._set("value", val);

		if(this._started){
			// tell the world that we have changed
			setTimeout(dojo.hitch(this, "onChange", val), 0); // setTimeout prevents browser freeze for long-running event handlers
		}
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use get('value') instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.getValue() is deprecated.  Use get('value') instead.", "", "2.0");
		return this.get("value");
	},

	cancel: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, discarding any changes made in the editor
		// tags:
		//		private

		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		// tell the world that we have no changes
		setTimeout(dojo.hitch(this, "onCancel"), 0); // setTimeout prevents browser freeze for long-running event handlers

		this._showText(focus);
	}
});

dojo.declare(
	"dijit._InlineEditor",
	 [dijit._Widget, dijit._Templated],
{
	// summary:
	// 		Internal widget used by InlineEditBox, displayed when in editing mode
	//		to display the editor and maybe save/cancel buttons.  Calling code should
	//		connect to save/cancel methods to detect when editing is finished
	//
	//		Has mainly the same parameters as InlineEditBox, plus these values:
	//
	// style: Object
	//		Set of CSS attributes of display node, to replicate in editor
	//
	// value: String
	//		Value as an HTML string or plain text string, depending on renderAsHTML flag

	templateString: dojo.cache("dijit", "templates/InlineEditBox.html", "<span data-dojo-attach-point=\"editNode\" role=\"presentation\" style=\"position: absolute; visibility:hidden\" class=\"dijitReset dijitInline\"\n\tdata-dojo-attach-event=\"onkeypress: _onKeyPress\"\n\t><span data-dojo-attach-point=\"editorPlaceholder\"></span\n\t><span data-dojo-attach-point=\"buttonContainer\"\n\t\t><button data-dojo-type=\"dijit.form.Button\" data-dojo-props=\"label: '${buttonSave}', 'class': 'saveButton'\"\n\t\t\tdata-dojo-attach-point=\"saveButton\" data-dojo-attach-event=\"onClick:save\"></button\n\t\t><button data-dojo-type=\"dijit.form.Button\"  data-dojo-props=\"label: '${buttonCancel}', 'class': 'cancelButton'\"\n\t\t\tdata-dojo-attach-point=\"cancelButton\" data-dojo-attach-event=\"onClick:cancel\"></button\n\t></span\n></span>\n"),
	widgetsInTemplate: true,

	postMixInProperties: function(){
		this.inherited(arguments);
		this.messages = dojo.i18n.getLocalization("dijit", "common", this.lang);
		dojo.forEach(["buttonSave", "buttonCancel"], function(prop){
			if(!this[prop]){ this[prop] = this.messages[prop]; }
		}, this);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Create edit widget in place in the template
		var cls = typeof this.editor == "string" ? dojo.getObject(this.editor) : this.editor;

		// Copy the style from the source
		// Don't copy ALL properties though, just the necessary/applicable ones.
		// wrapperStyle/destStyle code is to workaround IE bug where getComputedStyle().fontSize
		// is a relative value like 200%, rather than an absolute value like 24px, and
		// the 200% can refer *either* to a setting on the node or it's ancestor (see #11175)
		var srcStyle = this.sourceStyle,
			editStyle = "line-height:" + srcStyle.lineHeight + ";",
			destStyle = dojo.getComputedStyle(this.domNode);
		dojo.forEach(["Weight","Family","Size","Style"], function(prop){
			var textStyle = srcStyle["font"+prop],
				wrapperStyle = destStyle["font"+prop];
			if(wrapperStyle != textStyle){
				editStyle += "font-"+prop+":"+srcStyle["font"+prop]+";";
			}
		}, this);
		dojo.forEach(["marginTop","marginBottom","marginLeft", "marginRight"], function(prop){
			this.domNode.style[prop] = srcStyle[prop];
		}, this);
		var width = this.inlineEditBox.width;
		if(width == "100%"){
			// block mode
			editStyle += "width:100%;";
			this.domNode.style.display = "block";
		}else{
			// inline-block mode
			editStyle += "width:" + (width + (Number(width) == width ? "px" : "")) + ";";
		}
		var editorParams = dojo.delegate(this.inlineEditBox.editorParams, {
			style: editStyle,
			dir: this.dir,
			lang: this.lang
		});
		editorParams[ "displayedValue" in cls.prototype ? "displayedValue" : "value"] = this.value;
		this.editWidget = new cls(editorParams, this.editorPlaceholder);

		if(this.inlineEditBox.autoSave){
			// Remove the save/cancel buttons since saving is done by simply tabbing away or
			// selecting a value from the drop down list
			dojo.destroy(this.buttonContainer);
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		var ew = this.editWidget;

		if(this.inlineEditBox.autoSave){
			// Selecting a value from a drop down list causes an onChange event and then we save
			this.connect(ew, "onChange", "_onChange");

			// ESC and TAB should cancel and save.  Note that edit widgets do a stopEvent() on ESC key (to
			// prevent Dialog from closing when the user just wants to revert the value in the edit widget),
			// so this is the only way we can see the key press event.
			this.connect(ew, "onKeyPress", "_onKeyPress");
		}else{
			// If possible, enable/disable save button based on whether the user has changed the value
			if("intermediateChanges" in ew){
				ew.set("intermediateChanges", true);
				this.connect(ew, "onChange", "_onIntermediateChange");
				this.saveButton.set("disabled", true);
			}
		}
	},

	_onIntermediateChange: function(val){
		// summary:
		//		Called for editor widgets that support the intermediateChanges=true flag as a way
		//		to detect when to enable/disabled the save button
		this.saveButton.set("disabled", (this.getValue() == this._resetValue) || !this.enableSave());
	},

	destroy: function(){
		this.editWidget.destroy(true); // let the parent wrapper widget clean up the DOM
		this.inherited(arguments);
	},

	getValue: function(){
		// summary:
		//		Return the [display] value of the edit widget
		var ew = this.editWidget;
		return String(ew.get("displayedValue" in ew ? "displayedValue" : "value"));
	},

	_onKeyPress: function(e){
		// summary:
		//		Handler for keypress in the edit box in autoSave mode.
		// description:
		//		For autoSave widgets, if Esc/Enter, call cancel/save.
		// tags:
		//		private

		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
			if(e.altKey || e.ctrlKey){ return; }
			// If Enter/Esc pressed, treat as save/cancel.
			if(e.charOrCode == dojo.keys.ESCAPE){
				dojo.stopEvent(e);
				this.cancel(true); // sets editing=false which short-circuits _onBlur processing
			}else if(e.charOrCode == dojo.keys.ENTER && e.target.tagName == "INPUT"){
				dojo.stopEvent(e);
				this._onChange(); // fire _onBlur and then save
			}

			// _onBlur will handle TAB automatically by allowing
			// the TAB to change focus before we mess with the DOM: #6227
			// Expounding by request:
			// 	The current focus is on the edit widget input field.
			//	save() will hide and destroy this widget.
			//	We want the focus to jump from the currently hidden
			//	displayNode, but since it's hidden, it's impossible to
			//	unhide it, focus it, and then have the browser focus
			//	away from it to the next focusable element since each
			//	of these events is asynchronous and the focus-to-next-element
			//	is already queued.
			//	So we allow the browser time to unqueue the move-focus event
			//	before we do all the hide/show stuff.
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the editor
		// tags:
		//		private

		this.inherited(arguments);
		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing){
			if(this.getValue() == this._resetValue){
				this.cancel(false);
			}else if(this.enableSave()){
				this.save(false);
			}
		}
	},

	_onChange: function(){
		// summary:
		//		Called when the underlying widget fires an onChange event,
		//		such as when the user selects a value from the drop down list of a ComboBox,
		//		which means that the user has finished entering the value and we should save.
		// tags:
		//		private

		if(this.inlineEditBox.autoSave && this.inlineEditBox.editing && this.enableSave()){
			dojo.style(this.inlineEditBox.displayNode, { display: "" });
			dijit.focus(this.inlineEditBox.displayNode); // fires _onBlur which will save the formatted value
		}
	},

	enableSave: function(){
		// summary:
		//		User overridable function returning a Boolean to indicate
		// 		if the Save button should be enabled or not - usually due to invalid conditions
		// tags:
		//		extension
		return (
			this.editWidget.isValid
			? this.editWidget.isValid()
			: true
		);
	},

	focus: function(){
		// summary:
		//		Focus the edit widget.
		// tags:
		//		protected

		this.editWidget.focus();
		setTimeout(dojo.hitch(this, function(){
			if(this.editWidget.focusNode && this.editWidget.focusNode.tagName == "INPUT"){
				dijit.selectInputText(this.editWidget.focusNode);
			}
		}), 0);
	}
});

}

if(!dojo._hasResource["dojo.DeferredList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.DeferredList"] = true;
dojo.provide("dojo.DeferredList");


dojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
	// summary:
	//		Provides event handling for a group of Deferred objects.
	// description:
	//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
	//		this new deferred will typically have its callback fired when all of the deferreds in
	//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	//		fireOnOneErrback, will fire before all the deferreds as appropriate
	//
	//	list:
	//		The list of deferreds to be synchronizied with this DeferredList
	//	fireOnOneCallback:
	//		Will cause the DeferredLists callback to be fired as soon as any
	//		of the deferreds in its list have been fired instead of waiting until
	//		the entire list has finished
	//	fireonOneErrback:
	//		Will cause the errback to fire upon any of the deferreds errback
	//	canceller:
	//		A deferred canceller function, see dojo.Deferred
	var resultList = [];
	dojo.Deferred.call(this);
	var self = this;
	if(list.length === 0 && !fireOnOneCallback){
		this.resolve([0, []]);
	}
	var finished = 0;
	dojo.forEach(list, function(item, i){
		item.then(function(result){
			if(fireOnOneCallback){
				self.resolve([i, result]);
			}else{
				addResult(true, result);
			}
		},function(error){
			if(fireOnOneErrback){
				self.reject(error);
			}else{
				addResult(false, error);
			}
			if(consumeErrors){
				return null;
			}
			throw error;
		});
		function addResult(succeeded, result){
			resultList[i] = [succeeded, result];
			finished++;
			if(finished === list.length){
				self.resolve(resultList);
			}
			
		}
	});
};
dojo.DeferredList.prototype = new dojo.Deferred();

dojo.DeferredList.prototype.gatherResults= function(deferredList){
	// summary:
	//	Gathers the results of the deferreds for packaging
	//	as the parameters to the Deferred Lists' callback

	var d = new dojo.DeferredList(deferredList, false, true, false);
	d.addCallback(function(results){
		var ret = [];
		dojo.forEach(results, function(result){
			ret.push(result[1]);
		});
		return ret;
	});
	return d;
};

}

if(!dojo._hasResource["dijit.tree.TreeStoreModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree.TreeStoreModel"] = true;
dojo.provide("dijit.tree.TreeStoreModel");


dojo.declare(
		"dijit.tree.TreeStoreModel",
		null,
	{
		// summary:
		//		Implements dijit.Tree.model connecting to a store with a single
		//		root item.  Any methods passed into the constructor will override
		//		the ones defined here.

		// store: dojo.data.Store
		//		Underlying store
		store: null,

		// childrenAttrs: String[]
		//		One or more attribute names (attributes in the dojo.data item) that specify that item's children
		childrenAttrs: ["children"],

		// newItemIdAttr: String
		//		Name of attribute in the Object passed to newItem() that specifies the id.
		//
		//		If newItemIdAttr is set then it's used when newItem() is called to see if an
		//		item with the same id already exists, and if so just links to the old item
		//		(so that the old item ends up with two parents).
		//
		//		Setting this to null or "" will make every drop create a new item.
		newItemIdAttr: "id",

		// labelAttr: String
		//		If specified, get label for tree node from this attribute, rather
		//		than by calling store.getLabel()
		labelAttr: "",

	 	// root: [readonly] dojo.data.Item
		//		Pointer to the root item (read only, not a parameter)
		root: null,

		// query: anything
		//		Specifies datastore query to return the root item for the tree.
		//		Must only return a single item.   Alternately can just pass in pointer
		//		to root item.
		// example:
		//	|	{id:'ROOT'}
		query: null,

		// deferItemLoadingUntilExpand: Boolean
		//		Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
		// 		until they are expanded. This allows for lazying loading where only one
		//		loadItem (and generally one network call, consequently) per expansion
		// 		(rather than one for each child).
		// 		This relies on partial loading of the children items; each children item of a
		// 		fully loaded item should contain the label and info about having children.
		deferItemLoadingUntilExpand: false,

		constructor: function(/* Object */ args){
			// summary:
			//		Passed the arguments listed above (store, etc)
			// tags:
			//		private

			dojo.mixin(this, args);

			this.connects = [];

			var store = this.store;
			if(!store.getFeatures()['dojo.data.api.Identity']){
				throw new Error("dijit.Tree: store must support dojo.data.Identity");
			}

			// if the store supports Notification, subscribe to the notification events
			if(store.getFeatures()['dojo.data.api.Notification']){
				this.connects = this.connects.concat([
					dojo.connect(store, "onNew", this, "onNewItem"),
					dojo.connect(store, "onDelete", this, "onDeleteItem"),
					dojo.connect(store, "onSet", this, "onSetItem")
				]);
			}
		},

		destroy: function(){
			dojo.forEach(this.connects, dojo.disconnect);
			// TODO: should cancel any in-progress processing of getRoot(), getChildren()
		},

		// =======================================================================
		// Methods for traversing hierarchy

		getRoot: function(onItem, onError){
			// summary:
			//		Calls onItem with the root item for the tree, possibly a fabricated item.
			//		Calls onError on error.
			if(this.root){
				onItem(this.root);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: dojo.hitch(this, function(items){
						if(items.length != 1){
							throw new Error(this.declaredClass + ": query " + dojo.toJson(this.query) + " returned " + items.length +
							 	" items, but must return exactly one item");
						}
						this.root = items[0];
						onItem(this.root);
					}),
					onError: onError
				});
			}
		},

		mayHaveChildren: function(/*dojo.data.Item*/ item){
			// summary:
			//		Tells if an item has or may have children.  Implementing logic here
			//		avoids showing +/- expando icon for nodes that we know don't have children.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			return dojo.some(this.childrenAttrs, function(attr){
				return this.store.hasAttribute(item, attr);
			}, this);
		},

		getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
			// summary:
			// 		Calls onComplete() with array of child items of given parent item, all loaded.

			var store = this.store;
			if(!store.isItemLoaded(parentItem)){
				// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand
				// mode, so we will load it and just return the children (without loading each
				// child item)
				var getChildren = dojo.hitch(this, arguments.callee);
				store.loadItem({
					item: parentItem,
					onItem: function(parentItem){
						getChildren(parentItem, onComplete, onError);
					},
					onError: onError
				});
				return;
			}
			// get children of specified item
			var childItems = [];
			for(var i=0; i<this.childrenAttrs.length; i++){
				var vals = store.getValues(parentItem, this.childrenAttrs[i]);
				childItems = childItems.concat(vals);
			}

			// count how many items need to be loaded
			var _waitCount = 0;
			if(!this.deferItemLoadingUntilExpand){
				dojo.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });
			}

			if(_waitCount == 0){
				// all items are already loaded (or we aren't loading them).  proceed...
				onComplete(childItems);
			}else{
				// still waiting for some or all of the items to load
				dojo.forEach(childItems, function(item, idx){
					if(!store.isItemLoaded(item)){
						store.loadItem({
							item: item,
							onItem: function(item){
								childItems[idx] = item;
								if(--_waitCount == 0){
									// all nodes have been loaded, send them to the tree
									onComplete(childItems);
								}
							},
							onError: onError
						});
					}
				});
			}
		},

		// =======================================================================
		// Inspecting items

		isItem: function(/* anything */ something){
			return this.store.isItem(something);	// Boolean
		},

		fetchItemByIdentity: function(/* object */ keywordArgs){
			this.store.fetchItemByIdentity(keywordArgs);
		},

		getIdentity: function(/* item */ item){
			return this.store.getIdentity(item);	// Object
		},

		getLabel: function(/*dojo.data.Item*/ item){
			// summary:
			//		Get the label for an item
			if(this.labelAttr){
				return this.store.getValue(item,this.labelAttr);	// String
			}else{
				return this.store.getLabel(item);	// String
			}
		},

		// =======================================================================
		// Write interface

		newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
			// summary:
			//		Creates a new item.   See `dojo.data.api.Write` for details on args.
			//		Used in drag & drop when item from external source dropped onto tree.
			// description:
			//		Developers will need to override this method if new items get added
			//		to parents with multiple children attributes, in order to define which
			//		children attribute points to the new item.

			var pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;

			if(this.newItemIdAttr && args[this.newItemIdAttr]){
				// Maybe there's already a corresponding item in the store; if so, reuse it.
				this.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){
					if(item){
						// There's already a matching item in store, use it
						this.pasteItem(item, null, parent, true, insertIndex);
					}else{
						// Create new item in the tree, based on the drag source.
						LnewItem=this.store.newItem(args, pInfo);
						if (LnewItem && (insertIndex!=undefined)){
							// Move new item to desired position
							this.pasteItem(LnewItem, parent, parent, false, insertIndex);
						}
					}
				}});
			}else{
				// [as far as we know] there is no id so we must assume this is a new item
				LnewItem=this.store.newItem(args, pInfo);
				if (LnewItem && (insertIndex!=undefined)){
					// Move new item to desired position
					this.pasteItem(LnewItem, parent, parent, false, insertIndex);
				}
			}
		},

		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
			// summary:
			//		Move or copy an item from one parent item to another.
			//		Used in drag & drop
			var store = this.store,
				parentAttr = this.childrenAttrs[0];	// name of "children" attr in parent item

			// remove child from source item, and record the attribute that child occurred in
			if(oldParentItem){
				dojo.forEach(this.childrenAttrs, function(attr){
					if(store.containsValue(oldParentItem, attr, childItem)){
						if(!bCopy){
							var values = dojo.filter(store.getValues(oldParentItem, attr), function(x){
								return x != childItem;
							});
							store.setValues(oldParentItem, attr, values);
						}
						parentAttr = attr;
					}
				});
			}

			// modify target item's children attribute to include this item
			if(newParentItem){
				if(typeof insertIndex == "number"){
					// call slice() to avoid modifying the original array, confusing the data store
					var childItems = store.getValues(newParentItem, parentAttr).slice();
					childItems.splice(insertIndex, 0, childItem);
					store.setValues(newParentItem, parentAttr, childItems);
				}else{
					store.setValues(newParentItem, parentAttr,
						store.getValues(newParentItem, parentAttr).concat(childItem));
				}
			}
		},

		// =======================================================================
		// Callbacks

		onChange: function(/*dojo.data.Item*/ item){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},

		onChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
			// summary:
			//		Callback to do notifications about new, updated, or deleted items.
			// tags:
			//		callback
		},

		onDelete: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
			// summary:
			//		Callback when an item has been deleted.
			// description:
			//		Note that there will also be an onChildrenChange() callback for the parent
			//		of this item.
			// tags:
			//		callback
		},

		// =======================================================================
		// Events from data store

		onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
			// summary:
			//		Handler for when new items appear in the store, either from a drop operation
			//		or some other way.   Updates the tree view (if necessary).
			// description:
			//		If the new item is a child of an existing item,
			//		calls onChildrenChange() with the new list of children
			//		for that existing item.
			//
			// tags:
			//		extension

			// We only care about the new item if it has a parent that corresponds to a TreeNode
			// we are currently displaying
			if(!parentInfo){
				return;
			}

			// Call onChildrenChange() on parent (ie, existing) item with new list of children
			// In the common case, the new list of children is simply parentInfo.newValue or
			// [ parentInfo.newValue ], although if items in the store has multiple
			// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,
			// so call getChildren() to be sure to get right answer.
			this.getChildren(parentInfo.item, dojo.hitch(this, function(children){
				this.onChildrenChange(parentInfo.item, children);
			}));
		},

		onDeleteItem: function(/*Object*/ item){
			// summary:
			//		Handler for delete notifications from underlying store
			this.onDelete(item);
		},

		onSetItem: function(/* item */ item,
						/* attribute-name-string */ attribute,
						/* object | array */ oldValue,
						/* object | array */ newValue){
			// summary:
			//		Updates the tree view according to changes in the data store.
			// description:
			//		Handles updates to an item's children by calling onChildrenChange(), and
			//		other updates to an item by calling onChange().
			//
			//		See `onNewItem` for more details on handling updates to an item's children.
			// tags:
			//		extension

			if(dojo.indexOf(this.childrenAttrs, attribute) != -1){
				// item's children list changed
				this.getChildren(item, dojo.hitch(this, function(children){
					// See comments in onNewItem() about calling getChildren()
					this.onChildrenChange(item, children);
				}));
			}else{
				// item's label/icon/etc. changed.
				this.onChange(item);
			}
		}
	});

}

if(!dojo._hasResource["dijit.tree.ForestStoreModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree.ForestStoreModel"] = true;
dojo.provide("dijit.tree.ForestStoreModel");



dojo.declare("dijit.tree.ForestStoreModel", dijit.tree.TreeStoreModel, {
	// summary:
	//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
	//		a.k.a. a store that has multiple "top level" items.
	//
	// description
	//		Use this class to wrap a dojo.data store, making all the items matching the specified query
	//		appear as children of a fabricated "root item".  If no query is specified then all the
	//		items returned by fetch() on the underlying store become children of the root item.
	//		This class allows dijit.Tree to assume a single root item, even if the store doesn't have one.
	//
	//		When using this class the developer must override a number of methods according to their app and
	//		data, including:
	//			- onNewRootItem
	//			- onAddToRoot
	//			- onLeaveRoot
	//			- onNewItem
	//			- onSetItem

	// Parameters to constructor

	// rootId: String
	//		ID of fabricated root item
	rootId: "$root$",

	// rootLabel: String
	//		Label of fabricated root item
	rootLabel: "ROOT",

	// query: String
	//		Specifies the set of children of the root item.
	// example:
	//	|	{type:'continent'}
	query: null,

	// End of parameters to constructor

	constructor: function(params){
		// summary:
		//		Sets up variables, etc.
		// tags:
		//		private

		// Make dummy root item
		this.root = {
			store: this,
			root: true,
			id: params.rootId,
			label: params.rootLabel,
			children: params.rootChildren	// optional param
		};
	},

	// =======================================================================
	// Methods for traversing hierarchy

	mayHaveChildren: function(/*dojo.data.Item*/ item){
		// summary:
		//		Tells if an item has or may have children.  Implementing logic here
		//		avoids showing +/- expando icon for nodes that we know don't have children.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		extension
		return item === this.root || this.inherited(arguments);
	},

	getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){
		// summary:
		// 		Calls onComplete() with array of child items of given parent item, all loaded.
		if(parentItem === this.root){
			if(this.root.children){
				// already loaded, just return
				callback(this.root.children);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: dojo.hitch(this, function(items){
						this.root.children = items;
						callback(items);
					}),
					onError: onError
				});
			}
		}else{
			this.inherited(arguments);
		}
	},

	// =======================================================================
	// Inspecting items

	isItem: function(/* anything */ something){
		return (something === this.root) ? true : this.inherited(arguments);
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		if(keywordArgs.identity == this.root.id){
			var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, this.root);
			}
		}else{
			this.inherited(arguments);
		}
	},

	getIdentity: function(/* item */ item){
		return (item === this.root) ? this.root.id : this.inherited(arguments);
	},

	getLabel: function(/* item */ item){
		return	(item === this.root) ? this.root.label : this.inherited(arguments);
	},

	// =======================================================================
	// Write interface

	newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
		// summary:
		//		Creates a new item.   See dojo.data.api.Write for details on args.
		//		Used in drag & drop when item from external source dropped onto tree.
		if(parent === this.root){
			this.onNewRootItem(args);
			return this.store.newItem(args);
		}else{
			return this.inherited(arguments);
		}
	},

	onNewRootItem: function(args){
		// summary:
		//		User can override this method to modify a new element that's being
		//		added to the root of the tree, for example to add a flag like root=true
	},

	pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
		// summary:
		//		Move or copy an item from one parent item to another.
		//		Used in drag & drop
		if(oldParentItem === this.root){
			if(!bCopy){
				// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches
				// this.query... thus triggering an onChildrenChange() event to notify the Tree
				// that this element is no longer a child of the root node
				this.onLeaveRoot(childItem);
			}
		}
		dijit.tree.TreeStoreModel.prototype.pasteItem.call(this, childItem,
			oldParentItem === this.root ? null : oldParentItem,
			newParentItem === this.root ? null : newParentItem,
			bCopy,
			insertIndex
		);
		if(newParentItem === this.root){
			// It's onAddToRoot()'s responsibility to modify the item so it matches
			// this.query... thus triggering an onChildrenChange() event to notify the Tree
			// that this element is now a child of the root node
			this.onAddToRoot(childItem);
		}
	},

	// =======================================================================
	// Handling for top level children

	onAddToRoot: function(/* item */ item){
		// summary:
		//		Called when item added to root of tree; user must override this method
		//		to modify the item so that it matches the query for top level items
		// example:
		//	|	store.setValue(item, "root", true);
		// tags:
		//		extension
		console.log(this, ": item ", item, " added to root");
	},

	onLeaveRoot: function(/* item */ item){
		// summary:
		//		Called when item removed from root of tree; user must override this method
		//		to modify the item so it doesn't match the query for top level items
		// example:
		// 	|	store.unsetAttribute(item, "root");
		// tags:
		//		extension
		console.log(this, ": item ", item, " removed from root");
	},

	// =======================================================================
	// Events from data store

	_requeryTop: function(){
		// reruns the query for the children of the root node,
		// sending out an onSet notification if those children have changed
		var oldChildren = this.root.children || [];
		this.store.fetch({
			query: this.query,
			onComplete: dojo.hitch(this, function(newChildren){
				this.root.children = newChildren;

				// If the list of children or the order of children has changed...
				if(oldChildren.length != newChildren.length ||
					dojo.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){
					this.onChildrenChange(this.root, newChildren);
				}
			})
		});
	},

	onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
		// summary:
		//		Handler for when new items appear in the store.  Developers should override this
		//		method to be more efficient based on their app/data.
		// description:
		//		Note that the default implementation requeries the top level items every time
		//		a new item is created, since any new item could be a top level item (even in
		//		addition to being a child of another item, since items can have multiple parents).
		//
		//		If developers can detect which items are possible top level items (based on the item and the
		//		parentInfo parameters), they should override this method to only call _requeryTop() for top
		//		level items.  Often all top level items have parentInfo==null, but
		//		that will depend on which store you use and what your data is like.
		// tags:
		//		extension
		this._requeryTop();

		this.inherited(arguments);
	},

	onDeleteItem: function(/*Object*/ item){
		// summary:
		//		Handler for delete notifications from underlying store

        console.log('fsmX.onNewItem');
		// check if this was a child of root, and if so send notification that root's children
		// have changed
		if(dojo.indexOf(this.root.children, item) != -1){
			this._requeryTop();
		}

		this.inherited(arguments);
	},

	onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* object | array */ oldValue,
					/* object | array */ newValue){
		// summary:
		//		Updates the tree view according to changes to an item in the data store.
		//		Developers should override this method to be more efficient based on their app/data.
		// description:
		//		Handles updates to an item's children by calling onChildrenChange(), and
		//		other updates to an item by calling onChange().
		//
		//		Also, any change to any item re-executes the query for the tree's top-level items,
		//		since this modified item may have started/stopped matching the query for top level items.
		//
		//		If possible, developers should override this function to only call _requeryTop() when
		//		the change to the item has caused it to stop/start being a top level item in the tree.
		// tags:
		//		extension

		this._requeryTop();
		this.inherited(arguments);
	}

});

}

if(!dojo._hasResource["dijit.tree._dndContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree._dndContainer"] = true;
dojo.provide("dijit.tree._dndContainer");




dojo.getObject("tree", true, dojo);

dijit.tree._compareNodes = function(n1, n2){
	if(n1 === n2){
		return 0;
	}
	
	if('sourceIndex' in document.documentElement){ //IE
		//TODO: does not yet work if n1 and/or n2 is a text node
		return n1.sourceIndex - n2.sourceIndex;
	}else if('compareDocumentPosition' in document.documentElement){ //FF, Opera
		return n1.compareDocumentPosition(n2) & 2 ? 1: -1;
	}else if(document.createRange){ //Webkit
		var r1 = doc.createRange();
		r1.setStartBefore(n1);

		var r2 = doc.createRange();
		r2.setStartBefore(n2);

		return r1.compareBoundaryPoints(r1.END_TO_END, r2);
	}else{
		throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
	}
};

dojo.declare("dijit.tree._dndContainer",
	null,
	{

		// summary:
		//		This is a base class for `dijit.tree._dndSelector`, and isn't meant to be used directly.
		//		It's modeled after `dojo.dnd.Container`.
		// tags:
		//		protected

		/*=====
		// current: DomNode
		//		The currently hovered TreeNode.rowNode (which is the DOM node
		//		associated w/a given node in the tree, excluding it's descendants)
		current: null,
		=====*/

		constructor: function(tree, params){
			// summary:
			//		A constructor of the Container
			// tree: Node
			//		Node or node's id to build the container on
			// params: dijit.tree.__SourceArgs
			//		A dict of parameters, which gets mixed into the object
			// tags:
			//		private
			this.tree = tree;
			this.node = tree.domNode;	// TODO: rename; it's not a TreeNode but the whole Tree
			dojo.mixin(this, params);

			// class-specific variables
			this.map = {};
			this.current = null;	// current TreeNode's DOM node

			// states
			this.containerState = "";
			dojo.addClass(this.node, "dojoDndContainer");

			// set up events
			this.events = [
				// container level events
				dojo.connect(this.node, "onmouseenter", this, "onOverEvent"),
				dojo.connect(this.node, "onmouseleave",	this, "onOutEvent"),

				// switching between TreeNodes
				dojo.connect(this.tree, "_onNodeMouseEnter", this, "onMouseOver"),
				dojo.connect(this.tree, "_onNodeMouseLeave", this, "onMouseOut"),

				// cancel text selection and text dragging
				dojo.connect(this.node, "ondragstart", dojo, "stopEvent"),
				dojo.connect(this.node, "onselectstart", dojo, "stopEvent")
			];
		},

		getItem: function(/*String*/ key){
			// summary:
			//		Returns the dojo.dnd.Item (representing a dragged node) by it's key (id).
			//		Called by dojo.dnd.Source.checkAcceptance().
			// tags:
			//		protected

			var widget = this.selection[key],
				ret = {
					data: widget,
					type: ["treeNode"]
				};

			return ret;	// dojo.dnd.Item
		},

		destroy: function(){
			// summary:
			//		Prepares this object to be garbage-collected

			dojo.forEach(this.events, dojo.disconnect);
			// this.clearItems();
			this.node = this.parent = null;
		},

		// mouse events
		onMouseOver: function(/*TreeNode*/ widget, /*Event*/ evt){
			// summary:
			//		Called when mouse is moved over a TreeNode
			// tags:
			//		protected
			this.current = widget;
		},

		onMouseOut: function(/*TreeNode*/ widget, /*Event*/ evt){
			// summary:
			//		Called when mouse is moved away from a TreeNode
			// tags:
			//		protected
			this.current = null;
		},

		_changeState: function(type, newState){
			// summary:
			//		Changes a named state to new state value
			// type: String
			//		A name of the state to change
			// newState: String
			//		new state
			var prefix = "dojoDnd" + type;
			var state = type.toLowerCase() + "State";
			//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
			dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
			this[state] = newState;
		},

		_addItemClass: function(node, type){
			// summary:
			//		Adds a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			dojo.addClass(node, "dojoDndItem" + type);
		},

		_removeItemClass: function(node, type){
			// summary:
			//		Removes a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			dojo.removeClass(node, "dojoDndItem" + type);
		},

		onOverEvent: function(){
			// summary:
			//		This function is called once, when mouse is over our container
			// tags:
			//		protected
			this._changeState("Container", "Over");
		},

		onOutEvent: function(){
			// summary:
			//		This function is called once, when mouse is out of our container
			// tags:
			//		protected
			this._changeState("Container", "");
		}
});

}

if(!dojo._hasResource["dijit.tree._dndSelector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree._dndSelector"] = true;
dojo.provide("dijit.tree._dndSelector");




dojo.declare("dijit.tree._dndSelector",
	dijit.tree._dndContainer,
	{
		// summary:
		//		This is a base class for `dijit.tree.dndSource` , and isn't meant to be used directly.
		//		It's based on `dojo.dnd.Selector`.
		// tags:
		//		protected

		/*=====
		// selection: Hash<String, DomNode>
		//		(id, DomNode) map for every TreeNode that's currently selected.
		//		The DOMNode is the TreeNode.rowNode.
		selection: {},
		=====*/

		constructor: function(tree, params){
			// summary:
			//		Initialization
			// tags:
			//		private

			this.selection={};
			this.anchor = null;

			dijit.setWaiState(this.tree.domNode, "multiselect", !this.singular);

			this.events.push(
				dojo.connect(this.tree.domNode, "onmousedown", this,"onMouseDown"),
				dojo.connect(this.tree.domNode, "onmouseup", this,"onMouseUp"),
				dojo.connect(this.tree.domNode, "onmousemove", this,"onMouseMove")
			);
		},

		//	singular: Boolean
		//		Allows selection of only one element, if true.
		//		Tree hasn't been tested in singular=true mode, unclear if it works.
		singular: false,

		// methods
		getSelectedTreeNodes: function(){
			// summary:
			//		Returns a list of selected node(s).
			//		Used by dndSource on the start of a drag.
			// tags:
			//		protected
			var nodes=[], sel = this.selection;
			for(var i in sel){
				nodes.push(sel[i]);
			}
			return nodes;
		},

		selectNone: function(){
			// summary:
			//		Unselects all items
			// tags:
			//		private

			this.setSelection([]);
			return this;	// self
		},

		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected
			this.inherited(arguments);
			this.selection = this.anchor = null;
		},
		addTreeNode: function(/*dijit._TreeNode*/node, /*Boolean?*/isAnchor){
			// summary
			//		add node to current selection
			// node: Node
			//		node to add
			// isAnchor: Boolean
			//		Whether the node should become anchor.

			this.setSelection(this.getSelectedTreeNodes().concat( [node] ));
			if(isAnchor){ this.anchor = node; }
			return node;
		},
		removeTreeNode: function(/*dijit._TreeNode*/node){
			// summary
			//		remove node from current selection
			// node: Node
			//		node to remove
			this.setSelection(this._setDifference(this.getSelectedTreeNodes(), [node]))
			return node;
		},
		isTreeNodeSelected: function(/*dijit._TreeNode*/node){
			// summary
			//		return true if node is currently selected
			// node: Node
			//		the node to check whether it's in the current selection

			return node.id && !!this.selection[node.id];
		},
		setSelection: function(/*dijit._treeNode[]*/ newSelection){
			// summary
			//      set the list of selected nodes to be exactly newSelection. All changes to the
			//      selection should be passed through this function, which ensures that derived
			//      attributes are kept up to date. Anchor will be deleted if it has been removed
			//      from the selection, but no new anchor will be added by this function.
			// newSelection: Node[]
			//      list of tree nodes to make selected
			var oldSelection = this.getSelectedTreeNodes();
			dojo.forEach(this._setDifference(oldSelection, newSelection), dojo.hitch(this, function(node){
				node.setSelected(false);
				if(this.anchor == node){
					delete this.anchor;
				}
				delete this.selection[node.id];
			}));
			dojo.forEach(this._setDifference(newSelection, oldSelection), dojo.hitch(this, function(node){
				node.setSelected(true);
				this.selection[node.id] = node;
			}));
			this._updateSelectionProperties();
		},
		_setDifference: function(xs,ys){
			// summary
			//      Returns a copy of xs which lacks any objects
			//      occurring in ys. Checks for membership by
			//      modifying and then reading the object, so it will
			//      not properly handle sets of numbers or strings.
			
			dojo.forEach(ys, function(y){ y.__exclude__ = true; });
			var ret = dojo.filter(xs, function(x){ return !x.__exclude__; });

			// clean up after ourselves.
			dojo.forEach(ys, function(y){ delete y['__exclude__'] });
			return ret;
		},
		_updateSelectionProperties: function() {
			// summary
			//      Update the following tree properties from the current selection:
			//      path[s], selectedItem[s], selectedNode[s]
			
			var selected = this.getSelectedTreeNodes();
			var paths = [], nodes = [];
			dojo.forEach(selected, function(node) {
				nodes.push(node);
				paths.push(node.getTreePath());
			});
			var items = dojo.map(nodes,function(node) { return node.item; });
			this.tree._set("paths", paths);
			this.tree._set("path", paths[0] || []);
			this.tree._set("selectedNodes", nodes);
			this.tree._set("selectedNode", nodes[0] || null);
			this.tree._set("selectedItems", items);
			this.tree._set("selectedItem", items[0] || null);
		},
		// mouse events
		onMouseDown: function(e){
			// summary:
			//		Event processor for onmousedown
			// e: Event
			//		mouse event
			// tags:
			//		protected

			// ignore click on expando node
			if(!this.current || this.tree.isExpandoNode( e.target, this.current)){ return; }

			if(e.button == dojo.mouseButtons.RIGHT){ return; }	// ignore right-click

			dojo.stopEvent(e);

			var treeNode = this.current,
			  copy = dojo.isCopyKey(e), id = treeNode.id;

			// if shift key is not pressed, and the node is already in the selection,
			// delay deselection until onmouseup so in the case of DND, deselection
			// will be canceled by onmousemove.
			if(!this.singular && !e.shiftKey && this.selection[id]){
				this._doDeselect = true;
				return;
			}else{
				this._doDeselect = false;
			}
			this.userSelect(treeNode, copy, e.shiftKey);
		},

		onMouseUp: function(e){
			// summary:
			//		Event processor for onmouseup
			// e: Event
			//		mouse event
			// tags:
			//		protected

			// _doDeselect is the flag to indicate that the user wants to either ctrl+click on
			// a already selected item (to deselect the item), or click on a not-yet selected item
			// (which should remove all current selection, and add the clicked item). This can not
			// be done in onMouseDown, because the user may start a drag after mousedown. By moving
			// the deselection logic here, the user can drags an already selected item.
			if(!this._doDeselect){ return; }
			this._doDeselect = false;
			this.userSelect(this.current, dojo.isCopyKey( e ), e.shiftKey);
		},
		onMouseMove: function(e){
			// summary
			//		event processor for onmousemove
			// e: Event
			//		mouse event
			this._doDeselect = false;
		},

		userSelect: function(node, multi, range){
			// summary:
			//		Add or remove the given node from selection, responding
			//      to a user action such as a click or keypress.
			// multi: Boolean
			//		Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)
			// range: Boolean
			//		Indicates whether this is meant to be a ranged action (e.g. shift-click)
			// tags:
			//		protected

			if(this.singular){
				if(this.anchor == node && multi){
					this.selectNone();
				}else{
					this.setSelection([node]);
					this.anchor = node;
				}
			}else{
				if(range && this.anchor){
					var cr = dijit.tree._compareNodes(this.anchor.rowNode, node.rowNode),
					begin, end, anchor = this.anchor;
					
					if(cr < 0){ //current is after anchor
						begin = anchor;
						end = node;
					}else{ //current is before anchor
						begin = node;
						end = anchor;
					}
					nodes = [];
					//add everything betweeen begin and end inclusively
					while(begin != end) {
						nodes.push(begin)
						begin = this.tree._getNextNode(begin);
					}
					nodes.push(end)

					this.setSelection(nodes);
				}else{
				    if( this.selection[ node.id ] && multi ) {
						this.removeTreeNode( node );
				    } else if(multi) {
						this.addTreeNode(node, true);
					} else {
						this.setSelection([node]);
						this.anchor = node;
				    }
				}
			}
		},

		forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
			// summary:
			//		Iterates over selected items;
			//		see `dojo.dnd.Container.forInItems()` for details
			o = o || dojo.global;
			for(var id in this.selection){
				// console.log("selected item id: " + id);
				f.call(o, this.getItem(id), id, this);
			}
		}
});

}

if(!dojo._hasResource["dijit.Tree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tree"] = true;
dojo.provide("dijit.Tree");













dojo.declare(
	"dijit._TreeNode",
	[dijit._Widget, dijit._Templated, dijit._Container, dijit._Contained, dijit._CssStateMixin],
{
	// summary:
	//		Single node within a tree.   This class is used internally
	//		by Tree and should not be accessed directly.
	// tags:
	//		private

	// item: [const] dojo.data.Item
	//		the dojo.data entry this tree represents
	item: null,

	// isTreeNode: [protected] Boolean
	//		Indicates that this is a TreeNode.   Used by `dijit.Tree` only,
	//		should not be accessed directly.
	isTreeNode: true,

	// label: String
	//		Text of this tree node
	label: "",

	// isExpandable: [private] Boolean
	//		This node has children, so show the expando node (+ sign)
	isExpandable: null,

	// isExpanded: [readonly] Boolean
	//		This node is currently expanded (ie, opened)
	isExpanded: false,

	// state: [private] String
	//		Dynamic loading-related stuff.
	//		When an empty folder node appears, it is "UNCHECKED" first,
	//		then after dojo.data query it becomes "LOADING" and, finally "LOADED"
	state: "UNCHECKED",

	templateString: dojo.cache("dijit", "templates/TreeNode.html", "<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div dojoAttachPoint=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\" dojoAttachEvent=\"onmouseenter:_onMouseEnter, onmouseleave:_onMouseLeave, onclick:_onClick, ondblclick:_onDblClick\"\n\t\t><img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"expandoNode\" class=\"dijitTreeExpando\" role=\"presentation\"\n\t\t/><span dojoAttachPoint=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"\n\t\t></span\n\t\t><span dojoAttachPoint=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"iconNode\" class=\"dijitIcon dijitTreeIcon\" role=\"presentation\"\n\t\t\t/><span dojoAttachPoint=\"labelNode\" class=\"dijitTreeLabel\" role=\"treeitem\" tabindex=\"-1\" aria-selected=\"false\" dojoAttachEvent=\"onfocus:_onLabelFocus\"></span>\n\t\t</span\n\t></div>\n\t<div dojoAttachPoint=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\" style=\"display: none;\"></div>\n</div>\n"),

	baseClass: "dijitTreeNode",

	// For hover effect for tree node, and focus effect for label
	cssStateNodes: {
		rowNode: "dijitTreeRow",
		labelNode: "dijitTreeLabel"
	},

	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		label: {node: "labelNode", type: "innerText"},
		tooltip: {node: "rowNode", type: "attribute", attribute: "title"}
	}),

	buildRendering: function(){
		this.inherited(arguments);

		// set expand icon for leaf
		this._setExpando();

		// set icon and label class based on item
		this._updateItemClasses(this.item);

		if(this.isExpandable){
			dijit.setWaiState(this.labelNode, "expanded", this.isExpanded);
		}

		//aria-selected should be false on all selectable elements.
		this.setSelected(false);
	},

	_setIndentAttr: function(indent){
		// summary:
		//		Tell this node how many levels it should be indented
		// description:
		//		0 for top level nodes, 1 for their children, 2 for their
		//		grandchildren, etc.

		// Math.max() is to prevent negative padding on hidden root node (when indent == -1)
		var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";

		dojo.style(this.domNode, "backgroundPosition",	pixels + " 0px");
		dojo.style(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);

		dojo.forEach(this.getChildren(), function(child){
			child.set("indent", indent+1);
		});
		
		this._set("indent", indent);
	},

	markProcessing: function(){
		// summary:
		//		Visually denote that tree is loading data, etc.
		// tags:
		//		private
		this.state = "LOADING";
		this._setExpando(true);
	},

	unmarkProcessing: function(){
		// summary:
		//		Clear markup from markProcessing() call
		// tags:
		//		private
		this._setExpando(false);
	},

	_updateItemClasses: function(item){
		// summary:
		//		Set appropriate CSS classes for icon and label dom node
		//		(used to allow for item updates to change respective CSS)
		// tags:
		//		private
		var tree = this.tree, model = tree.model;
		if(tree._v10Compat && item === model.root){
			// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)
			item = null;
		}
		this._applyClassAndStyle(item, "icon", "Icon");
		this._applyClassAndStyle(item, "label", "Label");
		this._applyClassAndStyle(item, "row", "Row");
	},

	_applyClassAndStyle: function(item, lower, upper){
		// summary:
		//		Set the appropriate CSS classes and styles for labels, icons and rows.
		//
		// item:
		//		The data item.
		//
		// lower:
		//		The lower case attribute to use, e.g. 'icon', 'label' or 'row'.
		//
		// upper:
		//		The upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.
		//
		// tags:
		//		private

		var clsName = "_" + lower + "Class";
		var nodeName = lower + "Node";
		var oldCls = this[clsName];

		this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
		dojo.replaceClass(this[nodeName], this[clsName] || "", oldCls || "");
 
		dojo.style(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
 	},

	_updateLayout: function(){
		// summary:
		//		Set appropriate CSS classes for this.domNode
		// tags:
		//		private
		var parent = this.getParent();
		if(!parent || parent.rowNode.style.display == "none"){
			/* if we are hiding the root node then make every first level child look like a root node */
			dojo.addClass(this.domNode, "dijitTreeIsRoot");
		}else{
			dojo.toggleClass(this.domNode, "dijitTreeIsLast", !this.getNextSibling());
		}
	},

	_setExpando: function(/*Boolean*/ processing){
		// summary:
		//		Set the right image for the expando node
		// tags:
		//		private

		var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened",
						"dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"],
			_a11yStates = ["*","-","+","*"],
			idx = processing ? 0 : (this.isExpandable ?	(this.isExpanded ? 1 : 2) : 3);

		// apply the appropriate class to the expando node
		dojo.replaceClass(this.expandoNode, styles[idx], styles);

		// provide a non-image based indicator for images-off mode
		this.expandoNodeText.innerHTML = _a11yStates[idx];

	},

	expand: function(){
		// summary:
		//		Show my children
		// returns:
		//		Deferred that fires when expansion is complete

		// If there's already an expand in progress or we are already expanded, just return
		if(this._expandDeferred){
			return this._expandDeferred;		// dojo.Deferred
		}

		// cancel in progress collapse operation
		this._wipeOut && this._wipeOut.stop();

		// All the state information for when a node is expanded, maybe this should be
		// set when the animation completes instead
		this.isExpanded = true;
		dijit.setWaiState(this.labelNode, "expanded", "true");
		if(this.tree.showRoot || this !== this.tree.rootNode){
			dijit.setWaiRole(this.containerNode, "group");
		}
		dojo.addClass(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);
		if(this == this.tree.rootNode){
			dijit.setWaiState(this.tree.domNode, "expanded", "true");
		}

		var def,
			wipeIn = dojo.fx.wipeIn({
				node: this.containerNode, duration: dijit.defaultDuration,
				onEnd: function(){
					def.callback(true);
				}
			});

		// Deferred that fires when expand is complete
		def = (this._expandDeferred = new dojo.Deferred(function(){
			// Canceller
			wipeIn.stop();
		}));

		wipeIn.play();

		return def;		// dojo.Deferred
	},

	collapse: function(){
		// summary:
		//		Collapse this node (if it's expanded)

		if(!this.isExpanded){ return; }

		// cancel in progress expand operation
		if(this._expandDeferred){
			this._expandDeferred.cancel();
			delete this._expandDeferred;
		}

		this.isExpanded = false;
		dijit.setWaiState(this.labelNode, "expanded", "false");
		if(this == this.tree.rootNode){
			dijit.setWaiState(this.tree.domNode, "expanded", "false");
		}
		dojo.removeClass(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);

		if(!this._wipeOut){
			this._wipeOut = dojo.fx.wipeOut({
				node: this.containerNode, duration: dijit.defaultDuration
			});
		}
		this._wipeOut.play();
	},

	// indent: Integer
	//		Levels from this node to the root node
	indent: 0,

	setChildItems: function(/* Object[] */ items){
		// summary:
		//		Sets the child items of this node, removing/adding nodes
		//		from current children to match specified items[] array.
		//		Also, if this.persist == true, expands any children that were previously
		// 		opened.
		// returns:
		//		Deferred object that fires after all previously opened children
		//		have been expanded again (or fires instantly if there are no such children).

		var tree = this.tree,
			model = tree.model,
			defs = [];	// list of deferreds that need to fire before I am complete


		// Orphan all my existing children.
		// If items contains some of the same items as before then we will reattach them.
		// Don't call this.removeChild() because that will collapse the tree etc.
		dojo.forEach(this.getChildren(), function(child){
			dijit._Container.prototype.removeChild.call(this, child);
		}, this);

		this.state = "LOADED";

		if(items && items.length > 0){
			this.isExpandable = true;

			// Create _TreeNode widget for each specified tree node, unless one already
			// exists and isn't being used (presumably it's from a DnD move and was recently
			// released
			dojo.forEach(items, function(item){
				var id = model.getIdentity(item),
					existingNodes = tree._itemNodesMap[id],
					node;
				if(existingNodes){
					for(var i=0;i<existingNodes.length;i++){
						if(existingNodes[i] && !existingNodes[i].getParent()){
							node = existingNodes[i];
							node.set('indent', this.indent+1);
							break;
						}
					}
				}
				if(!node){
					node = this.tree._createTreeNode({
							item: item,
							tree: tree,
							isExpandable: model.mayHaveChildren(item),
							label: tree.getLabel(item),
							tooltip: tree.getTooltip(item),
							dir: tree.dir,
							lang: tree.lang,
							indent: this.indent + 1
						});
					if(existingNodes){
						existingNodes.push(node);
					}else{
						tree._itemNodesMap[id] = [node];
					}
				}
				this.addChild(node);

				// If node was previously opened then open it again now (this may trigger
				// more data store accesses, recursively)
				if(this.tree.autoExpand || this.tree._state(item)){
					defs.push(tree._expandNode(node));
				}
			}, this);

			// note that updateLayout() needs to be called on each child after
			// _all_ the children exist
			dojo.forEach(this.getChildren(), function(child, idx){
				child._updateLayout();
			});
		}else{
			this.isExpandable=false;
		}

		if(this._setExpando){
			// change expando to/from dot or + icon, as appropriate
			this._setExpando(false);
		}

		// Set leaf icon or folder icon, as appropriate
		this._updateItemClasses(this.item);

		// On initial tree show, make the selected TreeNode as either the root node of the tree,
		// or the first child, if the root node is hidden
		if(this == tree.rootNode){
			var fc = this.tree.showRoot ? this : this.getChildren()[0];
			if(fc){
				fc.setFocusable(true);
				tree.lastFocused = fc;
			}else{
				// fallback: no nodes in tree so focus on Tree <div> itself
				tree.domNode.setAttribute("tabIndex", "0");
			}
		}

		return new dojo.DeferredList(defs);	// dojo.Deferred
	},

	getTreePath: function(){
		var node = this;
		var path = [];
		while(node && node !== this.tree.rootNode){
				path.unshift(node.item);
				node = node.getParent();
		}
		path.unshift(this.tree.rootNode.item);

		return path;
	},

	getIdentity: function() {
		return this.tree.model.getIdentity(this.item);
	},

	removeChild: function(/* treeNode */ node){
		this.inherited(arguments);

		var children = this.getChildren();
		if(children.length == 0){
			this.isExpandable = false;
			this.collapse();
		}

		dojo.forEach(children, function(child){
				child._updateLayout();
		});
	},

	makeExpandable: function(){
		// summary:
		//		if this node wasn't already showing the expando node,
		//		turn it into one and call _setExpando()

		// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0

		this.isExpandable = true;
		this._setExpando(false);
	},

	_onLabelFocus: function(evt){
		// summary:
		//		Called when this row is focused (possibly programatically)
		//		Note that we aren't using _onFocus() builtin to dijit
		//		because it's called when focus is moved to a descendant TreeNode.
		// tags:
		//		private
		this.tree._onNodeFocus(this);
	},

	setSelected: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) currently selected node.
		//		Mark that this node is/isn't that currently selected node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).
		dijit.setWaiState(this.labelNode, "selected", selected);
		dojo.toggleClass(this.rowNode, "dijitTreeRowSelected", selected);
	},

	setFocusable: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) node that's focusable.
		//		Mark that this node is/isn't that currently focsuable node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).

		this.labelNode.setAttribute("tabIndex", selected ? "0" : "-1");
	},

	_onClick: function(evt){
		// summary:
		//		Handler for onclick event on a node
		// tags:
		//		private
		this.tree._onClick(this, evt);
	},
	_onDblClick: function(evt){
		// summary:
		//		Handler for ondblclick event on a node
		// tags:
		//		private
		this.tree._onDblClick(this, evt);
	},

	_onMouseEnter: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseEnter(this, evt);
	},

	_onMouseLeave: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseLeave(this, evt);
	}
});

dojo.declare(
	"dijit.Tree",
	[dijit._Widget, dijit._Templated],
{
	// summary:
	//		This widget displays hierarchical data from a store.

	// store: [deprecated] String||dojo.data.Store
	//		Deprecated.  Use "model" parameter instead.
	//		The store to get data to display in the tree.
	store: null,

	// model: dijit.Tree.model
	//		Interface to read tree data, get notifications of changes to tree data,
	//		and for handling drop operations (i.e drag and drop onto the tree)
	model: null,

	// query: [deprecated] anything
	//		Deprecated.  User should specify query to the model directly instead.
	//		Specifies datastore query to return the root item or top items for the tree.
	query: null,

	// label: [deprecated] String
	//		Deprecated.  Use dijit.tree.ForestStoreModel directly instead.
	//		Used in conjunction with query parameter.
	//		If a query is specified (rather than a root node id), and a label is also specified,
	//		then a fake root node is created and displayed, with this label.
	label: "",

	// showRoot: [const] Boolean
	//		Should the root node be displayed, or hidden?
	showRoot: true,

	// childrenAttr: [deprecated] String[]
	//		Deprecated.   This information should be specified in the model.
	//		One ore more attributes that holds children of a tree node
	childrenAttr: ["children"],

	// paths: String[][] or Item[][]
	//		Full paths from rootNode to selected nodes expressed as array of items or array of ids.
	//		Since setting the paths may be asynchronous (because ofwaiting on dojo.data), set("paths", ...)
	//		returns a Deferred to indicate when the set is complete.
	paths: [],
	
	// path: String[] or Item[]
	//      Backward compatible singular variant of paths.
	path: [],

	// selectedItems: [readonly] Item[]
	//		The currently selected items in this tree.
	//		This property can only be set (via set('selectedItems', ...)) when that item is already
	//		visible in the tree.   (I.e. the tree has already been expanded to show that node.)
	//		Should generally use `paths` attribute to set the selected items instead.
	selectedItems: null,

	// selectedItem: [readonly] Item
	//      Backward compatible singular variant of selectedItems.
	selectedItem: null,

	// openOnClick: Boolean
	//		If true, clicking a folder node's label will open it, rather than calling onClick()
	openOnClick: false,

	// openOnDblClick: Boolean
	//		If true, double-clicking a folder node's label will open it, rather than calling onDblClick()
	openOnDblClick: false,

	templateString: dojo.cache("dijit", "templates/Tree.html", "<div class=\"dijitTree dijitTreeContainer\" role=\"tree\"\n\tdojoAttachEvent=\"onkeypress:_onKeyPress\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" dojoAttachPoint=\"indentDetector\"></div>\n</div>\n"),

	// persist: Boolean
	//		Enables/disables use of cookies for state saving.
	persist: true,

	// autoExpand: Boolean
	//		Fully expand the tree on load.   Overrides `persist`.
	autoExpand: false,

	// dndController: [protected] String
	//		Class name to use as as the dnd controller.  Specifying this class enables DnD.
	//		Generally you should specify this as "dijit.tree.dndSource".
	//      Default of "dijit.tree._dndSelector" handles selection only (no actual DnD).
	dndController: "dijit.tree._dndSelector",

	// parameters to pull off of the tree and pass on to the dndController as its params
	dndParams: ["onDndDrop","itemCreator","onDndCancel","checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"],

	//declare the above items so they can be pulled from the tree's markup

	// onDndDrop: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndDrop`.
	//		Generally this doesn't need to be set.
	onDndDrop: null,

	/*=====
	itemCreator: function(nodes, target, source){
		// summary:
		//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
		//		dropped onto the tree.   Developer must override this method to enable
		// 		dropping from external sources onto this Tree, unless the Tree.model's items
		//		happen to look like {id: 123, name: "Apple" } with no other attributes.
		// description:
		//		For each node in nodes[], which came from source, create a hash of name/value
		//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
		// nodes: DomNode[]
		//		The DOMNodes dragged from the source container
		// target: DomNode
		//		The target TreeNode.rowNode
		// source: dojo.dnd.Source
		//		The source container the nodes were dragged from, perhaps another Tree or a plain dojo.dnd.Source
		// returns: Object[]
		//		Array of name/value hashes for each new item to be added to the Tree, like:
		// |	[
		// |		{ id: 123, label: "apple", foo: "bar" },
		// |		{ id: 456, label: "pear", zaz: "bam" }
		// |	]
		// tags:
		//		extension
		return [{}];
	},
	=====*/
	itemCreator: null,

	// onDndCancel: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndCancel`.
	//		Generally this doesn't need to be set.
	onDndCancel: null,

/*=====
	checkAcceptance: function(source, nodes){
		// summary:
		//		Checks if the Tree itself can accept nodes from this source
		// source: dijit.tree._dndSource
		//		The source which provides items
		// nodes: DOMNode[]
		//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
		//		source is a dijit.Tree.
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkAcceptance: null,

/*=====
	checkItemAcceptance: function(target, source, position){
		// summary:
		//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
		// description:
		//		In the base case, this is called to check if target can become a child of source.
		//		When betweenThreshold is set, position="before" or "after" means that we
		//		are asking if the source node can be dropped before/after the target node.
		// target: DOMNode
		//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
		//		Use dijit.getEnclosingWidget(target) to get the TreeNode.
		// source: dijit.tree.dndSource
		//		The (set of) nodes we are dropping
		// position: String
		//		"over", "before", or "after"
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkItemAcceptance: null,

	// dragThreshold: Integer
	//		Number of pixels mouse moves before it's considered the start of a drag operation
	dragThreshold: 5,

	// betweenThreshold: Integer
	//		Set to a positive value to allow drag and drop "between" nodes.
	//
	//		If during DnD mouse is over a (target) node but less than betweenThreshold
	//		pixels from the bottom edge, dropping the the dragged node will make it
	//		the next sibling of the target node, rather than the child.
	//
	//		Similarly, if mouse is over a target node but less that betweenThreshold
	//		pixels from the top edge, dropping the dragged node will make it
	//		the target node's previous sibling rather than the target node's child.
	betweenThreshold: 0,

	// _nodePixelIndent: Integer
	//		Number of pixels to indent tree nodes (relative to parent node).
	//		Default is 19 but can be overridden by setting CSS class dijitTreeIndent
	//		and calling resize() or startup() on tree after it's in the DOM.
	_nodePixelIndent: 19,

	_publish: function(/*String*/ topicName, /*Object*/ message){
		// summary:
		//		Publish a message for this widget/topic
		dojo.publish(this.id, [dojo.mixin({tree: this, event: topicName}, message || {})]);
	},

	postMixInProperties: function(){
		this.tree = this;

		if(this.autoExpand){
			// There's little point in saving opened/closed state of nodes for a Tree
			// that initially opens all it's nodes.
			this.persist = false;
		}

		this._itemNodesMap={};

		if(!this.cookieName){
			this.cookieName = this.id + "SaveStateCookie";
		}

		this._loadDeferred = new dojo.Deferred();

		this.inherited(arguments);
	},

	postCreate: function(){
		this._initState();

		// Create glue between store and Tree, if not specified directly by user
		if(!this.model){
			this._store2model();
		}

		// monitor changes to items
		this.connect(this.model, "onChange", "_onItemChange");
		this.connect(this.model, "onChildrenChange", "_onItemChildrenChange");
		this.connect(this.model, "onDelete", "_onItemDelete");

		this._load();

		this.inherited(arguments);

		if(this.dndController){
			if(dojo.isString(this.dndController)){
				this.dndController = dojo.getObject(this.dndController);
			}
			var params={};
			for(var i=0; i<this.dndParams.length;i++){
				if(this[this.dndParams[i]]){
					params[this.dndParams[i]] = this[this.dndParams[i]];
				}
			}
			this.dndController = new this.dndController(this, params);
		}
	},

	_store2model: function(){
		// summary:
		//		User specified a store&query rather than model, so create model from store/query
		this._v10Compat = true;
		dojo.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");

		var modelParams = {
			id: this.id + "_ForestStoreModel",
			store: this.store,
			query: this.query,
			childrenAttrs: this.childrenAttr
		};

		// Only override the model's mayHaveChildren() method if the user has specified an override
		if(this.params.mayHaveChildren){
			modelParams.mayHaveChildren = dojo.hitch(this, "mayHaveChildren");
		}

		if(this.params.getItemChildren){
			modelParams.getChildren = dojo.hitch(this, function(item, onComplete, onError){
				this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
			});
		}
		this.model = new dijit.tree.ForestStoreModel(modelParams);

		// For backwards compatibility, the visibility of the root node is controlled by
		// whether or not the user has specified a label
		this.showRoot = Boolean(this.label);
	},

	onLoad: function(){
		// summary:
		//		Called when tree finishes loading and expanding.
		// description:
		//		If persist == true the loading may encompass many levels of fetches
		//		from the data store, each asynchronous.   Waits for all to finish.
		// tags:
		//		callback
	},

	_load: function(){
		// summary:
		//		Initial load of the tree.
		//		Load root node (possibly hidden) and it's children.
		this.model.getRoot(
			dojo.hitch(this, function(item){
				var rn = (this.rootNode = this.tree._createTreeNode({
					item: item,
					tree: this,
					isExpandable: true,
					label: this.label || this.getLabel(item),
					indent: this.showRoot ? 0 : -1
				}));
				if(!this.showRoot){
					rn.rowNode.style.display="none";
					// if root is not visible, move tree role to the invisible
					// root node's containerNode, see #12135
					dijit.setWaiRole(this.domNode, 'presentation');
					
					dijit.setWaiRole(rn.labelNode, 'presentation');
					dijit.setWaiRole(rn.containerNode, 'tree');
				}
				this.domNode.appendChild(rn.domNode);
				var identity = this.model.getIdentity(item);
				if(this._itemNodesMap[identity]){
					this._itemNodesMap[identity].push(rn);
				}else{
					this._itemNodesMap[identity] = [rn];
				}

				rn._updateLayout();		// sets "dijitTreeIsRoot" CSS classname

				// load top level children and then fire onLoad() event
				this._expandNode(rn).addCallback(dojo.hitch(this, function(){
					this._loadDeferred.callback(true);
					this.onLoad();
				}));
			}),
			function(err){
				console.error(this, ": error loading root: ", err);
			}
		);
	},

	getNodesByItem: function(/*dojo.data.Item or id*/ item){
		// summary:
		//		Returns all tree nodes that refer to an item
		// returns:
		//		Array of tree nodes that refer to passed item

		if(!item){ return []; }
		var identity = dojo.isString(item) ? item : this.model.getIdentity(item);
		// return a copy so widget don't get messed up by changes to returned array
		return [].concat(this._itemNodesMap[identity]);
	},

	_setSelectedItemAttr: function(/*dojo.data.Item or id*/ item){
		this.set('selectedItems', [item]);
	},

	_setSelectedItemsAttr: function(/*dojo.data.Items or ids*/ items){
		// summary:
		//		Select tree nodes related to passed items.
		//		WARNING: if model use multi-parented items or desired tree node isn't already loaded
		//		behavior is undefined. Use set('paths', ...) instead.
		var tree = this;
		this._loadDeferred.addCallback( dojo.hitch(this, function(){
			var identities = dojo.map(items, function(item){
				return (!item || dojo.isString(item)) ? item : tree.model.getIdentity(item);
			});
			var nodes = [];
			dojo.forEach(identities, function(id){
				nodes = nodes.concat(tree._itemNodesMap[id] || []);
			});
			this.set('selectedNodes', nodes);
		}));
	},

	_setPathAttr: function(/*Item[] || String[]*/ path){
		// summary:
		//      Singular variant of _setPathsAttr
		if(path.length) {
			return this.set("paths", [path]);
		} else {
			//Empty list is interpreted as "select nothing"
			return this.set("paths", []);
		}
	},
	
	_setPathsAttr: function(/*Item[][] || String[][]*/ paths){
		// summary:
		//		Select the tree nodes identified by passed paths.
		// paths:
		//		Array of arrays of items or item id's
		// returns:
		//		Deferred to indicate when the set is complete
		var tree = this;

		// We may need to wait for some nodes to expand, so setting
		// each path will involve a Deferred. We bring those deferreds
		// together witha DeferredList.
		return new dojo.DeferredList(dojo.map(paths, function(path){
			var d = new dojo.Deferred();
			
			// normalize path to use identity
			path = dojo.map(path, function(item){
				return dojo.isString(item) ? item : tree.model.getIdentity(item);
			});

			if(path.length){
				// Wait for the tree to load, if it hasn't already.
				tree._loadDeferred.addCallback(function(){ selectPath(path, [tree.rootNode], d); });
			}else{
				d.errback("Empty path");
			}
			return d;
		})).addCallback(setNodes);

		function selectPath(path, nodes, def){
			// Traverse path; the next path component should be among "nodes".
			var nextPath = path.shift();
			var nextNode = dojo.filter(nodes, function(node){
				return node.getIdentity() == nextPath;
			})[0];
			if(!!nextNode){
				if(path.length){
					tree._expandNode(nextNode).addCallback(function(){ selectPath(path, nextNode.getChildren(), def); });
				}else{
					//Successfully reached the end of this path
					def.callback(nextNode);
				}
			} else {
				def.errback("Could not expand path at " + nextPath);
			}
		}
		
		function setNodes(newNodes){
			//After all expansion is finished, set the selection to
			//the set of nodes successfully found.
			tree.set("selectedNodes", dojo.map(
				dojo.filter(newNodes,function(x){return x[0];}),
				function(x){return x[1];}));
		}
	},

	_setSelectedNodeAttr: function(node){
		this.set('selectedNodes', [node]);
	},
	_setSelectedNodesAttr: function(nodes){
		this._loadDeferred.addCallback( dojo.hitch(this, function(){
			this.dndController.setSelection(nodes);
		}));
	},


	////////////// Data store related functions //////////////////////
	// These just get passed to the model; they are here for back-compat

	mayHaveChildren: function(/*dojo.data.Item*/ item){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		//		Overridable function to tell if an item has or may have children.
		//		Controls whether or not +/- expando icon is shown.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		deprecated
	},

	getItemChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		// 		Overridable function that return array of child items of given parent item,
		//		or if parentItem==null then return top items in tree
		// tags:
		//		deprecated
	},

	///////////////////////////////////////////////////////
	// Functions for converting an item to a TreeNode
	getLabel: function(/*dojo.data.Item*/ item){
		// summary:
		//		Overridable function to get the label for a tree node (given the item)
		// tags:
		//		extension
		return this.model.getLabel(item);	// String
	},

	getIconClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display icon
		// tags:
		//		extension
		return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf"
	},

	getLabelClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display label
		// tags:
		//		extension
	},

	getRowClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display row
		// tags:
		//		extension
	},

	getIconStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display icon
		// returns:
		//		Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}
		// tags:
		//		extension
	},

	getLabelStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display label
		// returns:
		//		Object suitable for input to dojo.style() like {color: "red", background: "green"}
		// tags:
		//		extension
	},

	getRowStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display row
		// returns:
		//		Object suitable for input to dojo.style() like {background-color: "#bbb"}
		// tags:
		//		extension
	},

	getTooltip: function(/*dojo.data.Item*/ item){
		// summary:
		//		Overridable function to get the tooltip for a tree node (given the item)
		// tags:
		//		extension
		return "";	// String
	},

	/////////// Keyboard and Mouse handlers ////////////////////

	_onKeyPress: function(/*Event*/ e){
		// summary:
		//		Translates keypress events into commands for the controller
		if(e.altKey){ return; }
		var dk = dojo.keys;
		var treeNode = dijit.getEnclosingWidget(e.target);
		if(!treeNode){ return; }

		var key = e.charOrCode;
		if(typeof key == "string" && key != " "){	// handle printables (letter navigation)
			// Check for key navigation.
			if(!e.altKey && !e.ctrlKey && !e.shiftKey && !e.metaKey){
				this._onLetterKeyNav( { node: treeNode, key: key.toLowerCase() } );
				dojo.stopEvent(e);
			}
		}else{	// handle non-printables (arrow keys)
			// clear record of recent printables (being saved for multi-char letter navigation),
			// because "a", down-arrow, "b" shouldn't search for "ab"
			if(this._curSearch){
				clearTimeout(this._curSearch.timer);
				delete this._curSearch;
			}

			var map = this._keyHandlerMap;
			if(!map){
				// setup table mapping keys to events
				map = {};
				map[dk.ENTER]="_onEnterKey";
				//On WebKit based browsers, the combination ctrl-enter
				//does not get passed through. To allow accessible
				//multi-select on those browsers, the space key is
				//also used for selection.
				map[dk.SPACE]= map[" "] = "_onEnterKey";
				map[this.isLeftToRight() ? dk.LEFT_ARROW : dk.RIGHT_ARROW]="_onLeftArrow";
				map[this.isLeftToRight() ? dk.RIGHT_ARROW : dk.LEFT_ARROW]="_onRightArrow";
				map[dk.UP_ARROW]="_onUpArrow";
				map[dk.DOWN_ARROW]="_onDownArrow";
				map[dk.HOME]="_onHomeKey";
				map[dk.END]="_onEndKey";
				this._keyHandlerMap = map;
			}
			if(this._keyHandlerMap[key]){
				this[this._keyHandlerMap[key]]( { node: treeNode, item: treeNode.item, evt: e } );
				dojo.stopEvent(e);
			}
		}
	},

	_onEnterKey: function(/*Object*/ message){
		this._publish("execute", { item: message.item, node: message.node } );
		this.dndController.userSelect(message.node, dojo.isCopyKey( message.evt ), message.evt.shiftKey);
		this.onClick(message.item, message.node, message.evt);
	},

	_onDownArrow: function(/*Object*/ message){
		// summary:
		//		down arrow pressed; get next visible node, set focus there
		var node = this._getNextNode(message.node);
		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onUpArrow: function(/*Object*/ message){
		// summary:
		//		Up arrow pressed; move to previous visible node

		var node = message.node;

		// if younger siblings
		var previousSibling = node.getPreviousSibling();
		if(previousSibling){
			node = previousSibling;
			// if the previous node is expanded, dive in deep
			while(node.isExpandable && node.isExpanded && node.hasChildren()){
				// move to the last child
				var children = node.getChildren();
				node = children[children.length-1];
			}
		}else{
			// if this is the first child, return the parent
			// unless the parent is the root of a tree with a hidden root
			var parent = node.getParent();
			if(!(!this.showRoot && parent === this.rootNode)){
				node = parent;
			}
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onRightArrow: function(/*Object*/ message){
		// summary:
		//		Right arrow pressed; go to child node
		var node = message.node;

		// if not expanded, expand, else move to 1st child
		if(node.isExpandable && !node.isExpanded){
			this._expandNode(node);
		}else if(node.hasChildren()){
			node = node.getChildren()[0];
			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		}
	},

	_onLeftArrow: function(/*Object*/ message){
		// summary:
		//		Left arrow pressed.
		//		If not collapsed, collapse, else move to parent.

		var node = message.node;

		if(node.isExpandable && node.isExpanded){
			this._collapseNode(node);
		}else{
			var parent = node.getParent();
			if(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){
				this.focusNode(parent);
			}
		}
	},

	_onHomeKey: function(){
		// summary:
		//		Home key pressed; get first visible node, and set focus there
		var node = this._getRootOrFirstNode();
		if(node){
			this.focusNode(node);
		}
	},

	_onEndKey: function(/*Object*/ message){
		// summary:
		//		End key pressed; go to last visible node.

		var node = this.rootNode;
		while(node.isExpanded){
			var c = node.getChildren();
			node = c[c.length - 1];
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	// multiCharSearchDuration: Number
	//		If multiple characters are typed where each keystroke happens within
	//		multiCharSearchDuration of the previous keystroke,
	//		search for nodes matching all the keystrokes.
	//
	//		For example, typing "ab" will search for entries starting with
	//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
	multiCharSearchDuration: 250,

	_onLetterKeyNav: function(message){
		// summary:
		//		Called when user presses a prinatable key; search for node starting with recently typed letters.
		// message: Object
		//		Like { node: TreeNode, key: 'a' } where key is the key the user pressed.

		// Branch depending on whether this key starts a new search, or modifies an existing search
		var cs = this._curSearch;
		if(cs){
			// We are continuing a search.  Ex: user has pressed 'a', and now has pressed
			// 'b', so we want to search for nodes starting w/"ab".
			cs.pattern = cs.pattern + message.key;
			clearTimeout(cs.timer);
		}else{
			// We are starting a new search
			cs = this._curSearch = {
					pattern: message.key,
					startNode: message.node
			};
		}

		// set/reset timer to forget recent keystrokes
		var self = this;
		cs.timer = setTimeout(function(){
			delete self._curSearch;
		}, this.multiCharSearchDuration);

		// Navigate to TreeNode matching keystrokes [entered so far].
		var node = cs.startNode;
		do{
			node = this._getNextNode(node);
			//check for last node, jump to first node if necessary
			if(!node){
				node = this._getRootOrFirstNode();
			}
		}while(node !== cs.startNode && (node.label.toLowerCase().substr(0, cs.pattern.length) != cs.pattern));
		if(node && node.isTreeNode){
			// no need to set focus if back where we started
			if(node !== cs.startNode){
				this.focusNode(node);
			}
		}
	},

	isExpandoNode: function(node, widget){
		// summary:
		//		check whether a dom node is the expandoNode for a particular TreeNode widget
		return dojo.isDescendant(node, widget.expandoNode);
	},
	_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

		if( (this.openOnClick && nodeWidget.isExpandable) || isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		dojo.stopEvent(e);
	},
	_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates double-click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = (domElement == nodeWidget.expandoNode || domElement == nodeWidget.expandoNodeText);

		if( (this.openOnDblClick && nodeWidget.isExpandable) ||isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onDblClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		dojo.stopEvent(e);
	},

	_onExpandoClick: function(/*Object*/ message){
		// summary:
		//		User clicked the +/- icon; expand or collapse my children.
		var node = message.node;

		// If we are collapsing, we might be hiding the currently focused node.
		// Also, clicking the expando node might have erased focus from the current node.
		// For simplicity's sake just focus on the node with the expando.
		this.focusNode(node);

		if(node.isExpanded){
			this._collapseNode(node);
		}else{
			this._expandNode(node);
		}
	},

	onClick: function(/* dojo.data */ item, /*TreeNode*/ node, /*Event*/ evt){
		// summary:
		//		Callback when a tree node is clicked
		// tags:
		//		callback
	},
	onDblClick: function(/* dojo.data */ item, /*TreeNode*/ node, /*Event*/ evt){
		// summary:
		//		Callback when a tree node is double-clicked
		// tags:
		//		callback
	},
	onOpen: function(/* dojo.data */ item, /*TreeNode*/ node){
		// summary:
		//		Callback when a node is opened
		// tags:
		//		callback
	},
	onClose: function(/* dojo.data */ item, /*TreeNode*/ node){
		// summary:
		//		Callback when a node is closed
		// tags:
		//		callback
	},

	_getNextNode: function(node){
		// summary:
		//		Get next visible node

		if(node.isExpandable && node.isExpanded && node.hasChildren()){
			// if this is an expanded node, get the first child
			return node.getChildren()[0];		// _TreeNode
		}else{
			// find a parent node with a sibling
			while(node && node.isTreeNode){
				var returnNode = node.getNextSibling();
				if(returnNode){
					return returnNode;		// _TreeNode
				}
				node = node.getParent();
			}
			return null;
		}
	},

	_getRootOrFirstNode: function(){
		// summary:
		//		Get first visible node
		return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
	},

	_collapseNode: function(/*_TreeNode*/ node){
		// summary:
		//		Called when the user has requested to collapse the node

		if(node._expandNodeDeferred){
			delete node._expandNodeDeferred;
		}

		if(node.isExpandable){
			if(node.state == "LOADING"){
				// ignore clicks while we are in the process of loading data
				return;
			}

			node.collapse();
			this.onClose(node.item, node);

			if(node.item){
				this._state(node.item,false);
				this._saveState();
			}
		}
	},

	_expandNode: function(/*_TreeNode*/ node, /*Boolean?*/ recursive){
		// summary:
		//		Called when the user has requested to expand the node
		// recursive:
		//		Internal flag used when _expandNode() calls itself, don't set.
		// returns:
		//		Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
		//		that were previously opened too

		if(node._expandNodeDeferred && !recursive){
			// there's already an expand in progress (or completed), so just return
			return node._expandNodeDeferred;	// dojo.Deferred
		}

		var model = this.model,
			item = node.item,
			_this = this;

		switch(node.state){
			case "UNCHECKED":
				// need to load all the children, and then expand
				node.markProcessing();

				// Setup deferred to signal when the load and expand are finished.
				// Save that deferred in this._expandDeferred as a flag that operation is in progress.
				var def = (node._expandNodeDeferred = new dojo.Deferred());

				// Get the children
				model.getChildren(
					item,
					function(items){
						node.unmarkProcessing();

						// Display the children and also start expanding any children that were previously expanded
						// (if this.persist == true).   The returned Deferred will fire when those expansions finish.
						var scid = node.setChildItems(items);

						// Call _expandNode() again but this time it will just to do the animation (default branch).
						// The returned Deferred will fire when the animation completes.
						// TODO: seems like I can avoid recursion and just use a deferred to sequence the events?
						var ed = _this._expandNode(node, true);

						// After the above two tasks (setChildItems() and recursive _expandNode()) finish,
						// signal that I am done.
						scid.addCallback(function(){
							ed.addCallback(function(){
								def.callback();
							})
						});
					},
					function(err){
						console.error(_this, ": error loading root children: ", err);
					}
				);
				break;

			default:	// "LOADED"
				// data is already loaded; just expand node
				def = (node._expandNodeDeferred = node.expand());

				this.onOpen(node.item, node);

				if(item){
					this._state(item, true);
					this._saveState();
				}
		}

		return def;	// dojo.Deferred
	},

	////////////////// Miscellaneous functions ////////////////

	focusNode: function(/* _tree.Node */ node){
		// summary:
		//		Focus on the specified node (which must be visible)
		// tags:
		//		protected

		// set focus so that the label will be voiced using screen readers
		dijit.focus(node.labelNode);
	},

	_onNodeFocus: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when a TreeNode gets focus, either by user clicking
		//		it, or programatically by arrow key handling code.
		// description:
		//		It marks that the current node is the selected one, and the previously
		//		selected node no longer is.

		if(node && node != this.lastFocused){
			if(this.lastFocused && !this.lastFocused._destroyed){
				// mark that the previously focsable node is no longer focusable
				this.lastFocused.setFocusable(false);
			}

			// mark that the new node is the currently selected one
			node.setFocusable(true);
			this.lastFocused = node;
		}
	},

	_onNodeMouseEnter: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when mouse is over a node (onmouseenter event),
		//		this is monitored by the DND code
	},

	_onNodeMouseLeave: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when mouse leaves a node (onmouseleave event),
		//		this is monitored by the DND code
	},

	//////////////// Events from the model //////////////////////////

	_onItemChange: function(/*Item*/ item){
		// summary:
		//		Processes notification of a change to an item's scalar values like label
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			var label = this.getLabel(item),
				tooltip = this.getTooltip(item);
			dojo.forEach(nodes, function(node){
				node.set({
					item: item,		// theoretically could be new JS Object representing same item
					label: label,
					tooltip: tooltip
				});
				node._updateItemClasses(item);
			});
		}
	},

	_onItemChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
		// summary:
		//		Processes notification of a change to an item's children
		var model = this.model,
			identity = model.getIdentity(parent),
			parentNodes = this._itemNodesMap[identity];

		if(parentNodes){
			dojo.forEach(parentNodes,function(parentNode){
				parentNode.setChildItems(newChildrenList);
			});
		}
	},

	_onItemDelete: function(/*Item*/ item){
		// summary:
		//		Processes notification of a deletion of an item
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			dojo.forEach(nodes,function(node){
				// Remove node from set of selected nodes (if it's selected)
				this.dndController.removeTreeNode(node);

				var parent = node.getParent();
				if(parent){
					// if node has not already been orphaned from a _onSetItem(parent, "children", ..) call...
					parent.removeChild(node);
				}
				node.destroyRecursive();
			}, this);
			delete this._itemNodesMap[identity];
		}
	},

	/////////////// Miscellaneous funcs

	_initState: function(){
		// summary:
		//		Load in which nodes should be opened automatically
		if(this.persist){
			var cookie = dojo.cookie(this.cookieName);
			this._openedItemIds = {};
			if(cookie){
				dojo.forEach(cookie.split(','), function(item){
					this._openedItemIds[item] = true;
				}, this);
			}
		}
	},
	_state: function(item,expanded){
		// summary:
		//		Query or set expanded state for an item,
		if(!this.persist){
			return false;
		}
		var id=this.model.getIdentity(item);
		if(arguments.length === 1){
			return this._openedItemIds[id];
		}
		if(expanded){
			this._openedItemIds[id] = true;
		}else{
			delete this._openedItemIds[id];
		}
	},
	_saveState: function(){
		// summary:
		//		Create and save a cookie with the currently expanded nodes identifiers
		if(!this.persist){
			return;
		}
		var ary = [];
		for(var id in this._openedItemIds){
			ary.push(id);
		}
		dojo.cookie(this.cookieName, ary.join(","), {expires:365});
	},

	destroy: function(){
		if(this._curSearch){
			clearTimeout(this._curSearch.timer);
			delete this._curSearch;
		}
		if(this.rootNode){
			this.rootNode.destroyRecursive();
		}
		if(this.dndController && !dojo.isString(this.dndController)){
			this.dndController.destroy();
		}
		this.rootNode = null;
		this.inherited(arguments);
	},

	destroyRecursive: function(){
		// A tree is treated as a leaf, not as a node with children (like a grid),
		// but defining destroyRecursive for back-compat.
		this.destroy();
	},

	resize: function(changeSize){
		if(changeSize){
			dojo.marginBox(this.domNode, changeSize);
		}

		// The only JS sizing involved w/tree is the indentation, which is specified
		// in CSS and read in through this dummy indentDetector node (tree must be
		// visible and attached to the DOM to read this)
		this._nodePixelIndent = dojo._getMarginSize(this.tree.indentDetector).w;

		if(this.tree.rootNode){
			// If tree has already loaded, then reset indent for all the nodes
			this.tree.rootNode.set('indent', this.showRoot ? 0 : -1);
		}
	},

	_createTreeNode: function(/*Object*/ args){
		// summary:
		//		creates a TreeNode
		// description:
		//		Developers can override this method to define their own TreeNode class;
		//		However it will probably be removed in a future release in favor of a way
		//		of just specifying a widget for the label, rather than one that contains
		//		the children too.
		return new dijit._TreeNode(args);
	}
});

// For back-compat.  TODO: remove in 2.0

}

if(!dojo._hasResource['bfree.widget.folder.Tree']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.folder.Tree'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 23/10/11
 * Time: 8:10 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.folder.Tree')






//


dojo.declare('bfree.widget._TreeNode', dijit._TreeNode, {

    _editor: null,
    _isEditing: false,

    library: null,
    group: null,
    user: null,


    _createEditor: function(){

        dojo.attr(this.labelNode, 'innerHTML', '');
        var editSpan = dojo.create('span', {innerHTML: this.label}, this.labelNode, 'first');

		var nc = dojo.coords(this.labelNode);
		var tc = dojo.coords(this.tree.domNode);

        this._editor = new dijit.InlineEditBox({
            id: 'wdgEditor',
            intermediateChanges:false,
			tree: this.tree,
            node: this,
            autoSave: true,
			onChange: dojo.hitch(this, this._editor_onChange),
			onCancel: dojo.hitch(this, this._editor_onCancel),
			width: (tc.w - nc.l - 25) + 'px',
            scrollIntoView: false,
            value: this.item.name
        }, editSpan);

		this._editor.startup();
    },

    _destroyEditor: function(){

        try{
            this._editor.destroyRecursive();
            this._editor = null;
        }
        catch(e){
            console.log(e);
        }

    },

    _editor_onCancel: function(){

        try{
            this.set('label', this.item.name);

            var parent;
            if(this.item.parent_id==0){
                parent=this.tree.rootNode.item;
            }else{
                parent=this.tree.folders.fetchById({id: this.item.parent_id});
            }

            if(this.item.isNew()){
                var nodes=this.tree.getNodesByItem(parent);
                dojo.forEach(nodes, function(node, idx){
                    var children=node.getChildren();
                    children.removeByValue(this);
                    for(var i in children){
                        if(children[i].item){
                            children[i]=children[i].item;
                        }
                    }
                    node.setChildItems(children);
                }, this);

                this.tree.folders.destroy({item: this.item});
                this.tree.folders.save();
            }else{
                this.tree.folders.revert();
                this.tree.folders.save();
            }

        }catch(e){
            console.error(e);
        }
        finally{
           this.tree.setEditing(false);
           this._destroyEditor();
        }
    },

    _editor_onChange: function(value, index){
        var isNew = false;

        try{

            var parent;
            if(this.item.parent_id==0){
                parent=this.tree.rootNode.item;
            }else{
                parent=this.tree.folders.fetchById({id: this.item.parent_id});
            }

            for(var i in parent.children){
                if(i!="__parent"&&
                   parent.children[i].declaredClass=="bfree.api.Folder"&&
                   parent.children[i].name.toLowerCase()==value.toLowerCase()&&
                   parent.children[i].id!=this.item.id){
                    alert("Duplicate folder names are not allowed.");
                    this._destroyEditor();
                    setTimeout(dojo.hitch(this, function(){
                        this.edit();
                    }), 100);
                    return;
                }
            }

            if(value==""){
                this.set('label', this.item.name);
                this.tree.folders.revert();
                this.tree._afterSelected(this);
                this.tree.setEditing(false);
                this._destroyEditor();
                return;
            }

            this.set('label', value);

            this.tree._beforeSelected(this);

            isNew = this.item.isNew();

            this.tree.folders.setValue(this.item, 'name', value);
            this.tree.folders.save();

            var nodes = this.tree.getNodesByItem(parent);
            dojo.forEach(nodes, function(node, idx){
//                node.item.children.sort(bfree.api.Folder.sort);
                node.setChildItems(node.item.children);
            }, this);

            (isNew) ?
               this.tree.onNewNode(this) :
               this.tree.onUpdateNode(this);

            this.tree._afterSelected(this);
            this.tree.setEditing(false);
            this._destroyEditor();

        }
        catch(e){
            console.error(e);
        }
        finally{
            this.setSelected(true);
        }

    },

    constructor: function(args){

    },

    edit: function(){
        this._createEditor();
	    this._editor.edit();
        this.tree.setEditing(true);

        //this was causing issues in IE, will discuss later
//        setTimeout(dojo.hitch(this, function(){
//            this._editor.wrapperWidget.editWidget.domNode.focus();
//        }), 100);

        this._editor.wrapperWidget.editWidget.domNode.focus();
    },

    hide: function(){
        dojo.style(this.domNode, 'display', 'none');
    },

    show: function(){
        dojo.style(this.domNode, 'display', 'block');
    },

    postCreate: function(){
		this.inherited('postCreate', arguments);



	},

    startup: function(){
        this.inherited('startup', arguments);

    }
});


dojo.declare('bfree.widget.folder.Tree', dijit.Tree, {

    _nodeStyles: ['dijitTreeExpandoLoading', 'dijitTreeExpandoOpened', 'dijitTreeExpandoClosed', 'dijitTreeExpandoLeaf'],

    folders: null,
    isSearchHidden: true,
    isShareRootHidden: false,
    isTrashHidden: false,
    openOnDblClick: true,

    library: null,

    _afterSelected: function(node){
        //Set node to original (not working image)
        var i = node.isExpandable ? (node.isExpanded ? 1 : 2) : 3;
        dojo.replaceClass(node.expandoNode, this._nodeStyles[i], this._nodeStyles);
    },

    _beforeSelected: function(node){
        //Set node to "working"
        dojo.replaceClass(node.expandoNode, this._nodeStyles[0], this._nodeStyles);
    },

    _mnuFolder_onClose: function(evt){
        dojo.removeClass(this._mnuFolder.activeNode.rowNode, 'dijitTreeMenuRow')
    },

    _mnuFolder_onOpen: function(evt){
        dojo.addClass(this._mnuFolder.activeNode.rowNode, 'dijitTreeMenuRow');
    },

    _createTreeNode: function(args){
        return new bfree.widget._TreeNode(args);
    },

    _hideNodesByItem: function(item){
        var nodes = this.getNodesByItem(item);
        dojo.forEach(nodes, function(node,idx){
            node.hide();
        });
    },

    _showNodesByItem: function(item){
        var nodes = this.getNodesByItem(item);
        dojo.forEach(nodes, function(node,idx){
            node.show();
        });
    },

    _onChildrenChange: function(item,children){
        item.children.sort(bfree.api.Folder.sort);
    },

    _onKeyPress: function(e) {
        //infinite loops are too much fun
        //so they need to be prevented with code like this
        if (this.tree._isEditing)
        	return; // we are editing so we should ignore all keys
        this.inherited(arguments);
    },

    _mayHaveChildren: function(item){

        if((item.isTrash()) || (item.isSearch()))
            return false;

        return dojo.isArray(item.children) ?
							(item.children.length > 0):
							(item.children);
	},

    _node_onClick: function(item, node){
        if(!(this.tree._isEditing&&node._editor)){
            this._beforeSelected(node);
            this.inherited('onClick', arguments);
            this._onSelected(item, node);
            this._afterSelected(node);
        }
	},

    _onCommand: function(cmdId, option, params)
    {
       this.onCommand(cmdId, option, params);
    },

    _onSelected: function(item, node){
        this.onSelected(item, node);
    },

    constructor: function(args){
        this['class'] = 'versafile';

        this.model = new dijit.tree.TreeStoreModel({
            store: args.folders.store,
            deferItemLoadingUntilExpand: true,
            query: 'root',
            mayHaveChildren: this._mayHaveChildren
        })

        this.persist = false;
        this.openOnClick = false;
    },

    createFolder: function(parentItem){

//        var parentInfo = (parentItem.root) ?
//                            null :
//                            { parent: parentItem, attribute: 'children' };

        var parentInfo = { parent: parentItem, attribute: 'children' };

        var uniqueName = this.folders.generateUniqueName({base_name: 'Folder', parent: parentItem});
        var item = this.folders.store.newItem({
            name: '',
            parent_id: parentItem.id,
            children: []
        }, parentInfo);

        //Get parent and expand (if closed)
        var nodes = this.getNodesByItem(parentItem);
        dojo.forEach(nodes, function(node, idx){ this._expandNode(node); }, this);

        //Edit new node
        nodes = this.getNodesByItem(item);

        dojo.forEach(nodes, function(node, idx){
            node.edit();
        }, this);

    },

    deleteFolder: function(item){
        var msg = ''
        if(item.isShare()){
            msg = dojo.replace('Are you sure you want to delete the shared folder \'{name}\'?', item);
        }
        else{
            msg = dojo.replace(
                'Are you sure you want to delete the folder \'{name}\'?\n\n' +
                'NOTE: this will delete all existing sub-folders and contained documents.',
                item
            );
        }

		if(!confirm(msg)){
            this.setBusy(item, false);
            return;
        }


        var path = item.path;

        var nodes = this.getNodesByItem(item);
        dojo.forEach(nodes, function(node, idx){
            var parent = node.getParent();
            var children = parent.getChildren();
            children.removeByValue(node);
            for(var i in children){
                if(children[i].item){
                    children[i] = children[i].item;
                }
            }
            parent.setChildItems(children);

        }, this);

		this.folders.destroy({item: item});
        this.folders.save();

        path.pop();

        this.setSelectedPath(path);

    },

    editFolder: function(item){
        if(item.is_trash||item.is_search){
            return;
        }

        var nodes = this.getNodesByItem(item);
        dojo.forEach(nodes, function(node, idx){

            //defunct nodes do not have a node at some point,
            //trace it up till you find the tree
            var dNode=node.domNode;
            while(dNode!=null){
                var wgt=dijit.getEnclosingWidget(dNode);
                if(wgt.declaredClass=="bfree.widget.folder.Tree"){
                    node.edit();
                    break;
                }
                dNode=dNode.parentNode;
            }
        }, this);

    },

    getIconClass: function(item, opened){
        var iconClass = 'dijitFolderOpened';

        if(item.isRoot())
            iconClass = 'folderIcon bfreeRootFolder'
        else if(item.isTrash())
            iconClass = 'folderIcon bfreeTrashFolder';
        else if(item.isSearch())
            iconClass = 'folderIcon bfreeSearchFolder';
        else if(item.isShareRoot())
            iconClass = 'folderIcon bfreeShareRootFolder';
        else if(item.isShare())
            iconClass = (!item || this.model.mayHaveChildren(item)) ?
                (opened ? 'folderIcon bfreeShareFolderOpened' : 'folderIcon bfreeShareFolderClosed') : 'folderIcon bfreeShareFolderClosed';
        else
            iconClass = (!item || this.model.mayHaveChildren(item)) ?
                (opened ? 'dijitFolderOpened' : 'dijitFolderClosed') : 'dijitFolderClosed';

        return iconClass;
    },

    hideSearch: function(){
        var search = this.library.getFolders().getSearchFolder();
        this._hideNodesByItem(search);
    },

    hideShareRoot: function(){
        var share = this.library.getFolders().getShareRootFolder();
        this._hideNodesByItem(share);
    },

    hideTrash: function(){
        var trash = this.library.getFolders().getTrashFolder();
        this._hideNodesByItem(trash);
    },

    showSearch: function(){
        var search = this.library.getFolders().getSearchFolder();
        this._showNodesByItem(search);
    },

    getNodesByItem: function(/*dojo.data.Item or id*/ item){
		// summary:
		//		Returns all tree nodes that refer to an item
		// returns:
		//		Array of tree nodes that refer to passed item
        //this replaces the tree getNodesByItem method,
        //it adds the ability to find an item by _clientId if the
        //item cannot be found by the id value
		if(!item){ return []; }
		var identity = dojo.isString(item) ? item : this.model.getIdentity(item);
		// return a copy so widget don't get messed up by changes to returned array
        if(this._itemNodesMap[identity]){
            return [].concat(this._itemNodesMap[identity]);
        }else{
            return [].concat(this._itemNodesMap[item.__clientId.substring(item.__clientId.lastIndexOf('/')+1)]);
        }

	},

    onNewNode: function(node){
        //changed to 'setSelectedItem' => 'setSelectedNode' didn't highlight row in all cases
        this.setSelectedItem(node.item);
    },

    onUpdateNode: function(node){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._mnuFolder = new bfree.widget.folder.ContextMenu({
            tree: this,
            activeLibrary: this.library,
            activeUser: this.user,
            onCommand: dojo.hitch(this, this._onCommand),
            onOpen: dojo.hitch(this, this._mnuFolder_onOpen),
            onClose: dojo.hitch(this, this._mnuFolder_onClose),
            targetNodeIds: [this.id]
        });

        dojo.connect(this, 'onClick', this._node_onClick);
        dojo.connect(this, 'onMouseDown', this, this._onMouseDown);

        this.dndController.onCommand = dojo.hitch(this, this.onCommand);
    },

    _onMouseDown: function(evt){
        var node = dijit.getEnclosingWidget(evt.target);

        if(this.tree._isEditing && node._editor){

        }else{
            //TODO: create a "new" node here...the tree node here is formatted with
            //the tree's indentation, looks strange when dragging nested folders
            this.dndController.startNode = node;
            if(evt.button == 2){
                this._mnuFolder.set('activeNode', node);
            }
        }

    },

    onSelected: function(item, node){
    },

    selectRoot: function(){
        this.setSelectedNode(this.rootNode);
    },

    setBusy: function(item, isBusy){
        var nodes = this.getNodesByItem(item);
        dojo.forEach(nodes, function(node, idx){
            (isBusy) ?
                node.markProcessing() :
                node.unmarkProcessing();
        }, this);
    },

    setEditing: function(isEditing){
		this._isEditing = isEditing;
	},

    setSelectedItem: function(item){

        var nodes = this.getNodesByItem(item);
        this.set('selectedNode', nodes[0]);
        this._onSelected(item, nodes[0]);

    },

    setSelectedNode: function(node){
        this.set('selectedNode', node);
        this._onSelected(node.item, node);
    },

    setSelectedPath: function(path){
        this.set('path', path);
        this.setSelectedNode(this.selectedNode);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._mnuFolder.startup();

        /*
        //Can we mixin with "bfree.api.Folder"???;
        var folderItem = new bfree.api.Folder({
            id: 0,
            active_permissions: this.library.active_permissions,
            name: this.library.name,text_path: '/',
            created_at: this.library.created_at,
            updated_at: this.library.updated_at,
            children: this.rootNode.item.children,
            path: ['0'],
            store: this.rootNode.item.store,
            root: this.rootNode.item.root
        });
        this.rootNode.item = folderItem;
        this.model.root = folderItem;

        this.rootNode.item.children.sort(bfree.api.Folder.sort);
        this.rootNode.setChildItems(this.rootNode.item.children);
        */

        if(this.isSearchHidden)
            this.hideSearch();
        if(this.isTrashHidden)
            this.hideTrash();
        if(this.isShareRootHidden)
            this.hideShareRoot();

    },



    _onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates click events into commands for the controller to process

        if(!(this.tree._isEditing && nodeWidget._editor)){
            var domElement = e.target,
                isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

            if( (this.openOnClick && nodeWidget.isExpandable) || isExpandoClick ){
                // expando node was clicked, or label of a folder node was clicked; open it
                if(nodeWidget.isExpandable){
                    this._onExpandoClick({node:nodeWidget});
                }
            }else{
                setTimeout(dojo.hitch(this, function(){
                    this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
                    this.onClick(nodeWidget.item, nodeWidget, e);
                    this.focusNode(nodeWidget);
                }), 50);
            }
            dojo.stopEvent(e);
        }

	}

});


}

if(!dojo._hasResource['bfree.widget.document.Header']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.Header'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/12/11
 * Time: 11:57 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.Header');




dojo.declare('bfree.widget.document.Header', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/document", "template/Header.html", "<div style=\"height:32px;padding-left:36px;position:relative;top:0;left:0;\">\n\n    <div style=\"position:absolute;top:0;left:0;\">\n\t\t<img dojoAttachPoint=\"typeIconNode\" src=\"\" height=\"32\" width=\"32\"/>\n\t</div>\n\n    <div style=\"height:100%;position:relative;left:0;top:0\">\n\t\t<div style=\"position:absolute;top:2px;left:2px;\">\n\t\t\t<span class=\"dijitMediumLabel dijitDarkLabel dijitBoldLabel\" dojoAttachPoint=\"nameNode\" style=\"white-space:nowrap;\"></span>\n\t\t</div>\n\t\t<div class=\"hr\" style=\"position:absolute;top:16px;left:0;\"></div>\n\t\t<div class=\"dijitSmallLabel dijitDarkLabel\" style=\"position:absolute;top:18px;\">\n\t\t\t<span dojoAttachPoint=\"typeNode\" style=\"padding-left:4px\"></span>\n\t\t</div>\n\t\t<div class=\"dijitSmallLabel dijitDarkLabel\" style=\"position:absolute;top:18px;right:0\">\n\t\t\t<span dojoAttachPoint=\"sizeNode\" style=\"padding-left:4px\"></span>\n\t\t</div>\n\t</div>\n\n</div>\n"),
    widgetsInTemplate: false,

    activeItem: null,

    _initialize: function(){
        if(this.activeItem){
            this.typeIconNode.src = bfree.api.Document.getIconUrl(this.activeItem.binary_content_type, 32);
            this.nameNode.innerHTML = this.activeItem.name;
            this.typeNode.innerHTML =  this.activeItem.document_type_name;
            this.sizeNode.innerHTML = bfree.api.Utilities.readablizeBytes({bytes: this.activeItem.binary_file_size});
        }
    },

    _setActiveItemAttr: function(document){
        this.activeItem = document;
        this._initialize();
    },

    constructor: function(args){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);
        this._initialize();
    },

    startup: function(){
        this.inherited('startup', arguments);

    }

});

}

if(!dojo._hasResource['bfree.widget.document.Move']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.Move'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.document.Move');











dojo.declare('bfree.widget.document.Move', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
	templateString: dojo.cache("bfree/widget/document", "template/Move.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"padding:8px;height:100%;width:100%;\">\n\n     <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;height:20px\">\n        <!-- Does not handle multi-select yet -->\n        <!-- div dojoAttachPoint=\"headerNode\"></div -->\n        <span dojoAttachPoint=\"folderNameNode\" class=\"dijitDarkLabel dijitMediumLabel\">Select Folder:</span>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\"\n                splitter=\"true\"\n                style=\"padding:0\"\n                class=\"highlightPane\">\n\n       <div dojoAttachPoint=\"treeNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
	widgetsInTemplate: true,

    _tvwFolders: null,

    activeFolder: null,
    references: null,
    folder: null,
	library: null,
    zone: null,

    _doCancel: function(){

        var canClose = false;

        try{
            //nothing to do here.
            canClose = true;
        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    _doSave: function(){
        var canClose = false;

        try{

            //TODO: What happens if document or folder has been deleted?
            dojo.forEach(this.references, function(reference, idx){
                reference.file({
                    zone: this.zone,
                    library: this.library,
                    folder: this.activeFolder

                });
            }, this);

            //this.library.getReferences().save();
            canClose = true;
        }
        catch(e){

            var err = new bfree.api.Error('Failed to move documents to folder', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    _loadItems: function(){

        try{
            if((this.folder) && (this.folder.path)){
                this._tvwFolders.set('path', this.folder.path);
            }
        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _tvwFolders_onSelected: function(item, node){
        this.activeFolder = item;
        this.onValueChange();
    },

	constructor: function(args){

    },

    destroy: function(){

        if(this._tvwFolders){
            this._tvwFolders.destroy();
            this._tvwFolders = null;
        }

        this.inherited('destroy', arguments);
    },

    isValid: function(){
        return (this.activeFolder !== this.folder);
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            this.returnValue = this.references;
            canClose = (dlgResult == bfree.widget.Dialog.dialogResult.ok) ?
                            this._doSave() :
                            this._doCancel();


        }
        catch(e){
           var err = new bfree.api.Error('Failed to close \'Edit Document\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        //this.library.getFolders().refresh();

        this._tvwFolders = new bfree.widget.folder.Tree({
            id: 'tvwFolders',
            library: this.library,
            folders: this.library.getFolders(),
            isSearchHidden: true,
            isTrashHidden: true,
            isShareRootHidden: true,
            onSelected: dojo.hitch(this, this._tvwFolders_onSelected),
            style: 'height: 100%'
        }, this.treeNode);

	},

    startup: function(){
        this.inherited('startup', arguments);
        this._tvwFolders.startup();

        setTimeout(bfree.widget.document.Move._loadFnRef(this), 10);
    }
	
	
});

bfree.widget.document.Move._loadFnRef = function(that){
    return ( function() {
       that._loadItems();
    });
}

bfree.widget.document.Move.show = function(args){

    var title = (dojo.isArray(args.items) && (args.items.length > 1)) ?
                dojo.replace('Move {length} documents', args.items):
                dojo.replace('Move document: {name}', args.items[0]);

    var dlg = new bfree.widget.Dialog({
        id: 'dlgMoveDocument',
        title: title,
        widgetConstructor: bfree.widget.document.Move,
        widgetParams: {
            references: args.items,
            folder: args.folder,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 480,
        width: 480,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['bfree.widget.document.SystemInfo']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.SystemInfo'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/03/12
 * Time: 4:18 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.SystemInfo');









dojo.declare('bfree.widget.document.SystemInfo', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/document", "template/SystemInfo.html", "<div style=\"width:100%;height:100%\">\n\n     <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    _form: null,
    _lblCkoBy: null,
    _lblCreatedAt: null,
    _lblCreatedBy: null,
    _lblId: null,
    _lblIsCko: null,
    _lblIsIndexed: null,
    _lblUpdatedAt: null,
    _lblUpdatedBy: null,
    _tblProperties: null,

    activeItem: null,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        this._lblId.set('value', this.activeItem.id);
        this._lblIsCko.set('value', this.activeItem.getState(bfree.api.Document.states.CHECKED_OUT));
        this._lblCkoBy.set('value', (String.isEmpty(this.activeItem.checked_out_by) ? 'Nobody' : this.activeItem.checked_out_by));
        this._lblIsIndexed.set('value', this.activeItem.getState(bfree.api.Document.states.INDEXED));
        this._lblCreatedBy.set('value', this.activeItem.created_by);
        this._lblCreatedAt.set('value', versa.api.Formatter.formatDateTime(this.activeItem.created_at));
        this._lblUpdatedBy.set('value', this.activeItem.updated_by);
        this._lblUpdatedAt.set('value', versa.api.Formatter.formatDateTime(this.activeItem.updated_at))

        this._tblProperties.refresh();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'infoObjForm'
        }, this.formNode);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblObjInfo1',
            customClass: 'versainfo',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._lblId = new bfree.widget.Label({
           id: 'lblId',
           label: 'Document ID'
        });
        this._tblProperties.addChild(this._lblId);

        this._lblIsCko = new bfree.widget.Label({
           id: 'lblIsCko',
           label: 'Is Checked Out?'
        });
        this._tblProperties.addChild(this._lblIsCko);

        this._lblCkoBy = new bfree.widget.Label({
           id: 'lblCkoBy',
           label: 'Checked Out By'
        });
        this._tblProperties.addChild(this._lblCkoBy);

        this._lblIsIndexed = new bfree.widget.Label({
            id: 'lblIsIndexed',
           label: 'Is Indexed'
        });
        this._tblProperties.addChild(this._lblIsIndexed);

        this._lblCreatedBy = new bfree.widget.Label({
           id: 'lblCreatedBy',
           label: 'Created By'
        });
        this._tblProperties.addChild(this._lblCreatedBy);

        this._lblCreatedAt = new bfree.widget.Label({
           id: 'lblCreatedAt',
           label: 'Create Date'
        });
        this._tblProperties.addChild(this._lblCreatedAt);

        this._lblUpdatedBy = new bfree.widget.Label({
           id: 'lblUpdatedBy',
           label: 'Last Modified By'
        });
        this._tblProperties.addChild(this._lblUpdatedBy);

        this._lblUpdatedAt = new bfree.widget.Label({
           id: 'lblUpdatedAt',
           label: 'Last Modified Date'
        });
        this._tblProperties.addChild(this._lblUpdatedAt);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.document.PropertyEditor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.PropertyEditor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 09/12/11
 * Time: 9:25 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.PropertyEditor');




/*




*/









dojo.declare('bfree.widget.document.PropertyEditor', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/document", "template/PropertyEditor.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"padding:0px 8px 4px 8px;height:100%;width:100%;\">\n\n     <div   dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"overflow:hidden;height:32px\">\n\n         <div dojoAttachPoint=\"headerNode\"></div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            splitter=\"false\"\n            region=\"center\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\"\n                splitter=\"true\"\n                class=\"highlightPane\"\n                style=\"padding:8px\">\n\n           <div dojoAttachPoint=\"editorNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                region=\"bottom\"\n                splitter=\"false\"\n                style=\"padding:8px;overflow:hidden;height:128px\">\n\n             <div dojoAttachPoint=\"infoNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _document: null,
    _editor: null,
    _wdgHeader: null,
    _wdgInfo: null,

    activeReference: null,
    references: null,
    library: null,
    zone: null,

    _doCancel: function(){
        var canClose = false;

        try{
            //nothing to do here now
            canClose = true;
        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert document', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    _doSave: function(){
        var canClose = false;

        try{

            if(!this._document.isValid({library: this.library})){
                throw new Error('One or more properties are missing or invalid');
            }

            if(this.library.getReferences().isDirty({item: this.activeReference})){
                this.library.getReferences().save();
                this.library.getDocuments().invalidate(this.activeReference.document_id);
            }

            canClose = true;
        }
        catch(e){

            var err = new bfree.api.Error('Failed to save document', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });

            //The store loses the "dirty" flag when item save fails and revert hasn't occurred
            this.library.getDocuments().clone({item: this._document});

            if(e.status == 404){
                canClose = this._doCancel();
                this.library.getDocuments().store.onDelete(this._document);
            }


        }

        return canClose;
    },

    _loadItem: function(){

        //Retrieve referenced document
        this.library.getDocuments().refreshAsync({
            scope: this,
            identity: this.activeReference.document_id,
            onItem: this._onItemLoaded,
            onError: this._onItemError
        });

    },

    _onItemError: function(e){
        try{
            var err = new bfree.api.Error('Failed to load document', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this.onWidgetLoaded();
        }
    },

    _onItemLoaded: function(item){

        try{

            this._document = item;
            this.library.getDocuments().clone({item: this._document});

            var documentType =  this.library.getDocumentTypes().fetchById({id: this._document.document_type_id});

            this._wdgHeader.set('activeItem', this._document);
            this._editor.set('activeItem', this._document);
//            this._editor.setValues(this._document);
            this._wdgInfo.set('activeItem', this._document);
        }
        finally{
            this.onWidgetLoaded();
        }
    },

    _onValueChange: function(id, value){

        var property_id = id.replace('documents.', '');

        if(!this._document.valueEquals(property_id, value)){
            this.library.getDocuments().setValue(this._document, property_id, value);
            this.library.getReferences().setValue(this.activeReference, property_id, value);
            this._wdgHeader.set('activeItem', this._document);
            this.onValueChange();
        }


    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._editor){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    isValid: function(){
        //Check performance of this?
        this._document.validate({library: this.library});
        return ((this.library.getDocuments().isDirty({item: this._document})) && (!this._document.getState(bfree.api.Document.states.INVALID)));
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            this.returnValue = this.references;
            canClose = (dlgResult == bfree.widget.Dialog.dialogResult.ok) ?
                            this._doSave() :
                            this._doCancel();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to close \'Edit Document\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            //always revert document object...update reference only
            this.library.getDocuments().revert();
            //this.library.getReferences().refreshItem(this.activeReference.getId());
        }


        return canClose;
    },

    _onValidChange: function(){
        this.onValueChange();
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this.activeReference = this.references[0];

        this._wdgHeader = new bfree.widget.document.Header({
        }, this.headerNode);

        var choiceLists = this.library.getChoiceLists();
        choiceLists.refresh();

        var propertyDefinitions = this.library.getPropertyDefinitions();
        propertyDefinitions.refresh();

        this._editor = new bfree.widget.document.Editor({
            id: 'editor1',
            library: this.library,
            onValidChange: dojo.hitch(this, this._onValidChange),
            onSubmit: dojo.hitch(this, this._onSubmit),
            onValueChange: dojo.hitch(this, this._onValueChange)
        }, this.editorNode);

        this._wdgInfo = new bfree.widget.document.SystemInfo({
            id: 'wdgDocSysInfo1'
        }, this.infoNode);

    },

    startup: function(){
        this.inherited('startup', arguments);
        setTimeout(bfree.widget.document.PropertyEditor._loadFnRef(this), 10);
    }

});

bfree.widget.document.PropertyEditor._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.document.PropertyEditor.show = function(args){

    if((!args.items) || (args.items.length < 1))
        throw new Error('No documents selected');

    var reference = args.items[0];

    var dlg = new bfree.widget.Dialog({
        id: 'dlgEditDocument',
        title: 'Edit Document: ' + reference.name.display_limit(32),
        widgetConstructor: bfree.widget.document.PropertyEditor,
        widgetParams: {
            user: args.user,
            references: args.items,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 480,
        width: 400,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();


}

}

if(!dojo._hasResource['bfree.widget.document.version.ContextMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.version.ContextMenu'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 02/03/12
 * Time: 3:11 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.version.ContextMenu');




dojo.declare('bfree.widget.document.version.ContextMenu', bfree.widget.HeaderMenu,{
    _btnDocCopy: null,
    _btnDocView: null,

    menuLabel: 'Version',
    activeItem: null,
    versions: null,
    document: null,

    refresh: function(){
    },

    _onCommand: function(cmdId, option, e){
        this.onCommand(cmdId, option, {document: this.document, version: this.activeItem});
    },

    _openMyself: function(evt){

        try{
            if((!this.rowHit) || (this.activeItem == null)){
                evt.cancelBubble = true;
                evt.returnValue = false;
            }else{
                this.inherited('_openMyself', arguments);
            }
        }finally{
            this.rowHit = false;
        }

    },

    constructor: function(args){

    },

    onHide: function(){
        this.activeItem = null;
        this.inherited('onHide', arguments);
    },

    onCommand: function(cmdId, option, params){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnDocView = new dijit.MenuItem({
            label: 'View',
            iconClass: 'menuIcon bfreeIconViewDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.VIEW,
                bfree.widget.Bfree.ObjectTypes.VERSION)
        });
        this.addChild(this._btnDocView);

        this._btnDocCopy = new dijit.MenuItem({
            label: 'Copy Local...',
            iconClass: 'menuIcon bfreeIconCopyDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.COPY,
                bfree.widget.Bfree.ObjectTypes.VERSION)
        });
		this.addChild(this._btnDocCopy);
    }

});




}

if(!dojo._hasResource['bfree.widget.document.version.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.version.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 02/03/12
 * Time: 3:11 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.version.Grid');




dojo.declare('bfree.widget.document.version.Grid', [bfree.widget._Grid], {

    _mnuVersion: null,

    activeDocument: null,
    library: null,
    zone: null,

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return false;
    },

    _onCommand: function(cmdId, option, params){
        this.onCommand(cmdId, option, params);
    },

    _onRowContextMenu: function(evt){

        if((this._mnuVersion == null) || (evt.rowIndex < 0)){
            this.rowHit = false;
            evt.cancelBubble = true;
        }
        else{
            var selected=this.selection.selected[evt.rowIndex];

            var item;
            if(selected){
                item=this.getItem(evt.rowIndex);
            }else{
                this.selection.clear();
                item=this.getItem(evt.rowIndex);
                this.selection.select(evt.rowIndex);
                this._mnuVersion.rowHit = true;
                this._mnuVersion.activeItem = item;
            }
            this._mnuVersion.rowHit = true;
            this._mnuVersion.activeItem = item;
        }

    },

    _setActiveDocumentAttr: function(value){
        this.activeDocument = value;
        this.setStore(this.activeDocument.getVersions({zone: this.zone, library: this.library}).store, {}, {cache: true});
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};
		this.selectionMode = 'single';

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Versions found';
        this.sortInfo = 4;
	},

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this._mnuVersion = new bfree.widget.document.version.ContextMenu({
            onCommand: dojo.hitch(this, this._onCommand),
            versions: this.versions,
            document: this.document,
            targetNodeIds: [this.id]
        });

        this.onRowContextMenu = dojo.hitch(this, this._onRowContextMenu);

        this.set('structure', bfree.widget.document.version.Grid.view);
        //this.set('sortInfo', 2);
    },

    onRowDblClick: function(evt){

        if(evt.rowIndex < 0){
            evt.cancelBubble = true;
            return;
        }

        var item = this.getItem(evt.rowIndex);
        this._onCommand(bfree.widget.Bfree.Commands.VIEW, bfree.widget.Bfree.ObjectTypes.VERSION, {document: this.document, version: item});
    },

    onCommand: function(cmdId, option, params){
    },

    startup: function(){
        this.inherited('startup', arguments);
        //this.setStore(this.versions.store, {}, {cache: true});
    }

});

bfree.widget.document.version.Grid.formatState = function(data, rowIndex){

    var iconClass = '';

    if(data){
        iconClass = 'statusIcon bfreeIconNew';
    }
    return dojo.replace('<img src="/images/icons/16/blank.png" width="16" height="16" class="{0}"/>', [iconClass]);
}

bfree.widget.document.version.Grid.getVersion=function(idx, item){

    if(!item){
        return '';
    }

    return item.major_version_number;
}

bfree.widget.document.version.Grid.formatVersion=function(data, rowIndex){
    return data;
}

bfree.widget.document.version.Grid.view = [
    {
        cells: [
            {
                field: 'is_current_version',
                name: '&nbsp;',
                width: '16px',
                formatter: bfree.widget.document.version.Grid.formatState
            },
            {
                field: 'major_version_number',
                name: 'Version',
                get: bfree.widget.document.version.Grid.getVersion,
                formatter: bfree.widget.document.version.Grid.formatVersion
            },
            {
                field: 'binary_file_name',
                name: 'Filename',
                width: 'auto'
            },
            {
                field: 'sort_id',
                name: 'Sort',
                hidden: true
            }

        ],
        width: 'auto'
    }
]

}

if(!dojo._hasResource['versa.widget.reference.Accessor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.reference.Accessor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 05/04/12
 * Time: 12:43 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.reference.Accessor');

dojo.declare('versa.widget.reference.Accessor', null,{

    activeLibrary: null,
    activeZone: null,

    constructor: function(args){
        dojo.safeMixin(this, ((!args) ? { } : args));
    },

    doCancelCheckout: function(item){
        try{
            item.cancelCheckout({zone: this.activeZone, library: this.activeLibrary});
            this.activeLibrary.getDocuments().invalidate(item.document_id);
        }
        finally{
            // Tell the store to refresh item, NOT the best way to do this
            // OPTIONS:
            // - Incorporate actions into custom ServiceStore
            // - Use store 'EDIT' methods to automatically update store
            this.activeLibrary.getReferences().refreshItem(item.getId());
        }

    },

    doCheckout: function(item){

        try{
            item.checkout({zone: this.activeZone, library: this.activeLibrary});
            this.activeLibrary.getDocuments().invalidate(item.document_id);
        }
        finally{
            // SEE notes in 'doCancelCheckout' on this.
            this.activeLibrary.getReferences().refreshItem(item.getId());
        }

    },

    doCopyLocal: function(item, version_id){
        item.copyLocal({version_id: version_id, zone: this.activeZone, library: this.activeLibrary});
    },

    doMove: function(folder, item){
        item.file({zone: this.activeZone, library: this.activeLibrary, folder: folder});
    },

    doRestore: function(item){
        try{
            item.restore({zone: this.activeZone, library: this.activeLibrary});
        }
        finally{
            // SEE notes in 'doCancelCheckout' on this.
            this.activeLibrary.getReferences().refreshItem(item.getId());
        }
    },

    doShare: function(folder, item){
        item.share({zone: this.activeZone, library: this.activeLibrary, folder: folder});
    },

    doUnshare: function(item){
        item.unshare({zone: this.activeZone, library: this.activeLibrary});
    },

    doView: function(item, version_id){
        var box = bfree.api.Utilities.getBox({scale: 0.75});
        item.view({version_id: version_id, zone: this.activeZone, library: this.activeLibrary, windowBox: box});
    }

});

}

if(!dojo._hasResource['bfree.widget.document.version.Versions']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.version.Versions'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 02/03/12
 * Time: 2:14 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.document.version.Versions');




dojo.declare('bfree.widget.document.version.Versions', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/document/version", "template/Versions.html", "<div style=\"height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            style=\"height:100%;width:100%;\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                region=\"center\"\n                splitter=\"false\"\n                style=\"\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _accessor: null,
    _document: null,
    _grdVersions: null,

    activeReference: null,
    library: null,
    references: null,
    zone: null,

    __onCopy: function(args){
        var version = args.version;

        try{
            this._accessor.doCopyLocal(this.activeReference, version.getId());
        }
        catch(e){
            var err = new bfree.api.Error('Failed to copy document', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }
    },

    __onView: function(args){
        var version = args.version;

        try{
            this._accessor.doView(this.activeReference, version.getId());
        }
        catch(e){
            var err = new bfree.api.Error('Failed to view version', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

    },

     _loadItem: function(){

        //Retrieve referenced document
        this._document = this.library.getDocuments().refreshAsync({
            scope: this,
            identity: this.activeReference.document_id,
            onItem: this._onItemLoaded,
            onError: this._onItemError
        });

    },

    _onCommand: function(cmdId, option, e){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.VIEW:
                this.__onView(e);
                break;
            case bfree.widget.Bfree.Commands.COPY:
                this.__onCopy(e);
                break;
        }

    },

    _onItemError: function(e){
        try{
            var err = new bfree.api.Error('Failed to load document', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this.onWidgetLoaded();
        }
    },

    _onItemLoaded: function(item){
        try{
            this._document = item;
            this._grdVersions.set('activeDocument', this._document)
        }
        finally{
            this.onWidgetLoaded();
        }
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._grdVersions){
            this._grdVersions.destroyRecursive();
            this._grdVersions = null;
        }

        this.inherited('destroy', arguments);
    },

    onDialogClosing: function(){
        var canClose = false;

        try{

            this.returnValue = this.references;
            canClose = true;
        }
        catch(e){
            var err = new bfree.api.Error('Failed to close \'Edit Document\' dialog', e);
                bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this.activeReference = this.references[0];

        this._accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.library,
            activeZone: this.zone
        });

        this._grdVersions = new bfree.widget.document.version.Grid({
            id: 'grdVersions',
            'class': 'versaGridOutline',
            library: this.library,
            zone: this.zone,
            onCommand: dojo.hitch(this, this._onCommand)
        }, this.gridNode);


    },

    startup: function(){
        this.inherited('startup', arguments);
        this._grdVersions.resize();
        setTimeout(bfree.widget.document.PropertyEditor._loadFnRef(this), 10);
    }

});

bfree.widget.document.version.Versions._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.document.version.Versions.show = function(args){

    if((!args.items) || (args.items.length < 1))
        throw new Error('No documents selected');

    var reference = args.items[0];

    var dlg = new bfree.widget.Dialog({
        id: 'dlgVersions',
        title: 'Versions: ' + reference.name.display_limit(32),
        widgetConstructor: bfree.widget.document.version.Versions,
        widgetParams: {
            references: args.items,
            library: args.library,
            zone: args.zone,
            onCommand: args.onCommand
        },
        noResize: true,
        height: 480,
        width: 480,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource["dijit.tree.dndSource"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree.dndSource"] = true;
dojo.provide("dijit.tree.dndSource");




/*=====
dijit.tree.__SourceArgs = function(){
	// summary:
	//		A dict of parameters for Tree source configuration.
	// isSource: Boolean?
	//		Can be used as a DnD source. Defaults to true.
	// accept: String[]
	//		List of accepted types (text strings) for a target; defaults to
	//		["text", "treeNode"]
	// copyOnly: Boolean?
	//		Copy items, if true, use a state of Ctrl key otherwise,
	// dragThreshold: Number
	//		The move delay in pixels before detecting a drag; 0 by default
	// betweenThreshold: Integer
	//		Distance from upper/lower edge of node to allow drop to reorder nodes
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.dragThreshold = dragThreshold;
	this.betweenThreshold = betweenThreshold;
}
=====*/

dojo.declare("dijit.tree.dndSource", dijit.tree._dndSelector, {
	// summary:
	//		Handles drag and drop operations (as a source or a target) for `dijit.Tree`

	// isSource: [private] Boolean
	//		Can be used as a DnD source.
	isSource: true,

	// accept: String[]
	//		List of accepted types (text strings) for the Tree; defaults to
	//		["text"]
	accept: ["text", "treeNode"],

	// copyOnly: [private] Boolean
	//		Copy items, if true, use a state of Ctrl key otherwise
	copyOnly: false,

	// dragThreshold: Number
	//		The move delay in pixels before detecting a drag; 5 by default
	dragThreshold: 5,

	// betweenThreshold: Integer
	//		Distance from upper/lower edge of node to allow drop to reorder nodes
	betweenThreshold: 0,

	constructor: function(/*dijit.Tree*/ tree, /*dijit.tree.__SourceArgs*/ params){
		// summary:
		//		a constructor of the Tree DnD Source
		// tags:
		//		private
		if(!params){ params = {}; }
		dojo.mixin(this, params);
		this.isSource = typeof params.isSource == "undefined" ? true : params.isSource;
		var type = params.accept instanceof Array ? params.accept : ["text", "treeNode"];
		this.accept = null;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}

		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;	// DOMNode corresponding to the currently moused over TreeNode
		this.targetBox = null;	// coordinates of this.targetAnchor
		this.dropPosition = "";	// whether mouse is over/after/before this.targetAnchor
		this._lastX = 0;
		this._lastY = 0;

		// states
		this.sourceState = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}

		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start", this, "onDndStart"),
			dojo.subscribe("/dnd/drop", this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},

	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		Checks if the target can accept nodes from this source
		// source: dijit.tree.dndSource
		//		The source which provides items
		// nodes: DOMNode[]
		//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
		//		source is a dijit.Tree.
		// tags:
		//		extension
		return true;	// Boolean
	},

	copyState: function(keyPressed){
		// summary:
		//		Returns true, if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		The "copy" control key was pressed
		// tags:
		//		protected
		return this.copyOnly || keyPressed;	// Boolean
	},
	destroy: function(){
		// summary:
		//		Prepares the object to be garbage-collected.
		this.inherited("destroy",arguments);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	_onDragMouse: function(e){
		// summary:
		//		Helper method for processing onmousemove/onmouseover events while drag is in progress.
		//		Keeps track of current drop target.

		var m = dojo.dnd.manager(),
			oldTarget = this.targetAnchor,			// the TreeNode corresponding to TreeNode mouse was previously over
			newTarget = this.current,				// TreeNode corresponding to TreeNode mouse is currently over
			oldDropPosition = this.dropPosition;	// the previous drop position (over/before/after)

		// calculate if user is indicating to drop the dragged node before, after, or over
		// (i.e., to become a child of) the target node
		var newDropPosition = "Over";
		if(newTarget && this.betweenThreshold > 0){
			// If mouse is over a new TreeNode, then get new TreeNode's position and size
			if(!this.targetBox || oldTarget != newTarget){
				this.targetBox = dojo.position(newTarget.rowNode, true);
			}
			if((e.pageY - this.targetBox.y) <= this.betweenThreshold){
				newDropPosition = "Before";
			}else if((e.pageY - this.targetBox.y) >= (this.targetBox.h - this.betweenThreshold)){
				newDropPosition = "After";
			}
		}

		if(newTarget != oldTarget || newDropPosition != oldDropPosition){
			if(oldTarget){
				this._removeItemClass(oldTarget.rowNode, oldDropPosition);
			}
			if(newTarget){
				this._addItemClass(newTarget.rowNode, newDropPosition);
			}

			// Check if it's ok to drop the dragged node on/before/after the target node.
			if(!newTarget){
				m.canDrop(false);
			}else if(newTarget == this.tree.rootNode && newDropPosition != "Over"){
				// Can't drop before or after tree's root node; the dropped node would just disappear (at least visually)
				m.canDrop(false);
			}else if(m.source == this && (newTarget.id in this.selection)){
				// Guard against dropping onto yourself (TODO: guard against dropping onto your descendant, #7140)
				m.canDrop(false);
			}else if(this.checkItemAcceptance(newTarget.rowNode, m.source, newDropPosition.toLowerCase())
					&& !this._isParentChildDrop(m.source, newTarget.rowNode)){
				m.canDrop(true);
			}else{
				m.canDrop(false);
			}

			this.targetAnchor = newTarget;
			this.dropPosition = newDropPosition;
		}
	},

	onMouseMove: function(e){
		// summary:
		//		Called for any onmousemove events over the Tree
		// e: Event
		//		onmousemouse event
		// tags:
		//		private
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		this.inherited(arguments);
		var m = dojo.dnd.manager();
		if(this.isDragging){
			this._onDragMouse(e);
		}else{
			if(this.mouseDown && this.isSource &&
				 (Math.abs(e.pageX-this._lastX)>=this.dragThreshold || Math.abs(e.pageY-this._lastY)>=this.dragThreshold)){
				var nodes = this.getSelectedTreeNodes();
				if(nodes.length){
					if(nodes.length > 1){
						//filter out all selected items which has one of their ancestor selected as well
						var seen = this.selection, i = 0, r = [], n, p;
						nextitem: while((n = nodes[i++])){
							for(p = n.getParent(); p && p !== this.tree; p = p.getParent()){
								if(seen[p.id]){ //parent is already selected, skip this node
									continue nextitem;
								}
							}
							//this node does not have any ancestors selected, add it
							r.push(n);
						}
						nodes = r;
					}
					nodes = dojo.map(nodes, function(n){return n.domNode});
					m.startDrag(this, nodes, this.copyState(dojo.isCopyKey(e)));
				}
			}
		}
	},

	onMouseDown: function(e){
		// summary:
		//		Event processor for onmousedown
		// e: Event
		//		onmousedown event
		// tags:
		//		private
		this.mouseDown = true;
		this.mouseButton = e.button;
		this._lastX = e.pageX;
		this._lastY = e.pageY;
		this.inherited(arguments);
	},

	onMouseUp: function(e){
		// summary:
		//		Event processor for onmouseup
		// e: Event
		//		onmouseup event
		// tags:
		//		private
		if(this.mouseDown){
			this.mouseDown = false;
			this.inherited(arguments);
		}
	},

	onMouseOut: function(){
		// summary:
		//		Event processor for when mouse is moved away from a TreeNode
		// tags:
		//		private
		this.inherited(arguments);
		this._unmarkTargetAnchor();
	},

	checkItemAcceptance: function(target, source, position){
		// summary:
		//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
		// description:
		//		In the base case, this is called to check if target can become a child of source.
		//		When betweenThreshold is set, position="before" or "after" means that we
		//		are asking if the source node can be dropped before/after the target node.
		// target: DOMNode
		//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
		//		Use dijit.getEnclosingWidget(target) to get the TreeNode.
		// source: dijit.tree.dndSource
		//		The (set of) nodes we are dropping
		// position: String
		//		"over", "before", or "after"
		// tags:
		//		extension
		return true;
	},

	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		Topic event processor for /dnd/source/over, called when detected a current source.
		// source: Object
		//		The dijit.tree.dndSource / dojo.dnd.Source which has the mouse over it
		// tags:
		//		private
		if(this != source){
			this.mouseDown = false;
			this._unmarkTargetAnchor();
		}else if(this.isDragging){
			var m = dojo.dnd.manager();
			m.canDrop(false);
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		Topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		The dijit.tree.dndSource / dojo.dnd.Source which is providing the items
		// nodes: DomNode[]
		//		The list of transferred items, dndTreeNode nodes if dragging from a Tree
		// copy: Boolean
		//		Copy items, if true, move items otherwise
		// tags:
		//		private

		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.checkAcceptance(source, nodes);

		this._changeState("Target", accepted ? "" : "Disabled");

		if(this == source){
			dojo.dnd.manager().overSource(this);
		}

		this.isDragging = true;
	},

	itemCreator: function(/*DomNode[]*/ nodes, target, /*dojo.dnd.Source*/ source){
		// summary:
		//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
		//		dropped onto the tree.   Developer must override this method to enable
		// 		dropping from external sources onto this Tree, unless the Tree.model's items
		//		happen to look like {id: 123, name: "Apple" } with no other attributes.
		// description:
		//		For each node in nodes[], which came from source, create a hash of name/value
		//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
		// returns: Object[]
		//		Array of name/value hashes for each new item to be added to the Tree, like:
		// |	[
		// |		{ id: 123, label: "apple", foo: "bar" },
		// |		{ id: 456, label: "pear", zaz: "bam" }
		// |	]
		// tags:
		//		extension

		// TODO: for 2.0 refactor so itemCreator() is called once per drag node, and
		// make signature itemCreator(sourceItem, node, target) (or similar).

		return dojo.map(nodes, function(node){
			return {
				"id": node.id,
				"name": node.textContent || node.innerText || ""
			};
		}); // Object[]
	},

	onDndDrop: function(source, nodes, copy){
		// summary:
		//		Topic event processor for /dnd/drop, called to finish the DnD operation.
		// description:
		//		Updates data store items according to where node was dragged from and dropped
		//		to.   The tree will then respond to those data store updates and redraw itself.
		// source: Object
		//		The dijit.tree.dndSource / dojo.dnd.Source which is providing the items
		// nodes: DomNode[]
		//		The list of transferred items, dndTreeNode nodes if dragging from a Tree
		// copy: Boolean
		//		Copy items, if true, move items otherwise
		// tags:
		//		protected
		if(this.containerState == "Over"){
			var tree = this.tree,
				model = tree.model,
				target = this.targetAnchor,
				requeryRoot = false;	// set to true iff top level items change

			this.isDragging = false;

			// Compute the new parent item
			var targetWidget = target;
			var newParentItem;
			var insertIndex;
			newParentItem = (targetWidget && targetWidget.item) || tree.item;
			if(this.dropPosition == "Before" || this.dropPosition == "After"){
				// TODO: if there is no parent item then disallow the drop.
				// Actually this should be checked during onMouseMove too, to make the drag icon red.
				newParentItem = (targetWidget.getParent() && targetWidget.getParent().item) || tree.item;
				// Compute the insert index for reordering
				insertIndex = targetWidget.getIndexInParent();
				if(this.dropPosition == "After"){
					insertIndex = targetWidget.getIndexInParent() + 1;
				}
			}else{
				newParentItem = (targetWidget && targetWidget.item) || tree.item;
			}

			// If necessary, use this variable to hold array of hashes to pass to model.newItem()
			// (one entry in the array for each dragged node).
			var newItemsParams;

			dojo.forEach(nodes, function(node, idx){
				// dojo.dnd.Item representing the thing being dropped.
				// Don't confuse the use of item here (meaning a DnD item) with the
				// uses below where item means dojo.data item.
				var sourceItem = source.getItem(node.id);

				// Information that's available if the source is another Tree
				// (possibly but not necessarily this tree, possibly but not
				// necessarily the same model as this Tree)
				if(dojo.indexOf(sourceItem.type, "treeNode") != -1){
					var childTreeNode = sourceItem.data,
						childItem = childTreeNode.item,
						oldParentItem = childTreeNode.getParent().item;
				}

				if(source == this){
					// This is a node from my own tree, and we are moving it, not copying.
					// Remove item from old parent's children attribute.
					// TODO: dijit.tree.dndSelector should implement deleteSelectedNodes()
					// and this code should go there.

					if(typeof insertIndex == "number"){
						if(newParentItem == oldParentItem && childTreeNode.getIndexInParent() < insertIndex){
							insertIndex -= 1;
						}
					}
					model.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex);
				}else if(model.isItem(childItem)){
					// Item from same model
					// (maybe we should only do this branch if the source is a tree?)
					model.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex);
				}else{
					// Get the hash to pass to model.newItem().  A single call to
					// itemCreator() returns an array of hashes, one for each drag source node.
					if(!newItemsParams){
						newItemsParams = this.itemCreator(nodes, target.rowNode, source);
					}

					// Create new item in the tree, based on the drag source.
					model.newItem(newItemsParams[idx], newParentItem, insertIndex);
				}
			}, this);

			// Expand the target node (if it's currently collapsed) so the user can see
			// where their node was dropped.   In particular since that node is still selected.
			this.tree._expandNode(targetWidget);
		}
		this.onDndCancel();
	},

	onDndCancel: function(){
		// summary:
		//		Topic event processor for /dnd/cancel, called to cancel the DnD operation
		// tags:
		//		private
		this._unmarkTargetAnchor();
		this.isDragging = false;
		this.mouseDown = false;
		delete this.mouseButton;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},

	// When focus moves in/out of the entire Tree
	onOverEvent: function(){
		// summary:
		//		This method is called when mouse is moved over our container (like onmouseenter)
		// tags:
		//		private
		this.inherited(arguments);
		dojo.dnd.manager().overSource(this);
	},
	onOutEvent: function(){
		// summary:
		//		This method is called when mouse is moved out of our container (like onmouseleave)
		// tags:
		//		private
		this._unmarkTargetAnchor();
		var m = dojo.dnd.manager();
		if(this.isDragging){
			m.canDrop(false);
		}
		m.outSource(this);

		this.inherited(arguments);
	},

	_isParentChildDrop: function(source, targetRow){
		// summary:
		//		Checks whether the dragged items are parent rows in the tree which are being
		//		dragged into their own children.
		//
		// source:
		//		The DragSource object.
		//
		// targetRow:
		//		The tree row onto which the dragged nodes are being dropped.
		//
		// tags:
		//		private

		// If the dragged object is not coming from the tree this widget belongs to,
		// it cannot be invalid.
		if(!source.tree || source.tree != this.tree){
			return false;
		}


		var root = source.tree.domNode;
		var ids = source.selection;

		var node = targetRow.parentNode;

		// Iterate up the DOM hierarchy from the target drop row,
		// checking of any of the dragged nodes have the same ID.
		while(node != root && !ids[node.id]){
			node = node.parentNode;
		}

		return node.id && ids[node.id];
	},

	_unmarkTargetAnchor: function(){
		// summary:
		//		Removes hover class of the current target anchor
		// tags:
		//		private
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor.rowNode, this.dropPosition);
		this.targetAnchor = null;
		this.targetBox = null;
		this.dropPosition = null;
	},

	_markDndStatus: function(copy){
		// summary:
		//		Changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	}
});

}

if(!dojo._hasResource['bfree.widget.folder.DndSource']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.folder.DndSource'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: aaron
 * Date: 28/11/11
 * Time: 12:42 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.folder.DndSource');



dojo.declare('bfree.widget.folder.DndSource', dijit.tree.dndSource, {
    singular: true,

    _normalizedCreator: null,

    _checkDocumentDrag: function(sourceItems){
        var canDrag = true;
        //Place holder for start of document drag
        return canDrag;
    },

    _checkReferenceAcceptance: function(targetFolder, sourceItems){
        var canDrop = true;

        //We can drop a reference into:
        //- Never its current folder
        //- Trash Folder (with delete permissions)
        //- "Share" folder (Not the share root)
        //- Another content folder (with move permissions)
        //- Can't 'move' deleted items (yet)
        if(sourceItems[0].folder_id == targetFolder.getId()){
            canDrop = false;
        }
        else if(sourceItems[0].isDeleted()){
            canDrop = false;
        }
        else if(targetFolder.isSpecial()){
            if(targetFolder.isTrash()){
                canDrop = dojo.every(sourceItems, function(item, idx){
                    return item.hasRights(bfree.api._Securable.permissions.DELETE_ITEMS);
                }, this);
            }
            if(targetFolder.isSearch()){
                canDrop = false;
            }
            else if(targetFolder.isShareRoot()){
                canDrop = false;
            }
        }
        else if(targetFolder.hasRights(bfree.api._Securable.permissions.CREATE_DOCUMENTS)){
            canDrop = dojo.every(sourceItems, function(item, idx){
                return item.hasRights(bfree.api._Securable.permissions.WRITE_METADATA);
            }, this);
        }

        return canDrop;
    },

    _checkFolderAcceptance: function(targetFolder, sourceItems){
        var canDrop = true;

        //We can drop a folder into:
        // - Never its current parent
        // - Never drop folder into search folder.
        if(sourceItems[0].parent_id == targetFolder.getId()){
            canDrop = false;
        }
        else if(targetFolder.isSearch() || targetFolder.isShare()){
            canDrop = false;
        }

        return canDrop;

    },

    _checkFolderDrag: function(sourceItems){
        var canDrag = true;

        dojo.every(sourceItems, function(sourceItem, idx){

            if(sourceItem.isSpecial()){
                canDrag = false;
            }

            return canDrag;
        }, this);

        return canDrag;
    },

    _getSourceItems: function(source){
        var items = [];

        if(!source)
            return items;

        if(source.isInstanceOf(bfree.widget.folder.DndSource)){
            items.push(source.anchor.item);
        }
        else if(source.isInstanceOf(versa.widget.reference.dnd.Source)){
            var nodes = source.getSelectedNodes();
            dojo.forEach(nodes, function(node, idx){
                items.push(source.getItem(node.id).data);
            });
        }

        return items;
    },

    _getTargetItem: function(target){
        var targetNode = dijit.getEnclosingWidget(target);
        return targetNode.item;
    },

    _onFolderDrop: function(targetFolder, sourceItems){

        if(targetFolder.isTrash()){
             this.onCommand(bfree.widget.Bfree.Commands.DESTROY, bfree.widget.Bfree.ObjectTypes.FOLDER, {folder: sourceItems[0]});
        }
        else if(targetFolder.isShareRoot()){
            this.onCommand(bfree.widget.Bfree.Commands.NEW, bfree.widget.Bfree.ObjectTypes.SHARE, {folder: sourceItems[0]});
        }
    },

    _onReferenceDrop: function(targetFolder, sourceItems){

        if(targetFolder.isTrash()){
            this.onCommand(bfree.widget.Bfree.Commands.DELETE, bfree.widget.Bfree.ObjectTypes.DOCUMENT, {items: sourceItems});
        }
        else if(targetFolder.isShare()){
            this.onCommand(bfree.widget.Bfree.Commands.SHARE, bfree.widget.Bfree.ObjectTypes.DOCUMENT, {folder: targetFolder, items: sourceItems});
        }
        else{
            this.onCommand(bfree.widget.Bfree.Commands.MOVE, bfree.widget.Bfree.ObjectTypes.DOCUMENT, {folder: targetFolder, items: sourceItems})
        }

    },


    checkItemAcceptance: function(target, source, position){
        var canDrop = false;

        var targetItem = this._getTargetItem(target);
        var sourceItems = this._getSourceItems(source);

        if((!targetItem) || (sourceItems.length < 1))
            return canDrop;

        if(sourceItems[0].isInstanceOf(bfree.api.Reference)){
            canDrop = this._checkReferenceAcceptance(targetItem, sourceItems);
        }
        else if(sourceItems[0].isInstanceOf(bfree.api.Folder)){
            canDrop = this._checkFolderAcceptance(targetItem, sourceItems);
        }

        return canDrop;

    },

    constructor: function(args){
        //this._normalizedCreator = this._dndCreator;
        this._normalizedCreator = this.creator;
    },

    creator: function(treeNode, hint){
        var node = null;

        if(hint == 'avatar'){

            var imgSrc = bfree.api.Folder.getIconUrl(treeNode.item, 16);

            node = dojo.create('div',{
                'class': 'dijitDarkLabel',
                innerHTML: treeNode.item.name,
                style: {
                    paddingLeft: '18px',
                    height: '16px',
                    position: 'relative'
                }
            });
            dojo.create('img', {
                src: imgSrc,
                style: {
                    left: '0',
                    position: 'absolute',
                    top: '0'
                }
            }, node);

        }
        else{
            //create a 'dummy' node...will never be used for selection
            node = dojo.create('div', {innerHTML: treeNode.item.name});
        }

        return {node: node, data: treeNode, type: 'folder'};
    },

    onCommand: function(cmdId, option, params){
    },

    onDndDrop: function(source, nodes, copy){

        try{

            if(!this.targetAnchor)
                return;


            var targetItem = this.targetAnchor.item;
            var sourceItems = this._getSourceItems(source);

            if((!targetItem) || (sourceItems.length < 1))
                return;

            if(sourceItems[0].isInstanceOf(bfree.api.Reference)){
                this._onReferenceDrop(targetItem, sourceItems);
            }
            else if(sourceItems[0].isInstanceOf(bfree.api.Folder)){
                this._onFolderDrop(targetItem, sourceItems);
            }

            //this.tree._onItemsDnd(targetItem, sourceItems);
        }
        finally{
            this.inherited('onDndCancel', arguments);
        }
    },

    onDndStart: function(source, nodes, copy){

        if(source === this){
            //Can't dnd:
            //- Root folder
            //- Recycle Bin
            //- Search
            //- Shares
            var canDnd = dojo.every(nodes, function(node, idx){
                var treeNode = source.getItem(node.id).data;
                return !(treeNode.item.root || treeNode.item.isTrash() || treeNode.item.isShareRoot() || treeNode.item.isShare() );
            });

            if(!canDnd){
                dojo.dnd.manager().stopDrag();
                return;
            }
        }

        this.inherited('onDndStart', arguments);

    },

    moveFolder: function(args){
        var anchor=args.anchor;
        var targetAnchor=args.targetAnchor;
        var parentNode=anchor.getParent();

        targetAnchor.expand();

        var targetId=targetAnchor.item.id||targetAnchor.item.root?targetAnchor.item.id:targetAnchor.item.$ref;

        this.tree.folders.loadItem({
            item: targetAnchor.item,
            callback: dojo.hitch(this, function(item){
                this.tree.folders.setValue(anchor.item, 'parent_id', targetId);
                this.tree.model.pasteItem(anchor.item, parentNode.item, item, false);
            })
        });

        this.tree.folders.save();


        dojo.removeClass(targetAnchor.domNode, 'dijitTreeRowSelected');
        dojo.removeClass(targetAnchor.domNode, 'dijitTreeRowHover');

        this.tree.setSelectedPath(anchor.item.path);
    },


    onMouseDown: function(e){
		// summary:
		//		Event processor for onmousedown
		// e: Event
		//		onmousedown event
		// tags:
		//		private
        if(!(e.target.type&&e.target.type=='text')){
            this.mouseDown = true;
            this.mouseButton = e.button;
            this._lastX = e.pageX;
            this._lastY = e.pageY;
            this.inherited(arguments);
        }
	}
});

}

if(!dojo._hasResource['bfree.widget.group.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.group.CommandBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/12/11
 * Time: 1:17 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.group.CommandBar');





dojo.declare('bfree.widget.group.CommandBar', [dijit.Toolbar], {

    activeItem: null,

    _btnDelete: null,
    _btnEdit: null,
    _btnNew: null,
    _btnSave: null,
    _btnUndo: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;
        this._setState();
    },

    _setState: function(){

        var isDirty = this.groups.isDirty();
        var isNull = (this.activeItem == null);
        var canDelete = !((!isNull) && (this.activeItem.is_admin || this.activeItem.is_everyone));

        this._btnSave.set('disabled', !isDirty);
        this._btnUndo.set('disabled', !isDirty);
        this._btnEdit.set('disabled', isNull);
        this._btnDelete.set('disabled', !canDelete || isNull);

    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

         this._btnSave = new bfree.widget.Button({
                id: 'btnGroupsSave',
                label: 'Save Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconSave',
                disabledIconClass:'commandIcon bfreeIconSaveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.SAVE)
            });
        this.addChild(this._btnSave);

        this._btnUndo = new bfree.widget.Button({
                id: 'btnGroupsUndo',
                label: 'Undo Unsaved Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconUndo',
                disabledIconClass: 'commandIcon bfreeIconUndoD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.UNDO)
            });
        this.addChild(this._btnUndo);

        this._btnNew = new bfree.widget.Button({
                label: 'New Group...',
                showLabel: false,
                disabled: false,
                iconClass: 'commandIcon bfreeIconGroup',
                disabledIconClass: 'commandIcon bfreeIconGroupD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.NEW)
            });
        this.addChild(this._btnNew);

        this._btnEdit = new bfree.widget.Button({
                label: 'Edit selected Group...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconEdit',
                disabledIconClass: 'commandIcon bfreeIconEditD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT)
            });
        this.addChild(this._btnEdit);

        this._btnDelete = new bfree.widget.Button({
                label: 'Delete selected Group',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconDelete',
                disabledIconClass: 'commandIcon bfreeIconDeleteD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.DELETE)
            });
        this.addChild(this._btnDelete);

        this.addChild(new dijit.ToolbarSeparator());

        /*
        this._btnHelp =  new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconHelp',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            });
        this.addChild(this._btnHelp);
        */
    },

    startup: function(){
        this.inherited('startup', arguments);
    }

});

}

if(!dojo._hasResource['bfree.widget.SortGrid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.SortGrid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/11/11
 * Time: 11:57 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.SortGrid');



dojo.declare('bfree.widget.SortGrid', [bfree.widget._Grid], {

    sort_field: null,

    _canSort: function(){
        return false;
    },

    _swapItems: function(item1, item2){

        this.beginUpdate();

	    var order1 = this.store.getValue(item1, this.sort_field);
	    var order2 = this.store.getValue(item2, this.sort_field);

	    this.store.setValue(item1, this.sort_field, order2);
	    this.store.setValue(item2, this.sort_field, order1);

	    this.endUpdate();

        this.sort();

    },

    constructor: function(args){
        this.canSort = this._canSort;
        this.sortInfo = (args.sortInfo) ? args.sortInfo : 1;
    },

    moveItem: function(item, move){

        var idx = this.getItemIndex(item) + move;
	    if((idx < 0 ) || (idx >= this.rowCount)) return;

	    var swapItem = this.getItem(idx);

        this._swapItems(item, swapItem);

	    idx = this.getItemIndex(item);
	    this.setSelectedIndex(idx);

    }

});

bfree.widget.SortGrid.move = { 'UP' : -1, 'DOWN': 1};

}

if(!dojo._hasResource['bfree.widget.group.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.group.Info'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/12/11
 * Time: 10:42 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.group.Info');







dojo.declare('bfree.widget.group.Info', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/group", "template/Info.html", "<div style=\"width:100%;height:100%\">\n\n     <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    _form: null,
    _lblId: null,
    _lblIsAdmin: null,
    _lblIsEveryone: null,
    _lblCreatedBy: null,
    _lblCreatedAt: null,
    _lblUpdatedBy: null,
    _lblUpdatedAt: null,
    _tblProperties: null,

    activeItem: null,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        this._lblId.set('value', this.activeItem.id);
        this._lblIsAdmin.set('value', this.activeItem.is_admin);
        this._lblIsEveryone.set('value', this.activeItem.is_everyone);
        this._lblCreatedBy.set('value', this.activeItem.created_by);
        this._lblCreatedAt.set('value', (this.activeItem.created_at) ? dojo.date.locale.format(this.activeItem.created_at, {formatLength: 'medium'}) : '');
        this._lblUpdatedBy.set('value', this.activeItem.updated_by);
        this._lblUpdatedAt.set('value', (this.activeItem.updated_at) ? dojo.date.locale.format(this.activeItem.updated_at, {formatLength: 'medium'}) : '');

        this._tblProperties.refresh();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'infoObjForm'
        }, this.formNode);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblObjInfo1',
            customClass: 'versainfo',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._lblId = new bfree.widget.Label({
               id: 'lblId',
               label: 'ID'
            });
        this._tblProperties.addChild(this._lblId);

        this._lblIsAdmin = new bfree.widget.Label({
               id: 'lblIsAdmin',
               label: 'Administrator?'
            });
        this._tblProperties.addChild(this._lblIsAdmin);

         this._lblIsEveryone= new bfree.widget.Label({
               id: 'lblIsEveryone',
               label: 'Everyone?'
            });
        this._tblProperties.addChild(this._lblIsEveryone);

        this._lblCreatedBy = new bfree.widget.Label({
               id: 'lblCreatedBy',
               label: 'Created By'
            });
        this._tblProperties.addChild(this._lblCreatedBy);

        this._lblCreatedAt = new bfree.widget.Label({
               id: 'lblCreatedAt',
               label: 'Create Date'
            });
        this._tblProperties.addChild(this._lblCreatedAt);

        this._lblUpdatedBy = new bfree.widget.Label({
               id: 'lblUpdatedBy',
               label: 'Last Modified By:'
            });
        this._tblProperties.addChild(this._lblUpdatedBy);

        this._lblUpdatedAt = new bfree.widget.Label({
               id: 'lblUpdatedAt',
               label: 'Last Modified Date'
            });
        this._tblProperties.addChild(this._lblUpdatedAt);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.group.UserBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.group.UserBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/12/11
 * Time: 2:21 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.group.UserBar');





dojo.declare('bfree.widget.group.UserBar', [dijit.Toolbar], {

    _btnAdd: null,
    _btnRemove: null,

    activeGroup: null,
    activeUser: null,
    disabled: false,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveGroupAttr: function(item){
        this.activeGroup = item;
        this._setState();
    },

    _setActiveUserAttr: function(item){
        this.activeUser = item;
        this._setState();
    },

    _setDisabledAttr: function(value){
        this.disabled = value;
        this._setState();
    },

    _setState: function(){

        if(this.disabled){
            this._btnAdd.set('disabled', this.disabled);
            this._btnRemove.set('disabled', this.disabled);
        }
        else{

            var isGrpNull = (this.activeGroup == null);
            var isUsrNull = (this.activeUser == null);
            var isGrpEveryone = (this.activeGroup) ? this.activeGroup.is_everyone : false;;
            var isUsrAdmin = (this.activeUser) ? this.activeUser.is_admin[0] : false;

            var canAdd = !(isGrpNull || isGrpEveryone);
            var canRemove = !(isGrpNull || isUsrNull || isUsrAdmin || isGrpEveryone);

            this._btnAdd.set('disabled', !canAdd);
            this._btnRemove.set('disabled', !canRemove);

        }

    },


    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnAdd = new bfree.widget.Button({
            id: 'btnAddUser',
            label: 'Add User to Group...',
            showLabel: false,
            disabled: false,
            iconClass: 'commandIcon bfreeIconAdd',
            disabledIconClass:'sidebarIcon bfreeIconAddD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.ADD)
        });
        this.addChild(this._btnAdd);

        this._btnRemove = new bfree.widget.Button({
                id: 'btnRemoveUser',
                label: 'Remove User from Group...',
                showLabel: false,
                disabled: false,
                iconClass: 'sidebarIcon bfreeIconRemove',
                disabledIconClass: 'commandIcon bfreeIconRemoveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.REMOVE)
            });
        this.addChild(this._btnRemove);

    },

    startup: function(){
        this.inherited('startup', arguments);
        console.log('group.UserBar > startup');

    }
});

}

if(!dojo._hasResource['bfree.widget.user.FilterGrid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.FilterGrid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/12/11
 * Time: 1:15 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.FilterGrid');





dojo.declare('bfree.widget.user.FilterGrid', [bfree.widget._Grid], {

    _store: null,
    _view: [{
        cells: [
            {
                field: 'name',
                name: 'Name',
                width: 'auto'
            },
            {
                field: 'filter',
                name: 'Filter',
                width: '64px',
                hidden: true
            }
        ],
        width: 'auto'
    }],

    selectionMode: 'single',
    users: null,
    idFilter: [],

    _buildStore: function(){

        var items = [];

        this.users.forEach(function(item, idx){

            items.push({
                id: item.id,
                name: item.getFullName(),
                filter: dojo.has(this.idFilter, item.id)
            });

        }, this);

         this._store = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: items
            }
        });

    },

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Users found';
        this.sortInfo = 1;
	},

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this._buildStore();

        this.set('structure', this._view);
        //this.set('sortInfo', 2);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this._store);

        this.filter({filter: false});
    }

});

}

if(!dojo._hasResource['bfree.widget.user.List']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.List'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/12/11
 * Time: 12:54 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.List');










dojo.declare('bfree.widget.user.List', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/user", "template/List.html", "<div style=\"height:100%;width:100%\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            style=\"height:100%;width:100%;\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                region=\"center\"\n                splitter=\"false\"\n                style=\"\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n"),
    widgetsInTemplate: true,

    users: null,
    filter: [],

    _grdUsers: null,

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onSelectedItems: function(items){
        this.onValueChange();
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._grdUsers){
            this._grdUsers.destroyRecursive();
            this._grdUsers = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._grdUsers.domNode.focus();
    },

    isValid: function(){
        return true; //(this._grdUsers.selection.getSelectedCount() > 0);
    },

    onDialogClosing: function(dlgResult){

        var items = [];

        if(dlgResult == bfree.widget.Dialog.dialogResult.cancel){
            this.returnValue = items;
        }
        else{

            dojo.forEach(this._grdUsers.selection.getSelected(), function(item,idx){
                var id = this._grdUsers.store.getIdentity(item);
                items.push(id);
            }, this);

           this.returnValue = items;
        }

        return true;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._grdUsers = new bfree.widget.user.FilterGrid({
            id: 'grdUserList',
            'class': 'versaGridOutlineNoPad',
            users: this.users,
            selectionMode: 'extended',
            autoSelect: false,
            idFilter: this.filter,
            onSelectedItems: dojo.hitch(this, this._onSelectedItems)
        }, this.gridNode);
        this._grdUsers.startup();

    },

    startup: function(){
        this.inherited('startup', arguments);
        setTimeout(bfree.widget.user.List._loadFnRef(this), 10);
    }

});

bfree.widget.user.List._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.user.List.show = function(args){
    var dlg = new bfree.widget.Dialog({
        id: 'dlgUserList',
        title: 'Select User(s)...',
        widgetConstructor: bfree.widget.user.List,
        widgetParams: {
            users: args.users,
            filter: args.filter
        },
        noResize: true,
        height: 320,
        width: 320,
        zIndex: 2048,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}

}

if(!dojo._hasResource['bfree.widget.group.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.group.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 11/12/11
 * Time: 6:20 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.group.Editor');















dojo.declare('bfree.widget.group.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/group", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        liveSplitters=\"true\"\n        style=\"width:100%;height:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"top\"\n            style=\"overflow:hidden;padding:0;height: 100px;\">\n\n         <div dojoAttachPoint=\"formNode\">\n\n            <div dojoAttachPoint=\"tableNode\"></div>\n\n        </div>\n\n        Users:\n    </div>\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            splitter=\"false\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"width:100%;height:100%\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\">\n\n            <div dojoAttachPoint=\"userGridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"right\"\n                style=\"overflow:hidden;padding:16px 0 0 0;width:24px\">\n\n            <div dojoAttachPoint=\"userBarNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"bottom\"\n            style=\"padding:0 8px 0 8px;height: 112px;\">\n\n        <div dojoAttachPoint=\"infoNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _handles: [],

    _cmdBar: null,
    _form: null,
    _grdUsers: null,
    _tblProperties: null,
    _txtDescription: null,
    _txtName: null,
    _userStore: null,
    _wdgInfo: null,

    activeItem: null,
    groups: null,
    users: null,



    __onUserDlgClose: function(dlgResult, retValue){

        var item = null;

        if(dlgResult == bfree.widget.Dialog.dialogResult.ok){

            try{
                this._grdUsers.beginUpdate();
                dojo.forEach(retValue, function(id){
                    var user = this.users.fetchById({id: id});

                    var item = this._userStore.newItem({
                        id: user.id,
                        name: user.getFullName(),
                        is_admin: user.is_admin
                    });

                }, this);
            }
            finally{
                this._grdUsers.endUpdate();
            }

        }

        if(item){
            this._grdUsers.setSelectedItem(item);
        }

        return true;
    },


    _grdUsers_onSelectedItem: function(item){
        this._cmdBar.set('activeUser', item);
    },


    _onUserCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.ADD:
                this._onUserAdd();
                break;
            case bfree.widget.Bfree.Commands.REMOVE:
                this._onUserRemove();
        }
    },


    _onUserAdd: function(){

        try{

            var filter = [];

            //Never allow admin to be put in other groups.
            var admin = this.users.getAdmin();
            filter.push(admin.id);

            dojo.forEach(this.activeItem.active_users, function(item, idx){
                filter.push(item.user_id);
            },this);

            bfree.widget.user.List.show({
                users: this.users,
                filter: filter,
                onClose: dojo.hitch(this, this.__onUserDlgClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Users\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onUserCreated: function(newItem, parentInfo){

        var groups = this.groups.fetch();

        dojo.forEach(groups, function(group, idx){
            for(var i=0;i<group.active_users.length;i++){
                if(!group.is_everyone){
                    if(group.active_users[i].user_id==this._userStore.getIdentity(newItem)){
                        group.active_users.removeByValue(group.active_users[i]);
                        break;
                    }
                }
            }
        }, this);

        this.activeItem.active_users.push({
            user_id: this._userStore.getIdentity(newItem)
        });

        this.onValueChange(this.activeItem, 'active_users', [], this.activeItem.active_users);

    },

    _onUserDeleted: function(deletedItem){

        for(var idx = 0; idx < this.activeItem.active_users.length; idx++){
            var id =  this._userStore.getIdentity(deletedItem);
            if(this.activeItem.active_users[idx].user_id == id){
                this.activeItem.active_users.splice(idx, 1);
                break;
            }
        }
        this.onValueChange(this.activeItem, 'active_users', [], this.activeItem.active_users);

    },

    _onUserRemove: function(item){

        var idx = 0;

        try{

            this._grdUsers.beginUpdate();
            var item = this._grdUsers.selection.getFirstSelected();
            idx = this._grdUsers.getItemIndex(item);
            this._userStore.deleteItem(item);

        }
        catch(e){
            var err = new bfree.api.Error('Failed to remove User', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this._grdUsers.endUpdate();
        }

    },

    _onValueChange: function(property, newValue){

        if(!this.activeItem)
            return;

        var oldValue = this.users.getValue(this.activeItem, property);
        if(oldValue != newValue){
            this.users.store.setValue(this.activeItem, property, newValue);
            this.onValueChange(this.activeItem, property, oldValue, newValue);
        }

    },

    _setActiveItemAttr: function(item){

        this.activeItem = item;

        this._txtName.set('value', this.activeItem.name);
        this._txtDescription.set('value', this.activeItem.description);

        this._setStore();

        this._cmdBar.set('activeGroup', this.activeItem);
        this._wdgInfo.set('activeItem', this.activeItem);

        this._setState();

    },

    _setState: function(){

        var isDirty = this.groups.isDirty({item: this.activeItem});
        this._txtName.set('disabled', !isDirty);
        this._txtDescription.set('disabled', !isDirty);
        this._grdUsers.set('disabled', !isDirty);
        this._cmdBar.set('disabled', !isDirty);

    },

    _setStore: function(){

        var items = [];

        dojo.forEach(this.activeItem.active_users, function(active_user, idx){
            var user = this.users.fetchById({id: active_user.user_id});
            items.push({
                id: user.id,
                name: user.getFullName(),
                is_admin: user.is_admin
            });

        }, this);

        dojo.forEach(this._handles, function(hndl, idx){
            dojo.disconnect(hndl);
            delete this._handles[idx];
        }, this);


        this._userStore = new bfree.api.ItemFileWriteStore({
                data: {
                    identifier: 'id',
                    label: 'name',
                    items: items
                }
            });

        this._handles[0] = dojo.connect(this._userStore, 'onNew', this, this._onUserCreated);
        this._handles[1] = dojo.connect(this._userStore, 'onDelete', this, this._onUserDeleted);
        this._grdUsers.setStore(this._userStore);

    },

    constructor: function(args){

        this._userStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: []
            }
        });

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        if(this._wdgInfo){
            this._wdgInfo.destroy();
            this._wdgInfo = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
       this._txtName.setFocus(true);
    },

    onValueChange: function(item, property, oldValue, newValue){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'groupForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblGroup1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._txtName = new bfree.widget.ValidationTextBox({
            id: 'txtName',
            label: 'Name',
            required: true,
            intermediateChanges: true,
            selectOnClick: true,
            style: 'width:100%',
            trim: true,
            validator: dojo.hitch(this, this._txtNameValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'name')
		});
        this._tblProperties.addChild(this._txtName);

        this._txtDescription = new dijit.form.SimpleTextarea({
            label: 'Description',
            'class': 'bfree',
            style: 'resize:none;width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'description')
        });
        this._tblProperties.addChild(this._txtDescription);

        this._grdUsers = new bfree.widget._Grid({
            id: 'grdGroupUsers',
            'class': 'versaGridOutline versaNoHeader',
            query: {},
            noDataMessage: 'No Users in Group',
            store: this._userStore,
            structure: bfree.widget.group.Editor.view1,
            formatterScope: this,
            sortInfo: 2,
            rowsPerPage: 1000,
            style: 'width:100%;height:100%',
            onSelectedItem: dojo.hitch(this, this._grdUsers_onSelectedItem)
        }, this.userGridNode);

        this._cmdBar = new bfree.widget.group.UserBar({
            id: 'user',
            'class': 'versaSidebar',
            activeStore: this._userStore,
            onCommand: dojo.hitch(this, this._onUserCommand)
        }, this.userBarNode);

        this._wdgInfo = new bfree.widget.group.Info({
            id: 'wdgGroupInfo1'
        }, this.infoNode);

        this._grdUsers.startup();
    },

    _txtNameValidator: function(newValue){
        if(this._txtName){
            if(newValue.trim()==''){
                this._txtName.set('invalidMessage', 'Name cannot be blank');
                return false;
            }
            var items=this.groups.fetch();
            for(var i=0;i<items.length;i++){
                if(items[i].name&&
                   items[i].name.toLowerCase().trim()==newValue.toLowerCase().trim()&&
                   items[i].__id!=this.activeItem.__id){
                    this._txtName.set('invalidMessage', 'Duplicate group name');
                    return false;
                }
            }
        }
        return true;
    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();


    }


});

bfree.widget.group.Editor.view1 = [
    {
        cells: [
            {
                field: 'id',
                name: '&nbsp',
                width: '16px',
                hidden: true
            },
            {
                field: 'name',
                name: 'Property',
                width: 'auto'
            }
        ],
        width: 'auto'
    }
];

}

if(!dojo._hasResource['bfree.widget.group.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.group.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 11/12/11
 * Time: 4:28 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.group.Grid');



dojo.declare('bfree.widget.group.Grid', [bfree.widget._Grid], {

    groups: null,

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },


	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};
		this.selectionMode = 'single';

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Groups found';
        this.sortInfo = 3;

	},

	postCreate: function(){
		this.inherited('postCreate', arguments);
        this.set('structure', bfree.widget.group.Grid.view);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this.groups.store, {}, {cache: true});
    }

});

bfree.widget.group.Grid.getState = function(idx, item){

    if(!item)
        return 0;

    if(!item.isValid())
        return -1;

    if(this.grid.groups.isNew({item: item}))
        return 1;
    if(this.grid.groups.isDirty({item: item}))
        return 2;

    return 0;
}

bfree.widget.group.Grid.formatState = function(data, rowIndex){

    var iconClass = '';
    switch(data){
        case -1:
            iconClass = 'statusIcon bfreeIconInvalid';
            break;
        case 1:
            iconClass = 'statusIcon bfreeIconNew';
            break;
        case 2:
            iconClass = 'statusIcon bfreeIconEdit';
            break;
    }

    return dojo.replace('<img src="/images/icons/16/blank.png" width="16" height="16" class="{0}"/>', [iconClass]);
}

bfree.widget.group.Grid.view = [
    {
        cells: [
            {
                field: 'state',
                name: '&nbsp;',
                width: '16px',
                get: bfree.widget.group.Grid.getState,
                formatter: bfree.widget.group.Grid.formatState
            },
            {
                field: 'name',
                name: 'Name',
                width: 'auto'
            },
            {
                field: 'sort_id',
                name: 'Sort',
                hidden: true
            }
        ],
        width: 'auto'
    }
];

}

if(!dojo._hasResource['bfree.widget.group.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.group.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 11/12/11
 * Time: 4:23 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.group.Administration');










dojo.declare('bfree.widget.group.Administration', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget], {
    templateString: dojo.cache("bfree/widget/group", "template/Administration.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n     <!-- Command Bar -->\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;height:27px\">\n\n        <div dojoAttachPoint=\"commandBarNode\"></div>\n\n    </div>\n\n     <div   dojoType=\"dijit.layout.BorderContainer\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"padding:8px;height:100%;width:100%\">\n\n\n         <div   dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"leading\"\n                style=\"padding:0 8px 0 0;width: 256px;\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"true\"\n                region=\"center\"\n                class=\"highlightPane\"\n                style=\"padding:8px\">\n\n            <div dojoAttachPoint=\"editorNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _cmdBar: null,
    _editor: null,
    _grdGroups: null,
    _groups: null,
    _users: null,

    activeUser: null,
    zone: null,

    _grdGroups_onSelectedItems: function(items){
        var item = null;

        if((!items) || (items.length < 1))
            return;

        item = items[0];

        this._cmdBar.set('activeItem', item);
        this._editor.set('activeItem', item);
    },

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.NEW:
                this.createItem();
                break;
            case bfree.widget.Bfree.Commands.EDIT:
                this.editItem();
                break;
            case bfree.widget.Bfree.Commands.DELETE:
                this.deleteItem();
                break;
            case bfree.widget.Bfree.Commands.SAVE:
                this.save();
                break;
            case bfree.widget.Bfree.Commands.UNDO:
                this.undo();
                break;

        }

    },

    _onValueChange: function(item, property, oldValue, newValue){
        var idx = this._grdGroups.getItemIndex(item);
        this._grdGroups.updateRow(idx);
    },

    _validateItems: function(active){
        var valid = true;

		for(var idx = 0; idx < this._grdGroups.rowCount; idx++){
            var item = this._grdGroups.getItem(idx);
            if(this._groups.isDirty({item: item})){
                //this allows deletion of an invalid group
                if(!active||(active&&active.__id!=item.__id)){
                    var items=this._groups.fetch();
                    for(var i=0;i<items.length;i++){
                        if(items[i].name&&
                           items[i].name.toLowerCase().trim()==item.name.toLowerCase().trim()&&
                           items[i].__id!=item.__id){
                            return false;
                        }
                    }
                    valid &= item.isValid();
                }
            }
		}

		return valid;
	},

    constructor: function(args){

    },

    createItem: function(){
        try{

            var uniqueName = this._groups.generateUniqueName({base_name: 'group', appendix: '{index}'});
            var item = this._groups.create({
                name: uniqueName,
                description: '',
                created_by: this.activeUser.name,
                created_at: new Date(),
                updated_by: this.activeUser.name,
                updated_at: new Date(),
                is_admin: false,
                is_everyone: false,
                active_users: []
            });
            this._grdGroups.selectItem(item);
            this._editor.focus();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to create Group', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    deleteItem: function(){

        try{

            var item = this._grdGroups.selection.getFirstSelected();
            if(item){

                if(!this._validateItems(item)){
                    var msg = 'Cannot delete Group: One or more Groups contain invalid data';
                    alert(msg);
                    return;
                }

                var msg = dojo.replace('Are you sure you want to delete the group: \'{0}\'?', [item.name]);
                if (!confirm(msg))
                    return;

                var idx = this._grdGroups.getItemIndex(item);
                this._groups.destroy({item: item});
                this._grdGroups.setSelectedIndex(idx);
                this._editor.focus();
                //twice?
//                this._grdGroups.setSelectedIndex(idx);
            }

        }
        catch(e){
           var err = new bfree.api.Error('Failed to delete User', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }


    },

    destroy: function(){

        this.destroyDescendants();

        if(this._editor){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    editItem: function(){

        try{

            var item = this._grdGroups.selection.getFirstSelected();
            if(item){
                var idx = this._grdGroups.getItemIndex(item);
                this._groups.clone({item: item});
                this._grdGroups.updateRow(idx);
                this._grdGroups.setSelectedIndex(idx);
                this._editor.focus();
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to edit Group', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    isValid: function(){
        //return (this.isDirty || this._grd.store.isDirty());
        return true;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(this._groups.isDirty()){
                var msg = 'You have unsaved changes that will be lost. Do you wish to continue?';
                if(confirm(msg)){
                    if(this._groups != null)
                        this._groups.revert();
                    canClose = true;
                }
            }
            else{
                canClose = true;
            }
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close Group Administration dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._users = this.zone.getUsers();
        this._users.refresh();

        this._groups = this.zone.getGroups();
        this._groups.clearCache();

        this._cmdBar = new bfree.widget.group.CommandBar({
            id: 'cmdBar',
            groups: this._groups,
            onCommand: dojo.hitch(this, this._onCommand)
        }, this.commandBarNode);

        this._grdGroups = new bfree.widget.group.Grid({
            id: 'grdGroups',
            'class': 'versaGridOutline versaNoHeader',
            groups: this._groups,
            onSelectedItems: dojo.hitch(this, this._grdGroups_onSelectedItems)
        }, this.gridNode);

        this._editor = new bfree.widget.group.Editor({
            id: 'wdgEditor',
            groups: this._groups,
            users: this._users,
            onValueChange: dojo.hitch(this, this._onValueChange)
        }, this.editorNode);

    },

    save: function(){
        try{

            if(!this._validateItems()){
                var msg = 'Cannot save Group changes: One or more Groups contain invalid data';
                alert(msg);
                return;
            }

            var item = this._grdGroups.selection.getFirstSelected();
            this._groups.save({onComplete: dojo.hitch(this, this.saveOnComplete, item)});
        }
        catch(e){
            var err = new bfree.api.Error('Failed to save Group changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    saveOnComplete: function(item){
        this._groups.clearCache();
        this._grdGroups.sort();
        this._grdGroups.selectItem(item);
    },

    startup: function(){
        this.inherited('startup', arguments);

        this._grdGroups.startup();
        this._grdGroups.setSelectedIndex(0);

        setTimeout(bfree.widget.group.Administration._loadFnRef(this), 10);
    },

    undo: function(){
        try{

            var item = this._grdGroups.selection.getFirstSelected();

            this._groups.clearCache();
            this._groups.revert();

            if(item){
                var idx = this._grdGroups.getItemIndex(item);
                this._grdGroups.setSelectedIndex(idx);
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    }


});

bfree.widget.group.Administration._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.group.Administration.show = function(args){

    var dlg = new bfree.widget.Dialog({
        id: 'dlgGroupAdmin',
        title: 'Group Administration',
        widgetConstructor:  bfree.widget.group.Administration,
        widgetParams: {
            activeUser: args.user,
            zone: args.zone
        },
        noResize: true,
        height: 480,
        width: 640,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}

}

if(!dojo._hasResource['bfree.widget.doctype.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.CommandBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 10:10 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.CommandBar');





dojo.declare('bfree.widget.doctype.CommandBar', dijit.Toolbar, {

    _btnSave: null,
    _btnUndo: null,
    _btnNew: null,
    _btnEdit: null,
    _btnDelete: null,
    _btnHelp: null,

    activeItem: null,

    documentTypes: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;
        this._setState();
    },

    _setState: function(){

        var isDirty = this.documentTypes.isDirty();
        var isNull = (this.activeItem == null);

        var canDelete = !(isNull || this.activeItem.is_system);

        this._btnSave.set('disabled', !isDirty);
        this._btnUndo.set('disabled', !isDirty);
        this._btnEdit.set('disabled', isNull);
        this._btnDelete.set('disabled', !canDelete);
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._btnSave){
            this._btnSave.destroy();
            this._btnSave = null;
        }

        if(this._btnUndo){
            this._btnUndo.destroy();
            this._btnUndo = null;
        }

        if(this._btnNew){
            this._btnNew.destroy();
            this._btnNew = null;
        }

        if(this._btnEdit){
            this._btnEdit.destroy();
            this._btnEdit = null;
        }

        if(this._btnDelete){
            this._btnDelete.destroy();
            this._btnDelete = null;
        }

        if(this._btnHelp){
            this._btnHelp.destroy();
            this._btnHelp = null;
        }

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

         this._btnSave = new bfree.widget.Button({
                id: 'btnPropDefsSave',
                label: 'Save Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconSave',
                disabledIconClass:'commandIcon bfreeIconSaveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.SAVE)
            });
        this.addChild(this._btnSave);

        this._btnUndo = new bfree.widget.Button({
                label: 'Undo Unsaved Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconUndo',
                disabledIconClass: 'commandIcon bfreeIconUndoD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.UNDO)
            });
        this.addChild(this._btnUndo);

        this.addChild(new dijit.ToolbarSeparator());

        this._btnNew = new bfree.widget.Button({
                label: 'New Document Type...',
                showLabel: false,
                disabled: false,
                iconClass: 'commandIcon bfreeIconDocType',
                disabledIconClass: 'commandIcon bfreeIconAdminD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.NEW)
            });
        this.addChild(this._btnNew);

        this._btnEdit = new bfree.widget.Button({
                label: 'Edit selected DocumentType...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconEdit',
                disabledIconClass: 'commandIcon bfreeIconEditD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT)
            });
        this.addChild(this._btnEdit);

        this._btnDelete = new bfree.widget.Button({
                label: 'Delete selected Document Type',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconDelete',
                disabledIconClass: 'commandIcon bfreeIconDeleteD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.DELETE)
            });
        this.addChild(this._btnDelete);

        this.addChild(new dijit.ToolbarSeparator());

        /*
        this._btnHelp =  new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconHelp',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            });
        this.addChild(this._btnHelp);
        */
    }

});

}

if(!dojo._hasResource['bfree.widget.doctype.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.Info'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/12/11
 * Time: 8:55 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.Info');









dojo.declare('bfree.widget.doctype.Info', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/doctype", "template/Info.html", "<div style=\"width:100%;height:100%\">\n\n     <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    _form: null,
    _lblId: null,
    _lblIsSystem: null,
    _lblCreatedBy: null,
    _lblCreatedAt: null,
    _lblUpdatedBy: null,
    _lblUpdatedAt: null,
    _tblProperties: null,

    activeItem: null,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        if(item){
            this._lblId.set('value', this.activeItem.id);
            this._lblIsSystem.set('value', this.activeItem.is_system);
            this._lblCreatedBy.set('value', this.activeItem.created_by);
            this._lblCreatedAt.set('value', (this.activeItem.created_at) ? dojo.date.locale.format(this.activeItem.created_at, {formatLength: 'medium'}) : '');
            this._lblUpdatedBy.set('value', this.activeItem.updated_by);
            this._lblUpdatedAt.set('value', (this.activeItem.updated_at) ? dojo.date.locale.format(this.activeItem.updated_at, {formatLength: 'medium'}) : '');
        }
        else{
            this._lblId.reset();
            this._lblIsSystem.reset();
            this._lblCreatedBy.reset();
            this._lblCreatedAt.reset();
            this._lblUpdatedBy.reset();
            this._lblUpdatedAt.reset();
        }

        this._tblProperties.refresh();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants()

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'infoObjForm'
        }, this.formNode);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblObjInfo1',
            customClass: 'versainfo',
            showLabels: true,
            cols: 1,
            labelWidth: 112,
            style: 'width:100%'
        }, this.tableNode);

        this._lblId = new bfree.widget.Label({
               id: 'lblId',
               label: 'ID'
            });
        this._tblProperties.addChild(this._lblId);

        this._lblIsSystem = new bfree.widget.Label({
               id: 'lblIsSystem',
               label: 'System Document Type?'
            });
        this._tblProperties.addChild(this._lblIsSystem);

        this._lblCreatedBy = new bfree.widget.Label({
               id: 'lblCreatedBy',
               label: 'Created By:'
            });
        this._tblProperties.addChild(this._lblCreatedBy);

        this._lblCreatedAt = new bfree.widget.Label({
               id: 'lblCreatedAt',
               label: 'Create Date:'
            });
        this._tblProperties.addChild(this._lblCreatedAt);

        this._lblUpdatedBy = new bfree.widget.Label({
               id: 'lblUpdatedBy',
               label: 'Last Modified By:'
            });
        this._tblProperties.addChild(this._lblUpdatedBy);

        this._lblUpdatedAt = new bfree.widget.Label({
               id: 'lblUpdatedAt',
               label: 'Last Modified Date:'
            });
        this._tblProperties.addChild(this._lblUpdatedAt);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.doctype.PropMapBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.PropMapBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/12/11
 * Time: 2:21 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.PropMapBar');





dojo.declare('bfree.widget.doctype.PropMapBar', [dijit.Toolbar], {

    _btnAdd: null,
    _btnDown:null,
    _btnRemove: null,
    _btnUp: null,

    activeDocType: null,
    activePropMap: null,
    disabled: false,
    grid: null,
    valueStore: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveDocTypeAttr: function(item){
        this.activeDocType = item;
        this._setState();
    },

    _setActivePropMapAttr: function(item){
        this.activePropMap = item;
        this._setState();
    },

    _setDisabledAttr: function(value){
        this.disabled = value;
        this._setState();
    },

    _setState: function(){

        if(this.disabled){
            this._btnAdd.set('disabled', this.disabled);
            this._btnUp.set('disabled', this.disabled);
            this._btnDown.set('disabled', this.disabled);
            this._btnRemove.set('disabled', this.disabled);
        }
        else{
            var isDtNull = (this.activeDocType == null);
            var isPmNull = (this.activePropMap == null);
            var isName = ((this.activePropMap) && (this.activePropMap.is_name[0]));

            var idx = (this.activePropMap) ?
                    this.activePropMap.sort[0] :
                    0;

            var canAdd = true;
            var canMoveUp = (idx > 0);
            var canMoveDown = (idx < (this.grid.rowCount - 1));
            var canRemove = !(isDtNull || isPmNull || isName);

            this._btnAdd.set('disabled', !canAdd);
            this._btnUp.set('disabled', !canMoveUp);
            this._btnDown.set('disabled', !canMoveDown);
            this._btnRemove.set('disabled', !canRemove);
        }

    },


    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnAdd = new bfree.widget.Button({
            id: 'btnAddValue',
            label: 'Add Value to Choice List...',
            showLabel: false,
            disabled: false,
            iconClass: 'sidebarIcon bfreeIconAdd',
            disabledIconClass:'sidebarIcon bfreeIconAddD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.ADD)
        });
        this.addChild(this._btnAdd);

        this._btnUp = new bfree.widget.Button({
            id: 'btnValueUp',
            label: 'Move Value up...',
            showLabel: false,
            disabled: false,
            iconClass: 'sidebarIcon bfreeIconUp',
            disabledIconClass:'sidebarIcon bfreeIconUpD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.MOVE_UP)
        });
        this.addChild(this._btnUp);

        this._btnDown = new bfree.widget.Button({
            id: 'btnValueDown',
            label: 'Move Value down...',
            showLabel: false,
            disabled: false,
            iconClass: 'sidebarIcon bfreeIconDown',
            disabledIconClass:'sidebarIcon bfreeIconDownD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.MOVE_DOWN)
        });
        this.addChild(this._btnDown);

        this._btnRemove = new bfree.widget.Button({
                id: 'btnRemoveValue',
                label: 'Remove Value from Choice List...',
                showLabel: false,
                disabled: false,
                iconClass: 'sidebarIcon bfreeIconRemove',
                disabledIconClass: 'sidebarIcon bfreeIconRemoveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.REMOVE)
            });
        this.addChild(this._btnRemove);

    },

    startup: function(){
        this.inherited('startup', arguments);
        console.log('choicelist.ValuerBar > startup');

    }
});

}

if(!dojo._hasResource['bfree.widget.propdef.FilterGrid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.FilterGrid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 13/11/11
 * Time: 9:56 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.FilterGrid');





dojo.declare('bfree.widget.propdef.FilterGrid', [bfree.widget._Grid], {

    _store: null,
    _view: [{
        cells: [
            {
                field: 'name',
                name: 'Name',
                width: 'auto'
            },
            {
                field: 'data_type',
                name: 'Data Type',
                width: '80px'
            },
            {
                field: 'max_length',
                name: 'Length',
                width: '80px'
            },
            {
                field: 'filter',
                name: 'Filter',
                width: '64px',
                hidden: true
            }
        ],
        width: 'auto'
    }],

    _dataTypes: null,
    selectionMode: 'single',
    propertyDefinitions: null,
    idFilter: [],

    _buildStore: function(){

        var items = [];

        this.propertyDefinitions.forEach(function(item, idx){
            if(!(item.is_system && item.is_readonly)){
                var dataType = this._dataTypes.fetchById({id: item.data_type_id});

                items.push({
                    id: item.id,
                    name: item.name,
                    data_type: dataType.name,
                    max_length: item.max_length,
                    filter: dojo.has(this.idFilter, item.id)
                });
            }
        }, this);

         this._store = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: items
            }
        });

    },

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Property Definitions found';
        this.sortInfo = 1;
	},

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this._dataTypes = bfree.api.Application.getDataTypes();
        this._buildStore();

        this.set('structure', this._view);
        //this.set('sortInfo', 2);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this._store);

        this.filter({filter: false});
    }

});

}

if(!dojo._hasResource['bfree.widget.propdef.List']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.List'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 12/11/11
 * Time: 2:37 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.List');










dojo.declare('bfree.widget.propdef.List', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/propdef", "template/List.html", "<div style=\"height:100%;width:100%\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            style=\"height:100%;width:100%;\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                region=\"center\"\n                splitter=\"false\"\n                style=\"\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n"),
    widgetsInTemplate: true,

    propertyDefinitions: null,
    filter: [],

    _grdPropDefs: null,

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onSelectedItems: function(items){
        this.onValueChange();
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._grdPropDefs){
            this._grdPropDefs.destroyRecursive();
            this._grdPropDefs = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._grdPropDefs.domNode.focus();
    },

    isValid: function(){
        return (this._grdPropDefs.selection.getSelectedCount() > 0);
    },

    onDialogClosing: function(dlgResult){

        if(dlgResult == bfree.widget.Dialog.dialogResult.cancel){
            this.returnValue = null;
        }
        else{

            var items = []
            dojo.forEach(this._grdPropDefs.selection.getSelected(), function(item,idx){
                var id = this._grdPropDefs.store.getIdentity(item);
                items.push(id);
            }, this)

           this.returnValue = items;
        }

        return true;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._grdPropDefs = new bfree.widget.propdef.FilterGrid({
            id: 'grdPropDefs',
            'class': 'versaGridOutline',
            propertyDefinitions: this.propertyDefinitions,
            selectionMode: 'extended',
            autoSelect: false,
            idFilter: this.filter,
            onSelectedItems: dojo.hitch(this, this._onSelectedItems)
        }, this.gridNode);
        this._grdPropDefs.startup();

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._grdPropDefs.resize();

        setTimeout(bfree.widget.propdef.List._loadFnRef(this), 10);
    }

});

bfree.widget.propdef.List._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.propdef.List.show = function(args){

    var dlg = new bfree.widget.Dialog({
        id: 'dlgPropDefList',
        title: 'Select Property(s)...',
        widgetConstructor: bfree.widget.propdef.List,
        widgetParams: {
            propertyDefinitions: args.propertyDefinitions,
            filter: args.filter
        },
        noResize: true,
        height: 320,
        width: 320,
        zIndex: 2048,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['bfree.widget.doctype.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 1:54 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.Editor');




















dojo.declare('bfree.widget.doctype.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/doctype", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        liveSplitters=\"true\"\n        style=\"width:100%;height:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"top\"\n            style=\"overflow:hidden;padding:0;height: 76px;\">\n\n         <div dojoAttachPoint=\"formNode\">\n\n            <div dojoAttachPoint=\"tableNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            splitter=\"false\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"width:100%;height:100%\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\"\n                style=\"overflow:hidden;padding:16px 8px 8px 0;position:relative\">\n\n            <span class=\"dijitMediumLabel dijitDarkLabel\" style=\"position:absolute;top:0;left:0\">Properties</span>\n            <div dojoAttachPoint=\"propertyMappingsNode\" style=\"height:100%\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"right\"\n                style=\"overflow:hidden;padding:16px 0 0 0;width:24px\">\n\n            <div dojoAttachPoint=\"propMapBarNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"bottom\"\n            style=\"padding:0 8px 0 8px;height: 104px;\">\n\n        <div dojoAttachPoint=\"infoNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    activeItem: null,
    choiceLists: null,
    documentTypes: null,
    propertyDefinitions: null,

    _onNewHandle: null,
    _onDeleteHandle: null,
    _onSetHandle: null,

    _dataTypes: null,
    _form: null,
    _propMapStore: null,
    _cmdBar: null,
    _grdPropertyMappings: null,
    _tblProperties: null,
    _txtDescription: null,
    _txtName: null,

    __onPropMapDlgClose: function(dlgResult, retValue){

        if(dlgResult == bfree.widget.Dialog.dialogResult.ok){
            var item = null;

            try{

                var sort_offset =this._grdPropertyMappings.rowCount;
                this._grdPropertyMappings.beginUpdate();

                dojo.forEach(retValue, function(id, idx){

                    var propertyDefinition = this.propertyDefinitions.fetchById({id: id});
                    var dataType = this._dataTypes.fetchById({id: propertyDefinition.data_type_id});
                    var defaultValue;

                    if(dataType.isDateTime()){
                        defaultValue=null;
                    }else{
                        defaultValue='';
                    }
                    item = this._propMapStore.newItem({
                        sort: sort_offset,
                        id: propertyDefinition.id,
                        name: propertyDefinition.name,
                        data_type: dataType,
                        is_required: false,
                        choice_list_id: null,
                        default_value: defaultValue,
                        is_system: propertyDefinition.is_system,
                        is_name: propertyDefinition.is_name
                    });

                    sort_offset++;

                }, this);

            }
            finally{
                this._grdPropertyMappings.endUpdate();
            }

            if(item)
                this._grdPropertyMappings.selectItem(item);

        }

        return true;
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;
        this._grdPropertyMappings.selection.clear();

        if(this.activeItem){
            this._txtName.set('value', this.activeItem.name);
            this._txtDescription.set('value', this.activeItem.description);
        }
        else{
            this._txtName.reset();
            this._txtDescription.reset();
        }

        this._cmdBar.set('activeDocType', this.activeItem);
        this._wdgInfo.set('activeItem', this.activeItem);

        this._setStore();
        this._setState();

        this._grdPropertyMappings.resize();

    },

    _setState: function(){
        var isDirty = false;
        var isNew = false;

        if(this.activeItem ){
            isDirty = this.documentTypes.isDirty({item: this.activeItem});
            isNew = this.activeItem.isNew();
        }

        this._txtName.set('disabled', !isDirty);
        this._txtDescription.set('disabled', !isDirty);

        this._cmdBar.set('disabled', !isDirty);

    },

    _setStore: function(){

        var items = []

        if(this.activeItem){
            dojo.forEach(this.activeItem.property_mappings, function(item, idx){

                var propDef = this.propertyDefinitions.fetchById({id: item.property_definition_id});
                var dataType = this._dataTypes.fetchById({id: propDef.data_type_id});

                items.push({
                    sort: item.sort_order,
                    id: propDef.id,
                    name: propDef.name,
                    data_type: dataType,
                    is_required: item.is_required,
                    default_value: item.default_value,
                    choice_list_id: item.choice_list_id,
                    is_system: propDef.is_system,
                    is_name: propDef.is_name
                });

            }, this);
        }

        if(this._onNewHandle){
            dojo.disconnect(this._onNewHandle);
            this._onNewHandle = null;
            //this._propMapStore.close();
        }
        if(this._onDeleteHandle){
            dojo.disconnect(this._onDeleteHandle);
            this._onDeleteHandle = null;
        }

        if(this._onSetHandle){
            dojo.disconnect(this._onSetHandle);
            this._onSetHandle = null;
        }

        this._propMapStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: items
            }
        });
        this._onNewHandle = dojo.connect(this._propMapStore, 'onNew', this, this._onPropertyMapCreated);
        this._onDeleteHandle = dojo.connect(this._propMapStore, 'onDelete', this, this._onPropertyMapDeleted);
        this.__onSetHandle = dojo.connect(this._propMapStore, 'onSet', this, this._onPropertyMapUpdated);

        this._grdPropertyMappings.setStore(this._propMapStore)

    },


    _chkIsRequired_onChange: function(id, newValue){

        this._propMapStore.fetchItemByIdentity({
            identity: id,
            onItem: dojo.hitch(this,
                function(item){
                    this._propMapStore.setValue(item, 'is_required', newValue);
                })
        });

    },

    _cmbChoiceList_onChange: function(id, newValue){

        this._propMapStore.fetchItemByIdentity({
            identity: id,
            onItem: dojo.hitch(this,
                function(item){
                    if(newValue==-1){
                        newValue=null;
                    }
                    this._propMapStore.setValue(item, 'choice_list_id', newValue);
                })
        });

    },

    _grdPropMap_onSelectedItems: function(items){
        var item = null;
        if(dojo.isArray(items) && items.length > 0)
            item = items[0];

        this._cmdBar.set('activePropMap', item);
    },

    _onPropMapCommand: function(cmdId){
       switch(cmdId){
            case bfree.widget.Bfree.Commands.ADD:
                this._onPropertyMapAdd();
                break;
            case bfree.widget.Bfree.Commands.MOVE_UP:
                this._onPropertyMapUp();
                break;
            case bfree.widget.Bfree.Commands.MOVE_DOWN:
                this._onPropertyMapDown() ;
                break;
            case bfree.widget.Bfree.Commands.REMOVE:
                this._onPropertyMapRemove();
                break;
        }
    },

    _onPropertyMapAdd: function(){
        try{

            var currentFilter = [];
            dojo.forEach(this.activeItem.property_mappings, function(item, idx){
                currentFilter.push(item.property_definition_id);
            },this);

            bfree.widget.propdef.List.show({
                filter: currentFilter,
                propertyDefinitions: this.library.getPropertyDefinitions(),
                onClose: dojo.hitch(this, this.__onPropMapDlgClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Property Definitions\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

     _onPropertyMapCreated: function(newItem, parentInfo){

        this.activeItem.property_mappings.push({
            sort_order: this._propMapStore.getValue(newItem, 'sort'),
            property_definition_id: this._propMapStore.getIdentity(newItem),
            is_required: false,
            choice_list_id: null
        });
        this.onValueChange(this.activeItem, 'property_mappings', [], this.activeItem.property_mappings);

    },

    _onPropertyMapDeleted: function(deletedItem){

        var id = this._propMapStore.getIdentity(deletedItem);
        for(var idx = 0; idx < this.activeItem.property_mappings.length; idx++){
            if(this.activeItem.property_mappings[idx].property_definition_id == id){
                this.activeItem.property_mappings.splice(idx, 1);
                break;
            }
        }

        this.activeItem.property_mappings.sort(bfree.api.PropertyMapping.compare);

        for(var i=0;i<this.activeItem.property_mappings.length;i++){
            this.activeItem.property_mappings[i].sort_order=i;
        }

        this.onValueChange(this.activeItem, 'property_mappings', [], this.activeItem.property_mappings);

    },

    _onPropertyMapDown: function(){
        var item1 = this._grdPropertyMappings.selection.getFirstSelected();
        if(item1){
            this._grdPropertyMappings.moveItem(item1, bfree.widget.SortGrid.move.DOWN);
        }

        var index1=this._grdPropertyMappings.getItemIndex(item1);
        var index2=index1-1;
        var item2=this._grdPropertyMappings.getItem(index2);
        var sort1=this._propMapStore.getValue(item1, 'sort');
        var sort2=this._propMapStore.getValue(item2, 'sort');

        for(var i in this.activeItem.property_mappings){
            if(item1.id[0]==this.activeItem.property_mappings[i].property_definition_id){
                this.activeItem.property_mappings[i].sort_order=sort1;
            }
            if(item2.id[0]==this.activeItem.property_mappings[i].property_definition_id){
                this.activeItem.property_mappings[i].sort_order=sort2;
            }
        }
        this.documentTypes.setValue(this.activeItem, 'property_mappings', this.activeItem.property_mappings);
    },

    _onPropertyMapUp: function(){
        var item1 = this._grdPropertyMappings.selection.getFirstSelected();
        if(item1){
            this._grdPropertyMappings.moveItem(item1, bfree.widget.SortGrid.move.UP);
        }

        var index1=this._grdPropertyMappings.getItemIndex(item1);
        var index2=index1+1;
        var item2=this._grdPropertyMappings.getItem(index2);
        var sort1=this._propMapStore.getValue(item1, 'sort');
        var sort2=this._propMapStore.getValue(item2, 'sort');

        for(var i in this.activeItem.property_mappings){
            if(item1.id[0]==this.activeItem.property_mappings[i].property_definition_id){
                this.activeItem.property_mappings[i].sort_order=sort1;
            }
            if(item2.id[0]==this.activeItem.property_mappings[i].property_definition_id){
                this.activeItem.property_mappings[i].sort_order=sort2;
            }
        }
        this.documentTypes.setValue(this.activeItem, 'property_mappings', this.activeItem.property_mappings);

    },

    _onPropertyMapRemove: function(){

        if(!confirm('WARNING: There may be data associated with this document property. '+
                    'If you delete this property all data associated with this property will be deleted. '+
                    'Do you wish to continue?')){
            return;
        }

        var idx = 0;

        try{
            this._grdPropertyMappings.beginUpdate();

            var item = this._grdPropertyMappings.selection.getFirstSelected();
            idx = this._grdPropertyMappings.getItemIndex(item);
            this._propMapStore.deleteItem(item);

            var props=this._propMapStore._arrayOfTopLevelItems;
            props.sort(function(item1, item2){
                return item1.sort[0]-item2.sort[0];
            });

            for(var i=0;i<props.length;i++){
                if(props[i]){
                    this._propMapStore.setValue(props[i], 'sort', i);
                }
            }

            this._propMapStore.save();
        }
        catch(e){
            var err = new bfree.api.Error('Failed to remove Property Mapping', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
             this._grdPropertyMappings.endUpdate();
        }

        this._grdPropertyMappings.setSelectedIndex(idx);

    },

    _onPropertyMapUpdated: function(item, property, oldValue, newValue){

        //item is a propmap
        var id = this._propMapStore.getIdentity(item);
        for(var i = 0; i < this.activeItem.property_mappings.length; i++){
            //find item based on propdef id
            if(this.activeItem.property_mappings[i].property_definition_id == id){
                //update property
                if(this.activeItem.property_mappings[i].hasOwnProperty(property)){
                    if(this.activeItem.property_mappings[i][property] != newValue)
                        this.activeItem.property_mappings[i][property] = newValue;
                }

            }
        }
        this.onValueChange(this.activeItem, 'property_mappings', [], this.activeItem.property_mappings);
    },


    _txtDescription_onChange: function(newValue){

         if(!this.activeItem)


            return;

        if(this.activeItem.description != newValue)
            this.documentTypes.store.setValue(this.activeItem, 'description', newValue);

    },

    _txtName_onChange: function(newValue){

        if(!this.activeItem)
            return;

        if(this.activeItem.name != newValue)
            this.propertyDefinitions.store.setValue(this.activeItem, 'name', newValue);
    },

    _wdgDefault_onChange: function(id, newValue){

        var item = null;
        for(var i in this.activeItem.property_mappings){
            if(this.activeItem.property_mappings[i].property_definition_id==id){
                if(this.activeItem.property_mappings[i].default_value!=newValue){
                    this.activeItem.property_mappings[i].default_value=newValue;
                    this.documentTypes.setValue(this.activeItem, 'property_mappings', this.activeItem.property_mappings);
//                    this.activeItem.property_mappings[i].default_value=newValue;
                }
            }
        }
//        this._propMapStore.fetchItemByIdentity({
//            identity: id,
//            onItem: dojo.hitch(this,
//                function(item){
//                    var value = this._propMapStore.getValue(item, 'default_value');
//                    if(value != newValue)
//                        this._propMapStore.setValue(item, 'default_value', newValue);
//                })
//        });
    },

    constructor: function(args){

         this._propMapStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: []
            }
        });

    },

    destroy: function(){

        if(this._txtName){
            this._txtName.destroy();
            this._txtName = null;
        }

        if(this._txtDescription){
            this._txtDescription.destroy();
            this._txtDescription = null;
        }

        if(this._grdPropertyMappings){
            this._grdPropertyMappings.destroyDescendants();
            this._grdPropertyMappings.destroy();
            this._grdPropertyMappings = null;
        }

        if(this._tblProperties){
            this._tblProperties.destroyDescendants();
            this._tblProperties.destroy();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
       this._txtName.setFocus(true);
    },

    onValueChange: function(item, property, oldValue, newValue){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._dataTypes = bfree.api.Application.getDataTypes();

        this._form = new dijit.form.Form({
            id: 'docTypeForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._txtName = new bfree.widget.ValidationTextBox({
            label: 'Name',
            required: true,
            selectOnClick: true,
            style: 'width:100%',
            trim: true,
            validator: dojo.hitch(this, this._txtNameValidator),
            onChange: dojo.hitch(this, this._txtName_onChange)
        });
        this._tblProperties.addChild(this._txtName);

        this._txtDescription = new dijit.form.SimpleTextarea({
            label: 'Description',
            'class': 'bfree',
            rows: 2,
            style: 'resize:none;width:100%',
            onChange: dojo.hitch(this, this._txtDescription_onChange)
        });
        this._tblProperties.addChild(this._txtDescription);

        this._grdPropertyMappings = new bfree.widget.SortGrid({
            'class': 'versaGridOutlineNoPad',
            query: {},
            noDataMessage: 'No Properties Defined',
            store: this._propMapStore,
            sort_field: 'sort',
            structure: bfree.widget.doctype.Editor.view1,
            formatterScope: this,
            rowsPerPage: 1000,
            style: 'width:100%;height:100%',
            onSelectedItems: dojo.hitch(this, this._grdPropMap_onSelectedItems)
        }, this.propertyMappingsNode);

        this._cmdBar = new bfree.widget.doctype.PropMapBar({
            id: 'wdgPropDefBar',
            'class': 'versaSidebar',
            grid: this._grdPropertyMappings,
            onCommand: dojo.hitch(this, this._onPropMapCommand)
        }, this.propMapBarNode);

        this._wdgInfo = new bfree.widget.doctype.Info({
            id: 'wdgGroupInfo1'
        }, this.infoNode);

        this._grdPropertyMappings.startup();
    },

    _txtNameValidator: function(newValue){
        if(this._txtName){
            if(newValue.trim()==''){
                this._txtName.set('invalidMessage', 'Document type name cannot be blank');
                return false;
            }
            var items=this.documentTypes.fetch();
            for(var i=0;i<items.length;i++){
                if(items[i].name&&
                   items[i].name.toLowerCase().trim()==newValue.toLowerCase().trim()&&
                   items[i].__id!=this.activeItem.__id){
                    this._txtName.set('invalidMessage', 'Duplicate document type');
                    return false;
                }
            }
        }
        return true;
    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);

    }


});

bfree.widget.doctype.Editor.generateChoiceListWidget = function(choice_list_id, rowIndex){
    var wdg = null;

    var item = this._grdPropertyMappings.getItem(rowIndex);
    var data_type = this._propMapStore.getValue(item, 'data_type');
    var isDirty = this.documentTypes.isDirty({ item: this.activeItem });

    if((isDirty) && (data_type.allow_choice_list)){
        var lists=this.choiceLists.store.fetch({
			query: {data_type_id: data_type.id},
            queryOptions: {
                cache: true,
                clientFetch: true
            }
		}).results;

        var listData=new Array();
        var listObj=new Object();
        listObj[-1]='None';
        listData.push(listObj);

        for(var i=0;i<lists.length;i++){
            listObj=new Object();
            listObj[lists[i].id]=lists[i].name;
            listData.push(listObj);
        }

        var listStore = new dojox.data.KeyValueStore({
            dataVar:listData
        });

        wdg = new bfree.widget.FilteringSelect({
			store: listStore,
			searchAttr: 'name',
			required: false,
			value: choice_list_id,
			style:'width:128px',
            scrollOnFocus: false,
            onChange: dojo.hitch(this, this._cmbChoiceList_onChange, this._propMapStore.getIdentity(item) )
		});
    }
    else{

        if(choice_list_id){
			var choiceList = this.choiceLists.fetchById({
				id: choice_list_id
			});
			wdg = choiceList.name;
		}
        else{
            wdg = ''
        }

    }

    return wdg;
}

bfree.widget.doctype.Editor.generateDefaultWidget = function(default_value, rowIndex){

    var wdg = null;

    var item = this._grdPropertyMappings.getItem(rowIndex);
	var isDirty = this.documentTypes.isDirty({ item: this.activeItem });
    var dataType = this._propMapStore.getValue(item, 'data_type');

	if(isDirty){
        if(item.choice_list_id[0]!=null){
            var choiceList = this.choiceLists.fetchById({id: item.choice_list_id[0] });
            wdg=bfree.widget.propdef.Widget.getChoiceListWidget(null, '', choiceList, true);
            wdg.onChange = dojo.hitch(this, this._wdgDefault_onChange, this._propMapStore.getIdentity(item));
            wdg.set('style', {width: '128px'});
            wdg.set('required', false);
        }else{
            wdg = bfree.widget.propdef.Widget.getWidget(dataType, null, '', bfree.widget.propdef.Widget.formats.SHORT, default_value);
            wdg.set('intermediateChanges', false);
            wdg.onChange = dojo.hitch(this, this._wdgDefault_onChange, this._propMapStore.getIdentity(item));
        }

	}
    else{
        wdg = (!default_value) ? '' : default_value;
    }

	return wdg;
};

bfree.widget.doctype.Editor.generateRequiredWidget = function(is_required, rowIndex){

    var item = this._grdPropertyMappings.getItem(rowIndex);
	var isDirty = this.documentTypes.isDirty({ item: this.activeItem });
    var dataType = this._propMapStore.getValue(item, 'data_type');

	return new dijit.form.CheckBox({
		checked: is_required,
        scrollOnFocus: false,
		disabled: !isDirty || dataType.isText() || dataType.isBoolean(),
		onChange: dojo.hitch(this, this._chkIsRequired_onChange, this._propMapStore.getIdentity(item))
	});

};

bfree.widget.doctype.Editor.formatDataType = function(data, rowIndex){
    return data.name;
};

bfree.widget.doctype.Editor.view1 = [
    {
        cells: [
            {
                field: 'sort',
                name: '&nbsp',
                width: '16px',
                hidden: true
            },
            {
                field: 'name',
                name: 'Property',
                width: 'auto'
            },
            {
                field: 'data_type',
                name: 'Data Type',
                width: '96px',
                hidden: true,
                formatter: bfree.widget.doctype.Editor.formatDataType
            },
            {
                field: 'choice_list_id',
                name: 'Choice List',
                width:'132px',
                noresize: true,
                formatter: bfree.widget.doctype.Editor.generateChoiceListWidget
            },
            {
                field: 'default_value',
                name: 'Default',
                width: '128px',
                noresize: true,
                formatter: bfree.widget.doctype.Editor.generateDefaultWidget,
                styles: 'padding:0 2px 0 2px;'
            },
            {
                field: 'is_required',
                name: 'Required?',
                width: '64px',
                formatter: bfree.widget.doctype.Editor.generateRequiredWidget,
                styles: 'text-align:center;'
            }
        ],
        width: 'auto'
    }
];

}

if(!dojo._hasResource['bfree.widget.doctype.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/11/11
 * Time: 4:20 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.Grid');



dojo.declare('bfree.widget.doctype.Grid', [bfree.widget._Grid], {

    documentTypes: null,

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },


	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};
		this.selectionMode = 'single';

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Document Types found';
        this.sortInfo = 3;

	},

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this.set('structure', bfree.widget.doctype.Grid.view);
        //this.set('sortInfo', 2);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this.documentTypes.store, {}, {cache: true});
    }

});
bfree.widget.doctype.Grid.getState = function(idx, item){

    if(!item)
        return 0;

    if((item.hasOwnProperty('isValid')) && (!item.isValid()))
        return -1;

    if(this.grid.documentTypes.isNew({item: item}))
        return 1;
    if(this.grid.documentTypes.isDirty({item: item}))
        return 2;

    return 0;
}

bfree.widget.doctype.Grid.formatState = function(data, rowIndex){

    var iconClass = '';
    switch(data){
        case -1:
            iconClass = 'statusIcon bfreeIconInvalid';
            break;
        case 1:
            iconClass = 'statusIcon bfreeIconNew';
            break;
        case 2:
            iconClass = 'statusIcon bfreeIconEdit';
            break;
    }

    return dojo.replace('<img src="/images/icons/16/blank.png" width="16" height="16" class="{0}"/>', [iconClass]);
}

bfree.widget.doctype.Grid.view = [
    {
        cells: [
            {
                field: 'state',
                name: '&nbsp;',
                width: '16px',
                get: bfree.widget.doctype.Grid.getState,
                formatter: bfree.widget.doctype.Grid.formatState
            },
            {
                field: 'name',
                name: 'Name',
                width: 'auto'
            },
            {
                field: 'sort_id',
                name: 'Sort',
                hidden: true
            }
        ],
        width: 'auto'
    }
]

}

if(!dojo._hasResource['bfree.widget.doctype.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.doctype.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 08/11/11
 * Time: 3:38 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.doctype.Administration');












dojo.declare('bfree.widget.doctype.Administration', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/doctype", "template/Administration.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n     <!-- Command Bar -->\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;height:27px\">\n\n        <div dojoAttachPoint=\"commandBarNode\"></div>\n\n    </div>\n\n     <div   dojoType=\"dijit.layout.BorderContainer\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"padding:8px;height:100%;width:100%\">\n\n\n         <div   dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"leading\"\n                style=\"padding:0 8px 0 0;width: 256px;\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"true\"\n                region=\"center\"\n                class=\"highlightPane\"\n                style=\"padding:8px\">\n\n            <div dojoAttachPoint=\"editorNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _choiceLists: null,
    _cmdBar: null,
    _editor: null,
    _grdDocTypes: null,
    _documentTypes: null,
    _metrics: [],

    activeUser: null,
    library: null,
    zone: null,

    _cmdBar_onCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.NEW:
                this.createItem();
                break;
            case bfree.widget.Bfree.Commands.EDIT:
                this.editItem();
                break;
            case bfree.widget.Bfree.Commands.DELETE:
                this.deleteItem();
                break;
            case bfree.widget.Bfree.Commands.SAVE:
                this.save();
                break;
            case bfree.widget.Bfree.Commands.UNDO:
                this.undo();
                break;

        }

    },

    _getMetrics: function(documentType){
        var metrics = null;
        dojo.some(this._metrics, function(m, index){
            if(m.id == documentType.id){
                metrics = m.metrics;
                return true;
            }
            return false;
        }, this);

        return metrics;
    },

    _grdDocTypes_onSelectedItems: function(items){
        var item = null;

        if((!items) || (items.length < 1))
            return;

        item = items[0];

        //var metrics = item.getMetrics({zone: this.zone, library: this.library });
        this._cmdBar.set('activeItem', item);
        this._editor.set('activeItem', item);

    },

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _validateItems: function(active){
        var valid = true;

		for(var idx = 0; idx < this._grdDocTypes.rowCount; idx++){
            var item = this._grdDocTypes.getItem(idx);
            if(this._documentTypes.isDirty({item: item})){
                if(!active||(active&&active.__id!=item.__id)){
                    var items=this._documentTypes.fetch();
                    for(var i=0;i<items.length;i++){
                        if(items[i].name&&
                           items[i].name.toLowerCase().trim()==item.name.toLowerCase().trim()&&
                           items[i].__id!=item.__id){
                            return false;
                        }
                    }
                    valid &= item.isValid();
                }
            }
		}

		return valid;
	},

    constructor: function(args){

    },

    createItem: function(){

        try{

            var uniqueName = this._documentTypes.generateUniqueName({base_name: 'Document Type'});
            var item = this._documentTypes.create({
                name: uniqueName,
                description: '',
                property_mappings: [],
                is_system: false,
                created_by: this.activeUser.name,
                created_at: new Date(),
                updated_by: this.activeUser.name,
                updated_at: new Date()
            });

            var title = this._propertyDefinitions.getNameProperty();
            item.property_mappings.push({
                property_definition_id: title.id,
                choice_list_id: null,
                is_required: true,
                sort_order: 0
            });

            this._grdDocTypes.selectItem(item);
            this._editor.focus();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to create Document Type', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    deleteItem: function(){

        var idx = 0;
        var item = null;
        var isError = false;

        try{

            //this._grdDocTypes.beginUpdate();

            //Can we delete this
            var item = this._grdDocTypes.selection.getFirstSelected();
            idx = this._grdDocTypes.getItemIndex(item);

            if(!this._validateItems(item)){
                var msg = 'Cannot delete Document Type: One or more Document Types contain invalid data';
                alert(msg);
                return;
            }

            var metrics = this._getMetrics(item);
            if((metrics) && (metrics.document_count > 0)){
                var msg = dojo.replace('Cannot delete Document Type. One or more documents are assigned to \'{0}\'',
                    [item.name]);
                alert(msg);
                return;
            }

            if(item){

                var msg = dojo.replace('Are you sure you want to delete the Document Type: \'{0}\'?', [item.name]);
                if (!confirm(msg))
                    return;

                this._documentTypes.destroy({item: item});

            }

        }
        catch(e){

           isError = true;
           var err = new bfree.api.Error('Failed to delete Document Type', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });

        }
        finally{

            //This "should" get called by the grid automatically but it doesn't :(
            if(isError) this._grdDocTypes._onRevert();

            this._grdDocTypes.setSelectedIndex(idx);
            this._editor.focus();

         }


    },

    destroy: function(){

        if(this._cmdBar){
            this._cmdBar.destroyRecursive(false);
            this._cmdBar = null;
        }

        if(this._grdDocTypes){
            this._grdDocTypes.destroyRecursive();
            this._grdDocTypes = null;
        }

        if(this._editor){
            this._editor.destroyRecursive();
            this._editor = null;
        }

    },

    editItem: function(){

        try{

            var item = this._grdDocTypes.selection.getFirstSelected();
            if(item){
                var idx = this._grdDocTypes.getItemIndex(item);
                this._documentTypes.clone({item: item});
                this._grdDocTypes.updateRow(idx);
                this._grdDocTypes.setSelectedIndex(idx);
                this._editor.focus();
            }
        }
        catch(e){
            console.log(e)
        }

    },

    isValid: function(){
        //return (this.isDirty || this._grd.store.isDirty());
        return true;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(this._documentTypes.isDirty()){
                var msg = 'You have unsaved changes that will be lost. Do you wish to continue?';
                if(confirm(msg)){
                    if(this._documentTypes != null)
                        this._documentTypes.revert();
                    canClose = true;
                }
            }
            else{
                canClose = true;
            }
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close Document Types dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        //Retrieve property definitions collection and refresh from server
        this._propertyDefinitions = this.library.getPropertyDefinitions();
        this._propertyDefinitions.refresh();

        this._choiceLists = this.library.getChoiceLists();
        this._choiceLists.refresh();

        this._documentTypes = this.library.getDocumentTypes();
        this._documentTypes.clearCache();

        this._cmdBar = new bfree.widget.doctype.CommandBar({
            id: 'cmdBar',
            documentTypes: this._documentTypes,
            onCommand: dojo.hitch(this, this._cmdBar_onCommand)
        }, this.commandBarNode);

        this._grdDocTypes = new bfree.widget.doctype.Grid({
            id: 'grdDocTypes',
            'class': 'versaGridOutline versaNoHeader',
            documentTypes: this._documentTypes,
            onSelectedItems: dojo.hitch(this, this._grdDocTypes_onSelectedItems)
        }, this.gridNode);

        this._editor = new bfree.widget.doctype.Editor({
            library: this.library,
            zone: this.zone,
            choiceLists: this._choiceLists,
            documentTypes: this._documentTypes,
            propertyDefinitions: this._propertyDefinitions
        }, this.editorNode);

        this._metrics = this._documentTypes.getMetrics({
            zone: this.zone,
            library: this.library
        });

    },

    save: function(){
        try{

            if(!this._validateItems()){
                var msg = 'Cannot save Document Type changes: One or more Document Types contain invalid data';
                alert(msg);
                return;
            }

            var item = this._grdDocTypes.selection.getFirstSelected();
            this._documentTypes.save({onComplete: dojo.hitch(this, this.saveOnComplete, item)});
        }
        catch(e){
            var err = new bfree.api.Error('Failed to save Document Type changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    saveOnComplete: function(item){
        this._documentTypes.clearCache();
        this._grdDocTypes.sort();
        this._grdDocTypes.selectItem(item);
    },


    startup: function(){
        this.inherited('startup', arguments);

        this._grdDocTypes.startup();
        this._grdDocTypes.setSelectedIndex(0);

        setTimeout(bfree.widget.doctype.Administration._loadFnRef(this), 10);
    },

    undo: function(){
        try{

            var item = this._grdDocTypes.selection.getFirstSelected();
            this._documentTypes.clearCache();
            this._documentTypes.revert();

            if(item){
                var idx = this._grdDocTypes.getItemIndex(item);
                this._grdDocTypes.setSelectedIndex(idx);
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    }

});

bfree.widget.doctype.Administration._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.doctype.Administration.show = function(args){
    var dlg = new bfree.widget.Dialog({
        id: 'dlgEditDocTypes',
        title:'Document Types',
        widgetConstructor: bfree.widget.doctype.Administration,
        widgetParams: {
            activeUser: args.user,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 480,
        width: 800,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}

}

if(!dojo._hasResource['bfree.widget.propdef.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.CommandBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 10:10 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.CommandBar');





dojo.declare('bfree.widget.propdef.CommandBar', [dijit.Toolbar], {

    _btnSave: null,
    _btnUndo: null,
    _btnNew: null,
    _btnEdit: null,
    _btnDelete: null,
    _btnHelp: null,

    activeItem: null,
    propertyDefinitions: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;
        this._setState();
    },

    _setState: function(){

        var isDirty = this.propertyDefinitions.isDirty();
        var isNull = (this.activeItem == null);

        var canDelete = !(isNull || this.activeItem.is_system);

        this._btnSave.set('disabled', !isDirty);
        this._btnUndo.set('disabled', !isDirty);
        this._btnEdit.set('disabled', isNull);
        this._btnDelete.set('disabled', !canDelete || isNull);
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._btnSave){
            this._btnSave.destroy();
            this._btnSave = null;
        }

        if(this._btnUndo){
            this._btnUndo.destroy();
            this._btnUndo = null;
        }

        if(this._btnNew){
            this._btnNew.destroy();
            this._btnNew = null;
        }

        if(this._btnEdit){
            this._btnEdit.destroy();
            this._btnEdit = null;
        }

        if(this._btnDelete){
            this._btnDelete.destroy();
            this._btnDelete = null;
        }

        if(this._btnHelp){
            this._btnHelp.destroy();
            this._btnHelp = null;
        }

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnSave = new bfree.widget.Button({
                id: 'btnPropDefsSave',
                label: 'Save Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconSave',
                disabledIconClass:'commandIcon bfreeIconSaveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.SAVE)
            });
        this.addChild(this._btnSave);

        this._btnUndo = new bfree.widget.Button({
                label: 'Undo Unsaved Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconUndo',
                disabledIconClass: 'commandIcon bfreeIconUndoD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.UNDO)
            });
        this.addChild(this._btnUndo);

        this.addChild(new dijit.ToolbarSeparator());

        this._btnNew = new bfree.widget.Button({
                label: 'New Property Definition...',
                showLabel: false,
                disabled: false,
                iconClass: 'commandIcon bfreeIconPropDef',
                disabledIconClass: 'commandIcon bfreeIconAdminD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.NEW)
            });
        this.addChild(this._btnNew);

        this._btnEdit = new bfree.widget.Button({
                label: 'Edit selected Property Definition...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconEdit',
                disabledIconClass: 'commandIcon bfreeIconEditD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT)
            });
        this.addChild(this._btnEdit);

        this._btnDelete = new bfree.widget.Button({
                label: 'Delete selected Property Definition',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconDelete',
                disabledIconClass: 'commandIcon bfreeIconDeleteD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.DELETE)
            });
        this.addChild(this._btnDelete);

        this.addChild(new dijit.ToolbarSeparator());

        /*
        this._btnHelp =  new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconHelp',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            });
        this.addChild(this._btnHelp);
        */
    }

});

}

if(!dojo._hasResource['bfree.widget.propdef.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.Info'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/12/11
 * Time: 8:55 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.Info');









dojo.declare('bfree.widget.propdef.Info', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/propdef", "template/Info.html", "<div style=\"width:100%;height:100%\">\n\n     <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    _form: null,
    _lblId: null,
    _lblIsSystem: null,
    _lblIsReadOnly: null,
    _lblCreatedBy: null,
    _lblCreatedAt: null,
    _lblUpdatedBy: null,
    _lblUpdatedAt: null,
    _tblProperties: null,

    activeItem: null,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        this._lblId.set('value', this.activeItem.id);
        this._lblIsSystem.set('value', this.activeItem.is_system);
        this._lblIsReadOnly.set('value', this.activeItem.is_readonly);
        this._lblCreatedBy.set('value', this.activeItem.created_by);
        this._lblCreatedAt.set('value', (this.activeItem.created_at) ? dojo.date.locale.format(this.activeItem.created_at, {formatLength: 'medium'}) : '');
        this._lblUpdatedBy.set('value', this.activeItem.updated_by);
        this._lblUpdatedAt.set('value', (this.activeItem.updated_at) ? dojo.date.locale.format(this.activeItem.updated_at, {formatLength: 'medium'}) : '');

        this._tblProperties.refresh();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants()

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'infoObjForm'
        }, this.formNode);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblObjInfo1',
            customClass: 'versainfo',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._lblId = new bfree.widget.Label({
               id: 'lblId',
               label: 'ID'
            });
        this._tblProperties.addChild(this._lblId);

        this._lblIsSystem = new bfree.widget.Label({
               id: 'lblIsSystem',
               label: 'System Property'
            });
        this._tblProperties.addChild(this._lblIsSystem);

        this._lblIsReadOnly = new bfree.widget.Label({
               id: 'lblIsReadOnly',
               label: 'Read Only?'
            });
        this._tblProperties.addChild(this._lblIsReadOnly);

        this._lblCreatedBy = new bfree.widget.Label({
               id: 'lblCreatedBy',
               label: 'Created By'
            });
        this._tblProperties.addChild(this._lblCreatedBy);

        this._lblCreatedAt = new bfree.widget.Label({
               id: 'lblCreatedAt',
               label: 'Create Date:'
            });
        this._tblProperties.addChild(this._lblCreatedAt);

        this._lblUpdatedBy = new bfree.widget.Label({
               id: 'lblUpdatedBy',
               label: 'Last Modified By:'
            });
        this._tblProperties.addChild(this._lblUpdatedBy);

        this._lblUpdatedAt = new bfree.widget.Label({
               id: 'lblUpdatedAt',
               label: 'Last Modified Date:'
            });
        this._tblProperties.addChild(this._lblUpdatedAt);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.propdef.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 1:54 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.Editor');















dojo.declare('bfree.widget.propdef.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/propdef", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        liveSplitters=\"true\"\n        style=\"width:100%;height:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"center\"\n            style=\"overflow:hidden;padding:0\">\n\n         <div dojoAttachPoint=\"formNode\">\n\n            <div dojoAttachPoint=\"tableNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"bottom\"\n            style=\"overflow:hidden;height: 104px;\">\n\n        <div dojoAttachPoint=\"infoNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    activeItem: null,
    propertyDefinitions: null,

    _dataTypes: null,
    _form: null,
    _cmbDataType: null,
    _tblProperties: null,
    _txtDescription: null,
    _txtMaxLength: null,
    _txtName: null,
    _wdgInfo: null,

    _resetMaxLength: function(dataType, value, disable){

        var constraints = {
            min: 0,
		    max: 0,
		    places: 0,
		    pattern: '#'
        }

        if((dataType.isString()) || (dataType.isText())){
            constraints['min'] = 1;
            constraints['max'] = dataType.defaultMaxLength();
            this._txtMaxLength.set('disabled', disable);
            this._txtMaxLength.set('constraints', constraints);
        }
        else{
            this._txtMaxLength.set('disabled', true);
        }

        this._txtMaxLength.set('value', value);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        this._txtName.set('value', this.activeItem.name);

        if(this.activeItem.data_type_id){
            this._cmbDataType.set('value', this.activeItem.data_type_id);

            var dataType=this._dataTypes.fetchById({id:this.activeItem.data_type_id});
            this._resetMaxLength(dataType, this.activeItem.max_length, true);
        }else{
            this._cmbDataType.reset();
            this._cmbDataType.validate();
        }

//        this._txtMaxLength.set('value', this.activeItem.max_length);
        this._txtDescription.set('value', this.activeItem.description);

        this._wdgInfo.set('activeItem', this.activeItem);
        this._setState();

    },

    _setState: function(){

        var isDirty = this.propertyDefinitions.isDirty({item: this.activeItem});
        var isNew = this.activeItem.isNew();
        var dataType = (this.activeItem.data_type_id) ? this._dataTypes.fetchById({id: this.activeItem.data_type_id}) : null;
        var canSetMaxLength = ((isDirty) && (dataType != null) && (dataType.isString()));

        this._txtName.set('disabled', !isDirty);
        this._cmbDataType.set('disabled', !(isDirty && isNew));
        this._txtMaxLength.set('disabled', !(canSetMaxLength));
        this._txtDescription.set('disabled', !isDirty);


    },

    _cmbDataType_onChange: function(newValue){

        if((newValue == null) || newValue == '')
            return;

        var data_type_id = (newValue == null) ? -1 : parseInt(newValue);
        if(this.activeItem.data_type_id != data_type_id){
            var dataType = this._dataTypes.fetchById({id: data_type_id});
            this.propertyDefinitions.store.setValue(this.activeItem, 'data_type_id', data_type_id);
            this.propertyDefinitions.store.setValue(this.activeItem, 'max_length', dataType.defaultMaxLength());
            this._resetMaxLength(dataType, this.activeItem.max_length, false);
        }
    },

    _txtDescription_onChange: function(newValue){

         if(!this.activeItem||(this.activeItem.description==null&&newValue==""))
            return;

        if(this.activeItem.description != newValue){

            this.propertyDefinitions.store.setValue(this.activeItem, 'description', newValue);
        }
    },

    _txtMaxLength_onChange: function(newValue){

        if(this._txtMaxLength.constraints['max']<newValue){
            newValue=this._txtMaxLength.constraints['max'];
            this._txtMaxLength.set('value', newValue);
        }

        if(this._txtMaxLength.constraints['min']>newValue){
            newValue=this._txtMaxLength.constraints['min'];
            this._txtMaxLength.set('value', newValue);
        }

        if(!this.activeItem)
            return;

        if((!isNaN(newValue)) && (this.activeItem.max_length != newValue))
            this.propertyDefinitions.store.setValue(this.activeItem, 'max_length', newValue);
    },

    _txtName_onChange: function(newValue){

        if(!this.activeItem)
            return;

        if(this.activeItem.name != newValue)
            this.propertyDefinitions.store.setValue(this.activeItem, 'name', newValue);

        this._txtName.validate();
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._txtName){
            this._txtName.destroy();
            this._txtName = null;
        }

        if(this._cmbDataType){
            this._cmbDataType.destroy();
            this._cmbDataType = null;
        }

        if(this._txtMaxLength){
            this._txtMaxLength.destroy();
            this._txtMaxLength = null;
        }

        if(this._txtDescription){
            this._txtDescription.destroy();
            this._txtDescription = null;
        }

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._txtName.setFocus(true);
    },

    onValueChange: function(item, property, oldValue, newValue){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._dataTypes = bfree.api.Application.getDataTypes();

        this._form = new dijit.form.Form({
            id: 'propDefForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 112,
            style: 'width:100%'
        }, this.tableNode);

        this._txtName = new bfree.widget.ValidationTextBox({
            label: 'Name',
            intermediateChanges: true,
            selectOnClick: true,
            style: 'width:100%',
            required: true,
            trim: true,
            validator: dojo.hitch(this, this._txtNameValidator),
            onChange: dojo.hitch(this, this._txtName_onChange)
        });
        this._tblProperties.addChild(this._txtName);

        this._cmbDataType = new bfree.widget.FilteringSelect({
            label: 'Data Type',
            store: this._dataTypes.store,
            searchAttr: 'name',
            required: true,
            style: 'width:100%',
            onChange: dojo.hitch(this, this._cmbDataType_onChange)
        });
        this._tblProperties.addChild(this._cmbDataType);

        this._txtMaxLength = new dijit.form.NumberSpinner({
            customClass: 'bfree',
            label: 'Maximum Length',
			constraints:{min:1,max:255, places:0, pattern: '#'},
			value: 255,
			disabled: false,
            style: 'width:100%',
			onChange: dojo.hitch(this, this._txtMaxLength_onChange)
		});
        this._tblProperties.addChild(this._txtMaxLength);

        this._txtDescription = new dijit.form.SimpleTextarea({
            label: 'Description',
            intermediateChanges: true,
            'class': 'bfree',
            style: 'resize:none;width:100%',
            onChange: dojo.hitch(this, this._txtDescription_onChange)
        });
        this._tblProperties.addChild(this._txtDescription);

        this._wdgInfo = new bfree.widget.propdef.Info({
            id: 'wdgInfo1'
        }, this.infoNode);

    },

    _txtNameValidator: function(value){
        if(this._txtName){
            if(value.trim()==''){
                this._txtName.set('invalidMessage', 'Property definition name cannot be blank');
                return false;
            }
            if(this.activeItem){
                var items=this.propertyDefinitions.fetch();
                for(var i=0;i<items.length;i++){
                    if(items[i].name&&
                       items[i].name.toLowerCase().trim()==value.toLowerCase().trim()&&
                       items[i].__id!=this.activeItem.__id){
                        this._txtName.set('invalidMessage', 'Duplicate property definition name');
                        return false;
                    }
                }
                this._txtName.set('invalidMessage', null);

            }
        }
        return true;
    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.propdef.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/11/11
 * Time: 4:20 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.Grid');



dojo.declare('bfree.widget.propdef.Grid', bfree.widget._Grid, {

    selectionMode: 'single',
    propertyDefinitions: null,

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Property Definitions found';
        this.sortInfo = 3;

	},

	postCreate: function(){
		this.inherited('postCreate', arguments);
        this.set('structure', bfree.widget.propdef.Grid.view);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this.propertyDefinitions.store, {}, {cache: true});
    }

});

bfree.widget.propdef.Grid.getState = function(idx, item){

    if(!item)
        return 0;

    if((item.hasOwnProperty('isValid')) && (!item.isValid()))
        return -1;

    if(this.grid.propertyDefinitions.isNew({item: item}))
        return 1;
    if(this.grid.propertyDefinitions.isDirty({item: item}))
        return 2;

    return 0;
}

bfree.widget.propdef.Grid.formatState = function(data, rowIndex){

    var iconClass = '';
    switch(data){
        case -1:
            iconClass = 'statusIcon bfreeIconInvalid';
            break;
        case 1:
            iconClass = 'statusIcon bfreeIconNew';
            break;
        case 2:
            iconClass = 'statusIcon bfreeIconEdit';
            break;
    }

    return dojo.replace('<img src="/images/icons/16/blank.png" width="16" height="16" class="{0}"/>', [iconClass]);
}

bfree.widget.propdef.Grid.view = [
    {
        cells: [
            {
                field: 'state',
                name: '&nbsp;',
                width: '16px',
                get: bfree.widget.propdef.Grid.getState,
                formatter: bfree.widget.propdef.Grid.formatState
            },
            {
                field: 'name',
                name: 'Name',
                width: 'auto'
            },
            {
                field: 'sort_id',
                name: 'Sort',
                hidden: true
            }
        ],
        width: 'auto'
    }
];




}

if(!dojo._hasResource['bfree.widget.propdef.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.propdef.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 03/11/11
 * Time: 4:12 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.propdef.Administration');












dojo.declare('bfree.widget.propdef.Administration', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/propdef", "template/Administration.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n     <!-- Command Bar -->\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;height:27px\">\n\n        <div dojoAttachPoint=\"commandBarNode\"></div>\n\n    </div>\n\n     <div   dojoType=\"dijit.layout.BorderContainer\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"padding:8px;height:100%;width:100%\">\n\n\n         <div   dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"leading\"\n                style=\"padding:0 8px 0 0;width: 256px;\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"true\"\n                region=\"center\"\n                class=\"highlightPane\"\n                style=\"padding:8px\">\n\n            <div dojoAttachPoint=\"editorNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _cmdBar: null,
    _editor: null,
    _grdPropDefs: null,
    _propertyDefinitions: null,

    activeUser: null,
    library: null,
    zone: null,

    _cmdBar_onCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.NEW:
                this.createItem();
                break;
            case bfree.widget.Bfree.Commands.EDIT:
                this.editItem();
                break;
            case bfree.widget.Bfree.Commands.DELETE:
                this.deleteItem();
                break;
            case bfree.widget.Bfree.Commands.SAVE:
                this.save();
                break;
            case bfree.widget.Bfree.Commands.UNDO:
                this.undo();
                break;

        }

    },

    _grdPropDefs_onSelectedItems: function(items){
        var item = null;

        if((!items) || (items.length < 1))
            return;

        item = items[0];

        this._cmdBar.set('activeItem', item);
        this._editor.set('activeItem', item);
    },

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _validateItems: function(active){
        var valid = true;

		for(var idx = 0; idx < this._grdPropDefs.rowCount; idx++){
            var item = this._grdPropDefs.getItem(idx);
            if(this._propertyDefinitions.isDirty({item: item})){
                if(!active||(active&&active.__id!=item.__id)){
                    var items=this._propertyDefinitions.fetch();
                    for(var i=0;i<items.length;i++){
                        if(items[i].name&&
                           items[i].name.toLowerCase().trim()==item.name.toLowerCase().trim()&&
                           items[i].__id!=item.__id){
                            return false;
                        }
                    }
                    valid &= item.isValid();
                }
            }
		}

		return valid;
	},

    constructor: function(args){

    },

    createItem: function(){

         try{

            var uniqueName = this._propertyDefinitions.generateUniqueName({base_name: 'Property Definition', appendix: ' ({index})'});
            var item = this._propertyDefinitions.create({
                name: uniqueName,
                cardinality:  bfree.api.Cardinality.Single,
                description: '',
                max_length: 0,
                created_by: this.activeUser.name,
                created_at: new Date(),
                updated_by: this.activeUser.name,
                updated_at: new Date(),
                is_system: false,
                is_readonly: false,
                table_name: 'documents',
                column_name: ''
            });

            this._grdPropDefs.selectItem(item);
            this._editor.focus();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to create Property Definition', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    deleteItem: function(){

        try{
            var item = this._grdPropDefs.selection.getFirstSelected();
            if(item){
                if(!this._validateItems(item)){
                    var msg = 'Cannot delete Property Definition: One or more Property Definitions contain invalid data';
                    alert(msg);
                    return;
                }

                if(item.document_types_count>0){
                    alert('You cannot delete a property definition assigned to a document type.')
                    return;
                }

                var msg = dojo.replace('Are you sure you want to delete the property definition: \'{0}\'?', [item.name]);
                if (!confirm(msg))
                    return;

                var idx = this._grdPropDefs.getItemIndex(item);
                this._propertyDefinitions.destroy({item: item});
                this._grdPropDefs.setSelectedIndex(idx);
                this._editor.focus();
            }

        }
        catch(e){
           var err = new bfree.api.Error('Failed to delete Property Definition', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    destroy: function(){

        if(this._editor){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    editItem: function(){

        try{

            var item = this._grdPropDefs.selection.getFirstSelected();
            if(item){
                var idx = this._grdPropDefs.getItemIndex(item);
                this._propertyDefinitions.clone({item: item});
                this._grdPropDefs.updateRow(idx);

                this._grdPropDefs.sort();
                this._grdPropDefs.selectItem(item);

                this._editor.focus();
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to edit Property Definition', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    isValid: function(){
        return true;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(this._propertyDefinitions.isDirty()){
                var msg = 'You have unsaved changes that will be lost. Do you wish to continue?';
                if(confirm(msg)){
                    if(this._propertyDefinitions != null)
                        this._propertyDefinitions.revert();
                    canClose = true;
                }
            }
            else{
                canClose = true;
            }
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close Property Definition Administration dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        //Retrieve propdefs and clear cache so grid retrieves latest from server
        this._propertyDefinitions = this.library.getPropertyDefinitions();
        this._propertyDefinitions.clearCache();

        this._cmdBar = new bfree.widget.propdef.CommandBar({
            id: 'cmdBar',
            propertyDefinitions: this._propertyDefinitions,
            onCommand: dojo.hitch(this, this._cmdBar_onCommand)
        }, this.commandBarNode);

        this._grdPropDefs = new bfree.widget.propdef.Grid({
            id: 'grdPropDefs',
            'class': 'versaGridOutline versaNoHeader',
            propertyDefinitions: this._propertyDefinitions,
            onSelectedItems: dojo.hitch(this, this._grdPropDefs_onSelectedItems)
        }, this.gridNode);

        this._editor = new bfree.widget.propdef.Editor({
            id: 'edtPropDef',
            propertyDefinitions: this._propertyDefinitions
        }, this.editorNode);

    },

    resize: function(){
        this.inherited('resize', arguments);

        if(this._grdPropDefs){
            this._grdPropDefs.resize();
        }
    },

    save: function(){
        try{

            if(!this._validateItems()){
                var msg = 'Cannot save Property Definition changes: One or more Property Definitions contain invalid data';
                alert(msg);
                return;
            }

            var item = this._grdPropDefs.selection.getFirstSelected();
            this._propertyDefinitions.save({onComplete: dojo.hitch(this, this.saveOnComplete, item)});

        }
        catch(e){
            var err = new bfree.api.Error('Failed to save Property Definition changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    saveOnComplete: function(item){
        this._propertyDefinitions.clearCache();
        this._grdPropDefs.sort();
        this._grdPropDefs.selectItem(item);
    },

    startup: function(){
        this.inherited('startup', arguments);

        //this._grdPropDefs.startup();
        this._grdPropDefs.setSelectedIndex(0);

        setTimeout(bfree.widget.propdef.Administration._loadFnRef(this), 10);
    },

    undo: function(){
        try{

            var item = this._grdPropDefs.selection.getFirstSelected();

            this._propertyDefinitions.clearCache();
            this._propertyDefinitions.revert();

            if(item){
                var idx = this._grdPropDefs.getItemIndex(item);
                this._grdPropDefs.setSelectedIndex(idx);
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    }

});

bfree.widget.propdef.Administration._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.propdef.Administration.show = function(args){
    var dlg = new bfree.widget.Dialog({
        id: 'dlgEditPropDefs',
        title: 'Property Definition Administration',
        widgetConstructor: bfree.widget.propdef.Administration,
        widgetParams: {
            activeUser: args.user,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 384,
        width: 600,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}

}

if(!dojo._hasResource['bfree.widget.search.ConjunctionBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.search.ConjunctionBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 19/12/11
 * Time: 8:12 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.search.ConjunctionBar');





dojo.declare('bfree.widget.search.ConjunctionBar', [dijit.Toolbar], {

    _btnAdd: null,
    _btnRemove: null,

    disabled: false,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
        if(cmdId == bfree.widget.Bfree.Commands.ADD){
            dojo.toggleClass(this._btnAdd.domNode, 'versaHide', true);
            dojo.toggleClass(this._btnRemove.domNode, 'versaHide', false);
        }
    },

    _setDisabledAttr: function(value){
        this.disabled = value;
        this._setState();
    },

    _setState: function(){

        this._btnAdd.set('disabled', this.disabled);
        this._btnRemove.set('disabled', this.disabled);
    },


    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnAdd = new bfree.widget.Button({
            label: 'Add Row...',
            showLabel: false,
            disabled: false,
            iconClass: 'commandIcon bfreeIconAdd',
            disabledIconClass:'sidebarIcon bfreeIconAddD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.ADD)
        });
        this.addChild(this._btnAdd);

        this._btnRemove = new bfree.widget.Button({
                label: 'Remove Row...',
                showLabel: false,
                disabled: false,
                iconClass: 'sidebarIcon bfreeIconRemove',
                disabledIconClass: 'commandIcon bfreeIconRemoveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.REMOVE)
            });
        this.addChild(this._btnRemove);

        dojo.toggleClass(this._btnRemove.domNode, 'versaHide', true);
    },

    startup: function(){
        this.inherited('startup', arguments);
        console.log('search.ConjunctionBar > startup');

    }
});

}

if(!dojo._hasResource['bfree.widget.search.Criterion']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.search.Criterion'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/11/11
 * Time: 7:41 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.search.Criterion');









//

dojo.declare('bfree.widget.search.Criterion', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("bfree.widget.search", "template/Criterion.html", "<div style=\"width:100%;padding:0\">\n<table>\n    <tr>\n        <td><div dojoAttachPoint=\"propertiesNode\"></div></td>\n        <td><div dojoAttachPoint=\"operatorsNode\"></div></td>\n        <td style=\"width:184px\"><div dojoAttachPoint=\"valueNode\"></div></td>\n        <td style=\"width:20px\"><div dojoAttachPoint=\"cmdBarNode\"></div></td>\n    </tr>\n</table>\n</div>\n"),

    _cmdBar: null,
    _onChangeHndl: null,
    _onChangeHndl2: null,
    _cmbOperators: null,
    _cmbProperties: null,
    _wdgValue: null,

    dataTypes: null,
    operators: null,
    propertyDefinitions: null,

    _cmbOperators_onChange: function(newValue){
        var op=this.operators.fetchById({id: newValue});
        if(op.no_rhs){
            this._wdgValue.set('disabled', true);
        }else{
            this._wdgValue.set('disabled', false);
        }
        this._setState();
        this.onValueChange(null);
    },

    _cmbProperties_onChange: function(newValue){

        //1) Filter operators by data type
        var propertyDefinition = this.propertyDefinitions.fetchById({id: newValue});
        var dataType = this.dataTypes.fetchById({id:propertyDefinition.data_type_id});
        var ops = this.operators.byDataType(dataType.id);
        this._cmbOperators.set('query', {data_type_id: dataType.id});
        this._cmbOperators.set('value', ops[0].id);

        //2) Create data-type based widget
        var oldWidget = this._wdgValue;
        var format = (dataType.isBoolean()) ? bfree.widget.propdef.Widget.formats.LONG : bfree.widget.propdef.Widget.formats.SHORT;
        this._wdgValue = bfree.widget.propdef.Widget.getWidget(dataType, null, null, format);
        this._wdgValue.set('required', true);
        this._wdgValue.set('intermediateChanges', true);
        dojo.place(this._wdgValue.domNode, oldWidget.domNode, 'replace');
        this._wdgValue.startup();

        //3) Delete/Create 'onChange' event connections
        if(this._onChangeHndl){
            dojo.disconnect(this._onChangeHndl);
            this._onChangeHndl = null;
        }

        if(this._onChangeHndl2){
            dojo.disconnect(this._onChangeHndl2);
            this._onChangeHndl2 = null;
        }

        this._onChangeHndl = dojo.connect(this._wdgValue, 'onKeyUp', this, this._onChange);
        if(dataType.isDateTime()){
            this._onChangeHndl2 = dojo.connect(this._wdgValue, 'onChange', this, this._onChange);
        }

        //Delete old widget
        if(oldWidget){
            oldWidget.destroy();
            oldWidget = null;
        }

        //5) Send Notifications
        this.onStateChange();
        this.onValueChange(null);
    },

     _formatValue: function(value, dataType){
        var operands = [value];

        if(dataType.isBoolean()){
            operands = [(value == 1)];
        }
        else if(dataType.isDateTime()){
            operands = [dojo.date.stamp.toISOString(value, {zulu: true})];
        }

        return operands;
    },

    _onChange: function(newValue){
        this.onValueChange(newValue);
        this.onKeyUp(newValue);
    },

    _onCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.ADD:
                this._onRowAdd();
                break;
            case bfree.widget.Bfree.Commands.REMOVE:
                this._onRowRemove();
                break;
        }
    },

    _onRowAdd: function(){
        this.onNewRow();
    },

    _onRowRemove: function(){
        this.onDeleteRow(this);
    },

    _setState: function(){

        this.onStateChange();
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._cmbOperators){
            this._cmbOperators.destroy();
            this._cmbOperators = null;
        }

        if(this._cmbProperties){
            this._cmbProperties.destroy();
            this._cmbProperties = null;
        }

        if(this._wdgValue){
            this._wdgValue.destroy();
            this._wdgValue = null;
        }

        if(this._cmdBar){
            this._cmdBar.destroy();
            this._cmdBar = null;
        }

        this.inherited('destroy', arguments);
    },

    getQuery: function(){

        var propertyDefinition = this._cmbProperties.get('item');
        var operator = this._cmbOperators.get('item');
        var dataType = this.dataTypes.fetchById({id:propertyDefinition.data_type_id});

        return {
            operator_id: operator.id,
            lhs: propertyDefinition.id,
            rhs: this._formatValue(this._wdgValue.get('value'), dataType)
        }
    },

    onStateChange: function(){

    },

    onDeleteRow: function(widget){

    },

    onNewRow: function(){
    },

    onValueChange: function(newValue){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._cmbProperties = new bfree.widget.FilteringSelect({
            store: this.propertyDefinitions.store,
            onChange: dojo.hitch(this, this._cmbProperties_onChange)
        }, this.propertiesNode);

        this._cmbOperators = new bfree.widget.FilteringSelect({
            store: this.operators.store,
            onChange: dojo.hitch(this, this._cmbOperators_onChange)
        }, this.operatorsNode);

        this._wdgValue = bfree.widget.ValidationTextBox({
            style: 'width:100%'
        }, this.valueNode);

        this._cmdBar = new bfree.widget.search.ConjunctionBar({
            'class': 'versaSidebar',
            onCommand: dojo.hitch(this, this._onCommand)
        }, this.cmdBarNode);

    },

    onKeyUp: function(evt){

    },

    startup: function(){
        this.inherited('startup', arguments);

        //this._cmdBar.set('disabled', true);

        var item = this.propertyDefinitions.fetchByDbName('documents.name');
        this._cmbProperties.set('value', item.id);
    }

});

}

if(!dojo._hasResource['bfree.widget.search.Advanced']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.search.Advanced'] = true;


/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/11/11
 * Time: 1:56 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.search.Advanced');













//

dojo.declare('bfree.widget.search.Advanced', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("bfree/widget/search", "template/Advanced.html", "<div style=\"\">\n    <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"criteriaNode\"></div>\n    </div>\n    <div style=\"text-align: right\">\n        <div dojoAttachPoint=\"submitNode\"></div>\n        <div dojoAttachPoint=\"resetNode\"></div>\n    </div>\n</div>\n"),
    widgetsInTemplate: true,

    _btnReset: null,
    _btnSubmit: null,
    _form: null,
    _operators: null,
    _widgets: [],

    library: null,

    _btnReset_onClick: function(evt){
        this.reset();
    },

    _onSubmit: function(evt){

        var query = null;
        var tail = null;

        if(this._form.get('state') != '')
            return false;

        query = new Array();
        for(var idx = 0; idx < this._widgets.length; idx++){
            query.push(this._widgets[idx].getQuery());
//            var node = this._widgets[idx].getQuery();
//            if(query == null){
//                query = node;
//                tail = query;
//            }
//            else{
//                var subquery = {
//                    operator_id: tail.operator_id,
//                    lhs: tail.lhs,
//                    rhs: tail.rhs
//                };
//                var node = this._widgets[idx].getQuery()
//                tail['lhs'] = subquery;
//                tail['operator_id'] = this._operators.getAndOp().id,
//                tail['rhs'] = node;
//                tail = tail.rhs;
//            }

        }

        var searchItem = new bfree.api.Search({
            type: bfree.api.Search.types.ADVANCED,
            queryData: query
        });

        this.onSearch(searchItem);
    },

    _onStateChange: function(){
        this._form.connectChildren(false);
    },

    _onValueChange: function(newValue){
        this._btnSubmit.set('disabled', (this._form.isValid() == ''));
    },

    addRow: function(){

        var wdg = new bfree.widget.search.Criterion({
            dataTypes: bfree.api.Application.getDataTypes(),
            propertyDefinitions: this.library.getPropertyDefinitions(),
            operators: this._operators,
            onNewRow: dojo.hitch(this, this.addRow),
            onDeleteRow: dojo.hitch(this, this.deleteRow),
            onStateChange: dojo.hitch(this, this._onStateChange),
            onValueChange: dojo.hitch(this, this._onValueChange),
            onKeyUp: dojo.hitch(this, this._onKeyUp)
        });
        wdg.startup();

        wdg.placeAt(this.criteriaNode, 'last');
        this._widgets.push(wdg);
        this._form.connectChildren(false);
    },

    _onKeyUp: function(evt){
        if(evt.keyCode==13){
            this._onSubmit();
        }
    },

    constructor: function(args){

    },

    deleteRow: function(widget){
        widget.destroyRecursive();
        this._widgets.removeByValue(widget);
        this._form.connectChildren(false);
    },

    destroy: function(){

    },

    onSearch: function(searchItem){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._operators = bfree.api.Application.getOperators();

        this._form = new dijit.form.Form({
            onSubmit: dojo.hitch(this, this._onSubmit)
        }, this.formNode);

        this._btnSubmit = bfree.widget.Button({
            iconClass: 'commandIcon bfreeIconSearch',
            label: 'Search',
            showLabel: false,
            type: 'submit'
        }, this.submitNode);

        this._btnReset = bfree.widget.Button({
            iconClass: 'commandIcon bfreeIconCancel',
            label: 'Reset',
            showLabel: false,
            onClick: dojo.hitch(this, this._btnReset_onClick)
        }, this.resetNode);

    },

    reset: function(){

        while(this._widgets.length > 0){
            var wdg = this._widgets.pop();
            wdg.destroy();
            wdg = null;
        }
        this.addRow();

    },

    startup: function(){
        this.inherited('startup', arguments);
        this.addRow();
    }

});

}

if(!dojo._hasResource['bfree.widget.search.DropDown']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.search.DropDown'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/11/11
 * Time: 1:45 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.search.DropDown');





dojo.declare('bfree.widget.search.DropDown', dijit.form.DropDownButton,
{
    library: null,

    constructor: function(args){
        this.baseClass = 'versaSearchDropDown';
    },

    onSearch: function(searchItem){
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

		var wdg = new bfree.widget.search.Advanced({
            library: this.library,
            onSearch: dojo.hitch(this, this.onSearch)
        });

		this.dropDown = new dijit.TooltipDialog({
			content: wdg
		});


	}

});

}

if(!dojo._hasResource['bfree.widget.search.TextBox']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.search.TextBox'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/11/11
 * Time: 1:40 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.search.TextBox');












dojo.declare('bfree.widget.search.TextBox', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree.widget.search", "template/TextBox.html", "<div class=\"versaSearchBox dijitTextBox\">\n\n<div dojoAttachPoint=\"formNode\">\n\n\t<table cellpadding=\"0\" cellspacing=\"0\" style=\"height:100%;width:100%;\">\n\t\t<tr>\n            <td style=\"width:1px;\"><button dojoAttachPoint=\"advancedButtonNode\"></button></td>\n            <td style=\"\"><input dojoAttachPoint=\"textboxNode,focusNode\"></input></td>\n\t\t\t<td style=\"width:1px\"><button dojoAttachPoint=\"submitButtonNode\"></button></td>\n\t\t</tr>\t\t\n\t</table>\n\n</div>\n\n</div>\n"),

	operators: null,
	library: null,

    _form: null,

	btnAdvanced: null,
	btnReset: null,
	btnSubmit: null,
	frmSearch: null,
	txtSearch: null,

    _form_onReset: function(){

    },

    _form_onSubmit: function(){
        var searchText = this.txtSearch.get('value');

        try{

            var searchItem = new bfree.api.Search({
                type: bfree.api.Search.types.SIMPLE,
                queryData: searchText
            });

            this.onSearch(searchItem);

        }
        catch(e){
            console.log(e);
        }

        return false;
    },

	_textbox_onChange: function(newValue){
	},
	_textbox_onFocus: function(){
	},

	constructor: function(args){

	},

    onSearch: function(searchItem){

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
			onSubmit: dojo.hitch(this, this._form_onSubmit),
			onReset: dojo.hitch(this, this._form_onReset)
		}, this.formNode);

		new dijit.form.Button({
			baseClass: 'imageButton',
			iconClass: 'imageIcon bfreeIconSearch',
			label: 'Search',
			showLabel: false,
            type: 'submit'
		}, this.submitButtonNode);

		this.txtSearch = new bfree.widget.ValidationTextBox({
		 	intermediateChanges: true,
			placeHolder: 'Search documents...',
			style: 'border:0;font-size:13px;width:100%;background:transparent;'
		 }, this.textboxNode);

		new bfree.widget.search.DropDown({
			library: this.library,
            iconClass: 'searchIcon bfreeIcon',
			showLabel: false,
            onSearch: dojo.hitch(this, this.onSearch)
		}, this.advancedButtonNode);

	},

    startup: function(){
        this.inherited('startup', arguments);
    }

});

}

if(!dojo._hasResource['bfree.widget.user.UserMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.UserMenu'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 30/11/11
 * Time: 12:30 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.UserMenu');




dojo.declare('bfree.widget.user.UserMenu', [dijit.Menu],{
    activeUser: null,
    zone: null,

    _onCommand: function(cmdId, option, e){
        this.onCommand(cmdId, option);
    },

   constructor: function(args){

    },

    onCommand: function(cmdId, option){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this.addChild(
            new dijit.MenuItem({
                label: 'Edit Profile',
                iconClass: 'menuIcon bfreeIconEdit',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT, bfree.widget.Bfree.ObjectTypes.USER)
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Logout',
                iconClass: 'menuIcon bfreeIconLogout',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.LOGOFF)
            })
        );

    }

});

}

if(!dojo._hasResource["dijit.form.ComboButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ComboButton"] = true;
dojo.provide("dijit.form.ComboButton");




}

if(!dojo._hasResource['bfree.widget.user.ProfileButton']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.ProfileButton'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 30/11/11
 * Time: 9:57 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.ProfileButton');




dojo.declare('bfree.widget.user.ProfileButton', [dijit.form.ComboButton],
{
    _avatarNode: null,
    _avatarUrl: null,

    scrollOnFocus: false,
    user: null,
    zone: null,

    _onCommand: function(cmdId, option, e){
        this.onCommand(cmdId, option);
    },

    _setIconNode: function(srcUrl){

        if(this._avatarNode){
            dojo.destroy(this._avatarNode);
            this._avatarNode = null;
        }

        this._avatarNode = dojo.create('img', {src: srcUrl,width:'64',height:'64'}, this.iconNode);
    },

    constructor: function(args){

    },

    onCommand: function(cmdId, option){

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        var imgUrl = this.user.getAvatarUrl({zone: this.zone});
        this._setIconNode(imgUrl);

        this.dropDown = new bfree.widget.user.UserMenu({
                                activeUser: this.user,
                                zone: this.zone,
                                onCommand: dojo.hitch(this, this._onCommand)
                            });
	},

    refresh: function(){
        var imgUrl = this.user.getAvatarUrl({zone: this.zone});
        this._setIconNode(imgUrl);
    },

    startup: function(){
        this.inherited('startup', arguments);
        console.log('startup:> user/ProfileButton.js');
    }

});

}

if(!dojo._hasResource['bfree.widget.file.AvatarUploader']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.file.AvatarUploader'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/12/11
 * Time: 9:07 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.file.AvatarUploader');







dojo.declare('bfree.widget.file.AvatarUploader', bfree.widget.Uploader,{

    _avatarNode: null,
    _form: null,

    zone: null,

    _setIconNode: function(srcUrl){

        if(this._avatarNode){
            dojo.destroy(this._avatarNode);
            this._avatarNode = null;
        }

        //Find button widget...
        var wdgs = dijit.findWidgets(this.domNode);
        dojo.forEach(wdgs, function(wdg,idx){
            this._avatarNode = dojo.create('img', {id: 'avatarNode', src: srcUrl,width:'64',height:'64'}, wdg.iconNode);
            wdg.set('showLabel', false);
            wdg.set('iconClass', 'avatarIcon');
        }, this);
    },

    clean: function(){
        bfree.api.Uploader.clean({zone: this.zone});
    },

    constructor: function(args){
        this.multiple = false;
        this.uploadOnSelect = false;
        this.url = bfree.api.Uploader.getUploadUrl({ zone: args.zone });
    },

    destroy: function(){
        this.inherited('destroy', arguments);
    },

    onAvatarChange: function(temp_file){

    },

    onAfterUpload: function(uploaded_files){
        dojo.forEach(uploaded_files, function(uploaded_file, idx){
            var url = bfree.api.Uploader.getDownloadUrl({
                zone: this.zone,
                item: uploaded_file
            });
            this._setIconNode(url);
            this.onAvatarChange(uploaded_file);
        }, this);
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._setIconNode(this.avatarUrl);
    },

    startup: function(){
        this.inherited('startup', arguments);

    }

});

/*
dojo.provide('bfree.widget.file.AvatarUploader');





dojo.declare('bfree.widget.file.AvatarUploader', bfree.widget.Uploader,{

    _avatarNode: null,
    multiple: false,
    zone: null,

    avatarUrl: null,

  
    _onFileUploaded: function(item){

        console.log(item);

        if(this._avatarNode){
            dojo.destroy(this._avatarNode);
            this._avatarNode;
        }


        var wdgs = dijit.findWidgets(this.domNode);
        dojo.forEach(wdgs, function(wdg,idx){
            this._avatarNode = dojo.create('img', {id: 'avatarNode', src: this.avatarUrl,width:'64',height:'64'}, wdg.iconNode);
        }, this);

        this.onFileUploaded(item);

    },



    constructor: function(args){
        this.scrollOnFocus = false;
        this.uploadOnSelected = false;
        this.url = dojo.replace('/zones/{0}/upload', [args.zone.subdomain]);
    },

    onChange: function(evt){

        this.upload({
            authenticity_token: bfree.api.XhrHelper.authenticity_token,
            upload_type: this.uploadType
        });

    },


    onUploadComplete: function(uploaded_files){

        dojo.forEach(uploaded_files, function(item,idx){
            console.log(item.name + '\t' + item.file + '\t' + item.content_type + '\t' + item.size);
        });


    },

    onFileUploaded: function(fileItem){

    },


    onProgress: function(evt){
        console.log((evt.decimal * 100) + '%');
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        var wdgs = dijit.findWidgets(this.domNode);
        dojo.forEach(wdgs, function(wdg,idx){
            this._avatarNode = dojo.create('img', {id: 'avatarNode', src: this.avatarUrl,width:'64',height:'64'}, wdg.iconNode);
            wdg.set('showLabel', false);
            wdg.set('iconClass', 'avatarIcon');
        }, this);

    }


});
*/

}

if(!dojo._hasResource['bfree.widget.user.ProfileEditor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.ProfileEditor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 13/12/11
 * Time: 2:42 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.ProfileEditor');













dojo.declare('bfree.widget.user.ProfileEditor', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget], {

    templateString: dojo.cache("bfree/widget/user", "template/ProfileEditor.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"sidebar\"\n        gutters=\"false\"\n        style=\"padding:8px;height:100%;width:100%;\">\n\n     <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"leading\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;width:0px\">\n\n            <div dojoAttachPoint=\"avatarNode\"></div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\"\n                style=\"padding:8px;overflow:hidden\"\n                class=\"highlightPane\">\n\n        <div dojoAttachPoint=\"formNode\">\n            <div dojoAttachPoint=\"tableNode\"></div>\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _btnAvatar: null,
    _chkEditPassword: null,
    _lblName: null,
    _txtConfirmPassword: null,
    _txtEmail: null,
    _txtFirstName: null,
    _txtLastName: null,
    _txtOldPassword: null,
    _txtNewPassword: null,
    _users: null,

    zone: null,
    user: null,

    _chkEditPassword_onChange: function(checked){

        this._txtOldPassword.reset();
        this._txtNewPassword.reset();
        this._txtConfirmPassword.reset();

        this._txtOldPassword.set('disabled', !checked);
        this._txtNewPassword.set('disabled', !checked);
        this._txtConfirmPassword.set('disabled', !checked);

        if(checked)
            this._txtOldPassword.focus();

        this._users.setDirty(this.user);
        this.onValueChange();

    },

    _loadItem: function(){

        try{
            this._txtFirstName.setFocus(true);
        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onAvatarChange: function(temp_file){
        this._users.setValue(this.user, 'temp_file', temp_file);
        this.onValueChange();
    },

    _onValueChange: function(id, value){

        if(this.user.hasOwnProperty(id) && (this.user[id] != value)){
            this._users.setValue(this.user, id, value);
            this.onValueChange();
        }

    },

    _passwordValidator: function(value, constraints){
        return this._txtNewPassword.get('value') == value;
    },

    _passwordLengthValidator: function(value, constraints){
        if(this._txtOldPassword.get('value') == value){
            return false;
        }
        return value.length>=8;
    },

     _txtConfirmPassword_onChange: function(newValue){
        this.onValueChange();
    },

    _txtNewPassword_onChange: function(newValue){
        this._txtConfirmPassword.reset();
        this._users.setValue(this.user, 'password', newValue);
        this.onValueChange();
    },

    _txtOldPassword_onChange: function(newValue){
        this._users.setValue(this.user, 'old_password', newValue);
        this.onValueChange();
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._btnAvatar){
            this._btnAvatar.destroy();
            this._btnAvatar = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._txtFirstName.focus(true);
    },

    isValid: function(){
        var isValid = true;
        if(this._chkEditPassword.checked){
            isValid = (this._txtOldPassword.isValid() && this._txtNewPassword.isValid() && this._txtConfirmPassword.isValid());
        }
        if(String.isBlank(this.user.email)){
            isValid = false;
        }

        if(!bfree.api.Utilities.validateEmail(this.user.email)){
            isValid = false;
        }

        var password=this.user.reset_password;
        if(!(!password||password==null||password==""||password.length==0)){
            if(password.length>0&&password.length<8){
                isValid= false;
            }
        }

        return (this._users.isDirty({item: this.user})  && isValid);
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(dlgResult == bfree.widget.Dialog.dialogResult.ok){
                this._users.save();
                this._users.loadItem({
                    item: this.user
                });
            }
            else{
                this._users.revert();
            }

            //this._btnAvatar.clean();
            canClose = true;

        }
        catch(e){
           var err = new bfree.api.Error('Failed to close Profile Editor dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{

        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._users = this.zone.getUsers();

        /*
        var url = this.user.getAvatarUrl({zone: this.zone});
        this._btnAvatar = new bfree.widget.file.AvatarUploader({
            id: 'avatarUploader',
            zone: this.zone,
            avatarUrl: url,
            style: 'width:72px;height:68px;',
            onAvatarChange: dojo.hitch(this, this._onAvatarChange)
        }, this.avatarNode);
        */

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblUsers1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 112,
            style: 'width:100%'
        }, this.tableNode);

        this._lblName = new bfree.widget.Label({
            id: 'lblName',
            label: 'Username',
            value: this.user.name,
            style: 'width:100%'
		});
        this._tblProperties.addChild(this._lblName);

        this._txtFirstName = new bfree.widget.ValidationTextBox({
            id: 'txtFirstName',
            intermediateChanges: true,
            label: 'First Name',
            selectOnClick: true,
            value: this.user.first_name,
            style: 'width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'first_name')
		});
        this._tblProperties.addChild(this._txtFirstName);

        this._txtLastName = new bfree.widget.ValidationTextBox({
            id: 'txtLastName',
            intermediateChanges: true,
            label: 'Last Name',
            selectOnClick: true,
            value: this.user.last_name,
            style: 'width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'last_name')
		});
        this._tblProperties.addChild(this._txtLastName);

        this._txtEmail = new bfree.widget.ValidationTextBox({
            id: 'txtEmail',
            intermediateChanges: true,
            label: 'Email',
            selectOnClick: true,
            value: this.user.email,
            style: 'width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'email')
		});
        this._tblProperties.addChild(this._txtEmail);

        this._chkEditPassword = new dijit.form.CheckBox({
			name: 'chkEditPassword',
            label: 'Change Password',
            onChange: dojo.hitch(this, this._chkEditPassword_onChange)
		});
        this._tblProperties.addChild(this._chkEditPassword);

        this._txtOldPassword = new bfree.widget.ValidationTextBox({
            id: 'txtOldPassword',
            placeHolder: 'Enter old password',
            intermediateChanges: true,
            label: 'Old Password',
            selectOnClick: true,
            required: true,
            disabled: true,
            type: 'password',
            style: 'width:100%',
            onChange: dojo.hitch(this, this._txtOldPassword_onChange)
		});
        this._tblProperties.addChild(this._txtOldPassword);

        this._txtNewPassword = new bfree.widget.ValidationTextBox({
            id: 'txtNewPassword',
            placeHolder: 'Enter new password',
            intermediateChanges: true,
            label: 'New Password',
            selectOnClick: true,
            required: true,
            disabled: true,
            type: 'password',
            style: 'width:100%',
            validator: dojo.hitch(this, this._passwordLengthValidator),
            onChange: dojo.hitch(this, this._txtNewPassword_onChange)
		});
        this._tblProperties.addChild(this._txtNewPassword);

        this._txtConfirmPassword = new dijit.form.ValidationTextBox({
            id: 'txtConfirmPassword',
            label: 'Validate',
			intermediateChanges: true,
			invalidMessage: 'Passwords do not match',
			placeHolder: 'Confirm new password',
			required: true,
            disabled: true,
			type: 'password',
			validator: dojo.hitch(this, this._passwordValidator),
            style:'width:100%',
            onChange: dojo.hitch(this, this._txtConfirmPassword_onChange)
		});
        this._tblProperties.addChild(this._txtConfirmPassword);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._txtEmail.validate();
        setTimeout(bfree.widget.user.ProfileEditor._loadFnRef(this), 10);
    }

});

bfree.widget.user.ProfileEditor._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.user.ProfileEditor.show = function(args){
    var dlg = new bfree.widget.Dialog({
        id: 'dlgProfileEditor',
        title: 'Edit Profile: ' + args.user.name,
        widgetConstructor: bfree.widget.user.ProfileEditor,
        widgetParams: {
            user: args.user,
            zone: args.zone
        },
        noResize: true,
        height: 280,
        width: 420,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}

}

if(!dojo._hasResource['bfree.widget.user.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.CommandBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/12/11
 * Time: 1:17 PM
 * To change this template use File | Settings | File Templates.
 */
 dojo.provide('bfree.widget.user.CommandBar');





dojo.declare('bfree.widget.user.CommandBar', [dijit.Toolbar], {

    activeItem: null,

    _btnDelete: null,
    _btnEdit: null,
    _btnHelp: null,
    _btnNew: null,
    _btnSave: null,
    _btnUndo: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;
        this._setState();
    },

    _setState: function(){

        var isDirty = this.users.isDirty();
        var isNull = (this.activeItem == null);
        var canDelete = !this.activeItem.is_admin;

        this._btnSave.set('disabled', !isDirty);
        this._btnUndo.set('disabled', !isDirty);
        this._btnEdit.set('disabled', isNull);
        this._btnDelete.set('disabled', !canDelete || isNull);

    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

         this._btnSave = new bfree.widget.Button({
                id: 'btnUsersSave',
                label: 'Save Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconSave',
                disabledIconClass:'commandIcon bfreeIconSaveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.SAVE)
            });
        this.addChild(this._btnSave);

        this._btnUndo = new bfree.widget.Button({
                id: 'btnUsersUndo',
                label: 'Undo Unsaved Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconUndo',
                disabledIconClass: 'commandIcon bfreeIconUndoD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.UNDO)
            });
        this.addChild(this._btnUndo);

        this._btnNew = new bfree.widget.Button({
                label: 'New User...',
                showLabel: false,
                disabled: false,
                iconClass: 'commandIcon bfreeIconUser',
                disabledIconClass: 'commandIcon bfreeIconUserD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.NEW)
            });
        this.addChild(this._btnNew);

        this._btnEdit = new bfree.widget.Button({
                label: 'Edit selected User...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconEdit',
                disabledIconClass: 'commandIcon bfreeIconEditD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT)
            });
        this.addChild(this._btnEdit);

        this._btnDelete = new bfree.widget.Button({
                label: 'Delete selected User',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconDelete',
                disabledIconClass: 'commandIcon bfreeIconDeleteD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.DELETE)
            });
        this.addChild(this._btnDelete);

        this.addChild(new dijit.ToolbarSeparator());

        /*
        this._btnHelp =  new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconHelp',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            });
        this.addChild(this._btnHelp);
        */
    },

    startup: function(){
        this.inherited('startup', arguments);
    }

});

}

if(!dojo._hasResource['bfree.widget.user.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.Info'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/12/11
 * Time: 10:42 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.Info');







dojo.declare('bfree.widget.user.Info', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/user", "template/Info.html", "<div style=\"width:100%;height:100%\">\n\n     <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    _form: null,
    _lblId: null,
    _lblIsAdmin: null,
    _lblCreatedBy: null,
    _lblCreatedAt: null,
    _lblUpdatedBy: null,
    _lblUpdatedAt: null,
    _tblProperties: null,

    activeItem: null,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        this._lblId.set('value', this.activeItem.id);
        this._lblIsAdmin.set('value', this.activeItem.is_admin);
        this._lblCreatedBy.set('value', this.activeItem.created_by);
        this._lblCreatedAt.set('value', (this.activeItem.created_at) ? dojo.date.locale.format(this.activeItem.created_at, {formatLength: 'medium'}) : '');
        this._lblUpdatedBy.set('value', this.activeItem.updated_by);
        this._lblUpdatedAt.set('value', (this.activeItem.updated_at) ? dojo.date.locale.format(this.activeItem.updated_at, {formatLength: 'medium'}) : '');

        this._tblProperties.refresh();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'infoObjForm'
        }, this.formNode);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblObjInfo1',
            customClass: 'versainfo',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._lblId = new bfree.widget.Label({
               id: 'lblId',
               label: 'ID'
            });
        this._tblProperties.addChild(this._lblId);

        this._lblIsAdmin = new bfree.widget.Label({
               id: 'lblIsAdmin',
               label: 'Administrator?'
            });
        this._tblProperties.addChild(this._lblIsAdmin);

        this._lblCreatedBy = new bfree.widget.Label({
               id: 'lblCreatedBy',
               label: 'Created By'
            });
        this._tblProperties.addChild(this._lblCreatedBy);

        this._lblCreatedAt = new bfree.widget.Label({
               id: 'lblCreatedAt',
               label: 'Create Date'
            });
        this._tblProperties.addChild(this._lblCreatedAt);

        this._lblUpdatedBy = new bfree.widget.Label({
               id: 'lblUpdatedBy',
               label: 'Last Modified By:'
            });
        this._tblProperties.addChild(this._lblUpdatedBy);

        this._lblUpdatedAt = new bfree.widget.Label({
               id: 'lblUpdatedAt',
               label: 'Last Modified Date'
            });
        this._tblProperties.addChild(this._lblUpdatedAt);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.user.PasswordBox']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.PasswordBox'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/12/11
 * Time: 3:27 PM
 * To change this template use File | Settings | File Templates.
 */
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/12/11
 * Time: 2:40 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.PasswordBox');







dojo.declare('bfree.widget.user.PasswordBox', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/user", "template/PasswordBox.html", "<div style=\"height:100%;width:100%;\">\n\n    <table cellpadding=\"0\" cellspacing=\"0\" style=\"width:100%\">\n        <tr>\n            <td><div dojoAttachPoint=\"txtPasswordNode\"></div></td>\n            <td style=\"padding-left:4px;width:48px\"><div dojoAttachPoint=\"btnGenerateNode\"></div></td>\n        </tr>\n    </table>\n\n</div>\n"),
    widgetsInTemplate: true,

    _btnGenerate: null,
    _txtPassword: null,

    activeItem: null,
    disabled: false,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        if(this.activeItem){
            this._txtPassword.set('value', this.activeItem.password);
        }
        else{
            this._txtPassword.reset();
        }
    },

    _setDisabledAttr: function(value){
        this.disabled = value;

        if(this._btnGenerate)
            this._btnGenerate.set('disabled', this.disabled);

        if(this._txtPassword){
            this._txtPassword.set('disabled', (this.disabled || !this.activeItem.hasOwnProperty('password')));
            if(this._txtPassword.disabled)
                this._txtPassword.reset();
        }

    },

    _onChange: function(newValue){
        this.onChange(newValue);
    },

    _validator: function(newValue){
        return this.validator(newValue);
    },

    _onResetPassword: function(){

        var msg = dojo.replace('Are you sure you want to reset the password for user: {0}', [this.activeItem.getFullName()]);
        if(confirm(msg)){
            this.activeItem['password'] = '';
            var new_pword = bfree.api.Users.generatePassword({ length: 8 });
            this._txtPassword.set('value', new_pword);
            this.set('disabled', this.disabled);
            this._txtPassword.setFocus(true);

        }

    },

    constructor: function(args){
        this.disabled = (args.disabled) ? args.disabled : false;
    },

    destroy: function(){

        if(this._btnGenerate){
            this._btnGenerate.destroy();
            this._btnGenerate = null;
        }

        if(this._txtPassword){
            this._txtPassword.destroy();
            this._textPassowrd = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
       //this._txtName.setFocus(true);
    },

    onChange: function(newValue){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._txtPassword = new bfree.widget.ValidationTextBox({
            id: 'txtPassword',
            intermediateChanges: true,
            disabled: this.disabled,
            selectOnClick: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._validator),
            onChange: dojo.hitch(this, this._onChange)
		}, this.txtPasswordNode);

        this._btnGenerate = new bfree.widget.Button({
			iconClass: 'imageIcon bfreeIconLock',
            disabled: this.disabled,
			label: 'Reset User Password',
			showLabel: false,
            disabled: true,
            onClick: dojo.hitch(this, this._onResetPassword)
		}, this.btnGenerateNode);

    },

    startup: function(){
        this.inherited('startup', arguments);
    }


});

}

if(!dojo._hasResource['bfree.widget.user.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/12/11
 * Time: 2:40 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.Editor');












dojo.declare('bfree.widget.user.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/user", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        liveSplitters=\"true\"\n        style=\"width:100%;height:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"center\"\n            style=\"overflow:hidden;padding:0\">\n\n         <div dojoAttachPoint=\"formNode\">\n\n            <div dojoAttachPoint=\"tableNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"bottom\"\n            style=\"overflow:hidden;height: 88px;\">\n\n        <div dojoAttachPoint=\"infoNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _form: null,
    _chkDisabled: null,
    _cmbGroup: null,
    _tblProperties: null,
    _txtEmail: null,
    _txtFirstName: null,
    _txtLastName: null,
    _txtName: null,
    _txtPassword: null,
    _wdgInfo: null,

    activeItem: null,
    groups: null,
    users: null,

    _setActiveItemAttr: function(item){

        this.activeItem = item;

        this._txtName.set('value', this.activeItem.name);
        this._txtFirstName.set('value', this.activeItem.first_name);
        this._txtLastName.set('value', this.activeItem.last_name);
        this._txtEmail.set('value', this.activeItem.email);
        this._cmbGroup.set('value', this.activeItem.active_group);
        this._txtPassword.set('activeItem', this.activeItem);
        this._chkDisabled.set('checked', this.activeItem.disabled);

        this._txtEmail.set('required', this.activeItem.is_admin);

        this._wdgInfo.set('activeItem', this.activeItem);

        this._setState();

    },

    _setState: function(){

        var isDirty = this.users.isDirty({item: this.activeItem});
        var isNew = this.users.isNew({item: this.activeItem});
        var isAdmin = this.activeItem.is_admin;

        this._txtName.set('disabled', !(isDirty && isNew));
        this._txtFirstName.set('disabled', !isDirty);
        this._txtLastName.set('disabled', !isDirty);
        this._txtEmail.set('disabled', !isDirty);
        this._txtPassword.set('disabled', !isDirty);
        this._cmbGroup.set('disabled', !(isDirty && !isAdmin));
        this._chkDisabled.set('disabled', !(isDirty && !isAdmin));

    },

    _onValueChange: function(property, newValue){

        if(!this.activeItem)
            return;

        if(!this.activeItem.hasOwnProperty(property))
            return;

        var oldValue = this.users.getValue(this.activeItem, property);

        if(String.isEmpty(oldValue) && String.isEmpty(newValue))
            return;

        if(oldValue != newValue){
            this.users.store.setValue(this.activeItem, property, newValue);
            this.onValueChange(this.activeItem, property, oldValue, newValue);
        }

    },

    _onCmbGroupChange: function(newValue){
        this._onValueChange('active_group', newValue);
        this._txtEmail.validate();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._txtPassword){
            this._txtPassword.destroy();
            this._txtPassword = null;
        }

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
       this._txtName.setFocus(true);
    },

    onValueChange: function(item, property, oldValue, newValue){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'userForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblUsers1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._txtName = new bfree.widget.ValidationTextBox({
            id: 'txtName',
            label: 'Username',
            required: true,
            intermediateChanges: true,
            selectOnClick: true,
            style: 'width:100%',
            trim: true,
            validator: dojo.hitch(this, this._txtNameValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'name')
		});
        this._tblProperties.addChild(this._txtName);

         this._txtFirstName = new bfree.widget.ValidationTextBox({
            id: 'txtFirstName',
            intermediateChanges: true,
            label: 'First Name',
            selectOnClick: true,
            style: 'width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'first_name')
		});
        this._tblProperties.addChild(this._txtFirstName);

        this._txtLastName = new bfree.widget.ValidationTextBox({
            id: 'txtLastName',
            intermediateChanges: true,
            label: 'Last Name',
            selectOnClick: true,
            style: 'width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'last_name')
		});
        this._tblProperties.addChild(this._txtLastName);

        this._txtEmail = new bfree.widget.ValidationTextBox({
            id: 'txtEmail',
            label: 'Email Address',
            selectOnClick: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._emailValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'email')
		});
        this._tblProperties.addChild(this._txtEmail);

        this._txtPassword = new bfree.widget.user.PasswordBox({
            id: 'txtPwdBox',
            label: 'Password',
            disabled: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._passwordValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'password')
		});
        this._tblProperties.addChild(this._txtPassword);

        this._cmbGroup = new bfree.widget.FilteringSelect({
            label: 'Group',
            store: this.groups.store,
            query: {},
            queryOptions: { cache: true },
            onChange: dojo.hitch(this, this._onCmbGroupChange),
            searchAttr: 'name'
        });
        this._tblProperties.addChild(this._cmbGroup);

        this._chkDisabled = new dijit.form.CheckBox({
			label: 'User is disabled',
			onChange: dojo.hitch(this, this._onValueChange, 'disabled')
		});
        this._tblProperties.addChild(this._chkDisabled);

        this._wdgInfo = new bfree.widget.user.Info({
            id: 'wdgInfo1'
        }, this.infoNode);


    },

    _txtNameValidator: function(newValue){
        if(this._txtName){
            newValue=newValue.trim();

            if(newValue==""){
                this._txtName.set('invalidMessage', 'Username cannot be blank');
                return false;
            }
            if(newValue.length<4){
                this._txtName.set('invalidMessage', 'Username must be longer than 4 characters');
                return false;
            }
            if(newValue.indexOf(' ')>=0){
                this._txtName.set('invalidMessage', 'Username must be one word');
                return false;
            }
            var items=this.users.fetch();
            for(var i=0;i<items.length;i++){
                if(items[i].name&&
                   items[i].name.toLowerCase().trim()==newValue.toLowerCase().trim()&&
                   items[i].__id!=this.activeItem.__id){
                    this._txtName.set('invalidMessage', 'Duplicate username');
                    return false;
                }
            }
        }
        return true;
    },

    _passwordValidator: function(newValue){
        var password = newValue;

        if(this.activeItem.isNew()){
            if(password.length < 8){
                return false;
            }
        }else{

            if(!String.isEmpty(password)){
                return true;
            }
            if(password.length > 0 && password.length < 8){
                return false;
            }
        }
        return true;
    },

    _emailValidator: function(newValue){
        if(this._txtEmail){
            if(newValue.trim()==""){
                this._txtEmail.set('invalidMessage', 'Email cannot be blank');
                return false;
            }

            if(!bfree.api.Utilities.validateEmail(newValue)){
                this._txtEmail.set('invalidMessage', 'You must enter a valid email');
                return false;
            }
        }
        return true;
    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.user.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/12/11
 * Time: 1:53 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.Grid');



dojo.declare('bfree.widget.user.Grid', [bfree.widget._Grid], {

    users: null,

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },


	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};
		this.selectionMode = 'single';

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Users found';
        this.sortInfo = 3;

	},

	postCreate: function(){
		this.inherited('postCreate', arguments);
        this.set('structure', bfree.widget.user.Grid.view);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this.users.store, {}, {cache: true});
    }

});

bfree.widget.user.Grid.getState = function(idx, item){

    if(!item)
        return 0;

    if(!item.isValid())
        return -1;

    if(this.grid.users.isNew({item: item}))
        return 1;
    if(this.grid.users.isDirty({item: item}))
        return 2;

    return 0;
}

bfree.widget.user.Grid.formatState = function(data, rowIndex){

    var iconClass = '';
    switch(data){
        case -1:
            iconClass = 'statusIcon bfreeIconInvalid';
            break;
        case 1:
            iconClass = 'statusIcon bfreeIconNew';
            break;
        case 2:
            iconClass = 'statusIcon bfreeIconEdit';
            break;
    }

    return dojo.replace('<img src="/images/icons/16/blank.png" width="16" height="16" class="{0}"/>', [iconClass]);
}

bfree.widget.user.Grid.view = [
    {
        cells: [
            {
                field: 'state',
                name: '&nbsp;',
                width: '16px',
                get: bfree.widget.user.Grid.getState,
                formatter: bfree.widget.user.Grid.formatState
            },
            {
                field: 'name',
                name: 'Name',
                width: 'auto',
                get: function(idx, item){ return (item) ? item.getFullName() : ''; }
            },
            {
                field: 'sort_id',
                name: 'Sort',
                hidden: true
            }
        ],
        width: 'auto'
    }
];

}

if(!dojo._hasResource['bfree.widget.user.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.user.Administration'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/12/11
 * Time: 1:00 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.user.Administration');










dojo.declare('bfree.widget.user.Administration', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget], {
    templateString: dojo.cache("bfree/widget/user", "template/Administration.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n     <!-- Command Bar -->\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;height:27px\">\n\n        <div dojoAttachPoint=\"commandBarNode\"></div>\n\n    </div>\n\n     <div   dojoType=\"dijit.layout.BorderContainer\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"padding:8px;height:100%;width:100%\">\n\n\n         <div   dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"leading\"\n                style=\"padding:0 8px 0 0;width: 256px;\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"true\"\n                region=\"center\"\n                class=\"highlightPane\"\n                style=\"padding:8px\">\n\n            <div dojoAttachPoint=\"editorNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _cmdBar: null,
    _editor: null,
    _grdUsers: null,
    _groups: null,
    _users: null,

    activeUser: null,
    zone: null,

    _grdUsers_onSelectedItems: function(items){
        var item = null;

        if((!items) || (items.length < 1))
            return;

        item = items[0];

        this._cmdBar.set('activeItem', item);
        this._editor.set('activeItem', item);
    },

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.NEW:
                this.createItem();
                break;
            case bfree.widget.Bfree.Commands.EDIT:
                this.editItem();
                break;
            case bfree.widget.Bfree.Commands.DELETE:
                this.deleteItem();
                break;
            case bfree.widget.Bfree.Commands.SAVE:
                this.save();
                break;
            case bfree.widget.Bfree.Commands.UNDO:
                this.undo();
                break;

        }

    },

    _onValueChange: function(item, property, oldValue, newValue){
        var idx = this._grdUsers.getItemIndex(item);
        this._grdUsers.updateRow(idx);
    },

    _validateItems: function(active){
        var valid = true;

		for(var idx = 0; idx < this._grdUsers.rowCount; idx++){
            var item = this._grdUsers.getItem(idx);
            if(this._users.isDirty({item: item})){
                //this allows the deletion of an invalid user
                if(!active||(active&&active.__id!=item.__id)){
                    var items=this._users.fetch();
                    for(var i=0;i<items.length;i++){
                        if(items[i].name&&
                           items[i].name.toLowerCase().trim()==item.name.toLowerCase().trim()&&
                           items[i].__id!=item.__id){
                            return false;
                        }
                    }
                    if(item.email==""){
                        valid=false;
                    }
                    valid &= item.isValid();
                }
            }
		}

		return valid;
	},

    constructor: function(args){

    },

    createItem: function(){
        try{

            var uniqueName = this._users.generateUniqueName({base_name: 'user', appendix: '{index}'});
            var item = this._users.create({
                name: uniqueName,
                created_by: this.activeUser.name,
                created_at: new Date(),
                updated_by: this.activeUser.name,
                updated_at: new Date(),
                is_admin: false,
                active_group: this._groups.getEveryone().id,
                password: bfree.api.Users.generatePassword({ length: 8 }),
                disabled: false
            });

            this._grdUsers.selectItem(item);
            this._editor.focus();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to create User', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    deleteItem: function(){

        try{
            var item = this._grdUsers.selection.getFirstSelected();
            if(item){
                if(!this._validateItems(item)){
                    var msg = 'Cannot delete user: One or more Users contain invalid data';
                    alert(msg);
                    return;
                }

                var msg = dojo.replace('Are you sure you want to delete the user: \'{0}\'?', [item.getFullName()]);
                if (!confirm(msg))
                    return;

                var idx = this._grdUsers.getItemIndex(item);

                this._users.destroy({item: item, onComplete: dojo.hitch(this, this.deleteOnComplete, idx)})
            }
        }
        catch(e){
            var err = new bfree.api.Error('Failed to delete User', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    deleteOnComplete: function(idx){
        this._grdUsers.setSelectedIndex(idx);
        this._editor.focus();
    },


    destroy: function(){

        this.destroyDescendants();

        if(this._editor){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    editItem: function(){

        try{

            var item = this._grdUsers.selection.getFirstSelected();
            if(item){
                var idx = this._grdUsers.getItemIndex(item);
                this._users.clone({item: item});
                this._grdUsers.updateRow(idx);
                this._grdUsers.setSelectedIndex(idx);
                //this._users.setValue(item, 'reset_password', "");
                this._editor.focus();
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to edit User', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    isValid: function(){
        //return (this.isDirty || this._grd.store.isDirty());
        return true;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(this._users.isDirty()){
                var msg = 'You have unsaved changes that will be lost. Do you wish to continue?';
                if(confirm(msg)){
                    if(this._users != null)
                        this._users.revert();
                    canClose = true;
                }
            }
            else{
                canClose = true;
            }
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close User Administration dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._groups = this.zone.getGroups();
        this._groups.refresh();

        this._users = this.zone.getUsers();
        this._users.clearCache();

        this._cmdBar = new bfree.widget.user.CommandBar({
            id: 'cmdBar',
            users: this._users,
            onCommand: dojo.hitch(this, this._onCommand)
        }, this.commandBarNode);

        this._grdUsers = new bfree.widget.user.Grid({
            id: 'grdUsers',
            'class': 'versaGridOutline versaNoHeader',
            users: this._users,
            onSelectedItems: dojo.hitch(this, this._grdUsers_onSelectedItems)
        }, this.gridNode);

        this._editor = new bfree.widget.user.Editor({
            id: 'wdgEditor',
            groups: this._groups,
            users: this._users,
            onValueChange: dojo.hitch(this, this._onValueChange)
        }, this.editorNode);

    },

    save: function(){
        try{
            if(!this._validateItems()){
                var msg = 'Cannot save User changes: One or more Users contain invalid data';
                alert(msg);
                return;
            }

            var item = this._grdUsers.selection.getFirstSelected();
            this._users.save({onComplete: dojo.hitch(this, this.saveOnComplete, item)});
        }
        catch(e){
            var err = new bfree.api.Error('Failed to save User changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    saveOnComplete: function(item){
        this._users.clearCache();
        this._grdUsers.sort();
        this._grdUsers.selectItem(item);
    },

    startup: function(){
        this.inherited('startup', arguments);

        this._grdUsers.startup();
        this._grdUsers.setSelectedIndex(0);

        setTimeout(bfree.widget.user.Administration._loadFnRef(this), 10);

    },

    undo: function(){
        try{

            var item = this._grdUsers.selection.getFirstSelected();
            var idx = (item) ? this._grdUsers.getItemIndex(item) : 0;

            this._users.clearCache();

            this._users.revert();

            this._grdUsers.setSelectedIndex(idx);

        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    }


});

bfree.widget.user.Administration._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.user.Administration.show = function(args){

    var dlg = new bfree.widget.Dialog({
        id: 'dlgUserAdmin',
        title: 'User Administration',
        widgetConstructor:  bfree.widget.user.Administration,
        widgetParams: {
            activeUser: args.user,
            zone: args.zone
        },
        noResize: true,
        height: 400,
        width: 600,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}

}

if(!dojo._hasResource['bfree.widget.view.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.view.CommandBar'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.view.CommandBar');





dojo.declare('bfree.widget.view.CommandBar', [dijit.Toolbar], {

    _btnSave: null,
    _btnUndo: null,
    _btnNew: null,
    _btnEdit: null,
    _btnDelete: null,
    _btnHelp: null,

    activeItem: null,
    viewDefinitions: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;
        this._setState();
    },

    _setState: function(){

        var isDirty = this.viewDefinitions.isDirty();
        var isNull = (this.activeItem == null);
        var canDelete = !(isNull || this.activeItem.is_system);

        this._btnSave.set('disabled', !isDirty);
        this._btnUndo.set('disabled', !isDirty);
        this._btnEdit.set('disabled', isNull);
        this._btnDelete.set('disabled', !canDelete);
    },

    constructor: function(args){

    },

    destroy: function(){

        if(this._btnSave){
            this._btnSave.destroy();
            this._btnSave = null;
        }

        if(this._btnUndo){
            this._btnUndo.destroy();
            this._btnUndo = null;
        }

        if(this._btnNew){
            this._btnNew.destroy();
            this._btnNew = null;
        }

        if(this._btnEdit){
            this._btnEdit.destroy();
            this._btnEdit = null;
        }

        if(this._btnDelete){
            this._btnDelete.destroy();
            this._btnDelete = null;
        }

        if(this._btnHelp){
            this._btnHelp.destroy();
            this._btnHelp = null;
        }

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnSave = new bfree.widget.Button({
                id: 'btnViewDefsSave',
                label: 'Save Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconSave',
                disabledIconClass:'commandIcon bfreeIconSaveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.SAVE)
            });
        this.addChild(this._btnSave);

        this._btnUndo = new bfree.widget.Button({
                label: 'Undo Unsaved Changes...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconUndo',
                disabledIconClass: 'commandIcon bfreeIconUndoD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.UNDO)
            });
        this.addChild(this._btnUndo);

        this.addChild(new dijit.ToolbarSeparator());

        this._btnNew = new bfree.widget.Button({
                label: 'New View Definition...',
                showLabel: false,
                disabled: false,
                iconClass: 'commandIcon bfreeIconViewDef',
                disabledIconClass: 'commandIcon bfreeIconViewDefD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.NEW)
            });
        this.addChild(this._btnNew);

        this._btnEdit = new bfree.widget.Button({
                label: 'Edit selected View Definition...',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconEdit',
                disabledIconClass: 'commandIcon bfreeIconEditD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT)
            });
        this.addChild(this._btnEdit);

        this._btnDelete = new bfree.widget.Button({
                label: 'Delete selected View Definition',
                showLabel: false,
                disabled: true,
                iconClass: 'commandIcon bfreeIconDelete',
                disabledIconClass: 'commandIcon bfreeIconDeleteD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.DELETE)
            });
        this.addChild(this._btnDelete);

        this.addChild(new dijit.ToolbarSeparator());

        /*
        this._btnHelp =  new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon bfreeIconHelp',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            });
        this.addChild(this._btnHelp);
        */
    }

});

}

if(!dojo._hasResource['bfree.widget.view.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.view.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/11/11
 * Time: 4:20 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.view.Grid');



dojo.declare('bfree.widget.view.Grid', [bfree.widget._Grid], {

    selectionMode: 'single',
    viewDefinitions: null,

    _canEdit: function(cell, rowIndex){
        return false;
    },

	_canSort: function(columnIndex){
        return true;
    },

	constructor: function(/* Object */args){
		//this.baseClass = 'bfree';
		this.updateDelay = 0;
		this.rowsPerPage = 25;
        this.formatterScope = this;

		this.query = {};
		this.queryOptions = {cache: true};

		this.clientSort = false;
        this.canEdit = this._canEdit;
		this.canSort = this._canSort;
		this.noDataMessage = 'No View Definitions found';
        this.sortInfo = 3;

	},

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this.set('structure', bfree.widget.view.Grid.view1);
        //this.set('sortInfo', 2);
    },

    startup: function(){
        this.inherited('startup', arguments);
        this.setStore(this.viewDefinitions.store, {is_template: true}, {cache: true});
    }

});

bfree.widget.view.Grid.getState = function(idx, item){

    if(!item)
        return 0;

    if(!item.isValid())
        return -1;

    if(this.grid.viewDefinitions.isNew({item: item}))
        return 1;
    if(this.grid.viewDefinitions.isDirty({item: item}))
        return 2;

    return 0;
}

bfree.widget.view.Grid.formatState = function(data, rowIndex){

    var iconClass = '';
    switch(data){
        case -1:
            iconClass = 'statusIcon bfreeIconInvalid';
            break;
        case 1:
            iconClass = 'statusIcon bfreeIconNew';
            break;
        case 2:
            iconClass = 'statusIcon bfreeIconEdit';
            break;
    }

    return dojo.replace('<img src="/images/icons/16/blank.png" width="16" height="16" class="{0}"/>', [iconClass]);
}

bfree.widget.view.Grid.view1 = [
    {
        cells: [
            {
                field: 'state',
                name: '&nbsp;',
                width: '16px',
                get: bfree.widget.view.Grid.getState,
                formatter: bfree.widget.view.Grid.formatState
            },
            {
                field: 'name',
                name: 'Name',
                width: 'auto'
            },
            {
                field: 'sort_id',
                name: 'Sort',
                hidden: true
            }
        ],
        width: 'auto'
    }
];




}

if(!dojo._hasResource['bfree.widget.view.CellBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.view.CellBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 15/12/11
 * Time: 2:21 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.view.CellBar');





dojo.declare('bfree.widget.view.CellBar', [dijit.Toolbar], {

    _btnAdd: null,
    _btnDown:null,
    _btnRemove: null,
    _btnUp: null,
    _btnEdit: null,

    activeView: null,
    activeCell: null,
    disabled: false,
    grid: null,
    cellStore: null,

    _onCommand: function(cmdId, e){
        this.onCommand(cmdId);
    },

    _setActiveViewAttr: function(item){
        this.activeView = item;
        this._setState();
    },

    _setActiveCellAttr: function(item){
        this.activeCell = item;
        this._setState();
    },

    _setDisabledAttr: function(value){
        this.disabled = value;
        this._setState();
    },

    _setState: function(){

        if(this.disabled){
            this._btnAdd.set('disabled', this.disabled);
            this._btnUp.set('disabled', this.disabled);
            this._btnDown.set('disabled', this.disabled);
            this._btnRemove.set('disabled', this.disabled);
            //this._btnEdit.set('disabled', this.disabled);
        }
        else{
            var isViewNull = (this.activeView == null);
            var isCellNull = (this.activeCell == null);

            var idx = (this.activeCell) ?
                    this.activeCell.sort[0] :
                    0;

            //let's not move the icon columns
            var canAdd = true;
            var canMoveUp = (idx > 3);
            var canMoveDown = ((idx < (this.grid.rowCount - 1)) && (idx > 2));
            var canRemove = (idx > 2);
            var canEdit = ((!isCellNull) && (idx > 1));

            this._btnAdd.set('disabled', !canAdd);
            this._btnUp.set('disabled', !canMoveUp);
            this._btnDown.set('disabled', !canMoveDown);
            this._btnRemove.set('disabled', !canRemove);
            //this._btnEdit.set('disabled', !canEdit);
        }

    },


    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants();

        this.inherited('destroy', arguments);
    },

    onCommand: function(cmdId){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._btnAdd = new bfree.widget.Button({
            id: 'btnAddCell',
            label: 'Add Column to View...',
            showLabel: false,
            disabled: false,
            iconClass: 'sidebarIcon bfreeIconAdd',
            disabledIconClass:'sidebarIcon bfreeIconAddD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.ADD)
        });
        this.addChild(this._btnAdd);

        this._btnUp = new bfree.widget.Button({
            id: 'btnCellUp',
            label: 'Move Column to the left...',
            showLabel: false,
            disabled: false,
            iconClass: 'sidebarIcon bfreeIconUp',
            disabledIconClass:'sidebarIcon bfreeIconUpD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.MOVE_UP)
        });
        this.addChild(this._btnUp);

        this._btnDown = new bfree.widget.Button({
            id: 'btnCellDown',
            label: 'Move Column to the right...',
            showLabel: false,
            disabled: false,
            iconClass: 'sidebarIcon bfreeIconDown',
            disabledIconClass:'sidebarIcon bfreeIconDownD',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.MOVE_DOWN)
        });
        this.addChild(this._btnDown);

        this._btnRemove = new bfree.widget.Button({
                id: 'btnRemoveCell',
                label: 'Remove Column from View...',
                showLabel: false,
                disabled: false,
                iconClass: 'sidebarIcon bfreeIconRemove',
                disabledIconClass: 'sidebarIcon bfreeIconRemoveD',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.REMOVE)
            });
        this.addChild(this._btnRemove);

        /*
        this._btnEdit = new bfree.widget.Button({
                id: 'btnEditCell',
                label: 'Edit Column...',
                showLabel: false,
                disabled: false,
                iconClass: 'sidebarIcon bfreeIconEdit',
                disabledIconClass: 'sidebarIcon bfreeIconEditD',
                style: 'position:relative;top:16px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EDIT)
            });
        this.addChild(this._btnEdit);
        */

    },

    startup: function(){
        this.inherited('startup', arguments);
        console.log('viewdef.CellBar > startup');

    }
});

}

if(!dojo._hasResource['bfree.widget.view.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.view.Info'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.view.Info');









dojo.declare('bfree.widget.view.Info', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/view", "template/Info.html", "<div style=\"width:100%;height:100%\">\n\n     <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    _form: null,
    _lblId: null,
    _lblIsSystem: null,
    _lblCreatedBy: null,
    _lblCreatedAt: null,
    _lblUpdatedBy: null,
    _lblUpdatedAt: null,
    _tblProperties: null,

    activeItem: null,

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        if(item){
            this._lblId.set('value', this.activeItem.id);
            this._lblIsSystem.set('value', this.activeItem.is_system);
            this._lblCreatedBy.set('value', this.activeItem.created_by);
            this._lblCreatedAt.set('value', (this.activeItem.created_at) ? dojo.date.locale.format(this.activeItem.created_at, {formatLength: 'medium'}) : '');
            this._lblUpdatedBy.set('value', this.activeItem.updated_by);
            this._lblUpdatedAt.set('value', (this.activeItem.updated_at) ? dojo.date.locale.format(this.activeItem.updated_at, {formatLength: 'medium'}) : '');
        }
        else{
            this._lblId.reset();
            this._lblIsSystem.reset();
            this._lblCreatedBy.reset();
            this._lblCreatedAt.reset();
            this._lblUpdatedBy.reset();
            this._lblUpdatedAt.reset();
        }

        this._tblProperties.refresh();
    },

    constructor: function(args){

    },

    destroy: function(){

        this.destroyDescendants()

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },


    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'infoObjForm'
        }, this.formNode);

        this._tblProperties = new bfree.widget.PropertyTable({
            id: 'tblObjInfo1',
            customClass: 'versainfo',
            showLabels: true,
            cols: 1,
            labelWidth: 112,
            style: 'width:100%'
        }, this.tableNode);

        this._lblId = new bfree.widget.Label({
               id: 'lblId',
               label: 'ID'
            });
        this._tblProperties.addChild(this._lblId);

        this._lblIsSystem = new bfree.widget.Label({
               id: 'lblIsSystem',
               label: 'System View?'
            });
        this._tblProperties.addChild(this._lblIsSystem);

        this._lblCreatedBy = new bfree.widget.Label({
               id: 'lblCreatedBy',
               label: 'Created By:'
            });
        this._tblProperties.addChild(this._lblCreatedBy);

        this._lblCreatedAt = new bfree.widget.Label({
               id: 'lblCreatedAt',
               label: 'Create Date:'
            });
        this._tblProperties.addChild(this._lblCreatedAt);

        this._lblUpdatedBy = new bfree.widget.Label({
               id: 'lblUpdatedBy',
               label: 'Last Modified By:'
            });
        this._tblProperties.addChild(this._lblUpdatedBy);

        this._lblUpdatedAt = new bfree.widget.Label({
               id: 'lblUpdatedAt',
               label: 'Last Modified Date:'
            });
        this._tblProperties.addChild(this._lblUpdatedAt);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

}

if(!dojo._hasResource['bfree.widget.view.cell.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.view.cell.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/12/11
 * Time: 10:31 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.view.cell.Editor');











dojo.declare('bfree.widget.view.cell.Editor', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/view/cell", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoType=\"dijit.layout.ContentPane\"\n        style=\"padding:8px;overflow:hidden;\">\n\n<div class=\"highlightPane\" style=\"padding:8px\">\n    <div dojoAttachPoint=\"formNode\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n</div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _cmbColumn: null,
    _form: null,

    _first: null,
    _formatStore: null,
    _propertyStore: null,
    _tblProperties: null,
    _txtLabel: null,


    propertyDefinitions: null,
    filter: [],

    __loadItem: function(){

        try{
            if(this._first)
                this._cmbColumn.set('value', this._first.id);
        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _buildFormatStore: function(){
        this._formatStore=bfree.api.Utilities.getFormatStore();
    },

    _buildPropertyStore: function(){

        var items = [];

        this.propertyDefinitions.forEach(function(propDef, idx){
            var dbName = propDef.getDbName();

            if(!dojo.has(this.filter, dbName)){

                var item = {
                    id: dbName,
                    name: propDef.name,
                    table_name: propDef.table_name,
                    column_name: propDef.column_name,
                    data_type_id: propDef.data_type_id
                }
                if(!this._first)
                    this._first = item;
                items.push(item);
            }

        }, this);

        if(!dojo.has(this.filter, 'document_types.name')){
            items.push({
                id: 'document_types.name',
                name: 'Document Type',
                table_name: 'document_types',
                column_name: 'name',
                data_type_id: bfree.api.DataTypes.types.STRING
            });
        }

        if(!dojo.has(this.filter, 'versions.version_number')){
            items.push({
                id: 'versions.version_number',
                name: 'Version',
                table_name: 'versions',
                column_name: 'version_number',
                data_type_id: bfree.api.DataTypes.types.STRING
            });
        }

        if(!dojo.has(this.filter, 'versions.binary_file_size')){
            items.push({
                id: 'versions.binary_file_size',
                name: 'Size',
                table_name: 'versions',
                column_name: 'binary_file_size',
                data_type_id: bfree.api.DataTypes.types.INTEGER,
                formatter: bfree.api.CellDefinition.formats.size
            });
        }

        items.sort(function(a, b) {
            na = a.name.toLowerCase();
            nb = b.name.toLowerCase();
            return (na == nb) ? 0 : ((na < nb) ? -1 : 1);
        });

         this._propertyStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'name',
                items: items
            }
        });

    },


    _getDefaultWidth: function(data_type_id){
        return bfree.api.CellDefinitions.getDefaultWidth(data_type_id);
    },

    _onColumnChange: function(newValue){

        var item = this._cmbColumn.item;
        if(item){
            var name =  this._propertyStore.getValue(item, 'name');
            var data_type_id = this._propertyStore.getValue(item, 'data_type_id');

            this._txtLabel.set('value', name);
            this._txtWidth.set('value', this._getDefaultWidth(data_type_id));
            this._cmbFormatType.set('query', { data_type_id:  data_type_id });
            this._cmbFormatType.set('value', data_type_id + ':' + bfree.api.CellDefinition.formats.none);
        }
        else{
            this._txtName.reset();
            this._txtLabel.reset();
        }

        this.onValueChange();

    },

    constructor: function(args){

    },

    destroy: function(){
        this.destroyDescendants();

        /*
        if(this._txtPrevious){
            this._txtPrevious.destroy();
            this._txtPrevious = null;
        }

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }
        */

        this.inherited('destroy', arguments);
    },

    focus: function(){
        //this._txtDisplay.setFocus();
    },

    isValid: function(){
        return true; //this._form.isValid();
    },

    onDialogClosing: function(dlgResult){

        if(dlgResult == bfree.widget.Dialog.dialogResult.cancel){
            this.returnValue = null;
        }
        else{
            if(isNaN(this._txtWidth.get('value'))){
                alert('Width must be a number');
                return false;
            }
            if(this._txtWidth.get('value')<=0){
                alert('Width must be greater than 0');
                return false;
            }
            var column = this._cmbColumn.item;
            var formatter = this._cmbFormatType.item;

            this.returnValue = {
                id: this._propertyStore.getIdentity(column),
                table_name: this._propertyStore.getValue(column, 'table_name'),
                column_name: this._propertyStore.getValue(column, 'column_name'),
                name: this._propertyStore.getValue(column, 'name'),
                label: this._txtLabel.get('value'),
                formatter: this._formatStore.getValue(formatter, 'format_id'),
                noresize: false,
                width: this._txtWidth.get('value')+'px',
                style: ''
            }

        }

        return true;
    },

    onLoaded: function(){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._buildPropertyStore();
        this._buildFormatStore();

        this._form = new dijit.form.Form({
            id: 'columnForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblValueProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 96,
            style: 'width:100%'
        }, this.tableNode);

        this._cmbColumn = new bfree.widget.FilteringSelect({
            label: 'Column',
            store: this._propertyStore,
            query: {},
            queryOptions: { cache: true },
            onChange: dojo.hitch(this, this._onColumnChange),
            searchAttr: 'name',
            style: 'width:100%'
        });
        this._tblProperties.addChild(this._cmbColumn);

        this._txtLabel = new bfree.widget.ValidationTextBox({
            label: 'Label',
            selectOnClick: true,
            style: 'width:100%',
            required: true,
            onChange: dojo.hitch(this, this._onValueChange, 'name')
        });
        this._tblProperties.addChild(this._txtLabel);

        this._txtWidth = new dijit.form.NumberSpinner({
            label: 'Width',
            selectOnClick: true,
            style: 'width:100%',
            required: true,
            constraints: {min: 0},
            onChange: dojo.hitch(this, this._onValueChange, 'name')
        });
        this._tblProperties.addChild(this._txtWidth);

        this._cmbFormatType = new bfree.widget.FilteringSelect({
            store: this._formatStore,
            query: { },
            label: 'Format Type',
            selectOnClick: true,
            style: 'width:100%',
            required: true,
            onChange: dojo.hitch(this, this._onValueChange, 'name')
        });
        this._tblProperties.addChild(this._cmbFormatType);

    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();

        setTimeout(bfree.widget.view.cell.Editor._loadFnRef(this), 10);
    }


});

bfree.widget.view.cell.Editor._loadFnRef = function(that){
    return ( function() {
       that.__loadItem();
    });
}


bfree.widget.view.cell.Editor.show = function(args){

    var dlg = new bfree.widget.Dialog({
        id: 'dlgCells',
        title: 'View Columns...',
        widgetConstructor: bfree.widget.view.cell.Editor,
        widgetParams: {
            propertyDefinitions: args.propertyDefinitions,
            filter: args.filter
        },
        noResize: true,
        height: 220,
        width: 360,
        zIndex: 2048,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['bfree.widget.view.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.view.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 07/11/11
 * Time: 1:54 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.view.Editor');


















dojo.declare('bfree.widget.view.Editor', [dijit._Widget, dijit._Templated],{
    templateString: dojo.cache("bfree/widget/view", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoAttachPoint=\"mainNode\"\n        dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        liveSplitters=\"true\"\n        style=\"width:100%;height:100%\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"top\"\n            style=\"overflow:hidden;padding:0;height: 104px;\">\n\n         <div dojoAttachPoint=\"formNode\">\n\n            <div dojoAttachPoint=\"tableNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            splitter=\"false\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"width:100%;height:100%\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\"\n                style=\"\">\n\n            <div dojoAttachPoint=\"cellGridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"right\"\n                style=\"overflow:hidden;padding:16px 0 0 0;width:24px\">\n\n            <div dojoAttachPoint=\"cellBarNode\"></div>\n\n        </div>\n\n    </div>\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"bottom\"\n            style=\"padding:0 8px 0 8px;height: 96px;\">\n\n        <div dojoAttachPoint=\"infoNode\"></div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    activeItem: null,
    viewDefinitions: null,

    _handles: [],
    _cmbSort: null,
    _cmdBar: null,
    _cellStore: null,
    _form: null,
    _grdCells: null,
    _tblProperties: null,
    _txtDescription: null,
    _txtName: null,
    _wdgInfo: null,

    __onCellDlgClose: function(dlgResult, retValue){

        var item = null;

        if(dlgResult == bfree.widget.Dialog.dialogResult.ok){

            try{
                this._grdCells.beginUpdate();

                item = this._cellStore.newItem({
                    sort: (this._grdCells.rowCount),
                    id: retValue.id,
                    name: retValue.name,
                    display: retValue.label,
                    table_name: retValue.table_name,
                    column_name: retValue.column_name,
                    formatter: retValue.formatter,
                    noresize: retValue.noresize,
                    width: retValue.width,
                    style: retValue.style
                });


            }
            finally{
                this._grdCells.endUpdate();
            }

            if(item)
                this._grdCells.selectItem(item);

        }

        return true;
    },

    _grdCells_onSelectedItems: function(items){
        var item = null;
        if(dojo.isArray(items) && items.length > 0)
            item = items[0];

        this._cmdBar.set('activeCell', item);
    },

    _onCellCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.ADD:
                this._onCellAdd();
                break;
            case bfree.widget.Bfree.Commands.MOVE_UP:
                this._onCellUp();
                break;
            case bfree.widget.Bfree.Commands.MOVE_DOWN:
                this._onCellDown() ;
                break;
            case bfree.widget.Bfree.Commands.REMOVE:
                this._onCellRemove();
                break;

        }
    },

    _onCellAdd: function(){
        try{

            var currentFilter = [];
            dojo.forEach(this.activeItem.cell_definitions, function(item, idx){
                var cell_id = bfree.api.CellDefinition.getDbName(item);
                currentFilter.push(cell_id);
            },this);

            var propDef = this.propertyDefinitions.fetch();

            //4 definitions are special and not included in the propdef table
            //state, content type, version, size and document type
            if(currentFilter.length>=(propDef.length+5)){
                alert('No property definitions left to add');
                return;
            }

            bfree.widget.view.cell.Editor.show({
                filter: currentFilter,
                propertyDefinitions: this.propertyDefinitions,
                onClose: dojo.hitch(this, this.__onCellDlgClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Column Editor\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onCellCreated: function(newItem, parentInfo){

        this.activeItem.cell_definitions.push({
            table_name: this._cellStore.getValue(newItem, 'table_name'),
            column_name: this._cellStore.getValue(newItem, 'column_name'),
            name: this._cellStore.getValue(newItem, 'name'),
            label: this._cellStore.getValue(newItem, 'display'),
            formatter: this._cellStore.getValue(newItem, 'formatter'),
            noresize: this._cellStore.getValue(newItem, 'noresize'),
            width: this._cellStore.getValue(newItem, 'width'),
            style: this._cellStore.getValue(newItem, 'style'),
            column_order: this._cellStore.getValue(newItem, 'sort')
        });
        this.onValueChange(this.activeItem, 'cell_definitions', [], this.activeItem.cell_definitions);

    },

    _onCellDeleted: function(deletedItem){

        var id = this._cellStore.getIdentity(deletedItem);
        for(var idx = 0; idx < this.activeItem.cell_definitions.length; idx++){
            var cell_id = bfree.api.CellDefinition.getDbName(this.activeItem.cell_definitions[idx]);
            if(cell_id == id){
                this.activeItem.cell_definitions.splice(idx, 1);
                break;
            }
        }

        this.activeItem.cell_definitions.sort(bfree.api.CellDefinition.compare);

        for(var i=0;i<this.activeItem.cell_definitions.length;i++){
            this.activeItem.cell_definitions[i].sort_order=i;
        }

        this.onValueChange(this.activeItem, 'cell_definitions', [], this.activeItem.cell_definitions);

    },

    _onCellDown: function(){
        var item = this._grdCells.selection.getFirstSelected();
        if(item){
            this._grdCells.moveItem(item, bfree.widget.SortGrid.move.DOWN);
        }
    },

    _onCellUp: function(){
        var item = this._grdCells.selection.getFirstSelected();
        if(item){
            this._grdCells.moveItem(item, bfree.widget.SortGrid.move.UP);
        }
    },

    _onCellRemove: function(){

        var idx = 0;

        try{
            this._grdCells.beginUpdate();

            var item = this._grdCells.selection.getFirstSelected();
            idx = this._grdCells.getItemIndex(item);
            this._cellStore.deleteItem(item);

            if(item.id == this.activeItem.sort_by){
                this.activeItem.sort_by = null;
                this._cmbSort.reset();
                this._cmbSort.validate();
            }

            var props=this._cellStore._arrayOfTopLevelItems;
            props.sort(function(item1, item2){
                return item1.sort[0]-item2.sort[0];
            });

            for(var i=0;i<props.length;i++){
                if(props[i]){
                    this._cellStore.setValue(props[i], 'sort', i);
                }
            }

            this._cellStore.save();
        }
        catch(e){
            var err = new bfree.api.Error('Failed to remove Cell Definition', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
             this._grdCells.endUpdate();
        }

        this._grdCells.setSelectedIndex(idx);

    },

    _onCellUpdated: function(item, property, oldValue, newValue){

        property = (property == 'sort') ? 'column_order' : property;

        var id = this._cellStore.getIdentity(item);
        for(var idx = 0; idx < this.activeItem.cell_definitions.length; idx++){
            var cell_id = bfree.api.CellDefinition.getDbName(this.activeItem.cell_definitions[idx]);
             if(cell_id == id){
                if(this.activeItem.cell_definitions[idx].hasOwnProperty(property)){
                    if(this.activeItem.cell_definitions[idx][property] != newValue){
                        this.activeItem.cell_definitions[idx][property] = newValue;
                    }
                }
            }

        }
        this.onValueChange(this.activeItem, 'cell_definitions', [], this.activeItem.cell_definitions);

    },

     _onValueChange: function(property, newValue){

        if(!this.activeItem)
            return;

        if(!this.activeItem.hasOwnProperty(property))
            return;

        var oldValue = this.viewDefinitions.getValue(this.activeItem, property);
        if(oldValue != newValue){
            this.viewDefinitions.store.setValue(this.activeItem, property, newValue);
            this.onValueChange(this.activeItem, property, oldValue, newValue);
        }

    },

    _setActiveItemAttr: function(item){
        this.activeItem = item;

        this._setStore();

        this._txtName.set('value', this.activeItem.name);
        this._txtDescription.set('value', this.activeItem.description);
        this._cmbSort.set('value', this.activeItem.sort_by);

        this._cmdBar.set('activeView', this.activeItem);
        this._wdgInfo.set('activeItem', this.activeItem);

        this._setState();

    },

    _setState: function(){

        var isDirty = this.viewDefinitions.isDirty({item: this.activeItem});
        var isNew = this.activeItem.isNew();

        this._txtName.set('disabled', !isDirty);
        this._txtDescription.set('disabled', !isDirty);
        this._cmbSort.set('disabled', !isDirty);
        this._grdCells.set('disabled', !isDirty);
        this._cmdBar.set('disabled', !isDirty);
    },

    _setStore: function(){

        var items = []

        if(this.activeItem){
            dojo.forEach(this.activeItem.cell_definitions, function(item, idx){

                items.push({
                    sort: item.column_order,
                    id: bfree.api.CellDefinition.getDbName(item),
                    name: item.name,
                    display: item.label,
                    table_name: item.table_name,
                    column_name: item.column_name,
                    formatter: item.formatter,
                    noresize: item.noresize,
                    width: item.width,
                    style: item.style
                });

            }, this);
        }


        dojo.forEach(this._handles, function(hndl, idx){
            dojo.disconnect(hndl);
            delete this._handles[idx];
        }, this);


        this._cellStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'display',
                items: items
            }
        });

        this._handles[0] = dojo.connect(this._cellStore, 'onNew', this, this._onCellCreated);
        this._handles[1] = dojo.connect(this._cellStore, 'onDelete', this, this._onCellDeleted);
        this._handles[2] = dojo.connect(this._cellStore, 'onSet', this, this._onCellUpdated);

        this._cmbSort.set('store', this._cellStore);
        this._grdCells.setStore(this._cellStore);
        this._grdCells.resize();
        this._grdCells.setSelectedIndex(0);

    },


    constructor: function(args){

        this._cellStore = new bfree.api.ItemFileWriteStore({
            data: {
                identifier: 'id',
                label: 'display',
                items: []
            }
        });

    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyDescendants();
            this._tblProperties.destroy();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

    focus: function(){
        this._txtName.setFocus(true);
    },

    onValueChange: function(item, property, oldValue, newValue){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._form = new dijit.form.Form({
            id: 'propDefForm'
        }, this.formNode);

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 112,
            style: 'width:100%'
        }, this.tableNode);

        this._txtName = new bfree.widget.ValidationTextBox({
            label: 'Name',
            intermediateChanges: true,
            selectOnClick: true,
            style: 'width:100%',
            required: true,
            trim: true,
            validator: dojo.hitch(this, this._txtNameValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'name')
        });
        this._tblProperties.addChild(this._txtName);

        this._txtDescription = new dijit.form.SimpleTextarea({
            label: 'Description',
            'class': 'bfree',
            rows: 2,
            style: 'resize:none;width:100%',
            onChange: dojo.hitch(this, this._onValueChange, 'description')
        });
        this._tblProperties.addChild(this._txtDescription);

        this._cmbSort = new bfree.widget.FilteringSelect({
            label: 'Sort By Column',
            store: this._cellStore,
            query: {},
            queryOptions: { cache: true },
            onChange: dojo.hitch(this, this._onValueChange, 'sort_by'),
            searchAttr: 'name'
        });
        this._tblProperties.addChild(this._cmbSort);

        this._grdCells = new bfree.widget.SortGrid({
            'class': 'versaGridOutlineNoPad',
            query: {},
            noDataMessage: 'No Columns Defined',
            store: this._cellStore,
            sort_field: 'sort',
            structure: bfree.widget.view.Editor.view1,
            formatterScope: this,
            rowsPerPage: 1000,
            style: 'width:100%;height:100%',
            onSelectedItems: dojo.hitch(this, this._grdCells_onSelectedItems)
        }, this.cellGridNode);

        this._cmdBar = new bfree.widget.view.CellBar({
            id: 'wdgCellBar',
            'class': 'versaSidebar',
            grid: this._grdCells,
            onCommand: dojo.hitch(this, this._onCellCommand)
        }, this.cellBarNode);


        this._wdgInfo = new bfree.widget.view.Info({
            id: 'wdgInfo1'
        }, this.infoNode);

        this._grdCells.startup();
    },

    _txtNameValidator: function(newValue){
        if(this._txtName){
            if(newValue.trim()==''){
                this._txtName.set('invalidMessage', 'View definition name cannot be blank');
                return false;
            }
            var items=this.viewDefinitions.fetch();
            for(var i=0;i<items.length;i++){
                if(items[i].name&&
                   items[i].name.toLowerCase().trim()==newValue.toLowerCase().trim()&&
                   items[i].__id!=this.activeItem.__id){
                    this._txtName.set('invalidMessage', 'Duplicate view definition');
                    return false;
                }
            }
        }
        return true;
    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainNode.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }


});

bfree.widget.view.Editor.getFormatFn = function(idx, item){
    var value = 'None';

    if(!item)
        return value;

    var format = this.grid.store.getValue(item, 'formatter');

    switch(format){
        case bfree.api.CellDefinition.formats.icon:
            value = 'Icon';
            break;
        case bfree.api.CellDefinition.formats.size:
            value = 'Size';
            break;
        case bfree.api.CellDefinition.formats.status:
            value = 'Status';
            break;
        case bfree.api.CellDefinition.formats.datetime:
            value = 'Date';
            break;
        case bfree.api.CellDefinition.formats.date:
            value = 'Date';
            break;
        case bfree.api.CellDefinition.formats.time:
            value = 'Time';
            break;
    }

    return value;
}

bfree.widget.view.Editor.view1 = [
    {
        cells: [
            {
                field: 'sort',
                name: '&nbsp',
                width: '16px',
                hidden: true
            },
            {
                field : 'name',
                name: 'Name',
                width: '128px'
            },
            {
                field: 'display',
                name: 'Label',
                width: 'auto'
            },
            {
                field: 'width',
                name: 'Width',
                width: '64px'
            },
            {
                field: 'formatter',
                name: 'Format',
                width: '64px',
                get: bfree.widget.view.Editor.getFormatFn
            }
        ],
        width: 'auto'
    }

];

}

if(!dojo._hasResource['bfree.widget.view.Administration']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.view.Administration'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.view.Administration');












dojo.declare('bfree.widget.view.Administration', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget], {
    templateString: dojo.cache("bfree/widget/view", "template/Administration.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n     <!-- Command Bar -->\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"top\"\n            splitter=\"false\"\n            style=\"padding:0;overflow:hidden;height:27px\">\n\n        <div dojoAttachPoint=\"commandBarNode\"></div>\n\n    </div>\n\n     <div   dojoType=\"dijit.layout.BorderContainer\"\n            region=\"center\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            liveSplitters=\"true\"\n            style=\"padding:8px;height:100%;width:100%\">\n\n\n         <div   dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"leading\"\n                style=\"padding:0 8px 0 0;width: 256px;\">\n\n            <div dojoAttachPoint=\"gridNode\"></div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"true\"\n                region=\"center\"\n                class=\"highlightPane\"\n                style=\"padding:8px\">\n\n            <div dojoAttachPoint=\"editorNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _cmdBar: null,
    _grdViews: null,
    _editor: null,
    _propertyDefinitions: null,
    _viewDefinitions: null,

    activeUser: null,
    library: null,
    doRefresh: false,
    zone: null,


    _onCommand: function(cmdId){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.NEW:
                this.createItem();
                break;
            case bfree.widget.Bfree.Commands.EDIT:
                this.editItem();
                break;
            case bfree.widget.Bfree.Commands.DELETE:
                this.deleteItem();
                break;
            case bfree.widget.Bfree.Commands.SAVE:
                this.save();
                break;
            case bfree.widget.Bfree.Commands.UNDO:
                this.undo();
                break;

        }

    },

    _grdViews_onSelectedItems: function(items){
        var item = null;

        if((!items) || (items.length < 1))
            return;

        item = items[0];

        this._cmdBar.set('activeItem', item);
        this._editor.set('activeItem', item);
    },

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    _onValueChange: function(item, property, oldValue, newValue){
        var idx = this._grdViews.getItemIndex(item);
        this._grdViews.updateRow(idx);
    },

    _validateItems: function(active){
        var valid = true;

		for(var idx = 0; idx < this._grdViews.rowCount; idx++){
            var item = this._grdViews.getItem(idx);
            if(this._viewDefinitions.isDirty({item: item})){
                if(!active||(active&&active.__id!=item.__id)){
                    var items=this._viewDefinitions.fetch();
                    for(var i=0;i<items.length;i++){
                        if(items[i].name&&
                           items[i].name.toLowerCase().trim()==item.name.toLowerCase().trim()&&
                           items[i].__id!=item.__id){
                            return false;
                        }
                    }
                    valid &= item.isValid();
                }
            }
		}

		return valid;
	},

    constructor: function(args){

    },

    createItem: function(){

        try{

            var uniqueName = this._viewDefinitions.generateUniqueName({base_name: 'View'});
            var item = this._viewDefinitions.create({
                name: uniqueName,
                description: '',
                scope: '*',
                cell_definitions: [],
                sort_by: 'documents.name',
                is_system: false,
                created_by: this.activeUser.name,
                created_at: new Date(),
                updated_by: this.activeUser.name,
                updated_at: new Date(),
                is_template: true
            });

            var idx = 0;
            item.cell_definitions.push({
                column_order: idx,
                table_name: 'documents',
                column_name: 'state',
                label: '',
                name: 'State',
                noresize: true,
                style: '',
                width: '18px',
                formatter: bfree.api.CellDefinition.formats.status
            });
            idx++;

            item.cell_definitions.push({
                column_order: idx,
                table_name: 'versions',
                column_name: 'binary_content_type',
                label: '',
                name: 'Content Type',
                noresize: true,
                style: '',
                width: '18px',
                formatter: bfree.api.CellDefinition.formats.icon
            });
            idx++;

            item.cell_definitions.push({
                column_order: idx,
                table_name: 'documents',
                column_name: 'name',
                label: 'Title',
                name: 'Title',
                noresize: false,
                style: '',
                width: 'auto',
                formatter: bfree.api.CellDefinition.formats.none
            });
            idx++;

            item.cell_definitions.push({
                column_order: idx,
                table_name: 'document_types',
                column_name: 'name',
                label: 'Document Type',
                name: 'Document Type',
                noresize: false,
                width: '128px',
                formatter: bfree.api.CellDefinition.formats.none,
                style: ''
            });
            idx++;

            item.cell_definitions.push({
                column_order: idx,
                table_name: 'versions',
                column_name: 'version_number',
                label: 'Version',
                name: 'Version',
                noresize: false,
                width: '64px',
                formatter: bfree.api.CellDefinition.formats.none,
                style: ''
            });
            idx++;

            item.cell_definitions.push({
                column_order: idx,
                table_name: 'versions',
                column_name: 'binary_file_size',
                label: 'Size',
                name: 'Size',
                noresize: false,
                width: '64px',
                formatter: bfree.api.CellDefinition.formats.size,
                style: ''
            });
            idx++;

            item.cell_definitions.push({
                column_order: idx,
                table_name: 'documents',
                column_name: 'updated_by',
                label: 'Owner',
                name: 'Owner',
                noresize: false,
                width: '128px',
                formatter: bfree.api.CellDefinition.formats.none,
                style: ''
            });
            idx++;

            this._grdViews.selectItem(item);
            this._editor.focus();

        }
        catch(e){
            var err = new bfree.api.Error('Failed to create Document Type', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    deleteItem: function(){

         try{

            var item = this._grdViews.selection.getFirstSelected();
            if(item){

                if(!this._validateItems(item)){
                    var msg = 'Cannot delete View: One or more Views contain invalid data';
                    alert(msg);
                    return;
                }

                var msg = dojo.replace('Are you sure you want to delete the view: \'{0}\'?', [item.name]);
                if (!confirm(msg))
                    return;

                var idx = this._grdViews.getItemIndex(item);
                this._viewDefinitions.destroy({item: item});
                this._grdViews.setSelectedIndex(idx);
                this._editor.focus();

                this.doRefresh = true;
            }

        }
        catch(e){
           var err = new bfree.api.Error('Failed to delete View', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }


    },

    destroy: function(){

        if(this._cmdBar){
            this._cmdBar.destroy();
            this._cmdBar = null;
        }

        if(this._grdViews){
            this._grdViews.destroy();
            this._grdViews = null;
        }

        if(this._editor){
            this._editor.destroy();
            this._editor = null;
        }

        this.inherited('destroy', arguments);
    },

    editItem: function(){

        try{

            var item = this._grdViews.selection.getFirstSelected();
            if(item){
                var idx = this._grdViews.getItemIndex(item);
                this._viewDefinitions.clone({item: item});
                this._grdViews.updateRow(idx);
                this._grdViews.setSelectedIndex(idx);
                this._editor.focus();
            }

        }
        catch(e){
            var err = new bfree.api.Error('Failed to edit View', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    isValid: function(){
        return (this.isDirty || this._grdAcl.store.isDirty());
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            if(this._viewDefinitions.isDirty()){
                var msg = 'You have unsaved changes that will be lost. Do you wish to continue?';
                if(confirm(msg)){
                    if(this._viewDefinitions != null)
                        this._viewDefinitions.revert();
                    canClose = true;
                }
            }
            else{
                canClose = true;
            }

            this.returnValue = this.doRefresh;
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close View Definitions dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._propertyDefinitions = this.library.getPropertyDefinitions();
        this._propertyDefinitions.refresh();

        //Retrieve viewdefs and clear cache so grid retrieves latest from server
        this._viewDefinitions = this.library.getViewDefinitions();
        this._viewDefinitions.clearCache();

        this._cmdBar = new bfree.widget.view.CommandBar({
            id: 'cmdBar',
            viewDefinitions: this._viewDefinitions,
            onCommand: dojo.hitch(this, this._onCommand)
        }, this.commandBarNode);

        this._grdViews = new bfree.widget.view.Grid({
            id: 'grdViews',
            'class': 'versaGridOutline versaNoHeader',
            viewDefinitions: this._viewDefinitions,
            onSelectedItems: dojo.hitch(this, this._grdViews_onSelectedItems)
        }, this.gridNode);

        this._editor = new bfree.widget.view.Editor({
            id: 'edtViewDef',
            viewDefinitions: this._viewDefinitions,
            propertyDefinitions: this._propertyDefinitions,
            onValueChange: dojo.hitch(this, this._onValueChange)
        }, this.editorNode);

    },

    save: function(){

        try{

            if(!this._validateItems()){
                var msg = 'Cannot save View changes: One or more Views contain invalid data';
                alert(msg);
                return;
            }

            var item = this._grdViews.selection.getFirstSelected();
            this._viewDefinitions.save({onComplete: dojo.hitch(this, this.saveOnComplete, item)});
        }
        catch(e){
            var err = new bfree.api.Error('Failed to save View changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    saveOnComplete: function(item){
        this._viewDefinitions.clearCache();
        this._grdViews.sort();
        this._grdViews.selectItem(item);
        this.doRefresh = true;
    },

    startup: function(){
        this.inherited('startup', arguments);

        this._grdViews.startup();
        this._grdViews.setSelectedIndex(0);

        setTimeout(bfree.widget.view.Administration._loadFnRef(this), 10);
    },

    undo: function(){
        try{

            var item = this._grdViews.selection.getFirstSelected();
            var idx = (item) ? this._grdViews.getItemIndex(item) : 0;

            this._viewDefinitions.clearCache();
            this._viewDefinitions.revert();

            this._grdViews.setSelectedIndex(idx);

        }
        catch(e){
            var err = new bfree.api.Error('Failed to revert changes', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    }


});

bfree.widget.view.Administration._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

bfree.widget.view.Administration.show = function(args){
    var dlg = new bfree.widget.Dialog({
        id: 'dlgEditViewDefs',
        title: 'View Definitions',
        widgetConstructor: bfree.widget.view.Administration,
        widgetParams: {
            activeUser: args.user,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 600,
        width: 800,
        zIndex: 1024,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}


}

if(!dojo._hasResource['bfree.widget.zone.AdminMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.zone.AdminMenu'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 19/09/11
 * Time: 2:39 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.zone.AdminMenu');




dojo.declare('bfree.widget.zone.AdminMenu', [dijit.Menu],{
    activeUser: null,
    zone: null,

    _onCommand: function(cmdId, option, e){
        this.onCommand(cmdId, option);
    },

   constructor: function(args){

    },

    onCommand: function(cmdId, option){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this.addChild(
            new dijit.MenuItem({
                label: 'Groups',
                iconClass: 'menuIcon bfreeIconGroup',
                onClick: dojo.hitch(this, this._onCommand,
                    bfree.widget.Bfree.Commands.ADMIN,
                    bfree.widget.Bfree.ObjectTypes.GROUP
                )
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Users',
                iconClass: 'menuIcon bfreeIconUser',
                onClick: dojo.hitch(this, this._onCommand,
                    bfree.widget.Bfree.Commands.ADMIN,
                    bfree.widget.Bfree.ObjectTypes.USER
                )
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Property Definitions',
                iconClass: 'menuIcon bfreeIconPropDef',
                onClick: dojo.hitch(this, this._onCommand,
                    bfree.widget.Bfree.Commands.ADMIN,
                    bfree.widget.Bfree.ObjectTypes.PROP_DEF
                )
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Choice Lists',
                iconClass: 'menuIcon bfreeIconChoiceList',
                onClick: dojo.hitch(this, this._onCommand,
                    bfree.widget.Bfree.Commands.ADMIN,
                    bfree.widget.Bfree.ObjectTypes.CHOICE_LIST)
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Document Types',
                iconClass: 'menuIcon bfreeIconDocType',
                onClick: dojo.hitch(this, this._onCommand,
                    bfree.widget.Bfree.Commands.ADMIN,
                    bfree.widget.Bfree.ObjectTypes.DOC_TYPE
                )
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'Views',
                iconClass: 'menuIcon bfreeIconViewDef',
                onClick: dojo.hitch(this, this._onCommand,
                    bfree.widget.Bfree.Commands.ADMIN,
                    bfree.widget.Bfree.ObjectTypes.VIEW_DEF
                )
            })
        );

        this.addChild(
            new dijit.MenuItem({
                label: 'VersaFile Quota/Metrics',
                iconClass: 'menuIcon bfreeIconQuota',
                onClick: dojo.hitch(this, this._onCommand,
                    bfree.widget.Bfree.Commands.ADMIN,
                    bfree.widget.Bfree.ObjectTypes.QUOTA
                )
            })
        );


    }

});

}

if(!dojo._hasResource['bfree.widget.zone.ExportMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.zone.ExportMenu'] = true;
/**
 * @author mattk
 */
dojo.provide('bfree.widget.zone.ExportMenu');





dojo.declare('bfree.widget.zone.ExportMenu', dijit.Menu,
{
    _onCommand: function(cmdId, option, e){
        this.onCommand(cmdId, option);
    },

    onCommand: function(cmdId, option){
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this.addChild(
			new dijit.MenuItem({
                iconClass: 'menuIcon bfreeIconPrint',
				label: 'Printable Version...',
				onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.PRINT)
			})
		);

		this.addChild(new dijit.MenuSeparator());

		this.addChild(
			new dijit.MenuItem({
                iconClass: 'menuIcon bfreeIconExportCSV',
				label: 'Comma Separated Values (*.csv)',
				onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EXPORT, bfree.api.Documents.ExportTypes.CSV)
			})
		);
		this.addChild(
			new dijit.MenuItem({
                iconClass: 'menuIcon bfreeIconExportPDF',
				label: 'Portable Document Format (*.pdf)',
				onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EXPORT, bfree.api.Documents.ExportTypes.PDF)
			})
		);
		this.addChild(
			new dijit.MenuItem({
                iconClass: 'menuIcon bfreeIconExportXML',
				label: 'Extensible Markup Language (*.xml)',
				onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.EXPORT, bfree.api.Documents.ExportTypes.XML)
			})
		);
			
		this.startup();

	}

});

}

if(!dojo._hasResource['bfree.widget.zone.CommandBar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.zone.CommandBar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 14/09/11
 * Time: 10:42 AM
 * To change this template use File | Settings | File Templates.
 */

dojo.provide('bfree.widget.zone.CommandBar');







dojo.declare('bfree.widget.zone.CommandBar', [dijit.Toolbar], {

    _btnDocACL: null,
    _btnDocCancelCKO: null,
    _btnDocCKI: null,
    _btnDocCKO: null,
    _btnDocCopy: null,
    _btnDocCreate: null,
    _btnDocDelete: null,
    _btnDocEdit: null,
    _btnDocMove: null,
    _btnDocView: null,
    _btnFldCreate: null,
    _btnFldEdit: null,
    _btnFldDelete: null,
    _btnFldACL: null,
    _btnPrintResults: null,
    _btnExportMenu: null,

    activeDocument: null,
    activeDocumentsCount: null,
    activeFolder: null,
    activeLibrary: null,
    activeUser: null,
    user: null,
    group: null,
    zone: null,
    checkout: null,
    checkin: null,

    _onCommand: function(cmdId, option, e){
        this.onCommand(cmdId, option, {document: this.activeDocument, folder: this.activeFolder});
    },

    _setActiveDocumentAttr: function(value){
        this.activeDocument = value;
        this._setState();
    },

    _setActiveDocumentsCountAttr: function(value){
        this.activeDocumentsCount=value;
        this._setState();
    },

    _setActiveFolderAttr: function(value){
        this.activeFolder = value;
        this._setState();
    },

    _setActiveLibraryAttr: function(value){
        this.activeLibrary = value;
        this._setState();
    },

    _setActiveUserAttr: function(value){
        this.activeUser = value;
        this._setState();
    },

    _setState: function(){

        var permissionSet = bfree.api.Document.getPermissionSet(this.activeDocument, this.activeLibrary, this.activeUser);

        this._btnDocCreate.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.CREATE]);
        this._btnDocView.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.VIEW]);
        this._btnDocCopy.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.COPY]);
        this._btnDocEdit.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.EDIT]);
        this._btnDocMove.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.MOVE]);
        this._btnDocCKO.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.CKO]);
        this._btnDocCKI.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.CKI]);
        this._btnDocCancelCKO.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.CANCEL_CKO]);
        this._btnDocDelete.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.DELETE]);
        this._btnDocACL.set('disabled', !permissionSet[bfree.api.Document.permissionIndices.SECURE]);

        permissionSet = bfree.api.Folder.getPermissionSet(this.activeFolder, this.activeLibrary, this.activeUser);
        this._btnFldCreate.set('disabled', !permissionSet[bfree.api.Folder.permissionIndices.CREATE]);
        this._btnFldEdit.set('disabled', !permissionSet[bfree.api.Folder.permissionIndices.EDIT]);
        this._btnFldDelete.set('disabled', !permissionSet[bfree.api.Folder.permissionIndices.DELETE]);
        this._btnFldACL.set('disabled', !permissionSet[bfree.api.Folder.permissionIndices.SECURE]);

        this._btnExportMenu.set('disabled', !(this.activeDocumentsCount > 0));
        this._btnPrintResults.set('disabled', !(this.activeDocumentsCount > 0));
    },

    constructor: function(args){

    },

    onCommand: function(cmdId, option, params){

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);


        this.addChild(
            new dijit.form.DropDownButton({
                label: 'Administration',
                showLabel: true,
                scrollOnFocus: false,
                iconClass: 'commandIcon bfreeIconAdmin',
                dropDown:   new bfree.widget.zone.AdminMenu({
                                activeUser: this.activeUser,
                                zone: this.zone,
                                onCommand: dojo.hitch(this, this._onCommand)
                            })
            })
        );

        this.addChild(new dijit.ToolbarSeparator());

        this._btnFldCreate = new bfree.widget.Button({
			label: 'New Folder...',
			showLabel: false,
            disabled: true,
			iconClass: 'commandIcon32 bfreeIconNewFolder32',
            disabledIconClass: 'commandIcon32 bfreeIconNewFolder32D',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.FOLDER
            )
		});
        this.addChild(this._btnFldCreate);

        this._btnFldEdit = new bfree.widget.Button({
			label: 'Edit Folder...',
			showLabel: false,
            disabled: true,
			iconClass: 'commandIcon32 bfreeIconEditFolder32',
            disabledIconClass: 'commandIcon32 bfreeIconEditFolder32D',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.EDIT,
                bfree.widget.Bfree.ObjectTypes.FOLDER
            )
		});
        this.addChild(this._btnFldEdit);

        this._btnFldDelete = new bfree.widget.Button({
			label: 'Delete Folder...',
			showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconDeleteFolder32',
			disabledIconClass: 'commandIcon32 bfreeIconDeleteFolder32D',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.DELETE,
                bfree.widget.Bfree.ObjectTypes.FOLDER
            )
		});
        this.addChild(this._btnFldDelete);

        this._btnFldACL = new bfree.widget.Button({
			label: 'Edit Folder Security...',
			showLabel: false,
            disabled: true,
			iconClass: 'commandIcon32 bfreeIconSecureFolder32',
            disabledIconClass: 'commandIcon32 bfreeIconSecureFolder32D',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.SECURE,
                bfree.widget.Bfree.ObjectTypes.FOLDER
            )
		});
        this.addChild( this._btnFldACL);

        this.addChild(new dijit.ToolbarSeparator());

        this.addChild(new bfree.widget.Button({
			label: 'Refresh Documents...',
			showLabel: false,
			iconClass: 'commandIcon32 bfreeIconRefreshDocument32',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.REFRESH,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
		}));

        this._btnDocCreate = new bfree.widget.Button({
			label: 'New Documents...',
			showLabel: false,
            disabled: true,
			iconClass: 'commandIcon32 bfreeIconNewDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconNewDocument32D',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT
            )
		});
        this.addChild(this._btnDocCreate);

        this._btnDocView = new bfree.widget.Button({
			label: 'View Document...',
			showLabel: false,
            disabled: true,
			iconClass: 'commandIcon32 bfreeIconViewDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconViewDocument32D',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.VIEW,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT
            )
		});
        this.addChild(this._btnDocView);

        this._btnDocCopy = new bfree.widget.Button({
            label: 'Copy Local...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconCopyDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconCopyDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.COPY,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT
            )
        });
        this.addChild(this._btnDocCopy);

        this._btnDocEdit = new bfree.widget.Button({
            label: 'Edit Document Properties...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconEditDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconEditDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.EDIT,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._btnDocEdit);

        this._btnDocMove = new bfree.widget.Button({
            label: 'Move Document to Folder...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconMoveDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconMoveDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.MOVE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._btnDocMove);

        this._btnDocCKO = new bfree.widget.Button({
            label: 'Checkout Document...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconCkoDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconCkoDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.CHECKOUT,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._btnDocCKO);

        this._btnDocCKI = new bfree.widget.Button({
            label: 'Checkin Document...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconCkiDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconCkiDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.CHECKIN,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        })
        this.addChild(this._btnDocCKI);

        this._btnDocCancelCKO = new bfree.widget.Button({
            label: 'Cancel Document Checkout...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconCancelCkoDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconCancelCkoDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.CANCEL_CKO,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        })
        this.addChild(this._btnDocCancelCKO);

        this._btnDocDelete = new bfree.widget.Button({
            label: 'Delete Document...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconDeleteDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconDeleteDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.DELETE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        })
        this.addChild(this._btnDocDelete);

        this._btnDocACL = new bfree.widget.Button({
            label: 'Edit Document Security...',
            showLabel: false,
            disabled: true,
            iconClass: 'commandIcon32 bfreeIconSecureDocument32',
            disabledIconClass: 'commandIcon32 bfreeIconSecureDocument32D',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.SECURE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._btnDocACL);


        this.addChild(
            new dijit.form.Button({
                label: 'Display Help...',
                showLabel: false,
                iconClass: 'commandIcon32 bfreeIconHelp32',
                style: 'position:absolute;right:8px;top:2px',
                onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.HELP)
            })
        );            this.addChild(new dijit.ToolbarSeparator({}));

        this._btnPrintResults = new bfree.widget.Button({
            label: 'Print Results...',
            showLabel: false,
            iconClass: 'commandIcon32 bfreeIconPrint32',
            disabledIconClass: 'commandIcon32 bfreeIconPrint32D',
            onClick: dojo.hitch(this, this._onCommand, bfree.widget.Bfree.Commands.PRINT)
        });

        this.addChild(this._btnPrintResults);

        this._btnExportMenu = new dijit.form.DropDownButton({
            label: 'Export Results...',
            showLabel: false,
            scrollOnFocus: false,
            dropDown:   new bfree.widget.zone.ExportMenu({
                            activeUser: this.activeUser,
                            zone: this.zone,
                            onCommand: dojo.hitch(this, this._onCommand)
                        }),
            iconClass: 'commandIcon32 bfreeIconSave32'
        });
        this.addChild(this._btnExportMenu);

        this.addChild(new dijit.ToolbarSeparator({}));

    }

});

bfree.widget.zone.CommandBar.Commands = {
    'NONE':         0x0000,
    'USRGRPEDIT':   0x0001,
    'PRINT':        0x0003,
    'SAVE':         0x0004,
    'REFRESH':      0x0005,
    'EDIT_USER':           0x0010,
    'ADMIN_ADD_EDIT_USER': 0x0100,
    'ADMIN_ADD_EDIT_GROUP':0x0101,
    'HELP':         0x00FF,
    'LOGOUT':       0xFFFF
};

}

if(!dojo._hasResource['bfree.widget.zone.ReLogon']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.zone.ReLogon'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/09/11
 * Time: 4:04 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.zone.ReLogon');






dojo.declare('bfree.widget.zone.ReLogon', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("bfree/widget/zone", "template/ReLogon.html", "<div style=\"padding:8px;height:100%;width:100%;\">\n\n    <div>\n        Your session has expired. Please logon to continue.\n    </div>\n\n    <div dojoAttachPoint=\"logonNode\">\n    </div>\n\n</div>\n"),
    widgetsInTemplate: false,

    activeUser: null,
    zone: null,

    _onLogon: function(){
        this.dialogResult = bfree.widget.Dialog.dialogResult.ok;
        this._closeDialog();
    },

    constructor: function(args){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        new bfree.widget.zone.Logon({
            zone: this.zone,
            user: this.activeUser,
            onLogon: dojo.hitch(this, this._onLogon)
	    }, this.logonNode);


    }

});

}

if(!dojo._hasResource['bfree.widget.zone.Toolbar']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.zone.Toolbar'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 10/01/12
 * Time: 3:22 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.zone.Toolbar');







dojo.declare('bfree.widget.zone.Toolbar', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree.widget.zone", "template/Toolbar.html", "<div style=\"width:100%;height:30px;\">\n    <div dojoAttachPoint=\"buttonsNode\" style=\"padding: 0 0 0 8px;position:relative\"></div>\n</div>\n"),

    _btnExport: null,
    _btnNew: null,
    _mniDocument: null,
    _mniFolder: null,
    _mnuNewItems: null,

    activeItems: null,
    activeFolder: null,
    activeLibrary: null,
    activeUser: null,

    _onCommand: function(cmdId, option, e){

        //Don't send folder if creating a new share
        ((cmdId == bfree.widget.Bfree.Commands.NEW) && (option ==  bfree.widget.Bfree.ObjectTypes.SHARE)) ?
            this.onCommand(cmdId, option, {document: this.activeDocument, folder: null}) :
            this.onCommand(cmdId, option, {document: this.activeDocument, folder: this.activeFolder});

    },

    _setActiveFolderAttr: function(value){
        this.activeFolder = value;
        this._setState();
    },

    _setActiveItemsAttr: function(value){
        this.activeItems = value;
        this._setState();
    },

    _setState: function(){

        var canExport = (this.activeFolder) ?
                            (this.activeFolder.document_count > 0) :
                            false;

        var canAddFolders = true;
        var canAddDocuments = true;
        var canAddShares = false;

        if(this.activeFolder){

            var activePrmSet = this.activeFolder.getPermissionSet(this.activeLibrary, this.activeUser);

            canAddFolders = (!this.activeFolder.isShareRoot()) && activePrmSet.getValue(versa.api.PermissionIndices.CREATE);
            canAddDocuments = activePrmSet.getValue(versa.api.PermissionIndices.FILE);
            canAddShares = this.activeFolder.isShareRoot() && activePrmSet.getValue(versa.api.PermissionIndices.CREATE);
        }

        this._mniDocument.set('disabled', !canAddDocuments);
        this._mniFolder.set('disabled', !canAddFolders);
        this._mniShare.set('disabled', !canAddShares);

        this._btnNew.set('disabled', !(canAddDocuments || canAddFolders || canAddShares));
        this._btnExport.set('disabled', !canExport);
    },

    clear: function(){
        this.activeFolder = null;
        this.activeItems = null;
        //this._setState();
    },

    constructor: function(args){

    },

    onCommand: function(cmdId, option, params){

    },

    postCreate: function(){
		this.inherited('postCreate', arguments);

        if(this.library.hasRights(bfree.api._Securable.permissions.ADMIN)){
            this._btnAdmin = new dijit.form.DropDownButton({
                label: 'Administration',
                showLabel: true,
                scrollOnFocus: false,
                dropDown:   new bfree.widget.zone.AdminMenu({
                                activeUser: this.activeUser,
                                zone: this.zone,
                                onCommand: dojo.hitch(this, this._onCommand)
                            })
            });
            this._btnAdmin.placeAt(this.buttonsNode);
        }

        this._mnuNewItems = new dijit.Menu();
        this._mniFolder = new dijit.MenuItem({
            label: 'Folder',
            disabled: true,
            iconClass: 'menuIcon bfreeIconFolder',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.FOLDER
            )
        });
        this._mnuNewItems.addChild(this._mniFolder);

        this._mniDocument = new dijit.MenuItem({
            label: 'Document(s)',
            disabled: true,
            iconClass: 'menuIcon bfreeIconDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT
            )
        });
        this._mnuNewItems.addChild(this._mniDocument);

        this._mniShare = new dijit.MenuItem({
            label: 'Share...',
            disabled: true,
            iconClass: 'menuIcon bfreeShareFolderClosed',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.NEW,
                bfree.widget.Bfree.ObjectTypes.SHARE
            )
        });
        this._mnuNewItems.addChild(this._mniShare);

        this._btnNew = new dijit.form.DropDownButton({
            label: 'Add New...',
            showLabel: true,
            scrollOnFocus: false,
            dropDown: this._mnuNewItems
        });
        this._btnNew.placeAt(this.buttonsNode);

        this._btnExport = new dijit.form.DropDownButton({
            label: 'Print/Export',
            showLabel: true,
            scrollOnFocus: false,
            dropDown:   new bfree.widget.zone.ExportMenu({
                            activeUser: this.user,
                            zone: this.zone,
                            onCommand: dojo.hitch(this, this._onCommand)
                        }),
            style: 'position:absolute;top:0;right:8px;'
        });
        this._btnExport.placeAt(this.buttonsNode);

        this.activeUser=this.user;
        this.activeLibrary=this.library;
    },

    startup: function(){
        this.inherited('startup', arguments);
    }

});

}

if(!dojo._hasResource['bfree.widget.document.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.Info'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.document.Info');










dojo.declare('bfree.widget.document.Info', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree/widget/document", "template/Info.html", "<div style=\"padding:4px 0 0 72px;position:relative;height:100%;width:100%\">\n\n    <div style=\"position:absolute;top:8px;left:8px;height:48px;width:48px;\">\n        <img dojoAttachPoint=\"typeIconNode\" src=\"\" height=\"48\" width=\"48\"/>\n        <img dojoAttachPoint=\"stateIconNode\" src=\"/images/loading/loading24.gif\" height=\"24\"width=\"24\" style=\"position:absolute;bottom:0;right:0\">\n    </div>\n\n    <div class=\"dijitBoldLabel dijitLargeLabel dijitDarkLabel\" dojoAttachPoint=\"nameNode\" style=\"margin-right:80px\"></div>\n    <div dojoAttachPoint=\"tableNode\"></div>\n\n</div>\n"),
	widgetsInTemplate: false,

    _itemMap: null,
    _labels: null,
    _colCount: 4,
    _rowCount: 3,
    _propertyCount: 12,
    _tblProperties: null,


	items: null,
    library: null,
	preferences: null,

    _generateMultiItem: function(items){
        var itemData = this._initData();
        var totalSize = 0;

        dojo.forEach(items, function(item, idx){
            totalSize += item.binary_file_size;
        }, this);

        itemData[0].label = 'Size';
        itemData[0].value =  bfree.api.Utilities.readablizeBytes({bytes: totalSize});

        return itemData;
    },

    _generateSingleItem: function(item){
        var itemData = this._initData();

        itemData[0].label = 'Type'
        itemData[0].value = item.document_type_name;

        itemData[3].label = 'Version'
        itemData[3].value = item.getFullVersion();

        itemData[6].label = 'Checked Out By';
        itemData[6].value = (item.getState(bfree.api.Document.states.CHECKED_OUT) ? item.checked_out_by : '');

        itemData[9].label = (item.isDeleted() ? 'Deletion Date' : 'Last Modified Date');
        itemData[9].value = versa.api.Formatter.formatDateTime(item.updated_at);

        var documentType = this.library.getDocumentTypes().fetchById({
            id: item.document_type_id
        });

        var col = 1;
        var row = 0;
        dojo.every(documentType.property_mappings, function(propMapItem){
            var idx = 0;

            var propDef = this.library.getPropertyDefinitions().fetchById({
                id: propMapItem.property_definition_id
            });

             if(!(propDef.is_system || propDef.isTypeText())){
                var value = item[propDef.column_name];
                value = bfree.api.PropertyMapping.formatValue(propDef, value);

                idx = (col + (row * this._rowCount));
                itemData[idx].label = propDef.name.display_limit(10);
                itemData[idx].value = value;

                row++;
                if(row > this._rowCount){
                    col++;
                    row = 0;
                }
            }

            return (idx < this._propertyCount);
        }, this);

        return itemData;
    },

    _initialize: function(){
        var imgSrc = '';
        var imgAlt = '';
        var name = '';

        if(this.items.length == 1){
            var item =  this.items[0];
            imgSrc = bfree.api.Document.getIconUrl(item.binary_content_type, 48);
            imgAlt = item.binary_content_type;
            name = item.name;
        }
         else if(this.items.length > 1){
            imgSrc = '/images/mimetypes/48/multi-document.png';
            imgAlt = 'Multiple documents selected';
            name = dojo.replace('{0} documents selected', [this.items.length]);
        }
        else{

        }

        dojo.attr(this.typeIconNode, 'src', imgSrc);
        dojo.attr(this.typeIconNode, 'alt', imgAlt);
        this.nameNode.innerHTML = name;

        this._labels[0].reset('Loading...', '');

        this._tblProperties.refresh();
    },

    _initData: function(){
        var itemData = new Array();

        for(var i = 0; i < this._propertyCount; i++){
            itemData.push({
                label: '',
                value: ''
            });
        }

        return itemData;
    },


    constructor: function(args){
        this._itemMap = new Object();
        this._labels = new Array();
    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

    errorItem: function(item, isDeleted){
        var imgSrc = '/images/icons/24/error.png';
        var imgAlt = 'An error occurred';

        dojo.attr(this.stateIconNode, 'src', imgSrc);
        this._labels[0].reset('Failed to load', '');

        this._tblProperties.refresh();
    },

    loadItem: function(item){

        var imgSrc = '';
        var imgAlt = '';
        var name = '';
        var itemData = null;

        if(!item.isInstanceOf(bfree.api.Document))
            return;

        if(this.items.length == 1){
            if(this._itemMap.hasOwnProperty(item.getId())){
                imgSrc = bfree.api.Document.getIconUrl(item.binary_content_type, 48);
                imgAlt = item.binary_content_type;
                name = item.name;
                itemData = this._generateSingleItem(item);
            }
        }
        else if(this.items.length > 1){
            imgSrc = '/images/mimetypes/48/multi-document.png';
            imgAlt = 'Multiple documents selected';
            name = dojo.replace('{0} documents selected', [this.items.length]);
            itemData = this._generateMultiItem(this.items);
        }
        else{

        }

        if(itemData){
            dojo.attr(this.typeIconNode, 'src', imgSrc);
            dojo.attr(this.typeIconNode, 'alt', imgAlt);
            this.nameNode.innerHTML = name;

            dojo.forEach(this._labels, function(label, idx){
                label.reset(itemData[idx].label, itemData[idx].value);
            }, this);

            this._tblProperties.refresh();
        }

        delete this._itemMap[item.getId()];
        if(Object.keys(this._itemMap).length < 1)
            this.setBusy(false);

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this._documents = this.library.getDocuments();

        dojo.forEach(this.items, function(item, idx){
            var id = item.isInstanceOf(bfree.api.Document) ?
                        item.getId() :
                        item.document_id;
            this._itemMap[id] = item;
        }, this);

        this._tblProperties = new bfree.widget.PropertyTable({
            customClass: 'versafoot',
            showLabels: true,
            cols: 3,
            labelWidth: 112,
            style: ''
        }, this.tableNode);

        //initialize property value table
        for(var i = 0; i < this._propertyCount; i++){
            this._labels.push(new bfree.widget.Label({label: '', value: ''}));
            this._tblProperties.addChild(this._labels[i]);
        }

	},

    setBusy: function(isBusy){
        (isBusy) ?
            dojo.style(this.stateIconNode, {display: 'block'}) :
            dojo.style(this.stateIconNode, {display: 'none'});
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
        this._initialize();
    }
		
});

}

if(!dojo._hasResource['bfree.widget.document.multiple.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.multiple.Info'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.document.multiple.Info');








dojo.declare('bfree.widget.document.multiple.Info', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree/widget/document/multiple", "template/Info.html", "<div style=\"padding:4px 0 0 72px;position:relative;height:100%;width:100%\">\n\n    <div style=\"position:absolute;top:8px;left:8px\">\n        <img dojoAttachPoint=\"typeIconNode\" src=\"/images/mimetypes/48/default.png\" height=\"48\" width=\"48\"/>\n    </div>\n\n    <div class=\"dijitBoldLabel dijitLargeLabel dijitDarkLabel\" dojoAttachPoint=\"nameNode\" style=\"margin-right:80px\"></div>\n    <div dojoAttachPoint=\"tableNode\"></div>\n\n</div>\n"),
	widgetsInTemplate: false,

    _tblProperties: null,

	items: null,

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        if(this._form){
            this._form.destroy();
            this._form = null;
        }

        this.inherited('destroy', arguments);
    },

	postCreate: function(){
		this.inherited('postCreate', arguments);

        this.nameNode.innerHTML = dojo.replace('{length} files selected', this.items);

        this._tblProperties = new bfree.widget.PropertyTable({
            customClass: 'versafoot',
            showLabels: true,
            cols: 3,
            labelWidth: 112,
            style: ''
        }, this.tableNode);

        var size=0
        for(var i in this.items){
            if(this.items[i]){
                size += this.items[i].binary_file_size;
            }
        }

        this._lblSize = new bfree.widget.Label({
            label: 'Size',
            value: bfree.api.Utilities.readablizeBytes({bytes: size})
        });
        this._tblProperties.addChild(this._lblSize);
	},

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
    }
		
});

}

if(!dojo._hasResource['bfree.widget.folder.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.folder.Info'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.folder.Info');






dojo.declare('bfree.widget.folder.Info', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree/widget/folder", "template/Info.html", "<div style=\"padding:4px 0 0 72px;position:relative;height:100%;width:100%\">\n\n    <div style=\"position:absolute;top:8px;left:8px;height:48px;width:48px;\">\n        <img dojoAttachPoint=\"typeIconNode\" src=\"\" height=\"48\" width=\"48\"/>\n        <img dojoAttachPoint=\"stateIconNode\" src=\"/images/loading/loading24.gif\" height=\"24\"width=\"24\" style=\"position:absolute;bottom:0;right:0\">\n    </div>\n\n    <div class=\"dijitBoldLabel dijitLargeLabel dijitDarkLabel\" dojoAttachPoint=\"nameNode\" style=\"margin-right:80px\"></div>\n    <div dojoAttachPoint=\"tableNode\"></div>\n\n</div>\n"),
	widgetsInTemplate: false,

    _itemMap: null,
    _labels: null,
    _propertyCount: 12,
    _tblProperties: null,

	items: null,
    library: null,

    _generateSingleItem: function(item){
        var itemData = this._initData();

        itemData[0].label = 'Type';
        itemData[0].value = bfree.api.Folder.getTypeLabel(item);

        itemData[1].label = 'Document Count';
        itemData[1].value = item.document_count;

        itemData[2].label = 'Path';
        itemData[2].value = item.text_path;

        itemData[3].label = 'Last Modified Date';
        itemData[3].value = versa.api.Formatter.formatDateTime(item.updated_at);

        return itemData;
    },

    _initData: function(){
        var itemData = new Array();

        for(var i = 0; i < this._propertyCount; i++){
            itemData.push({
                label: '',
                value: ''
            });
        }

        return itemData;
    },

    _initialize: function(){
        var imgSrc = '';
        var imgAlt = '';
        var name = '';

        if(this.items.length == 1){
            var item =  this.items[0];

            imgSrc = bfree.api.Folder.getIconUrl(item, 48);
            imgAlt = item.text_path;
            name = item.name;
            //itemData = this._generateSingleItem(item);
        }

        dojo.attr(this.typeIconNode, 'src', imgSrc);
        dojo.attr(this.typeIconNode, 'alt', imgAlt);
        this.nameNode.innerHTML = name;

        this._labels[0].reset('Loading...', '');

        this._tblProperties.refresh();
    },

    constructor: function(args){
        this._itemMap = new Object();
        this._labels = new Array();
    },

    destroy: function(){

        this.destroyDescendants();

        if(this._tblProperties){
            this._tblProperties.destroyRecursive();
            this._tblProperties = null;
        }

        this.inherited('destroy', arguments);
    },

    loadItem: function(item){

        var imgSrc = '';
        var imgAlt = '';
        var name = '';
        var itemData = null;

        if(!item.isInstanceOf(bfree.api.Folder))
            return;

        if(this._itemMap.hasOwnProperty(item.getId())){

            this.nameNode.innerHTML = item.name;

            itemData = this._generateSingleItem(item);
            dojo.forEach(this._labels, function(label, idx){
                label.reset(itemData[idx].label, itemData[idx].value);
            }, this);

            this._tblProperties.refresh();

            delete this._itemMap[item.getId()];
        }


        if(Object.keys(this._itemMap).length < 1)
            dojo.style(this.stateIconNode, {display: 'none'});

    },

	postCreate: function(){
		this.inherited('postCreate', arguments);	

        dojo.forEach(this.items, function(item, idx){
            var id = item.getId();
            this._itemMap[id] = item;
        }, this);

        this._tblProperties = new bfree.widget.PropertyTable({
            customClass: 'versafootfull',
            showLabels: true,
            cols: 1,
            labelWidth: 112,
            style: ''
        }, this.tableNode);

        //initialize property value table
        for(var i = 0; i < this._propertyCount; i++){
            this._labels.push(new bfree.widget.Label({label: '', value: ''}));
            this._tblProperties.addChild(this._labels[i]);
        }

        /*
        var type = 'Folder';
        var imgSrc = 'folder.png';



        */

	},

    startup: function(){
        this.inherited('startup', arguments);
        this._tblProperties.startup();
        this._initialize();
    }
		
});

}

if(!dojo._hasResource['bfree.widget.search.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.search.Info'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.search.Info');




dojo.declare('bfree.widget.search.Info', [dijit._Widget, dijit._Templated],{
	templateString: dojo.cache("bfree/widget/search", "template/Info.html", "<div style=\"height:100%;width:100%\">\t\n\t\n\t<table style=\"height:100%;width:100%;\">\n\t\t<tr>\n\t\t\t<td style=\"vertical-align:middle;width:48px\">\n\t\t\t\t<img dojoAttachPoint=\"typeIconNode\" src=\"/images/mimetypes/48/search.png\" height=\"48\" width=\"48\"></img>\n\t\t\t</td>\n\t\t\t<td style=\"padding:0 0 0 16px;width:100%\">\n\t\t\t\t<table style=\"height:100%;width:100%\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td style=\"vertical-align:bottom;width:33%\">\n\t\t\t\t\t\t\t<table style=\"height:100%;width:100%\">\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td dojoAttachPoint=\"titleNode\" colspan=\"2\" class=\"largeLabel darkBoldLabel\" style=\"height:20%;white-space:nowrap;\"></td>\t\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"mediumLabel darkLabel\" style=\"height:20%;padding:0 4px 0 0;white-space:nowrap;width:1px;\">Type:</td>\n\t\t\t\t\t\t\t\t\t<td dojoAttachPoint=\"typeNode\" class=\"mediumLabel darkBoldLabel\"></td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"mediumLabel darkLabel\" style=\"height:20%;padding:0 4px 0 0;white-space:nowrap;\">Document Count:</td>\n\t\t\t\t\t\t\t\t\t<td dojoAttachPoint=\"countNode\" class=\"mediumLabel darkBoldLabel\"></td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"mediumLabel darkLabel\" style=\"height:20%;padding:0 4px 0 0;white-space:nowrap;\">Created By:</td>\n\t\t\t\t\t\t\t\t\t<td dojoAttachPoint=\"createdByNode\" class=\"mediumLabel darkBoldLabel\"></td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t<td class=\"mediumLabel darkLabel\" style=\"height:20%;padding:0 4px 0 0;white-space:nowrap;\">Date Created:</td>\n\t\t\t\t\t\t\t\t\t<td dojoAttachPoint=\"createdAtNode\" class=\"mediumLabel darkBoldLabel\"></td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</td>\n\t\t</tr>\n\t</table>\n\t\n\n</div>\n"),
	widgetsInTemplate: false,

	item: null,

	postCreate: function(){
		this.inherited('postCreate', arguments);	

		var info = this.item.criteria.split(':');
		
		if(info[0] == 'simple'){
			this.titleNode.innerHTML = 'Keywords: ' + info[1];
			this.typeNode.innerHTML = 'Simple';	
		}
		else{
			var searchItem = dojo.fromJson(this.item.criteria.replace('advanced:',''));
			this.titleNode.innerHTML = searchItem.description;
			this.typeNode.innerHTML = 'Advanced';
		}
		
		this.countNode.innerHTML = this.item.documentCount;
		this.createdByNode.innerHTML = this.item.created_by;
		this.createdAtNode.innerHTML = this.item.created_at.toLocaleString();

	}
		
});

}

if(!dojo._hasResource['bfree.widget.ItemInfo']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.ItemInfo'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.ItemInfo');










dojo.declare('bfree.widget.ItemInfo', [dijit._Widget, dijit._Templated],{
	templateString: null,
	templateString: dojo.cache("bfree/widget", "template/ItemInfo.html", "<div dojoAttachPoint=\"mainNode\" style=\"height:100%;position:relative;width:100%\">\n\n<!-- div dojoAttachPoint=\"loadingNode\" style=\"position:absolute;top:0;left:0\">\n    <div style=\"position:absolute;top:8px;left:8px\">\n        <img dojoAttachPoint=\"typeIconNode\" src=\"/images/loading/loading48.gif\" height=\"48\" width=\"48\"/>\n    </div>\n    <div class=\"dijitBoldLabel dijitLargeLabel dijitDarkLabel\" dojoAttachPoint=\"nameNode\" style=\"white-space:nowrap;position:absolute;top:4px;left:74px\">Loading information...</div>\n</div -->\n\n</div>\t\n"),
	widgetsInTemplate: true,

	library: null,
	preferences: null,
    root: null,
	
	_item: null,
	_wdgInfo: null,

	postCreate: function(){
		this.inherited('postCreate', arguments);
			
	},

    _deleteWidget: function(){
        if(this._wdgInfo){
            this._wdgInfo.destroy(false);
            this._wdgInfo = null;
        }
    },

    clear: function(args){
        this._deleteWidget();
        //dojo.style(this.loadingNode, {display: 'block'});
    },

	addItem: function(args){
		var type = args.type;
		var item = args.item;
        var folders=args.folders;

        if(args.item == null){
            return;
        }

        if(item.isInstanceOf(bfree.api.Document)){

            if((this._wdgInfo) && (!this._wdgInfo.isInstanceOf( bfree.widget.document.Info))){
                this._deleteWidget();
            }
            if(!this._wdgInfo){
                this._wdgInfo = new bfree.widget.document.Info({
                    library: this.library
                });
            }
            this._wdgInfo.addItem(item);

        }
        else if(item.isInstanceOf(bfree.api.Folder)){

            if((this._wdgInfo) && (!this._wdgInfo.isInstanceOf(bfree.widget.folder.Info))){
                this._deleteWidget();
            }

            this._wdgInfo = new bfree.widget.folder.Info({
                root: this.root,
                folders: folders
            });
        }

        if(this._wdgInfo){
		    this._wdgInfo.placeAt(this.mainNode, 'last');
            this._wdgInfo.startup();
        }

	},

    errorItem: function(args){
        if(!this._wdgInfo)
            return;
        this._wdgInfo.errorItem(args.item, args.isDeleted);
    },

    loadItem: function(args){
        if(!this._wdgInfo)
            return;
        this._wdgInfo.loadItem(args.item);
    },

    preload: function(type, items){

        if(this._wdgInfo){
            this._deleteWidget();
        }

        switch(type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._wdgInfo = new bfree.widget.document.Info({
					items: items,
                    library: this.library
				});
                break;
            case bfree.widget.Bfree.ObjectTypes.FOLDER:
                this._wdgInfo = new bfree.widget.folder.Info({
                    items: items,
                    library: this.library
                });
        }

        if(this._wdgInfo){
		    this._wdgInfo.placeAt(this.mainNode, 'last');
            this._wdgInfo.startup();
		}

    },

    refresh: function(){
        if(this._wdgInfo){
            this._wdgInfo.refresh();
        }
    },

    setBusy: function(isBusy){
        if(this._wdgInfo){
            this._wdgInfo.setBusy(isBusy);
        }
    }

});

bfree.widget.ItemInfo.Type = { 'none': 0, 'document': 1, 'folder': 2, 'search': 3 };

}

if(!dojo._hasResource['bfree.widget.document.ViewMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.document.ViewMenu'] = true;
/**
 * @author Scott
 */
dojo.provide('bfree.widget.document.ViewMenu');


dojo.declare('bfree.widget.document.ViewMenu', bfree.widget.HeaderMenu,
{
    menuLabel: 'Views',
    user: null,
    library: null,
    activeView: null,
    activeFolder: null,
	rowHit: false,
    viewDefinitions: null,
    viewMappings: null,
    propertyDefinitions: null,
    parentMenu: null,
    cancelRefresh: false,

    _mnuTemplate: null,
    _mnuTemplatePopup: null,

	_buildViewMenus: function(){

        //Retreive all the current view definitions and sort
		var viewDefs = this.viewDefinitions.fetch();
        viewDefs = viewDefs.sort(bfree.api.ViewDefinition.compare);

        //for each view, create a menu item.
		dojo.forEach(viewDefs, function(viewDef){

            if(!viewDef.name)
                return;

            if(viewDef.is_template){
                var icon = 'menuIcon menuViewIcon';

                var mniView = new dijit.MenuItem({
                    iconClass: icon,
                    label: viewDef.name,
                    onClick: dojo.hitch(this, this._onChange, mniView, viewDef)
                });

                mniView.set('viewDefinition', viewDef);
                this._mnuTemplate.addChild(mniView);
            }

		}, this);

	},

    _buildColumnMenus: function(){

        var propDefs = this.propertyDefinitions.fetch();

        var getDbName=function(){
            return this.table_name+"."+this.column_name;
        };

        propDefs.push({
            id: 'document_types.name',
            name: 'Document Type',
            table_name: 'document_types',
            column_name: 'name',
            data_type_id: bfree.api.DataTypes.types.STRING,
            getDbName: getDbName
        });

        propDefs.push({
            id: 'versions.version_number',
            name: 'Version',
            table_name: 'versions',
            column_name: 'version_number',
            data_type_id: bfree.api.DataTypes.types.STRING,
            getDbName: getDbName
        });

        propDefs.push({
            id: 'versions.binary_file_size',
            name: 'Size',
            table_name: 'versions',
            column_name: 'binary_file_size',
            data_type_id: bfree.api.DataTypes.types.INTEGER,
            format_id: bfree.api.CellDefinition.formats.size,
            getDbName: getDbName
        });

        propDefs.sort(bfree.api.PropertyDefinition.compare);

        dojo.forEach(propDefs, function(propDef){
            if(!propDef.name){
                return;
            }

            var icon = 'menuIcon menuViewIcon';

            var mniProp = new dijit.MenuItem({
                propertyDefinition: propDef,
                iconClass: icon,
                label: propDef.name,
                onClick: dojo.hitch(this, this._onColumnToggle, propDef)
            });

            this.addChild(mniProp);
        }, this);

    },

    _onColumnToggle: function(property_definition){
        //Toggle on if cell doesn't exist in current view;
        //Toggle off if cell exists in current_view;
        var view_definition = this.library.getViewDefinitions().fetchById({id: this.activeView.id});
        var cell_definition = view_definition.getCellByField(property_definition.getDbName());
        this.onColumnToggle(property_definition, !cell_definition);
    },

    _onCommand: function(cmdId, options, params){
        this.onCommand(cmdId, options, params);
    },

    clear: function(){

        dojo.forEach(this.getChildren(), function(item, idx){
            console.log(item);
        }, this);

    },

    onColumnToggle: function(property_definition, condition){
    },

    onCommand: function(cmdId, options, params){
    },

    _onChange: function(mni, view_definition, evt){

        var view = view_definition.getView(this.library);
        this.set('activeView', view);
        this.onChange(this.activeView);

	},

    _setActiveFolderAttr: function(value){
        this.activeFolder = value;
    },

    _setActiveViewAttr: function(view){

        this.activeView = view;
        if(this.activeView)
            this.updateMenu();

    },

    constructor: function(args){
        this.parentMenu=args.parentMenu;
    },

    getSelectedId: function(){
		var mnuItems = this._mnuTemplate.getChildren();
		var id;
		for(var i = 0; i<mnuItems.length; i++){
			if(mnuItems[i].set('iconClass') == 'menuIcon bfreeIconOk')
				id = mnuItems[i].viewDefId;
		}
		return id || -1;
	},

    onChange: function(view, evt){
	},

	//postCreate:
	postCreate: function(){
		this.inherited('postCreate', arguments);

        this.propertyDefinitions = this.library.getPropertyDefinitions();
        this.viewDefinitions = this.library.getViewDefinitions();

        this._mnuTemplate = new dijit.Menu({});

        this._mnuTemplatePopup = new dijit.PopupMenuItem({
            label: 'Predefined Views',
            popup: this._mnuTemplate,
            iconClass: 'menuIcon'
        });

        this.addChild(this._mnuTemplatePopup);

        this._buildViewMenus();

        this._seperator1=new dijit.MenuSeparator();
        this.addChild(this._seperator1);

        this._buildColumnMenus();
	},

	refresh: function(){

        this.clear();

		var mnuItems = this._mnuTemplate.getChildren();
		while(mnuItems.length > 0){
			var mnuItem = mnuItems.pop();
            console.log(mnuItem);
			this._mnuTemplate.removeChild(mnuItem);
		}

		this._buildViewMenus();
        this._buildColumnMenus();

        this.set('activeView', this.activeView);

	},

    startup: function(){
        this.inherited('startup', arguments);
    },

    updateMenu: function(){
        var isTemplate = false;

        //Mark selected if Template View selected
        dojo.forEach(this._mnuTemplate.getChildren(), function(item, idx){
            if(item.viewDefinition.id == this.activeView.id){
                item.set('iconClass', 'menuIcon bfreeIconOk');
                isTemplate = true;
            }
            else{
                 item.set('iconClass', 'menuIcon bfreeIconBlank');
            }
        }, this);

        (isTemplate) ?
            this._mnuTemplatePopup.set('iconClass', 'menuIcon bfreeIconOk') :
            this._mnuTemplatePopup.set('iconClass', 'menuIcon bfreeIconBlank');

        var view_definition = this.library.getViewDefinitions().fetchById({id: this.activeView.id});
        dojo.forEach(this.getChildren(), function(item, idx){
            var property_definition = item.propertyDefinition;
            if(property_definition){
                var cell = view_definition.getCellByField(property_definition.getDbName());
                (cell) ?
                  item.set('iconClass', 'menuIcon bfreeIconOk') :
                  item.set('iconClass', 'menuIcon bfreeIconBlank');
            }
        }, this);

    }
});

}

if(!dojo._hasResource['versa.widget.reference.dnd.Source']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.reference.dnd.Source'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 10/04/12
 * Time: 9:49 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.reference.dnd.Source');


dojo.declare('versa.widget.reference.dnd.Source', dojo.dnd.Source, {
    selfAccept: false,

    _dndCreator: function(item, hint){
        var node = null;

        if(hint == 'avatar'){

            var imgSrc = bfree.api.Document.getIconUrl(item.binary_content_type, 16);

            node = dojo.create('div',{
                'class': 'dijitDarkLabel',
                innerHTML: item.name,
                style: {
                    paddingLeft: '20px',
                    height: '16px',
                    paddingTop: '2px',
                    position: 'relative'
                }
            });
            dojo.create('img', {
                src: imgSrc,
                style: {
                    left: '0',
                    position: 'absolute',
                    top: '0'
                }
            }, node);
        }
        else{
            //create a 'dummy' node...will never be used for selection
            node = dojo.create('div', {innerHTML: item.name, style:{display:'none'}});
        }

        return {node: node, data: item, type: 'document'};
    },

    checkAcceptance: function(source, nodes){

        if(this == source)
            return this.selfAccept;

        this.inherited('checkAcceptance', arguments);
    },

    constructor: function(node, params){
        this.creator = dojo.hitch(this, this._dndCreator);
    },

    onDndStart: function(source, nodes, copy){

        if(source !== this){
            this.inherited('onDndStart', arguments);
            return;
        }

        //Don't allow deleted items to be dragged (for now)
        //- Don't allow 'share' references to be DnD'd
        var canDnd = dojo.every(nodes, function(node, idx){
            var item = source.getItem(node.id).data;
            return !(item.isDeleted() || item.isShare());
        });


        if(!canDnd){
            dojo.dnd.manager().stopDrag();
        }
        else{
            this.inherited('onDndStart', arguments);
        }
    }



});

versa.widget.reference.dnd.Source.creator = function(node, hint){
    console.log('create');
    var n = dojo.create('div', {innerHTML: node})
    return {node: n, data: node};
};

}

if(!dojo._hasResource['versa.widget.reference.ContextMenu']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.reference.ContextMenu'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 05/04/12
 * Time: 9:15 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.reference.ContextMenu');





dojo.declare('versa.widget.reference.ContextMenu', bfree.widget.HeaderMenu,{
    menuLabel: 'Document',

    _arrDivides: [],
    _buttons: {},

    activeItems: null,
    activeFolder: null,
    activeLibrary: null,
    activeUser: null,
    grid: null,

    _onCommand: function(cmdId, option, e){
        this.onCommand(cmdId, option, {items: this.activeItems});
    },

    _openMyself: function(evt){

        //Do not open unless a row was clicked
        if(this.grid.views.views[0].scrollboxNode === evt.target)
            return;

        this._setState();
        this.inherited('_openMyself', arguments);
    },

    _setActiveItemsAttr: function(items){
        this.activeItems = (!items) ? [] : items;
    },

    _setState: function(){

        var hiddenItems = new Object();
        var isSingleItem = (this.activeItems.length == 1);

        var isDeleted = dojo.some(this.activeItems, function(item, idx){
            return (item.isDeleted() || this.activeFolder.isTrash());
        }, this);

        var isShareRef = dojo.some(this.activeItems, function(item, idx){
            return item.isShare();
        }, this);


        var hideDivs = (isDeleted || isShareRef);

        hiddenItems.VIEW = false;
        hiddenItems.COPY = isShareRef;
        hiddenItems.EDIT = (isDeleted || isShareRef);
        hiddenItems.VERSIONS = (isDeleted || isShareRef);
        hiddenItems.MOVE = (isDeleted || isShareRef);
        hiddenItems.CKO = (isDeleted || isShareRef);
        hiddenItems.CKI = (isDeleted || isShareRef);
        hiddenItems.CANCEL_CKO = (isDeleted || isShareRef);
        hiddenItems.DELETE = (isDeleted || isShareRef);
        hiddenItems.SECURE = (isDeleted);
        hiddenItems.RESTORE = (!isDeleted);
        hiddenItems.DESTROY = (!isDeleted);
        hiddenItems.UNSHARE = (!isShareRef);

        dojo.forEach(this._arrDivides, function(divider, idx){
            dojo.toggleClass(divider.domNode, 'versaHide', hideDivs);
        }, this);

        dojo.toggleClass(this._buttons.VIEW.domNode, 'versaHide', hiddenItems.VIEW);
        dojo.toggleClass(this._buttons.COPY.domNode, 'versaHide', hiddenItems.COPY);
        dojo.toggleClass(this._buttons.EDIT.domNode, 'versaHide', hiddenItems.EDIT);
        dojo.toggleClass(this._buttons.VERSIONS.domNode, 'versaHide', hiddenItems.VERSIONS);
        dojo.toggleClass(this._buttons.MOVE.domNode, 'versaHide', hiddenItems.MOVE);
        dojo.toggleClass(this._buttons.CKO.domNode, 'versaHide', hiddenItems.CKO);
        dojo.toggleClass(this._buttons.CKI.domNode, 'versaHide', hiddenItems.CKI);
        dojo.toggleClass(this._buttons.XCKO.domNode, 'versaHide', hiddenItems.CANCEL_CKO);
        dojo.toggleClass(this._buttons.DELETE.domNode, 'versaHide', hiddenItems.DELETE);
        dojo.toggleClass(this._buttons.ACL.domNode, 'versaHide', hiddenItems.SECURE);
        dojo.toggleClass(this._buttons.RESTORE.domNode, 'versaHide', hiddenItems.RESTORE);
        dojo.toggleClass(this._buttons.DESTROY.domNode, 'versaHide', hiddenItems.DESTROY);
        dojo.toggleClass(this._buttons.UNSHARE.domNode, 'versaHide', hiddenItems.UNSHARE);

        //calculate total permissions...will take the "least" amount of permissions
        var doAnd = (this.activeItems.length > 0) ? true : false;
        var activePrmSet = new versa.api.PermissionSet(doAnd);

        dojo.forEach(this.activeItems, function(item, idx){
            //perform AND to get "least" permissions
            var prmSet = item.getPermissionSet(this.activeFolder, this.activeLibrary, this.activeUser);
            activePrmSet = activePrmSet.andSet(prmSet);
        }, this);

        this._buttons.VIEW.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.VIEW) && isSingleItem));
        this._buttons.COPY.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.COPY) && isSingleItem));
        this._buttons.EDIT.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.EDIT) && isSingleItem));
        this._buttons.VERSIONS.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.EDIT) && isSingleItem));

        this._buttons.CKO.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.CKO) && isSingleItem));
        this._buttons.CKI.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.CKI) && isSingleItem));
        this._buttons.XCKO.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.CANCEL_CKO) && isSingleItem));

        this._buttons.MOVE.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.MOVE)));
        this._buttons.DELETE.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.DELETE)));
        this._buttons.ACL.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.SECURE) && isSingleItem));

        this._buttons.RESTORE.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.RESTORE)));
        this._buttons.DESTROY.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.DESTROY)));

        this._buttons.UNSHARE.set('disabled', !(activePrmSet.getValue(versa.api.PermissionIndices.DESTROY)));
    },

    constructor: function(args){

    },

    onCommand: function(cmdId, option, params){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._buttons.VIEW = new dijit.MenuItem({
            label: 'View',
            disabled: true,
            iconClass: 'menuIcon bfreeIconViewDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.VIEW,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.VIEW);

        this._buttons.COPY = new dijit.MenuItem({
            label: 'Copy Local...',
            disabled: true,
            iconClass: 'menuIcon bfreeIconCopyDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.COPY,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
		this.addChild(this._buttons.COPY);

        this._buttons.EDIT = new dijit.MenuItem({
			label: 'Edit Properties',
            disabled: true,
			iconClass: 'menuIcon bfreeIconEditDocument',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.EDIT,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
		})
		this.addChild(this._buttons.EDIT);

        this._buttons.VERSIONS = new dijit.MenuItem({
			label: 'Versions',
            disabled: true,
			iconClass: 'menuIcon bfreeIconNewDocument',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.EDIT,
                bfree.widget.Bfree.ObjectTypes.VERSION)
		})
		this.addChild(this._buttons.VERSIONS);

        this._arrDivides[0] = new dijit.MenuSeparator();
		this.addChild(this._arrDivides[0]);

        this._buttons.MOVE = new dijit.MenuItem({
			label: 'Move To Folder...',
            disabled: true,
			iconClass: 'menuIcon bfreeIconMoveDocument',
			onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.MOVE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
		});
		this.addChild(this._buttons.MOVE);

        this._arrDivides[1] = new dijit.MenuSeparator();
		this.addChild(this._arrDivides[1]);

        this._buttons.CKO = new dijit.MenuItem({
            label: 'Checkout',
            disabled: true,
            iconClass: 'menuIcon bfreeIconCkoDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.CHECKOUT,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.CKO);

		this._buttons.CKI = new dijit.MenuItem({
            label: 'Checkin',
            disabled: true,
            iconClass: 'menuIcon bfreeIconCkiDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.CHECKIN,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.CKI);

		this._buttons.XCKO = new dijit.MenuItem({
            label: 'Cancel Checkout',
            disabled: true,
            iconClass: 'menuIcon bfreeIconCancelCkoDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.CANCEL_CKO,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.XCKO);

		this._arrDivides[2] = new dijit.MenuSeparator();
		this.addChild(this._arrDivides[2]);

        this._buttons.DELETE = new dijit.MenuItem({
            label: 'Delete',
            disabled: true,
            iconClass: 'menuIcon bfreeIconDeleteDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.DELETE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
		this.addChild(this._buttons.DELETE);

        this._arrDivides[3] = new dijit.MenuSeparator();
		this.addChild(this._arrDivides[3]);

          this._buttons.ACL = new dijit.MenuItem({
            label: 'Permissions...',
            disabled: true,
            iconClass: 'menuIcon bfreeIconSecureDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.SECURE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.ACL);

        this._buttons.RESTORE = new dijit.MenuItem({
            label: 'Restore',
            disabled: true,
            iconClass: 'menuIcon bfreeIconCkoDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.RESTORE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.RESTORE);

        this._buttons.DESTROY = new dijit.MenuItem({
            label: 'Delete Permanently',
            disabled: true,
            iconClass: 'menuIcon bfreeIconDeleteDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.DESTROY,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.DESTROY);

        this._buttons.UNSHARE = new dijit.MenuItem({
            label: 'Remove Share',
            disabled: true,
            iconClass: 'menuIcon bfreeIconDeleteDocument',
            onClick: dojo.hitch(this, this._onCommand,
                bfree.widget.Bfree.Commands.UNSHARE,
                bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        });
        this.addChild(this._buttons.UNSHARE);


    }

});

}

if(!dojo._hasResource['versa.widget.reference.Grid']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.reference.Grid'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 04/04/12
 * Time: 11:39 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.reference.Grid');








dojo.declare('versa.widget.reference.Grid', bfree.widget._Grid, {

    _dndSource: null,
    _lastSelected: null,
    _mnuReference: null,
    _mnuViews: null,

    activeFolder: null,
    activeLibrary: null,
    activeUser: null,
    activeZone: null,

    __doSearch: function(query){
        this.setQuery(query, {cache: false});
        this.resize();
        this.setSelectedIndex(0, true);
        this._lastSelected = this.getItem(0);
        this.onQueryComplete();
    },

    __reWriteView: function(args){

        //Retrieve active view definition
        var view_definition = this.activeLibrary.getViewDefinitions().fetchById({id: this.activeView.id});

        //If active view is based on template make a copy of the template to modify
        if(view_definition.is_template){
            view_definition = this.activeLibrary.getViewDefinitions().cloneItem(view_definition);
            var customName = bfree.api.ViewDefinition.getCustomName(this.activeUser, this.activeFolder);
            this.activeLibrary.getViewDefinitions().setValue(view_definition, 'name', customName);
        }

        //Copy new order of columns
        cell_definitions = [];
        for(var idx = 0; idx < this.layout.cellCount; idx++){
            var cell = this.getCell(idx);

            //skip property if being removed.
            if((args.removeProperty) && (args.removeProperty.getDbName() == cell.field)){
                continue;
            }

            var cell_definition = view_definition.getCellByField(cell.field);
            var clone = bfree.api.CellDefinition.clone(cell_definition);

            if((args.resizeIndex) && (args.resizeIndex == cell.index)){
                clone.width = cell.unitWidth;
            }
            clone.column_order = cell_definitions.length;
            cell_definitions.push(clone);
        }

        //Add new cell
        if(args.addProperty){
            cell_definitions.push({
                table_name: args.addProperty.table_name,
                column_name: args.addProperty.column_name,
                name: args.addProperty.name,
                label: args.addProperty.name,
                formatter: args.addProperty.format_id ? args.addProperty.format_id : bfree.api.CellDefinition.formats.none,
                noresize: false,
                width: bfree.api.CellDefinitions.getDefaultWidth(args.addProperty.data_type_id)+'px',
                style: '',
                column_order: cell_definitions.length
            });
        }

        if(args.sortInfo){
            var is_desc = (args.sortInfo < 0);
            var sort_by = this.getCell(Math.abs(args.sortInfo) - 1).field;
            this.activeLibrary.getViewDefinitions().setValue(view_definition, 'sort_by', sort_by);
            this.activeLibrary.getViewDefinitions().setValue(view_definition, 'is_desc', is_desc);
        }

        //Save updated/new view definition.
        this.activeLibrary.getViewDefinitions().setValue(view_definition, 'cell_definitions', cell_definitions);
        this.activeLibrary.getViewDefinitions().save();

        return view_definition;
    },

    _canSort: function(columnIndex){
        return !(columnIndex == 1 || this._isLoading);
	},

    _onCommand: function(cmdId, option, params){
        this.onCommand(cmdId, option, params);
    },

    _onViewChange: function(view, evt){

        //Called when a user manually changes the view.
        this.set('activeView', view);
        this.set('activeQuery',  this.activeFolder.getActiveQuery().getQuery());

	},

    _setActiveFolderAttr: function(folder){

        //Don't re-query if user clicks on active folder...unless it is the 'Search' folder.
        var doQuery = ((folder !== this.activeFolder) || folder.isSearch());

        this.activeFolder = folder;
        this._mnuReference.set('activeFolder', this.activeFolder);

        var view_definition = this.activeLibrary.getViewDefinitions().fetchById({id: this.activeFolder.view_definition_id});

        if(doQuery){
            this.selection.clear();
            this.set('activeView', view_definition.getView(this.activeLibrary));
            this.set('activeQuery', this.activeFolder.getActiveQuery().getQuery());
        }
    },

    _setActiveQueryAttr: function(query){
        this._clearData();
        this.showMessage(this.loadingMessage);
        setTimeout(versa.widget.reference.Grid._searchFnRef(this, query), 10);
    },

    _setActiveViewAttr: function(view){

        this.activeView = view;

        this._clearData();
        this.set('sortInfo', this.activeView.sort_column);
        this.set('structure', this.activeView);
        this.resize();

        if(this._dndSource) this._dndSource.destroy();
        this._dndSource = new versa.widget.reference.dnd.Source(this.views.views[0].contentNode, {
            accept:[]
        });

        this._mnuViews.set('activeView', this.activeView);

        //Update folder's view definition if it has changed.
        if((this.activeFolder) && (!this.activeLibrary.getFolders().containsValue(this.activeFolder, 'view_definition_id', this.activeView.id))){
            this.activeLibrary.getFolders().setValue(this.activeFolder, 'view_definition_id', this.activeView.id);
            this.activeLibrary.getFolders().save();
        }

    },

    constructor: function(args){

        this.updateDelay = 0;
		this.rowsPerPage = 25;

		this.queryOptions = {cache: false};
		this.selectionMode = 'extended';
		this.clientSort = false;
		this.canSort = this._canSort;
		this.noDataMessage = 'No Documents Found';
        this.columnReordering = true;

    },

    export_results: function(export_type){

        var box = bfree.api.Utilities.getBox({scale: 0.75});

        var sortProps = this.getSortProps();

        this.activeLibrary.getReferences().export_query({
            zone: this.activeZone,
            library: this.activeLibrary,
            windowBox: box,
            type: export_type,
            query: this.get('query'),
            sort: ((sortProps) && (sortProps.length > 0)) ? sortProps[0] : null
        });

    },

    onColumnToggle: function(property_definition, toggleOn){
        var addProperty = null;
        var removeProperty = null;

        var view_definition = (toggleOn) ?
            this.__reWriteView({addProperty: property_definition}) :
            this.__reWriteView({removeProperty: property_definition});

        this.set('activeView', view_definition.getView(this.activeLibrary));
        this.set('activeQuery',  this.activeFolder.getActiveQuery().getQuery());
    },

    onCommand: function(cmdId, option, params){
    },

    onMoveColumn: function(){
        var view_definition = this.__reWriteView({});
        this.set('activeView', view_definition.getView(this.activeLibrary));
        this.set('activeQuery',  this.activeFolder.getActiveQuery().getQuery());
    },

    onQueryComplete: function(){
    },

    onResizeColumn: function(cellIdx){
        var view_definition = this.__reWriteView({resizeIndex: cellIdx});
        this.set('activeView', view_definition.getView(this.activeLibrary));
        this.set('activeQuery',  this.activeFolder.getActiveQuery().getQuery());
    },

    onRowContextMenu: function(evt){
        if(evt.rowIndex < 0){
            evt.cancelBubble = true;
            return;
        }

        //Get all selected items
        var items = this.selection.getSelected();

        //If row is already selected, re-fire 'onSelectedItem' event
        // *mimics normal left-click behaviour
        if(this.selection.isSelected(evt.rowIndex)){
            this.onSelectedItems(items);
        }
        else{
            //if new row selected, make sure it is selected..
            this.setSelectedIndex(evt.rowIndex)
            items = this.selection.getSelected();
        }

        this._mnuReference.set('activeItems', items);

    },

    /*
    onRowClick: function(evt){
        dojo.stopEvent(evt);
    },

    onRowMouseDown: function(evt){
        //this.inherited('onRowMouseDown', arguments);

        if(evt.ctrlKey){
            this._lastSelected = this.getItem(evt.rowIndex);
            this.selection.addToSelection(evt.rowIndex);
        }
        else if(evt.shiftKey){
            var idx = this.getItemIndex(this._lastSelected);
            this.selection.clear();
            this.selection.selectRange(idx, evt.rowIndex);
        }
        else{
            var rowItem = this.getItem(evt.rowIndex);
            var forceSelect = (rowItem === this._lastSelected);
            this.selection.select(evt.rowIndex);            ;
            if(forceSelect) this.onSelectedItems(this.selection.getSelected());
            this._lastSelected = rowItem;
        }

    },
    */

    onRowDblClick: function(evt){

        if(evt.rowIndex < 0){
            evt.cancelBubble = true;
            return;
        }

        var item = this.getItem(evt.rowIndex);
        this._onCommand(bfree.widget.Bfree.Commands.VIEW, bfree.widget.Bfree.ObjectTypes.DOCUMENT, {items: [item]});
    },

    onSelectionChanged: function(){
        var items = this.selection.getSelected();
        this._dndSource.deleteSelectedNodes();
        this._dndSource.insertNodes(true, items);
        this.inherited('onSelectionChanged', arguments);
    },

    postCreate: function(){
		this.inherited('postCreate', arguments);

        this._mnuReference = new versa.widget.reference.ContextMenu({
            id: 'mnuReference',
            grid: this,
            activeLibrary: this.activeLibrary,
            activeUser: this.activeUser,
            targetNodeIds: [this.id],
            onCommand: dojo.hitch(this, this._onCommand)
        });

        this._mnuViews = new bfree.widget.document.ViewMenu({
            id: 'mnuViews',
            library: this.activeLibrary,
            parentMenu: this,
            onChange: dojo.hitch(this, this._onViewChange),
            onColumnToggle: dojo.hitch(this, this.onColumnToggle)
		});

    },

    print_results: function(){

        var box = bfree.api.Utilities.getBox({scale: 0.75});

        var sortProps = this.getSortProps();

        this.activeLibrary.getReferences().print_query({
            zone: this.activeZone,
            library: this.activeLibrary,
            windowBox: box,
            query: this.get('query'),
            sort: ((sortProps) && (sortProps.length > 0)) ? sortProps[0] : null
        });

    },

    refreshViews: function(reset){

        if(this._mnuViews)
            this._mnuViews.destroy();

        this._mnuViews = new bfree.widget.document.ViewMenu({
            id: 'mnuViews',
            library: this.activeLibrary,
            parentMenu: this,
            onChange: dojo.hitch(this, this._onViewChange),
            onColumnToggle: dojo.hitch(this, this.onColumnToggle)
		});

        this._mnuViews.startup();
        this.set('headerMenu', this._mnuViews);
        this._mnuViews.set('activeView', this.activeView);

        if(reset){
            var view_definition = this.activeLibrary.getViewDefinitions().fetchById({id: this.activeView.id});
            this.set('activeView', view_definition.getView(this.activeLibrary));
            this.set('activeQuery',  this.activeFolder.getActiveQuery().getQuery());
        }

    },

    setBusy: function(item, isBusy){

        var idx = this.getItemIndex(item);
        if(idx < 0)
            return;

        if(isBusy){
            var rowNode = this.getRowNode(idx);
            var e = rowNode.getElementsByTagName('img');
            dojo.forEach(e, function(node, idx){
                if(node.name == 'statusIcon'){
                    dojo.attr(node, 'src', '/images/loading/loading16.gif')
                }
            });
        }
        else{
            this.updateRow(idx);
        }
    },

    sort: function(){
        var view_definition = this.__reWriteView({sortInfo: this.sortInfo});
        this.set('activeView', view_definition.getView(this.activeLibrary));
        this.set('activeQuery',  this.activeFolder.getActiveQuery().getQuery());
    },

    startup: function(){
        this.inherited('startup', arguments);
        this._mnuViews.startup();

        this.focus._delayedCellFocus = versa.widget.reference.Grid._delayedCellFocus;
        this.set('headerMenu', this._mnuViews);

        //Select 'default' initial view -- needed for startup
        var viewDefinition = this.activeLibrary.getViewDefinitions().getSystem()[0];
        this.set('activeView', viewDefinition.getView(this.activeLibrary));
        this.set('autoRender', false);

        this.setStore(this.activeLibrary.getReferences().store, { type: bfree.api.Search.types.NONE });

        this._dndSource = new versa.widget.reference.dnd.Source(this.views.views[0].contentNode, {
            accept:[]
        });

    }


});

versa.widget.reference.Grid._searchFnRef = function(that, query){
    return ( function() {
       that.__doSearch(query);
    });
}

versa.widget.reference.Grid._delayedCellFocus = function(){
    if(this.isNavHeader()||!this.grid._focused){
            return;
    }
    var n = this.cell && this.cell.getNode(this.rowIndex);
    if(n){
        try{
            if(!this.grid.edit.isEditing()){
                dojo.toggleClass(n, this.focusClass, true);
                if (this._colHeadNode){
                    this.blurHeader();
                }
                dojox.grid.util.fire(n, "focus");
            }
        }
        catch(e){}
    }
};

}

if(!dojo._hasResource['versa.widget.share.CopyLink']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.share.CopyLink'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 13/04/12
 * Time: 4:46 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.share.CopyLink');











dojo.declare('versa.widget.share.CopyLink', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("versa/widget/share", "template/CopyLink.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"padding:8px 8px 4px 8px;height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            splitter=\"false\"\n            region=\"center\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"top\"\n                splitter=\"false\"\n                style=\"padding:0 0 4px 0;overflow:hidden;height:16px;\">\n            <span class=\"dijitDarkLabel dijitMediumLabel\">Copy the following link to access the shared documents:</span>\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\"\n                splitter=\"false\"\n                class=\"highlightPane\"\n                style=\"padding:8px;overflow:hidden;text-align:center\">\n\n            <a dojoAttachPoint=\"anchorNode\" href=\"\" target=\"_blank\" class=\"dijitBoldLabel dijitLargeLabel versashare\"></a>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    share: null,
    library: null,
    zone: null,

    _itemLoaded: function(){

        console.log(this.share.share_url);
        dojo.attr(this.anchorNode, {
            href: this.share.share_url,
            innerHTML: this.share.share_url
        });

        this._loadComplete();
    },

    _loadItem: function(){

        try{

            //make sure folder is loaded (not a reference) before creating a new sub-folder
            this.library.getFolders().loadItem({
                item: this.share,
                callback: this._itemLoaded,
                scope: this
            });

        }
        finally{

        }

    },


    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);
    },

    isValid: function(){
        return true;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            canClose = true;
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close Share Copy Link dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{

        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

    },

    startup: function(){
        this.inherited('startup', arguments);
        setTimeout(versa.widget.share.CopyLink._loadFnRef(this), 0);
    }

});

versa.widget.share.CopyLink._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

versa.widget.share.CopyLink.show = function(args){

    var dlg = new bfree.widget.Dialog({
        id: 'dlgShareCopyLink',
        title: 'Shared Folder Link: ' + args.share.name.display_limit(32),
        widgetConstructor: versa.widget.share.CopyLink,
        widgetParams: {
            share: args.share,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 144,
        width: 640,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}


}

if(!dojo._hasResource['versa.widget.share.Editor']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.share.Editor'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 23/02/12
 * Time: 3:18 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.share.Editor');















dojo.declare('versa.widget.share.Editor', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget],{
    templateString: dojo.cache("versa/widget/share", "template/Editor.html", "<div style=\"height:100%;width:100%\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"padding:8px 8px 4px 8px;height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            splitter=\"false\"\n            region=\"center\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"center\"\n                splitter=\"true\"\n                class=\"highlightPane\"\n                style=\"padding:8px;overflow:hidden;\">\n\n            <div dojoAttachPoint=\"formNode\">\n                <div dojoAttachPoint=\"tableNode\"></div>\n            </div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _chkExpires: null,
    _form: null,
    _tblProperties: null,
    _txtExpiryDate: null,
    _txtName: null,
    _txtPassword: null,
    _txtRepeat: null,

    creation: false,
    item: null,
    seed: null,
    share: null,
    library: null,
    zone: null,

    __doCancel: function(){
        return true;
    },

    /*
    __doCreate: function(){
        var canClose = false;

        var expiryDate = null;

        if(!this._txtExpiryDate.disabled){
            //Set to end of day on selected day
            expiryDate =  this._txtExpiryDate.get('value');
            expiryDate = dojo.date.add(expiryDate, 'day', 1);
            expiryDate = dojo.date.add(expiryDate, 'second', -1);
        }

        this.share = this.library.createShare({
            name: this._txtName.value,
            password: this._txtPassword.value,
            expiry: expiryDate,
            seed: this.seed
        });
        canClose = true;

        return canClose;
    },

    __doEdit: function(){
        var canClose = false;

        if(this.library.getFolders().isDirty({item: this.share})){
            this.library.getFolders().save();
        }
        canClose = true;

        return canClose;
    },

    */

    __doSave: function(){
        var canClose = false;

        try{
            if(this.library.getFolders().isDirty({item: this.share})){
                this.library.getFolders().save();
            }
            canClose = true;
        }
        catch(e){

            var err = new bfree.api.Error('Failed to save shared folder', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });

            //The store loses the "dirty" flag when item save fails and revert hasn't occurred
            this.library.getFolders().clone({item: this.share});

            //TODO: Enable deletion detection
            //if(e.status == 404){
            //    canClose = this._doCancel();
            //   this.library.getDocuments().store.onDelete(this._document);
            //}

        }

        return canClose;
    },

    __onItemError: function(e){
        try{
            var err = new bfree.api.Error('Failed to load share information', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this.onWidgetLoaded();
        }
    },

    __onItemLoaded: function(shareRoot){

        try{

            if(this.share){
                //Shared folder was passed in for editing
                this.share = this.library.getFolders().refreshItem(this.share.getId());
                this.library.getFolders().clone({item: this.share});

                this._txtExpiryDate.set('value', this.share.expiry);
                this._chkExpires.set('checked', (this.share.expiry));

            }
            else{
                var shareName = (this.seed) ? this.seed.name : '';
                this.share = this.library.createShare({
                    name: shareName,
                    seed: this.seed,
                    expiry: null
                });

                this._chkPassword.set('checked', true);
            }

            this._txtName.set('value', this.share.name);
            this._txtName.setFocus(true);

        }
        finally{
            this.onWidgetLoaded();
        }
    },

    _chkExpires_onChange: function(checked){
        this._txtExpiryDate.set('disabled', !checked);

        if(checked){
            if(!this._txtExpiryDate.get('value')){
                this._txtExpiryDate.set('value', dojo.date.add(new Date(), 'week', 1));
            }
        }
        else{
            this._txtExpiryDate.reset();
        }
    },

     _chkPassword_onChange: function(checked){

        this._txtPassword.set('value', '');
        this._txtRepeat.set('value', '');

        this._txtPassword.set('disabled', !checked);
        this._txtRepeat.set('disabled', !checked);

        if(checked){
            this._txtPassword.validate();
            this._txtRepeat.validate();
            ///this._txtPassword.setFocus(true);
        }

        this.onValueChange();

    },

    _expiryValidator: function(value, constraints){

        if(this._txtExpiryDate){
            var now = new Date();
            var expiryDate = this._txtExpiryDate.parse(value, constraints);
            expiryDate = dojo.date.add(expiryDate, 'day', 1);
            expiryDate = dojo.date.add(expiryDate, 'second', -1);

            if(dojo.date.compare(expiryDate, now, 'date') < 0){
                this._txtExpiryDate.set('invalidMessage', 'Selected date has already passed');
                return false;
            }
        }

        return true;
    },

    _nameValidator: function(value, constraints){

        if(this._txtName){
            if(String.isBlank(value)){
                this._txtName.set('invalidMessage', 'Document type name cannot be blank');
                return false;
            }
        }

        return true;
    },

    _passwordValidator: function(value, constraints){

        if(this._txtPassword){
            if(String.isBlank(value)){
                this._txtPassword.set('invalidMessage', 'Password cannot be blank');
                return false;
            }
            else if(value.trim().length < 8){
                this._txtPassword.set('invalidMessage', 'Passwords must be at least 8 characters in length.');
                return false;
            }
        }

        return true;
    },

    _repeatValidator: function(value, constraints){

        if(this._txtRepeat){
            if(String.isBlank(value)){
                this._txtRepeat.set('invalidMessage', 'Password cannot be blank');
                return false;
            }
            else if(this._txtPassword.value != value.trim()){
                this._txtRepeat.set('invalidMessage', 'Passwords do not match');
                return false;
            }
        }

        return true;
    },

    _loadItem: function(){

        //Refresh ShareRoot if needed.
        this.library.getFolders().loadItem({
            item: this.library.getFolders().getShareRootFolder(),
            scope: this,
            onItem: this.__onItemLoaded,
            onError: this.__onItemError
        });

    },

    _onExpiryChange: function(id, value){

        this._txtExpiryDate.validate();

        //Set to end of day on selected day (if not already set).
        if(value){
            value.setHours(23,59,59,999);
        }

        this._onValueChange(id, value);
    },

    _onRepeatChange: function(value){
        this.onValueChange();
    },

    _onValueChange: function(id, value){


        var doUpdate = (id == 'expiry') ?
                            (dojo.date.compare(value, this.share.expiry, 'date') != 0) :
                            !this.share.valueEquals(id, value);
        if(doUpdate){
            this.library.getFolders().setValue(this.share, id, value);
            this.onValueChange();
        }

    },

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);
    },

    isValid: function(){
        var isValid = false;

        var isDirty = this.library.getFolders().isDirty({item: this.share});
        var isValid = (!isDirty) ?
                        false :
                        ((this._txtName.isValid()) &&
                            (this._txtPassword.disabled || this._txtPassword.isValid()) &&
                            (this._txtRepeat.disabled || this._txtRepeat.isValid()) &&
                            (this._txtExpiryDate.disabled || this._txtExpiryDate.isValid()))

        return isValid && isDirty;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{

            canClose = (dlgResult == bfree.widget.Dialog.dialogResult.ok) ?
                            this.__doSave() :
                            this.__doCancel();
            this.returnValue = this.share;

        }
        catch(e){
           var err = new bfree.api.Error('Failed to close Share Creation dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
        finally{
            this.library.getFolders().revert();
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        /*
        this._form = new dijit.form.Form({
            id: 'propDefForm'
        }, this.formNode);
        */

        this._tblProperties = new dojox.layout.TableContainer({
            id: 'tblProps1',
            customClass: 'versa',
            showLabels: true,
            cols: 1,
            labelWidth: 104,
            style: 'width:100%'
        }, this.tableNode);

        this._txtName = new bfree.widget.ValidationTextBox({
            id: 'txtName',
            label: 'Name',
            selectOnClick: true,
            intermediateChanges: true,
            required: true,
            trim: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._nameValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'name')
        });
        this._tblProperties.addChild(this._txtName);

        this._chkPassword = new dijit.form.CheckBox({
			name: 'chkPassword',
            label: 'Change Password',
            onChange: dojo.hitch(this, this._chkPassword_onChange)
		});
        if(this.share)
            this._tblProperties.addChild(this._chkPassword);

        this._txtPassword = new bfree.widget.ValidationTextBox({
            id: 'txtPassword',
            type: 'password',
            label: 'Password',
            disabled: true,
            selectOnClick: true,
            intermediateChanges: true,
            required: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._passwordValidator),
            onChange: dojo.hitch(this, this._onValueChange, 'password')
        });
        this._tblProperties.addChild(this._txtPassword);

        this._txtRepeat = new bfree.widget.ValidationTextBox({
            id: 'txtRepeat',
            type: 'password',
            label: 'Repeat Password',
            disabled: true,
            selectOnClick: true,
            intermediateChanges: true,
            required: true,
            style: 'width:100%',
            validator: dojo.hitch(this, this._repeatValidator),
            onChange: dojo.hitch(this, this._onRepeatChange)
        });
        this._tblProperties.addChild(this._txtRepeat);

        this._chkExpires = new dijit.form.CheckBox({
			name: 'chkExpires',
            label: 'Share Expires',
            onChange: dojo.hitch(this, this._chkExpires_onChange)
		});
        this._tblProperties.addChild(this._chkExpires);

        this._txtExpiryDate = new bfree.widget.DateTextBox({
            id: 'txtExpiry',
            label: 'Expiry Date',
            disabled: true,
            required: true,
            scrollOnFocus: false,
            selectOnClick: true,
            intermediateChanges: true,
            constraints: {min: new Date(), selector: 'date'},
            validator: dojo.hitch(this, this._expiryValidator),
            onChange: dojo.hitch(this, this._onExpiryChange, 'expiry')
        });
        this._tblProperties.addChild(this._txtExpiryDate);

    },

    startup: function(){
        this.inherited('startup', arguments);
        setTimeout(versa.widget.share.Editor._loadFnRef(this), 0);
    }

});

versa.widget.share.Editor._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}

versa.widget.share.Editor.show = function(args){

    var h = (!args.share) ? 212 : 228;

    var dlg = new bfree.widget.Dialog({
        id: 'dlgShareShow',
        title: 'Shared Folder',
        widgetConstructor: versa.widget.share.Editor,
        widgetParams: {
            mode: args.mode,
            share: args.share,
            seed: args.seed,
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: h,
        width: 368,
        buttons: bfree.widget.Dialog.buttons.ok | bfree.widget.Dialog.buttons.cancel,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();
}

}

if(!dojo._hasResource["dojox.gfx.matrix"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.gfx.matrix"] = true;
dojo.provide("dojox.gfx.matrix");

(function(){
	var m = dojox.gfx.matrix;

	// candidates for dojox.math:
	var _degToRadCache = {};
	m._degToRad = function(degree){
		return _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));
	};
	m._radToDeg = function(radian){ return radian / Math.PI * 180; };

	m.Matrix2D = function(arg){
		// summary: a 2D matrix object
		// description: Normalizes a 2D matrix-like object. If arrays is passed,
		//		all objects of the array are normalized and multiplied sequentially.
		// arg: Object
		//		a 2D matrix-like object, a number, or an array of such objects
		if(arg){
			if(typeof arg == "number"){
				this.xx = this.yy = arg;
			}else if(arg instanceof Array){
				if(arg.length > 0){
					var matrix = m.normalize(arg[0]);
					// combine matrices
					for(var i = 1; i < arg.length; ++i){
						var l = matrix, r = dojox.gfx.matrix.normalize(arg[i]);
						matrix = new m.Matrix2D();
						matrix.xx = l.xx * r.xx + l.xy * r.yx;
						matrix.xy = l.xx * r.xy + l.xy * r.yy;
						matrix.yx = l.yx * r.xx + l.yy * r.yx;
						matrix.yy = l.yx * r.xy + l.yy * r.yy;
						matrix.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
						matrix.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
					}
					dojo.mixin(this, matrix);
				}
			}else{
				dojo.mixin(this, arg);
			}
		}
	};

	// the default (identity) matrix, which is used to fill in missing values
	dojo.extend(m.Matrix2D, {xx: 1, xy: 0, yx: 0, yy: 1, dx: 0, dy: 0});

	dojo.mixin(m, {
		// summary: class constants, and methods of dojox.gfx.matrix

		// matrix constants

		// identity: dojox.gfx.matrix.Matrix2D
		//		an identity matrix constant: identity * (x, y) == (x, y)
		identity: new m.Matrix2D(),

		// flipX: dojox.gfx.matrix.Matrix2D
		//		a matrix, which reflects points at x = 0 line: flipX * (x, y) == (-x, y)
		flipX:    new m.Matrix2D({xx: -1}),

		// flipY: dojox.gfx.matrix.Matrix2D
		//		a matrix, which reflects points at y = 0 line: flipY * (x, y) == (x, -y)
		flipY:    new m.Matrix2D({yy: -1}),

		// flipXY: dojox.gfx.matrix.Matrix2D
		//		a matrix, which reflects points at the origin of coordinates: flipXY * (x, y) == (-x, -y)
		flipXY:   new m.Matrix2D({xx: -1, yy: -1}),

		// matrix creators

		translate: function(a, b){
			// summary: forms a translation matrix
			// description: The resulting matrix is used to translate (move) points by specified offsets.
			// a: Number: an x coordinate value
			// b: Number: a y coordinate value
			if(arguments.length > 1){
				return new m.Matrix2D({dx: a, dy: b}); // dojox.gfx.matrix.Matrix2D
			}
			// branch
			// a: dojox.gfx.Point: a point-like object, which specifies offsets for both dimensions
			// b: null
			return new m.Matrix2D({dx: a.x, dy: a.y}); // dojox.gfx.matrix.Matrix2D
		},
		scale: function(a, b){
			// summary: forms a scaling matrix
			// description: The resulting matrix is used to scale (magnify) points by specified offsets.
			// a: Number: a scaling factor used for the x coordinate
			// b: Number: a scaling factor used for the y coordinate
			if(arguments.length > 1){
				return new m.Matrix2D({xx: a, yy: b}); // dojox.gfx.matrix.Matrix2D
			}
			if(typeof a == "number"){
				// branch
				// a: Number: a uniform scaling factor used for the both coordinates
				// b: null
				return new m.Matrix2D({xx: a, yy: a}); // dojox.gfx.matrix.Matrix2D
			}
			// branch
			// a: dojox.gfx.Point: a point-like object, which specifies scale factors for both dimensions
			// b: null
			return new m.Matrix2D({xx: a.x, yy: a.y}); // dojox.gfx.matrix.Matrix2D
		},
		rotate: function(angle){
			// summary: forms a rotating matrix
			// description: The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number: an angle of rotation in radians (>0 for CW)
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			return new m.Matrix2D({xx: c, xy: -s, yx: s, yy: c}); // dojox.gfx.matrix.Matrix2D
		},
		rotateg: function(degree){
			// summary: forms a rotating matrix
			// description: The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox.gfx.matrix.rotate() for comparison.
			// degree: Number: an angle of rotation in degrees (>0 for CW)
			return m.rotate(m._degToRad(degree)); // dojox.gfx.matrix.Matrix2D
		},
		skewX: function(angle) {
			// summary: forms an x skewing matrix
			// description: The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number: an skewing angle in radians
			return new m.Matrix2D({xy: Math.tan(angle)}); // dojox.gfx.matrix.Matrix2D
		},
		skewXg: function(degree){
			// summary: forms an x skewing matrix
			// description: The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox.gfx.matrix.skewX() for comparison.
			// degree: Number: an skewing angle in degrees
			return m.skewX(m._degToRad(degree)); // dojox.gfx.matrix.Matrix2D
		},
		skewY: function(angle){
			// summary: forms a y skewing matrix
			// description: The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number: an skewing angle in radians
			return new m.Matrix2D({yx: Math.tan(angle)}); // dojox.gfx.matrix.Matrix2D
		},
		skewYg: function(degree){
			// summary: forms a y skewing matrix
			// description: The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox.gfx.matrix.skewY() for comparison.
			// degree: Number: an skewing angle in degrees
			return m.skewY(m._degToRad(degree)); // dojox.gfx.matrix.Matrix2D
		},
		reflect: function(a, b){
			// summary: forms a reflection matrix
			// description: The resulting matrix is used to reflect points around a vector,
			//		which goes through the origin.
			// a: dojox.gfx.Point: a point-like object, which specifies a vector of reflection
			// b: null
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// branch
			// a: Number: an x coordinate value
			// b: Number: a y coordinate value

			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = 2 * a * b / n2;
			return new m.Matrix2D({xx: 2 * a2 / n2 - 1, xy: xy, yx: xy, yy: 2 * b2 / n2 - 1}); // dojox.gfx.matrix.Matrix2D
		},
		project: function(a, b){
			// summary: forms an orthogonal projection matrix
			// description: The resulting matrix is used to project points orthogonally on a vector,
			//		which goes through the origin.
			// a: dojox.gfx.Point: a point-like object, which specifies a vector of projection
			// b: null
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// branch
			// a: Number: an x coordinate value
			// b: Number: a y coordinate value

			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = a * b / n2;
			return new m.Matrix2D({xx: a2 / n2, xy: xy, yx: xy, yy: b2 / n2}); // dojox.gfx.matrix.Matrix2D
		},

		// ensure matrix 2D conformance
		normalize: function(matrix){
			// summary: converts an object to a matrix, if necessary
			// description: Converts any 2D matrix-like object or an array of
			//		such objects to a valid dojox.gfx.matrix.Matrix2D object.
			// matrix: Object: an object, which is converted to a matrix, if necessary
			return (matrix instanceof m.Matrix2D) ? matrix : new m.Matrix2D(matrix); // dojox.gfx.matrix.Matrix2D
		},

		// common operations

		clone: function(matrix){
			// summary: creates a copy of a 2D matrix
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object to be cloned
			var obj = new m.Matrix2D();
			for(var i in matrix){
				if(typeof(matrix[i]) == "number" && typeof(obj[i]) == "number" && obj[i] != matrix[i]) obj[i] = matrix[i];
			}
			return obj; // dojox.gfx.matrix.Matrix2D
		},
		invert: function(matrix){
			// summary: inverts a 2D matrix
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object to be inverted
			var M = m.normalize(matrix),
				D = M.xx * M.yy - M.xy * M.yx,
				M = new m.Matrix2D({
					xx: M.yy/D, xy: -M.xy/D,
					yx: -M.yx/D, yy: M.xx/D,
					dx: (M.xy * M.dy - M.yy * M.dx) / D,
					dy: (M.yx * M.dx - M.xx * M.dy) / D
				});
			return M; // dojox.gfx.matrix.Matrix2D
		},
		_multiplyPoint: function(matrix, x, y){
			// summary: applies a matrix to a point
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix object to be applied
			// x: Number: an x coordinate of a point
			// y: Number: a y coordinate of a point
			return {x: matrix.xx * x + matrix.xy * y + matrix.dx, y: matrix.yx * x + matrix.yy * y + matrix.dy}; // dojox.gfx.Point
		},
		multiplyPoint: function(matrix, /* Number||Point */ a, /* Number, optional */ b){
			// summary: applies a matrix to a point
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix object to be applied
			// a: Number: an x coordinate of a point
			// b: Number: a y coordinate of a point
			var M = m.normalize(matrix);
			if(typeof a == "number" && typeof b == "number"){
				return m._multiplyPoint(M, a, b); // dojox.gfx.Point
			}
			// branch
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix object to be applied
			// a: dojox.gfx.Point: a point
			// b: null
			return m._multiplyPoint(M, a.x, a.y); // dojox.gfx.Point
		},
		multiply: function(matrix){
			// summary: combines matrices by multiplying them sequentially in the given order
			// matrix: dojox.gfx.matrix.Matrix2D...: a 2D matrix-like object,
			//		all subsequent arguments are matrix-like objects too
			var M = m.normalize(matrix);
			// combine matrices
			for(var i = 1; i < arguments.length; ++i){
				var l = M, r = m.normalize(arguments[i]);
				M = new m.Matrix2D();
				M.xx = l.xx * r.xx + l.xy * r.yx;
				M.xy = l.xx * r.xy + l.xy * r.yy;
				M.yx = l.yx * r.xx + l.yy * r.yx;
				M.yy = l.yx * r.xy + l.yy * r.yy;
				M.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
				M.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
			}
			return M; // dojox.gfx.matrix.Matrix2D
		},

		// high level operations

		_sandwich: function(matrix, x, y){
			// summary: applies a matrix at a centrtal point
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object, which is applied at a central point
			// x: Number: an x component of the central point
			// y: Number: a y component of the central point
			return m.multiply(m.translate(x, y), matrix, m.translate(-x, -y)); // dojox.gfx.matrix.Matrix2D
		},
		scaleAt: function(a, b, c, d){
			// summary: scales a picture using a specified point as a center of scaling
			// description: Compare with dojox.gfx.matrix.scale().
			// a: Number: a scaling factor used for the x coordinate
			// b: Number: a scaling factor used for the y coordinate
			// c: Number: an x component of a central point
			// d: Number: a y component of a central point

			// accepts several signatures:
			//	1) uniform scale factor, Point
			//	2) uniform scale factor, x, y
			//	3) x scale, y scale, Point
			//	4) x scale, y scale, x, y

			switch(arguments.length){
				case 4:
					// a and b are scale factor components, c and d are components of a point
					return m._sandwich(m.scale(a, b), c, d); // dojox.gfx.matrix.Matrix2D
				case 3:
					if(typeof c == "number"){
						// branch
						// a: Number: a uniform scaling factor used for both coordinates
						// b: Number: an x component of a central point
						// c: Number: a y component of a central point
						// d: null
						return m._sandwich(m.scale(a), b, c); // dojox.gfx.matrix.Matrix2D
					}
					// branch
					// a: Number: a scaling factor used for the x coordinate
					// b: Number: a scaling factor used for the y coordinate
					// c: dojox.gfx.Point: a central point
					// d: null
					return m._sandwich(m.scale(a, b), c.x, c.y); // dojox.gfx.matrix.Matrix2D
			}
			// branch
			// a: Number: a uniform scaling factor used for both coordinates
			// b: dojox.gfx.Point: a central point
			// c: null
			// d: null
			return m._sandwich(m.scale(a), b.x, b.y); // dojox.gfx.matrix.Matrix2D
		},
		rotateAt: function(angle, a, b){
			// summary: rotates a picture using a specified point as a center of rotation
			// description: Compare with dojox.gfx.matrix.rotate().
			// angle: Number: an angle of rotation in radians (>0 for CW)
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) rotation angle in radians, Point
			//	2) rotation angle in radians, x, y

			if(arguments.length > 2){
				return m._sandwich(m.rotate(angle), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// angle: Number: an angle of rotation in radians (>0 for CCW)
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.rotate(angle), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		rotategAt: function(degree, a, b){
			// summary: rotates a picture using a specified point as a center of rotation
			// description: Compare with dojox.gfx.matrix.rotateg().
			// degree: Number: an angle of rotation in degrees (>0 for CW)
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) rotation angle in degrees, Point
			//	2) rotation angle in degrees, x, y

			if(arguments.length > 2){
				return m._sandwich(m.rotateg(degree), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// degree: Number: an angle of rotation in degrees (>0 for CCW)
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.rotateg(degree), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewXAt: function(angle, a, b){
			// summary: skews a picture along the x axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewX().
			// angle: Number: an skewing angle in radians
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in radians, Point
			//	2) skew angle in radians, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewX(angle), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// angle: Number: an skewing angle in radians
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewX(angle), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewXgAt: function(degree, a, b){
			// summary: skews a picture along the x axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewXg().
			// degree: Number: an skewing angle in degrees
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in degrees, Point
			//	2) skew angle in degrees, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewXg(degree), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// degree: Number: an skewing angle in degrees
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewXg(degree), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewYAt: function(angle, a, b){
			// summary: skews a picture along the y axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewY().
			// angle: Number: an skewing angle in radians
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in radians, Point
			//	2) skew angle in radians, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewY(angle), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// angle: Number: an skewing angle in radians
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewY(angle), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number, optional */ b){
			// summary: skews a picture along the y axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewYg().
			// degree: Number: an skewing angle in degrees
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in degrees, Point
			//	2) skew angle in degrees, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewYg(degree), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// degree: Number: an skewing angle in degrees
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewYg(degree), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		}

		//TODO: rect-to-rect mapping, scale-to-fit (isotropic and anisotropic versions)

	});
})();

// propagate Matrix2D up
dojox.gfx.Matrix2D = dojox.gfx.matrix.Matrix2D;

}

if(!dojo._hasResource["dojox.gfx._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.gfx._base"] = true;
dojo.provide("dojox.gfx._base");

(function(){
	var g = dojox.gfx, b = g._base;

	// candidates for dojox.style (work on VML and SVG nodes)
	g._hasClass = function(/*DomNode*/node, /*String*/classStr){
		//	summary:
		//		Returns whether or not the specified classes are a portion of the
		//		class list currently applied to the node.
		// return (new RegExp('(^|\\s+)'+classStr+'(\\s+|$)')).test(node.className)	// Boolean
		var cls = node.getAttribute("className");
		return cls && (" " + cls + " ").indexOf(" " + classStr + " ") >= 0;  // Boolean
	};
	g._addClass = function(/*DomNode*/node, /*String*/classStr){
		//	summary:
		//		Adds the specified classes to the end of the class list on the
		//		passed node.
		var cls = node.getAttribute("className") || "";
		if(!cls || (" " + cls + " ").indexOf(" " + classStr + " ") < 0){
			node.setAttribute("className", cls + (cls ? " " : "") + classStr);
		}
	};
	g._removeClass = function(/*DomNode*/node, /*String*/classStr){
		//	summary: Removes classes from node.
		var cls = node.getAttribute("className");
		if(cls){
			node.setAttribute(
				"className",
				cls.replace(new RegExp('(^|\\s+)' + classStr + '(\\s+|$)'), "$1$2")
			);
		}
	};

	// candidate for dojox.html.metrics (dynamic font resize handler is not implemented here)

	//	derived from Morris John's emResized measurer
	b._getFontMeasurements = function(){
		//	summary:
		//		Returns an object that has pixel equivilents of standard font
		//		size values.
		var heights = {
			'1em': 0, '1ex': 0, '100%': 0, '12pt': 0, '16px': 0, 'xx-small': 0,
			'x-small': 0, 'small': 0, 'medium': 0, 'large': 0, 'x-large': 0,
			'xx-large': 0
		};

		if(dojo.isIE){
			//	we do a font-size fix if and only if one isn't applied already.
			//	NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			dojo.doc.documentElement.style.fontSize="100%";
		}

		//	set up the measuring node.
		var div = dojo.create("div", {style: {
				position: "absolute",
				left: "0",
				top: "-100px",
				width: "30px",
				height: "1000em",
				borderWidth: "0",
				margin: "0",
				padding: "0",
				outline: "none",
				lineHeight: "1",
				overflow: "hidden"
			}}, dojo.body());

		//	do the measurements.
		for(var p in heights){
			div.style.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}

		dojo.body().removeChild(div);
		return heights; 	//	object
	};

	var fontMeasurements = null;

	b._getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = b._getFontMeasurements();
		}
		return fontMeasurements;
	};

	// candidate for dojox.html.metrics

	var measuringNode = null, empty = {};
	b._getTextBox = function(	/*String*/ text,
								/*Object*/ style,
								/*String?*/ className){
		var m, s, al = arguments.length;
		if(!measuringNode){
			measuringNode = dojo.create("div", {style: {
				position: "absolute",
				top: "-10000px",
				left: "0"
			}}, dojo.body());
		}
		m = measuringNode;
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(al > 1 && style){
			for(var i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(al > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;

		if(m["getBoundingClientRect"]){
			var bcr = m.getBoundingClientRect();
			return {l: bcr.left, t: bcr.top, w: bcr.width || (bcr.right - bcr.left), h: bcr.height || (bcr.bottom - bcr.top)};
		}else{
			return dojo.marginBox(m);
		}
	};

	// candidate for dojo.dom

	var uniqueId = 0;
	b._getUniqueId = function(){
		// summary: returns a unique string for use with any DOM element
		var id;
		do{
			id = dojo._scopeName + "Unique" + (++uniqueId);
		}while(dojo.byId(id));
		return id;
	};
})();

dojo.mixin(dojox.gfx, {
	//	summary:
	// 		defines constants, prototypes, and utility functions

	// default shapes, which are used to fill in missing parameters
	defaultPath: {
		type: "path", path: ""
	},
	defaultPolyline: {
		type: "polyline", points: []
	},
	defaultRect: {
		type: "rect", x: 0, y: 0, width: 100, height: 100, r: 0
	},
	defaultEllipse: {
		type: "ellipse", cx: 0, cy: 0, rx: 200, ry: 100
	},
	defaultCircle: {
		type: "circle", cx: 0, cy: 0, r: 100
	},
	defaultLine: {
		type: "line", x1: 0, y1: 0, x2: 100, y2: 100
	},
	defaultImage: {
		type: "image", x: 0, y: 0, width: 0, height: 0, src: ""
	},
	defaultText: {
		type: "text", x: 0, y: 0, text: "", align: "start",
		decoration: "none", rotated: false, kerning: true
	},
	defaultTextPath: {
		type: "textpath", text: "", align: "start",
		decoration: "none", rotated: false, kerning: true
	},

	// default geometric attributes
	defaultStroke: {
		type: "stroke", color: "black", style: "solid", width: 1,
		cap: "butt", join: 4
	},
	defaultLinearGradient: {
		type: "linear", x1: 0, y1: 0, x2: 100, y2: 100,
		colors: [
			{ offset: 0, color: "black" }, { offset: 1, color: "white" }
		]
	},
	defaultRadialGradient: {
		type: "radial", cx: 0, cy: 0, r: 100,
		colors: [
			{ offset: 0, color: "black" }, { offset: 1, color: "white" }
		]
	},
	defaultPattern: {
		type: "pattern", x: 0, y: 0, width: 0, height: 0, src: ""
	},
	defaultFont: {
		type: "font", style: "normal", variant: "normal",
		weight: "normal", size: "10pt", family: "serif"
	},

	getDefault: (function(){
		var typeCtorCache = {};
		// a memoized delegate()
		return function(/*String*/ type){
			var t = typeCtorCache[type];
			if(t){
				return new t();
			}
			t = typeCtorCache[type] = new Function;
			t.prototype = dojox.gfx[ "default" + type ];
			return new t();
		}
	})(),

	normalizeColor: function(/*Color*/ color){
		//	summary:
		// 		converts any legal color representation to normalized
		// 		dojo.Color object
		return (color instanceof dojo.Color) ? color : new dojo.Color(color); // dojo.Color
	},
	normalizeParameters: function(existed, update){
		//	summary:
		// 		updates an existing object with properties from an "update"
		// 		object
		//	existed: Object
		//		the "target" object to be updated
		//	update:  Object
		//		the "update" object, whose properties will be used to update
		//		the existed object
		if(update){
			var empty = {};
			for(var x in existed){
				if(x in update && !(x in empty)){
					existed[x] = update[x];
				}
			}
		}
		return existed;	// Object
	},
	makeParameters: function(defaults, update){
		//	summary:
		// 		copies the original object, and all copied properties from the
		// 		"update" object
		//	defaults: Object
		//		the object to be cloned before updating
		//	update:   Object
		//		the object, which properties are to be cloned during updating
		if(!update){
			// return dojo.clone(defaults);
			return dojo.delegate(defaults);
		}
		var result = {};
		for(var i in defaults){
			if(!(i in result)){
				result[i] = dojo.clone((i in update) ? update[i] : defaults[i]);
			}
		}
		return result; // Object
	},
	formatNumber: function(x, addSpace){
		// summary: converts a number to a string using a fixed notation
		// x:			Number:		number to be converted
		// addSpace:	Boolean?:	if it is true, add a space before a positive number
		var val = x.toString();
		if(val.indexOf("e") >= 0){
			val = x.toFixed(4);
		}else{
			var point = val.indexOf(".");
			if(point >= 0 && val.length - point > 5){
				val = x.toFixed(4);
			}
		}
		if(x < 0){
			return val; // String
		}
		return addSpace ? " " + val : val; // String
	},
	// font operations
	makeFontString: function(font){
		// summary: converts a font object to a CSS font string
		// font:	Object:	font object (see dojox.gfx.defaultFont)
		return font.style + " " + font.variant + " " + font.weight + " " + font.size + " " + font.family; // Object
	},
	splitFontString: function(str){
		// summary:
		//		converts a CSS font string to a font object
		// description:
		//		Converts a CSS font string to a gfx font object. The CSS font
		//		string components should follow the W3C specified order
		//		(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):
		//		style, variant, weight, size, optional line height (will be
		//		ignored), and family.
		// str: String
		//		a CSS font string
		var font = dojox.gfx.getDefault("Font");
		var t = str.split(/\s+/);
		do{
			if(t.length < 5){ break; }
			font.style   = t[0];
			font.variant = t[1];
			font.weight  = t[2];
			var i = t[3].indexOf("/");
			font.size = i < 0 ? t[3] : t[3].substring(0, i);
			var j = 4;
			if(i < 0){
				if(t[4] == "/"){
					j = 6;
				}else if(t[4].charAt(0) == "/"){
					j = 5;
				}
			}
			if(j < t.length){
				font.family = t.slice(j).join(" ");
			}
		}while(false);
		return font;	// Object
	},
	// length operations
	cm_in_pt: 72 / 2.54,	// Number: points per centimeter
	mm_in_pt: 7.2 / 2.54,	// Number: points per millimeter
	px_in_pt: function(){
		// summary: returns a number of pixels per point
		return dojox.gfx._base._getCachedFontMeasurements()["12pt"] / 12;	// Number
	},
	pt2px: function(len){
		// summary: converts points to pixels
		// len: Number: a value in points
		return len * dojox.gfx.px_in_pt();	// Number
	},
	px2pt: function(len){
		// summary: converts pixels to points
		// len: Number: a value in pixels
		return len / dojox.gfx.px_in_pt();	// Number
	},
	normalizedLength: function(len) {
		// summary: converts any length value to pixels
		// len: String: a length, e.g., "12pc"
		if(len.length == 0) return 0;
		if(len.length > 2){
			var px_in_pt = dojox.gfx.px_in_pt();
			var val = parseFloat(len);
			switch(len.slice(-2)){
				case "px": return val;
				case "pt": return val * px_in_pt;
				case "in": return val * 72 * px_in_pt;
				case "pc": return val * 12 * px_in_pt;
				case "mm": return val * dojox.gfx.mm_in_pt * px_in_pt;
				case "cm": return val * dojox.gfx.cm_in_pt * px_in_pt;
			}
		}
		return parseFloat(len);	// Number
	},

	// a constant used to split a SVG/VML path into primitive components
	pathVmlRegExp: /([A-Za-z]+)|(\d+(\.\d+)?)|(\.\d+)|(-\d+(\.\d+)?)|(-\.\d+)/g,
	pathSvgRegExp: /([A-Za-z])|(\d+(\.\d+)?)|(\.\d+)|(-\d+(\.\d+)?)|(-\.\d+)/g,

	equalSources: function(a, b){
		// summary: compares event sources, returns true if they are equal
		return a && b && a == b;
	},
	
	switchTo: function(renderer){
		var ns = dojox.gfx[renderer];
		if(ns){
			dojo.forEach(["Group", "Rect", "Ellipse", "Circle", "Line",
					"Polyline", "Image", "Text", "Path", "TextPath",
					"Surface", "createSurface"], function(name){
				dojox.gfx[name] = ns[name];
			});
		}
	}
});

}

if(!dojo._hasResource["dojox.gfx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.gfx"] = true;
dojo.provide("dojox.gfx");




dojo.loadInit(function(){
	// Since loaderInit can be fired before any dojo.provide/require calls,
	// make sure the dojox.gfx object exists and only run this logic if dojox.gfx.renderer
	// has not been defined yet.
	var gfx = dojo.getObject("dojox.gfx", true), sl, flag, match;
	while(!gfx.renderer){
		// Have a way to force a GFX renderer, if so desired.
		// Useful for being able to serialize GFX data in a particular format.
		if(dojo.config.forceGfxRenderer){
			dojox.gfx.renderer = dojo.config.forceGfxRenderer;
			break;
		}
		var renderers = (typeof dojo.config.gfxRenderer == "string" ?
			dojo.config.gfxRenderer : "svg,vml,canvas,silverlight").split(",");
		for(var i = 0; i < renderers.length; ++i){
			switch(renderers[i]){
				case "svg":
					// the next test is from https://github.com/phiggins42/has.js
					if("SVGAngle" in dojo.global){
						dojox.gfx.renderer = "svg";
					}
					break;
				case "vml":
					if(dojo.isIE){
						dojox.gfx.renderer = "vml";
					}
					break;
				case "silverlight":
					try{
						if(dojo.isIE){
							sl = new ActiveXObject("AgControl.AgControl");
							if(sl && sl.IsVersionSupported("1.0")){
								flag = true;
							}
						}else{
							if(navigator.plugins["Silverlight Plug-In"]){
								flag = true;
							}
						}
					}catch(e){
						flag = false;
					}finally{
						sl = null;
					}
					if(flag){
						dojox.gfx.renderer = "silverlight";
					}
					break;
				case "canvas":
					if(dojo.global.CanvasRenderingContext2D){
						dojox.gfx.renderer = "canvas";
					}
					break;
			}
			if(gfx.renderer){
				break;
			}
		}
		break;
	}
	
	if(dojo.config.isDebug){
		console.log("gfx renderer = " + gfx.renderer);
	}

	// load & initialize renderer
	if(gfx[gfx.renderer]){
		// already loaded
		gfx.switchTo(gfx.renderer);
	}else{
		// load
		gfx.loadAndSwitch = gfx.renderer;
		dojo["require"]("dojox.gfx." + gfx.renderer);
	}
});

}

if(!dojo._hasResource["dojox.lang.functional.lambda"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.functional.lambda"] = true;
dojo.provide("dojox.lang.functional.lambda");

// This module adds high-level functions and related constructs:
//	- anonymous functions built from the string

// Acknoledgements:
//	- lambda() is based on work by Oliver Steele
//		(http://osteele.com/sources/javascript/functional/functional.js)
//		which was published under MIT License

// Notes:
//	- lambda() produces functions, which after the compilation step are
//		as fast as regular JS functions (at least theoretically).

// Lambda input values:
//	- returns functions unchanged
//	- converts strings to functions
//	- converts arrays to a functional composition

(function(){
	var df = dojox.lang.functional, lcache = {};

	// split() is augmented on IE6 to ensure the uniform behavior
	var split = "ab".split(/a*/).length > 1 ? String.prototype.split :
			function(sep){
				 var r = this.split.call(this, sep),
					 m = sep.exec(this);
				 if(m && m.index == 0){ r.unshift(""); }
				 return r;
			};
			
	var lambda = function(/*String*/ s){
		var args = [], sects = split.call(s, /\s*->\s*/m);
		if(sects.length > 1){
			while(sects.length){
				s = sects.pop();
				args = sects.pop().split(/\s*,\s*|\s+/m);
				if(sects.length){ sects.push("(function(" + args + "){return (" + s + ")})"); }
			}
		}else if(s.match(/\b_\b/)){
			args = ["_"];
		}else{
			var l = s.match(/^\s*(?:[+*\/%&|\^\.=<>]|!=)/m),
				r = s.match(/[+\-*\/%&|\^\.=<>!]\s*$/m);
			if(l || r){
				if(l){
					args.push("$1");
					s = "$1" + s;
				}
				if(r){
					args.push("$2");
					s = s + "$2";
				}
			}else{
				// the point of the long regex below is to exclude all well-known
				// lower-case words from the list of potential arguments
				var vars = s.
					replace(/(?:\b[A-Z]|\.[a-zA-Z_$])[a-zA-Z_$\d]*|[a-zA-Z_$][a-zA-Z_$\d]*:|this|true|false|null|undefined|typeof|instanceof|in|delete|new|void|arguments|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape|dojo|dijit|dojox|window|document|'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"/g, "").
					match(/([a-z_$][a-z_$\d]*)/gi) || [], t = {};
				dojo.forEach(vars, function(v){
					if(!(v in t)){
						args.push(v);
						t[v] = 1;
					}
				});
			}
		}
		return {args: args, body: s};	// Object
	};

	var compose = function(/*Array*/ a){
		return a.length ?
					function(){
						var i = a.length - 1, x = df.lambda(a[i]).apply(this, arguments);
						for(--i; i >= 0; --i){ x = df.lambda(a[i]).call(this, x); }
						return x;
					}
				:
					// identity
					function(x){ return x; };
	};

	dojo.mixin(df, {
		// lambda
		rawLambda: function(/*String*/ s){
			// summary:
			//		builds a function from a snippet, or array (composing),
			//		returns an object describing the function; functions are
			//		passed through unmodified.
			// description:
			//		This method is to normalize a functional representation (a
			//		text snippet) to an object that contains an array of
			//		arguments, and a body , which is used to calculate the
			//		returning value.
			return lambda(s);	// Object
		},
		buildLambda: function(/*String*/ s){
			// summary:
			//		builds a function from a snippet, returns a string, which
			//		represents the function.
			// description:
			//		This method returns a textual representation of a function
			//		built from the snippet. It is meant to be evaled in the
			//		proper context, so local variables can be pulled from the
			//		environment.
			s = lambda(s);
			return "function(" + s.args.join(",") + "){return (" + s.body + ");}";	// String
		},
		lambda: function(/*Function|String|Array*/ s){
			// summary:
			//		builds a function from a snippet, or array (composing),
			//		returns a function object; functions are passed through
			//		unmodified.
			// description:
			//		This method is used to normalize a functional
			//		representation (a text snippet, an array, or a function) to
			//		a function object.
			if(typeof s == "function"){ return s; }
			if(s instanceof Array){ return compose(s); }
			if(s in lcache){ return lcache[s]; }
			s = lambda(s);
			return lcache[s] = new Function(s.args, "return (" + s.body + ");");	// Function
		},
		clearLambdaCache: function(){
			// summary:
			//		clears internal cache of lambdas
			lcache = {};
		}
	});
})();

}

if(!dojo._hasResource["dojox.lang.functional.array"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.functional.array"] = true;
dojo.provide("dojox.lang.functional.array");



// This module adds high-level functions and related constructs:
//	- array-processing functions similar to standard JS functions

// Notes:
//	- this module provides JS standard methods similar to high-level functions in dojo/_base/array.js:
//		forEach, map, filter, every, some

// Defined methods:
//	- take any valid lambda argument as the functional argument
//	- operate on dense arrays
//	- take a string as the array argument
//	- take an iterator objects as the array argument

(function(){
	var d = dojo, df = dojox.lang.functional, empty = {};

	d.mixin(df, {
		// JS 1.6 standard array functions, which can take a lambda as a parameter.
		// Consider using dojo._base.array functions, if you don't need the lambda support.
		filter: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: creates a new array with all elements that pass the test
			//	implemented by the provided function.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var t = [], v, i, n;
			if(d.isArray(a)){
				// array
				for(i = 0, n = a.length; i < n; ++i){
					v = a[i];
					if(f.call(o, v, i, a)){ t.push(v); }
				}
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				for(i = 0; a.hasNext();){
					v = a.next();
					if(f.call(o, v, i++, a)){ t.push(v); }
				}
			}else{
				// object/dictionary
				for(i in a){
					if(!(i in empty)){
						v = a[i];
						if(f.call(o, v, i, a)){ t.push(v); }
					}
				}
			}
			return t;	// Array
		},
		forEach: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: executes a provided function once per array element.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var i, n;
			if(d.isArray(a)){
				// array
				for(i = 0, n = a.length; i < n; f.call(o, a[i], i, a), ++i);
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				for(i = 0; a.hasNext(); f.call(o, a.next(), i++, a));
			}else{
				// object/dictionary
				for(i in a){
					if(!(i in empty)){
						f.call(o, a[i], i, a);
					}
				}
			}
			return o;	// Object
		},
		map: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: creates a new array with the results of calling
			//	a provided function on every element in this array.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var t, n, i;
			if(d.isArray(a)){
				// array
				t = new Array(n = a.length);
				for(i = 0; i < n; t[i] = f.call(o, a[i], i, a), ++i);
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				t = [];
				for(i = 0; a.hasNext(); t.push(f.call(o, a.next(), i++, a)));
			}else{
				// object/dictionary
				t = [];
				for(i in a){
					if(!(i in empty)){
						t.push(f.call(o, a[i], i, a));
					}
				}
			}
			return t;	// Array
		},
		every: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: tests whether all elements in the array pass the test
			//	implemented by the provided function.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var i, n;
			if(d.isArray(a)){
				// array
				for(i = 0, n = a.length; i < n; ++i){
					if(!f.call(o, a[i], i, a)){
						return false;	// Boolean
					}
				}
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				for(i = 0; a.hasNext();){
					if(!f.call(o, a.next(), i++, a)){
						return false;	// Boolean
					}
				}
			}else{
				// object/dictionary
				for(i in a){
					if(!(i in empty)){
						if(!f.call(o, a[i], i, a)){
							return false;	// Boolean
						}
					}
				}
			}
			return true;	// Boolean
		},
		some: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: tests whether some element in the array passes the test
			//	implemented by the provided function.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var i, n;
			if(d.isArray(a)){
				// array
				for(i = 0, n = a.length; i < n; ++i){
					if(f.call(o, a[i], i, a)){
						return true;	// Boolean
					}
				}
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				for(i = 0; a.hasNext();){
					if(f.call(o, a.next(), i++, a)){
						return true;	// Boolean
					}
				}
			}else{
				// object/dictionary
				for(i in a){
					if(!(i in empty)){
						if(f.call(o, a[i], i, a)){
							return true;	// Boolean
						}
					}
				}
			}
			return false;	// Boolean
		}
	});
})();

}

if(!dojo._hasResource["dojox.lang.functional.object"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.functional.object"] = true;
dojo.provide("dojox.lang.functional.object");



// This module adds high-level functions and related constructs:
//	- object/dictionary helpers

// Defined methods:
//	- take any valid lambda argument as the functional argument
//	- skip all attributes that are present in the empty object
//		(IE and/or 3rd-party libraries).

(function(){
	var d = dojo, df = dojox.lang.functional, empty = {};

	d.mixin(df, {
		// object helpers
		keys: function(/*Object*/ obj){
			// summary: returns an array of all keys in the object
			var t = [];
			for(var i in obj){
				if(!(i in empty)){
					t.push(i);
				}
			}
			return	t; // Array
		},
		values: function(/*Object*/ obj){
			// summary: returns an array of all values in the object
			var t = [];
			for(var i in obj){
				if(!(i in empty)){
					t.push(obj[i]);
				}
			}
			return	t; // Array
		},
		filterIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: creates new object with all attributes that pass the test
			//	implemented by the provided function.
			o = o || d.global; f = df.lambda(f);
			var t = {}, v, i;
			for(i in obj){
				if(!(i in empty)){
					v = obj[i];
					if(f.call(o, v, i, obj)){ t[i] = v; }
				}
			}
			return t;	// Object
		},
		forIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: iterates over all object attributes.
			o = o || d.global; f = df.lambda(f);
			for(var i in obj){
				if(!(i in empty)){
					f.call(o, obj[i], i, obj);
				}
			}
			return o;	// Object
		},
		mapIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: creates new object with the results of calling
			//	a provided function on every attribute in this object.
			o = o || d.global; f = df.lambda(f);
			var t = {}, i;
			for(i in obj){
				if(!(i in empty)){
					t[i] = f.call(o, obj[i], i, obj);
				}
			}
			return t;	// Object
		}
	});
})();

}

if(!dojo._hasResource["dojox.lang.functional"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.functional"] = true;
dojo.provide("dojox.lang.functional");





}

if(!dojo._hasResource["dojox.lang.functional.fold"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.functional.fold"] = true;
dojo.provide("dojox.lang.functional.fold");



// This module adds high-level functions and related constructs:
//	- "fold" family of functions

// Notes:
//	- missing high-level functions are provided with the compatible API:
//		foldl, foldl1, foldr, foldr1
//	- missing JS standard functions are provided with the compatible API:
//		reduce, reduceRight
//	- the fold's counterpart: unfold

// Defined methods:
//	- take any valid lambda argument as the functional argument
//	- operate on dense arrays
//	- take a string as the array argument
//	- take an iterator objects as the array argument (only foldl, foldl1, and reduce)

(function(){
	var d = dojo, df = dojox.lang.functional, empty = {};

	d.mixin(df, {
		// classic reduce-class functions
		foldl: function(/*Array|String|Object*/ a, /*Function*/ f, /*Object*/ z, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from left
			//	to right using a seed value as a starting point; returns the final
			//	value.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var i, n;
			if(d.isArray(a)){
				// array
				for(i = 0, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				for(i = 0; a.hasNext(); z = f.call(o, z, a.next(), i++, a));
			}else{
				// object/dictionary
				for(i in a){
					if(!(i in empty)){
						z = f.call(o, z, a[i], i, a);
					}
				}
			}
			return z;	// Object
		},
		foldl1: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from left
			//	to right; returns the final value.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var z, i, n;
			if(d.isArray(a)){
				// array
				z = a[0];
				for(i = 1, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				if(a.hasNext()){
					z = a.next();
					for(i = 1; a.hasNext(); z = f.call(o, z, a.next(), i++, a));
				}
			}else{
				// object/dictionary
				var first = true;
				for(i in a){
					if(!(i in empty)){
						if(first){
							z = a[i];
							first = false;
						}else{
							z = f.call(o, z, a[i], i, a);
						}
					}
				}
			}
			return z;	// Object
		},
		foldr: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object*/ z, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from right
			//	to left using a seed value as a starting point; returns the final
			//	value.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			for(var i = a.length; i > 0; --i, z = f.call(o, z, a[i], i, a));
			return z;	// Object
		},
		foldr1: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from right
			//	to left; returns the final value.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var n = a.length, z = a[n - 1], i = n - 1;
			for(; i > 0; --i, z = f.call(o, z, a[i], i, a));
			return z;	// Object
		},
		// JS 1.8 standard array functions, which can take a lambda as a parameter.
		reduce: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ z){
			// summary: apply a function simultaneously against two values of the array
			//	(from left-to-right) as to reduce it to a single value.
			return arguments.length < 3 ? df.foldl1(a, f) : df.foldl(a, f, z);	// Object
		},
		reduceRight: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ z){
			// summary: apply a function simultaneously against two values of the array
			//	(from right-to-left) as to reduce it to a single value.
			return arguments.length < 3 ? df.foldr1(a, f) : df.foldr(a, f, z);	// Object
		},
		// the fold's counterpart: unfold
		unfold: function(/*Function|String|Array*/ pr, /*Function|String|Array*/ f,
						/*Function|String|Array*/ g, /*Object*/ z, /*Object?*/ o){
			// summary: builds an array by unfolding a value
			o = o || d.global; f = df.lambda(f); g = df.lambda(g); pr = df.lambda(pr);
			var t = [];
			for(; !pr.call(o, z); t.push(f.call(o, z)), z = g.call(o, z));
			return t;	// Array
		}
	});
})();

}

if(!dojo._hasResource["dojox.lang.functional.reversed"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.functional.reversed"] = true;
dojo.provide("dojox.lang.functional.reversed");



// This module adds high-level functions and related constructs:
//	- reversed versions of array-processing functions similar to standard JS functions

// Notes:
//	- this module provides reversed versions of standard array-processing functions:
//		forEachRev, mapRev, filterRev

// Defined methods:
//	- take any valid lambda argument as the functional argument
//	- operate on dense arrays
//	- take a string as the array argument

(function(){
	var d = dojo, df = dojox.lang.functional;

	d.mixin(df, {
		// JS 1.6 standard array functions, which can take a lambda as a parameter.
		// Consider using dojo._base.array functions, if you don't need the lambda support.
		filterRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: creates a new array with all elements that pass the test
			//	implemented by the provided function.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var t = [], v, i = a.length - 1;
			for(; i >= 0; --i){
				v = a[i];
				if(f.call(o, v, i, a)){ t.push(v); }
			}
			return t;	// Array
		},
		forEachRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: executes a provided function once per array element.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			for(var i = a.length - 1; i >= 0; f.call(o, a[i], i, a), --i);
		},
		mapRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: creates a new array with the results of calling
			//	a provided function on every element in this array.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var n = a.length, t = new Array(n), i = n - 1, j = 0;
			for(; i >= 0; t[j++] = f.call(o, a[i], i, a), --i);
			return t;	// Array
		},
		everyRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: tests whether all elements in the array pass the test
			//	implemented by the provided function.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			for(var i = a.length - 1; i >= 0; --i){
				if(!f.call(o, a[i], i, a)){
					return false;	// Boolean
				}
			}
			return true;	// Boolean
		},
		someRev: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: tests whether some element in the array passes the test
			//	implemented by the provided function.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			for(var i = a.length - 1; i >= 0; --i){
				if(f.call(o, a[i], i, a)){
					return true;	// Boolean
				}
			}
			return false;	// Boolean
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.Element"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.Element"] = true;
dojo.provide("dojox.charting.Element");



dojo.declare("dojox.charting.Element", null, {
	//	summary:
	//		A base class that is used to build other elements of a chart, such as
	//		a series.
	//	chart: dojox.charting.Chart2D
	//		The parent chart for this element.
	//	group: dojox.gfx.Group
	//		The visual GFX group representing this element.
	//	htmlElement: Array
	//		Any DOMNodes used as a part of this element (such as HTML-based labels).
	//	dirty: Boolean
	//		A flag indicating whether or not this element needs to be rendered.

	chart: null,
	group: null,
	htmlElements: null,
	dirty: true,

	constructor: function(chart){
		//	summary:
		//		Creates a new charting element.
		//	chart: dojox.charting.Chart2D
		//		The chart that this element belongs to.
		this.chart = chart;
		this.group = null;
		this.htmlElements = [];
		this.dirty = true;
		this.trailingSymbol = "...";
		this._events = [];
	},
	createGroup: function(creator){
		//	summary:
		//		Convenience function to create a new dojox.gfx.Group.
		//	creator: dojox.gfx.Surface?
		//		An optional surface in which to create this group.
		//	returns: dojox.charting.Element
		//		A reference to this object for functional chaining.
		if(!creator){ creator = this.chart.surface; }
		if(!this.group){
			this.group = creator.createGroup();
		}
		return this;	//	dojox.charting.Element
	},
	purgeGroup: function(){
		//	summary:
		//		Clear any elements out of our group, and destroy the group.
		//	returns: dojox.charting.Element
		//		A reference to this object for functional chaining.
		this.destroyHtmlElements();
		if(this.group){
			this.group.clear();
			this.group.removeShape();
			this.group = null;
		}
		this.dirty = true;
		if(this._events.length){
			dojo.forEach(this._events, function(item){
				item.shape.disconnect(item.handle);
			});
			this._events = [];
		}
		return this;	//	dojox.charting.Element
	},
	cleanGroup: function(creator){
		//	summary:
		//		Clean any elements (HTML or GFX-based) out of our group, and create a new one.
		//	creator: dojox.gfx.Surface?
		//		An optional surface to work with.
		//	returns: dojox.charting.Element
		//		A reference to this object for functional chaining.
		this.destroyHtmlElements();
		if(!creator){ creator = this.chart.surface; }
		if(this.group){
			this.group.clear();
		}else{
			this.group = creator.createGroup();
		}
		this.dirty = true;
		return this;	//	dojox.charting.Element
	},
	destroyHtmlElements: function(){
		//	summary:
		//		Destroy any DOMNodes that may have been created as a part of this element.
		if(this.htmlElements.length){
			dojo.forEach(this.htmlElements, dojo.destroy);
			this.htmlElements = [];
		}
	},
	destroy: function(){
		//	summary:
		//		API addition to conform to the rest of the Dojo Toolkit's standard.
		this.purgeGroup();
	},
	//text utilities
	getTextWidth: function(s, font){
		return dojox.gfx._base._getTextBox(s, {font: font}).w || 0;
	},
	getTextWithLimitLength: function(s, font, limitWidth, truncated){
		//	summary:
		//		Get the truncated string based on the limited width in px(dichotomy algorithm)
		//	s: String?
		//		candidate text.
		//	font: String?
		//		text's font style.
		//	limitWidth: Number?
		//		text limited width in px.
		//	truncated: Boolean?
		//		whether the input text(s) has already been truncated.
		//	returns: Object
		//		{
		//			text: processed text, maybe truncated or not
		//			truncated: whether text has been truncated
		//		}
		if (!s || s.length <= 0) {
			return {
				text: "",
				truncated: truncated || false
			};
		}
		if(!limitWidth || limitWidth <= 0){
			return {
				text: s,
				truncated: truncated || false
			};
		}
		var delta = 2,
			//golden section for dichotomy algorithm
			trucPercentage = 0.618,
			minStr = s.substring(0,1) + this.trailingSymbol,
			minWidth = this.getTextWidth(minStr, font);
		if (limitWidth <= minWidth) {
			return {
				text: minStr,
				truncated: true
			};
		}
		var width = this.getTextWidth(s, font);
		if(width <= limitWidth){
			return {
				text: s,
				truncated: truncated || false
			};
		}else{
			var begin = 0,
				end = s.length;
			while(begin < end){
				if(end - begin <= delta ){
					while (this.getTextWidth(s.substring(0, begin) + this.trailingSymbol, font) > limitWidth) {
						begin -= 1;
					}
					return {
						text: (s.substring(0,begin) + this.trailingSymbol),
						truncated: true
					};
				}
				var index = begin + Math.round((end - begin) * trucPercentage),
					widthIntercepted = this.getTextWidth(s.substring(0, index), font);
				if(widthIntercepted < limitWidth){
					begin = index;
					end = end;
				}else{
					begin = begin;
					end = index;
				}
			}
		}
	},
	getTextWithLimitCharCount: function(s, font, wcLimit, truncated){
		//	summary:
		//		Get the truncated string based on the limited character count(dichotomy algorithm)
		//	s: String?
		//		candidate text.
		//	font: String?
		//		text's font style.
		//	wcLimit: Number?
		//		text limited character count.
		//	truncated: Boolean?
		//		whether the input text(s) has already been truncated.
		//	returns: Object
		//		{
		//			text: processed text, maybe truncated or not
		//			truncated: whether text has been truncated
		//		}
		if (!s || s.length <= 0) {
			return {
				text: "",
				truncated: truncated || false
			};
		}
		if(!wcLimit || wcLimit <= 0 || s.length <= wcLimit){
			return {
				text: s,
				truncated: truncated || false
			};
		}
		return {
			text: s.substring(0, wcLimit) + this.trailingSymbol,
			truncated: true
		};
	},
	// fill utilities
	_plotFill: function(fill, dim, offsets){
		// process a plot-wide fill
		if(!fill || !fill.type || !fill.space){
			return fill;
		}
		var space = fill.space;
		switch(fill.type){
			case "linear":
				if(space === "plot" || space === "shapeX" || space === "shapeY"){
					// clone a fill so we can modify properly directly
					fill = dojox.gfx.makeParameters(dojox.gfx.defaultLinearGradient, fill);
					fill.space = space;
					// process dimensions
					if(space === "plot" || space === "shapeX"){
						// process Y
						var span = dim.height - offsets.t - offsets.b;
						fill.y1 = offsets.t + span * fill.y1 / 100;
						fill.y2 = offsets.t + span * fill.y2 / 100;
					}
					if(space === "plot" || space === "shapeY"){
						// process X
						var span = dim.width - offsets.l - offsets.r;
						fill.x1 = offsets.l + span * fill.x1 / 100;
						fill.x2 = offsets.l + span * fill.x2 / 100;
					}
				}
				break;
			case "radial":
				if(space === "plot"){
					// this one is used exclusively for scatter charts
					// clone a fill so we can modify properly directly
					fill = dojox.gfx.makeParameters(dojox.gfx.defaultRadialGradient, fill);
					fill.space = space;
					// process both dimensions
					var spanX = dim.width  - offsets.l - offsets.r,
						spanY = dim.height - offsets.t - offsets.b;
					fill.cx = offsets.l + spanX * fill.cx / 100;
					fill.cy = offsets.t + spanY * fill.cy / 100;
					fill.r  = fill.r * Math.sqrt(spanX * spanX + spanY * spanY) / 200;
				}
				break;
			case "pattern":
				if(space === "plot" || space === "shapeX" || space === "shapeY"){
					// clone a fill so we can modify properly directly
					fill = dojox.gfx.makeParameters(dojox.gfx.defaultPattern, fill);
					fill.space = space;
					// process dimensions
					if(space === "plot" || space === "shapeX"){
						// process Y
						var span = dim.height - offsets.t - offsets.b;
						fill.y = offsets.t + span * fill.y / 100;
						fill.height = span * fill.height / 100;
					}
					if(space === "plot" || space === "shapeY"){
						// process X
						var span = dim.width - offsets.l - offsets.r;
						fill.x = offsets.l + span * fill.x / 100;
						fill.width = span * fill.width / 100;
					}
				}
				break;
		}
		return fill;
	},
	_shapeFill: function(fill, bbox){
		// process shape-specific fill
		if(!fill || !fill.space){
			return fill;
		}
		var space = fill.space;
		switch(fill.type){
			case "linear":
				if(space === "shape" || space === "shapeX" || space === "shapeY"){
					// clone a fill so we can modify properly directly
					fill = dojox.gfx.makeParameters(dojox.gfx.defaultLinearGradient, fill);
					fill.space = space;
					// process dimensions
					if(space === "shape" || space === "shapeX"){
						// process X
						var span = bbox.width;
						fill.x1 = bbox.x + span * fill.x1 / 100;
						fill.x2 = bbox.x + span * fill.x2 / 100;
					}
					if(space === "shape" || space === "shapeY"){
						// process Y
						var span = bbox.height;
						fill.y1 = bbox.y + span * fill.y1 / 100;
						fill.y2 = bbox.y + span * fill.y2 / 100;
					}
				}
				break;
			case "radial":
				if(space === "shape"){
					// this one is used exclusively for bubble charts and pie charts
					// clone a fill so we can modify properly directly
					fill = dojox.gfx.makeParameters(dojox.gfx.defaultRadialGradient, fill);
					fill.space = space;
					// process both dimensions
					fill.cx = bbox.x + bbox.width  / 2;
					fill.cy = bbox.y + bbox.height / 2;
					fill.r  = fill.r * bbox.width  / 200;
				}
				break;
			case "pattern":
				if(space === "shape" || space === "shapeX" || space === "shapeY"){
					// clone a fill so we can modify properly directly
					fill = dojox.gfx.makeParameters(dojox.gfx.defaultPattern, fill);
					fill.space = space;
					// process dimensions
					if(space === "shape" || space === "shapeX"){
						// process X
						var span = bbox.width;
						fill.x = bbox.x + span * fill.x / 100;
						fill.width = span * fill.width / 100;
					}
					if(space === "shape" || space === "shapeY"){
						// process Y
						var span = bbox.height;
						fill.y = bbox.y + span * fill.y / 100;
						fill.height = span * fill.height / 100;
					}
				}
				break;
		}
		return fill;
	},
	_pseudoRadialFill: function(fill, center, radius, start, end){
		// process pseudo-radial fills
		if(!fill || fill.type !== "radial" || fill.space !== "shape"){
			return fill;
		}
		// clone and normalize fill
		var space = fill.space;
		fill = dojox.gfx.makeParameters(dojox.gfx.defaultRadialGradient, fill);
		fill.space = space;
		if(arguments.length < 4){
			// process both dimensions
			fill.cx = center.x;
			fill.cy = center.y;
			fill.r  = fill.r * radius / 100;
			return fill;
		}
		// convert to a linear gradient
		var angle = arguments.length < 5 ? start : (end + start) / 2;
		return {
			type: "linear",
			x1: center.x,
			y1: center.y,
			x2: center.x + fill.r * radius * Math.cos(angle) / 100,
			y2: center.y + fill.r * radius * Math.sin(angle) / 100,
			colors: fill.colors
		};
		return fill;
	}
});

}

if(!dojo._hasResource["dojo.colors"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.colors"] = true;
dojo.provide("dojo.colors");

dojo.getObject("colors", true, dojo);

//TODO: this module appears to break naming conventions

/*=====
dojo.colors = {
	// summary: Color utilities
}
=====*/

(function(){
	// this is a standard conversion prescribed by the CSS3 Color Module
	var hue2rgb = function(m1, m2, h){
		if(h < 0){ ++h; }
		if(h > 1){ --h; }
		var h6 = 6 * h;
		if(h6 < 1){ return m1 + (m2 - m1) * h6; }
		if(2 * h < 1){ return m2; }
		if(3 * h < 2){ return m1 + (m2 - m1) * (2 / 3 - h) * 6; }
		return m1;
	};
	
	dojo.colorFromRgb = function(/*String*/ color, /*dojo.Color?*/ obj){
		// summary:
		//		get rgb(a) array from css-style color declarations
		// description:
		//		this function can handle all 4 CSS3 Color Module formats: rgb,
		//		rgba, hsl, hsla, including rgb(a) with percentage values.
		var m = color.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
		if(m){
			var c = m[2].split(/\s*,\s*/), l = c.length, t = m[1], a;
			if((t == "rgb" && l == 3) || (t == "rgba" && l == 4)){
				var r = c[0];
				if(r.charAt(r.length - 1) == "%"){
					// 3 rgb percentage values
					a = dojo.map(c, function(x){
						return parseFloat(x) * 2.56;
					});
					if(l == 4){ a[3] = c[3]; }
					return dojo.colorFromArray(a, obj);	// dojo.Color
				}
				return dojo.colorFromArray(c, obj);	// dojo.Color
			}
			if((t == "hsl" && l == 3) || (t == "hsla" && l == 4)){
				// normalize hsl values
				var H = ((parseFloat(c[0]) % 360) + 360) % 360 / 360,
					S = parseFloat(c[1]) / 100,
					L = parseFloat(c[2]) / 100,
					// calculate rgb according to the algorithm
					// recommended by the CSS3 Color Module
					m2 = L <= 0.5 ? L * (S + 1) : L + S - L * S,
					m1 = 2 * L - m2;
				a = [
					hue2rgb(m1, m2, H + 1 / 3) * 256,
					hue2rgb(m1, m2, H) * 256,
					hue2rgb(m1, m2, H - 1 / 3) * 256,
					1
				];
				if(l == 4){ a[3] = c[3]; }
				return dojo.colorFromArray(a, obj);	// dojo.Color
			}
		}
		return null;	// dojo.Color
	};
	
	var confine = function(c, low, high){
		// summary:
		//		sanitize a color component by making sure it is a number,
		//		and clamping it to valid values
		c = Number(c);
		return isNaN(c) ? high : c < low ? low : c > high ? high : c;	// Number
	};
	
	dojo.Color.prototype.sanitize = function(){
		// summary: makes sure that the object has correct attributes
		var t = this;
		t.r = Math.round(confine(t.r, 0, 255));
		t.g = Math.round(confine(t.g, 0, 255));
		t.b = Math.round(confine(t.b, 0, 255));
		t.a = confine(t.a, 0, 1);
		return this;	// dojo.Color
	};
})();


dojo.colors.makeGrey = function(/*Number*/ g, /*Number?*/ a){
	// summary: creates a greyscale color with an optional alpha
	return dojo.colorFromArray([g, g, g, a]);
};

// mixin all CSS3 named colors not already in _base, along with SVG 1.0 variant spellings
dojo.mixin(dojo.Color.named, {
	aliceblue:	[240,248,255],
	antiquewhite:	[250,235,215],
	aquamarine:	[127,255,212],
	azure:	[240,255,255],
	beige:	[245,245,220],
	bisque:	[255,228,196],
	blanchedalmond:	[255,235,205],
	blueviolet:	[138,43,226],
	brown:	[165,42,42],
	burlywood:	[222,184,135],
	cadetblue:	[95,158,160],
	chartreuse:	[127,255,0],
	chocolate:	[210,105,30],
	coral:	[255,127,80],
	cornflowerblue:	[100,149,237],
	cornsilk:	[255,248,220],
	crimson:	[220,20,60],
	cyan:	[0,255,255],
	darkblue:	[0,0,139],
	darkcyan:	[0,139,139],
	darkgoldenrod:	[184,134,11],
	darkgray:	[169,169,169],
	darkgreen:	[0,100,0],
	darkgrey:	[169,169,169],
	darkkhaki:	[189,183,107],
	darkmagenta:	[139,0,139],
	darkolivegreen:	[85,107,47],
	darkorange:	[255,140,0],
	darkorchid:	[153,50,204],
	darkred:	[139,0,0],
	darksalmon:	[233,150,122],
	darkseagreen:	[143,188,143],
	darkslateblue:	[72,61,139],
	darkslategray:	[47,79,79],
	darkslategrey:	[47,79,79],
	darkturquoise:	[0,206,209],
	darkviolet:	[148,0,211],
	deeppink:	[255,20,147],
	deepskyblue:	[0,191,255],
	dimgray:	[105,105,105],
	dimgrey:	[105,105,105],
	dodgerblue:	[30,144,255],
	firebrick:	[178,34,34],
	floralwhite:	[255,250,240],
	forestgreen:	[34,139,34],
	gainsboro:	[220,220,220],
	ghostwhite:	[248,248,255],
	gold:	[255,215,0],
	goldenrod:	[218,165,32],
	greenyellow:	[173,255,47],
	grey:	[128,128,128],
	honeydew:	[240,255,240],
	hotpink:	[255,105,180],
	indianred:	[205,92,92],
	indigo:	[75,0,130],
	ivory:	[255,255,240],
	khaki:	[240,230,140],
	lavender:	[230,230,250],
	lavenderblush:	[255,240,245],
	lawngreen:	[124,252,0],
	lemonchiffon:	[255,250,205],
	lightblue:	[173,216,230],
	lightcoral:	[240,128,128],
	lightcyan:	[224,255,255],
	lightgoldenrodyellow:	[250,250,210],
	lightgray:	[211,211,211],
	lightgreen:	[144,238,144],
	lightgrey:	[211,211,211],
	lightpink:	[255,182,193],
	lightsalmon:	[255,160,122],
	lightseagreen:	[32,178,170],
	lightskyblue:	[135,206,250],
	lightslategray:	[119,136,153],
	lightslategrey:	[119,136,153],
	lightsteelblue:	[176,196,222],
	lightyellow:	[255,255,224],
	limegreen:	[50,205,50],
	linen:	[250,240,230],
	magenta:	[255,0,255],
	mediumaquamarine:	[102,205,170],
	mediumblue:	[0,0,205],
	mediumorchid:	[186,85,211],
	mediumpurple:	[147,112,219],
	mediumseagreen:	[60,179,113],
	mediumslateblue:	[123,104,238],
	mediumspringgreen:	[0,250,154],
	mediumturquoise:	[72,209,204],
	mediumvioletred:	[199,21,133],
	midnightblue:	[25,25,112],
	mintcream:	[245,255,250],
	mistyrose:	[255,228,225],
	moccasin:	[255,228,181],
	navajowhite:	[255,222,173],
	oldlace:	[253,245,230],
	olivedrab:	[107,142,35],
	orange:	[255,165,0],
	orangered:	[255,69,0],
	orchid:	[218,112,214],
	palegoldenrod:	[238,232,170],
	palegreen:	[152,251,152],
	paleturquoise:	[175,238,238],
	palevioletred:	[219,112,147],
	papayawhip:	[255,239,213],
	peachpuff:	[255,218,185],
	peru:	[205,133,63],
	pink:	[255,192,203],
	plum:	[221,160,221],
	powderblue:	[176,224,230],
	rosybrown:	[188,143,143],
	royalblue:	[65,105,225],
	saddlebrown:	[139,69,19],
	salmon:	[250,128,114],
	sandybrown:	[244,164,96],
	seagreen:	[46,139,87],
	seashell:	[255,245,238],
	sienna:	[160,82,45],
	skyblue:	[135,206,235],
	slateblue:	[106,90,205],
	slategray:	[112,128,144],
	slategrey:	[112,128,144],
	snow:	[255,250,250],
	springgreen:	[0,255,127],
	steelblue:	[70,130,180],
	tan:	[210,180,140],
	thistle:	[216,191,216],
	tomato:	[255,99,71],
	transparent: [0, 0, 0, 0],
	turquoise:	[64,224,208],
	violet:	[238,130,238],
	wheat:	[245,222,179],
	whitesmoke:	[245,245,245],
	yellowgreen:	[154,205,50]
});

}

if(!dojo._hasResource["dojox.color._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.color._base"] = true;
dojo.provide("dojox.color._base");


//	alias all the dojo.Color mechanisms
dojox.color.Color=dojo.Color;
dojox.color.blend=dojo.blendColors;
dojox.color.fromRgb=dojo.colorFromRgb;
dojox.color.fromHex=dojo.colorFromHex;
dojox.color.fromArray=dojo.colorFromArray;
dojox.color.fromString=dojo.colorFromString;

//	alias the dojo.colors mechanisms
dojox.color.greyscale=dojo.colors.makeGrey;

//	static methods
dojo.mixin(dojox.color, {
	fromCmy: function(/* Object|Array|int */cyan, /*int*/magenta, /*int*/yellow){
		//	summary
		//	Create a dojox.color.Color from a CMY defined color.
		//	All colors should be expressed as 0-100 (percentage)

		if(dojo.isArray(cyan)){
			magenta=cyan[1], yellow=cyan[2], cyan=cyan[0];
		} else if(dojo.isObject(cyan)){
			magenta=cyan.m, yellow=cyan.y, cyan=cyan.c;
		}
		cyan/=100, magenta/=100, yellow/=100;

		var r=1-cyan, g=1-magenta, b=1-yellow;
		return new dojox.color.Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
	},

	fromCmyk: function(/* Object|Array|int */cyan, /*int*/magenta, /*int*/yellow, /*int*/black){
		//	summary
		//	Create a dojox.color.Color from a CMYK defined color.
		//	All colors should be expressed as 0-100 (percentage)

		if(dojo.isArray(cyan)){
			magenta=cyan[1], yellow=cyan[2], black=cyan[3], cyan=cyan[0];
		} else if(dojo.isObject(cyan)){
			magenta=cyan.m, yellow=cyan.y, black=cyan.b, cyan=cyan.c;
		}
		cyan/=100, magenta/=100, yellow/=100, black/=100;
		var r,g,b;
		r = 1-Math.min(1, cyan*(1-black)+black);
		g = 1-Math.min(1, magenta*(1-black)+black);
		b = 1-Math.min(1, yellow*(1-black)+black);
		return new dojox.color.Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
	},
	
	fromHsl: function(/* Object|Array|int */hue, /* int */saturation, /* int */luminosity){
		//	summary
		//	Create a dojox.color.Color from an HSL defined color.
		//	hue from 0-359 (degrees), saturation and luminosity 0-100.

		if(dojo.isArray(hue)){
			saturation=hue[1], luminosity=hue[2], hue=hue[0];
		} else if(dojo.isObject(hue)){
			saturation=hue.s, luminosity=hue.l, hue=hue.h;
		}
		saturation/=100;
		luminosity/=100;

		while(hue<0){ hue+=360; }
		while(hue>=360){ hue-=360; }
		
		var r, g, b;
		if(hue<120){
			r=(120-hue)/60, g=hue/60, b=0;
		} else if (hue<240){
			r=0, g=(240-hue)/60, b=(hue-120)/60;
		} else {
			r=(hue-240)/60, g=0, b=(360-hue)/60;
		}
		
		r=2*saturation*Math.min(r, 1)+(1-saturation);
		g=2*saturation*Math.min(g, 1)+(1-saturation);
		b=2*saturation*Math.min(b, 1)+(1-saturation);
		if(luminosity<0.5){
			r*=luminosity, g*=luminosity, b*=luminosity;
		}else{
			r=(1-luminosity)*r+2*luminosity-1;
			g=(1-luminosity)*g+2*luminosity-1;
			b=(1-luminosity)*b+2*luminosity-1;
		}
		return new dojox.color.Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
	},
	
	fromHsv: function(/* Object|Array|int */hue, /* int */saturation, /* int */value){
		//	summary
		//	Create a dojox.color.Color from an HSV defined color.
		//	hue from 0-359 (degrees), saturation and value 0-100.

		if(dojo.isArray(hue)){
			saturation=hue[1], value=hue[2], hue=hue[0];
		} else if (dojo.isObject(hue)){
			saturation=hue.s, value=hue.v, hue=hue.h;
		}
		
		if(hue==360){ hue=0; }
		saturation/=100;
		value/=100;
		
		var r, g, b;
		if(saturation==0){
			r=value, b=value, g=value;
		}else{
			var hTemp=hue/60, i=Math.floor(hTemp), f=hTemp-i;
			var p=value*(1-saturation);
			var q=value*(1-(saturation*f));
			var t=value*(1-(saturation*(1-f)));
			switch(i){
				case 0:{ r=value, g=t, b=p; break; }
				case 1:{ r=q, g=value, b=p; break; }
				case 2:{ r=p, g=value, b=t; break; }
				case 3:{ r=p, g=q, b=value; break; }
				case 4:{ r=t, g=p, b=value; break; }
				case 5:{ r=value, g=p, b=q; break; }
			}
		}
		return new dojox.color.Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
	}
});

//	Conversions directly on dojox.color.Color
dojo.extend(dojox.color.Color, {
	toCmy: function(){
		//	summary
		//	Convert this Color to a CMY definition.
		var cyan=1-(this.r/255), magenta=1-(this.g/255), yellow=1-(this.b/255);
		return { c:Math.round(cyan*100), m:Math.round(magenta*100), y:Math.round(yellow*100) };		//	Object
	},
	
	toCmyk: function(){
		//	summary
		//	Convert this Color to a CMYK definition.
		var cyan, magenta, yellow, black;
		var r=this.r/255, g=this.g/255, b=this.b/255;
		black = Math.min(1-r, 1-g, 1-b);
		cyan = (1-r-black)/(1-black);
		magenta = (1-g-black)/(1-black);
		yellow = (1-b-black)/(1-black);
		return { c:Math.round(cyan*100), m:Math.round(magenta*100), y:Math.round(yellow*100), b:Math.round(black*100) };	//	Object
	},
	
	toHsl: function(){
		//	summary
		//	Convert this Color to an HSL definition.
		var r=this.r/255, g=this.g/255, b=this.b/255;
		var min = Math.min(r, b, g), max = Math.max(r, g, b);
		var delta = max-min;
		var h=0, s=0, l=(min+max)/2;
		if(l>0 && l<1){
			s = delta/((l<0.5)?(2*l):(2-2*l));
		}
		if(delta>0){
			if(max==r && max!=g){
				h+=(g-b)/delta;
			}
			if(max==g && max!=b){
				h+=(2+(b-r)/delta);
			}
			if(max==b && max!=r){
				h+=(4+(r-g)/delta);
			}
			h*=60;
		}
		return { h:h, s:Math.round(s*100), l:Math.round(l*100) };	//	Object
	},

	toHsv: function(){
		//	summary
		//	Convert this Color to an HSV definition.
		var r=this.r/255, g=this.g/255, b=this.b/255;
		var min = Math.min(r, b, g), max = Math.max(r, g, b);
		var delta = max-min;
		var h = null, s = (max==0)?0:(delta/max);
		if(s==0){
			h = 0;
		}else{
			if(r==max){
				h = 60*(g-b)/delta;
			}else if(g==max){
				h = 120 + 60*(b-r)/delta;
			}else{
				h = 240 + 60*(r-g)/delta;
			}

			if(h<0){ h+=360; }
		}
		return { h:h, s:Math.round(s*100), v:Math.round(max*100) };	//	Object
	}
});

}

if(!dojo._hasResource["dojox.color"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.color"] = true;
dojo.provide("dojox.color");


}

if(!dojo._hasResource["dojox.color.Palette"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.color.Palette"] = true;
dojo.provide("dojox.color.Palette");


(function(){
	var dxc = dojox.color;
	/***************************************************************
	*	dojox.color.Palette
	*
	*	The Palette object is loosely based on the color palettes
	*	at Kuler (http://kuler.adobe.com).  They are 5 color palettes
	*	with the base color considered to be the third color in the
	*	palette (for generation purposes).
	*
	*	Palettes can be generated from well-known algorithms or they
	* 	can be manually created by passing an array to the constructor.
	*
	*	Palettes can be transformed, using a set of specific params
	*	similar to the way shapes can be transformed with dojox.gfx.
	*	However, unlike with transformations in dojox.gfx, transforming
	* 	a palette will return you a new Palette object, in effect
	* 	a clone of the original.
	***************************************************************/

	//	ctor ----------------------------------------------------------------------------
	dxc.Palette = function(/* String|Array|dojox.color.Color|dojox.color.Palette */base){
		//	summary:
		//		An object that represents a palette of colors.
		//	description:
		//		A Palette is a representation of a set of colors.  While the standard
		//		number of colors contained in a palette is 5, it can really handle any
		//		number of colors.
		//
		//		A palette is useful for the ability to transform all the colors in it
		//		using a simple object-based approach.  In addition, you can generate
		//		palettes using dojox.color.Palette.generate; these generated palettes
		//		are based on the palette generators at http://kuler.adobe.com.
		//
		//	colors: dojox.color.Color[]
		//		The actual color references in this palette.
		this.colors = [];
		if(base instanceof dojox.color.Palette){
			this.colors = base.colors.slice(0);
		}
		else if(base instanceof dojox.color.Color){
			this.colors = [ null, null, base, null, null ];
		}
		else if(dojo.isArray(base)){
			this.colors = dojo.map(base.slice(0), function(item){
				if(dojo.isString(item)){ return new dojox.color.Color(item); }
				return item;
			});
		}
		else if (dojo.isString(base)){
			this.colors = [ null, null, new dojox.color.Color(base), null, null ];
		}
	}

	//	private functions ---------------------------------------------------------------

	//	transformations
	function tRGBA(p, param, val){
		var ret = new dojox.color.Palette();
		ret.colors = [];
		dojo.forEach(p.colors, function(item){
			var r=(param=="dr")?item.r+val:item.r,
				g=(param=="dg")?item.g+val:item.g,
				b=(param=="db")?item.b+val:item.b,
				a=(param=="da")?item.a+val:item.a
			ret.colors.push(new dojox.color.Color({
				r: Math.min(255, Math.max(0, r)),
				g: Math.min(255, Math.max(0, g)),
				b: Math.min(255, Math.max(0, b)),
				a: Math.min(1, Math.max(0, a))
			}));
		});
		return ret;
	}

	function tCMY(p, param, val){
		var ret = new dojox.color.Palette();
		ret.colors = [];
		dojo.forEach(p.colors, function(item){
			var o=item.toCmy(),
				c=(param=="dc")?o.c+val:o.c,
				m=(param=="dm")?o.m+val:o.m,
				y=(param=="dy")?o.y+val:o.y;
			ret.colors.push(dojox.color.fromCmy(
				Math.min(100, Math.max(0, c)),
				Math.min(100, Math.max(0, m)),
				Math.min(100, Math.max(0, y))
			));
		});
		return ret;
	}

	function tCMYK(p, param, val){
		var ret = new dojox.color.Palette();
		ret.colors = [];
		dojo.forEach(p.colors, function(item){
			var o=item.toCmyk(),
				c=(param=="dc")?o.c+val:o.c,
				m=(param=="dm")?o.m+val:o.m,
				y=(param=="dy")?o.y+val:o.y,
				k=(param=="dk")?o.b+val:o.b;
			ret.colors.push(dojox.color.fromCmyk(
				Math.min(100, Math.max(0, c)),
				Math.min(100, Math.max(0, m)),
				Math.min(100, Math.max(0, y)),
				Math.min(100, Math.max(0, k))
			));
		});
		return ret;
	}

	function tHSL(p, param, val){
		var ret = new dojox.color.Palette();
		ret.colors = [];
		dojo.forEach(p.colors, function(item){
			var o=item.toHsl(),
				h=(param=="dh")?o.h+val:o.h,
				s=(param=="ds")?o.s+val:o.s,
				l=(param=="dl")?o.l+val:o.l;
			ret.colors.push(dojox.color.fromHsl(h%360, Math.min(100, Math.max(0, s)), Math.min(100, Math.max(0, l))));
		});
		return ret;
	}

	function tHSV(p, param, val){
		var ret = new dojox.color.Palette();
		ret.colors = [];
		dojo.forEach(p.colors, function(item){
			var o=item.toHsv(),
				h=(param=="dh")?o.h+val:o.h,
				s=(param=="ds")?o.s+val:o.s,
				v=(param=="dv")?o.v+val:o.v;
			ret.colors.push(dojox.color.fromHsv(h%360, Math.min(100, Math.max(0, s)), Math.min(100, Math.max(0, v))));
		});
		return ret;
	}

	//	helper functions
	function rangeDiff(val, low, high){
		//	given the value in a range from 0 to high, find the equiv
		//		using the range low to high.
		return high-((high-val)*((high-low)/high));
	}

	//	object methods ---------------------------------------------------------------
	dojo.extend(dxc.Palette, {
		transform: function(/* dojox.color.Palette.__transformArgs */kwArgs){
			//	summary:
			//		Transform the palette using a specific transformation function
			//		and a set of transformation parameters.
			//	description:
			//		{palette}.transform is a simple way to uniformly transform
			//		all of the colors in a palette using any of 5 formulae:
			//		RGBA, HSL, HSV, CMYK or CMY.
			//
			//		Once the forumula to be used is determined, you can pass any
			//		number of parameters based on the formula "d"[param]; for instance,
			//		{ use: "rgba", dr: 20, dg: -50 } will take all of the colors in
			//		palette, add 20 to the R value and subtract 50 from the G value.
			//
			//		Unlike other types of transformations, transform does *not* alter
			//		the original palette but will instead return a new one.
			var fn=tRGBA;	//	the default transform function.
			if(kwArgs.use){
				//	we are being specific about the algo we want to use.
				var use=kwArgs.use.toLowerCase();
				if(use.indexOf("hs")==0){
					if(use.charAt(2)=="l"){ fn=tHSL; }
					else { fn=tHSV; }
				}
				else if(use.indexOf("cmy")==0){
					if(use.charAt(3)=="k"){ fn=tCMYK; }
					else { fn=tCMY; }
				}
			}
			//	try to guess the best choice.
			else if("dc" in kwArgs || "dm" in kwArgs || "dy" in kwArgs){
				if("dk" in kwArgs){ fn = tCMYK; }
				else { fn = tCMY; }
			}
			else if("dh" in kwArgs || "ds" in kwArgs){
				if("dv" in kwArgs){ fn = tHSV; }
				else { fn = tHSL; }
			}

			var palette = this;
			for(var p in kwArgs){
				//	ignore use
				if(p=="use"){ continue; }
				palette = fn(palette, p, kwArgs[p]);
			}
			return palette;		//	dojox.color.Palette
		},
		clone: function(){
			//	summary:
			//		Clones the current palette.
			return new dxc.Palette(this);	//	dojox.color.Palette
		}
	});

/*=====
dojox.color.Palette.__transformArgs = function(use, dr, dg, db, da, dc, dm, dy, dk, dh, ds, dv, dl){
	//	summary:
	//		The keywords argument to be passed to the dojox.color.Palette.transform function.  Note that
	//		while all arguments are optional, *some* arguments must be passed.  The basic concept is that
	//		you pass a delta value for a specific aspect of a color model (or multiple aspects of the same
	//		color model); for instance, if you wish to transform a palette based on the HSV color model,
	//		you would pass one of "dh", "ds", or "dv" as a value.
	//
	//	use: String?
	//		Specify the color model to use for the transformation.  Can be "rgb", "rgba", "hsv", "hsl", "cmy", "cmyk".
	//	dr: Number?
	//		The delta to be applied to the red aspect of the RGB/RGBA color model.
	//	dg: Number?
	//		The delta to be applied to the green aspect of the RGB/RGBA color model.
	//	db: Number?
	//		The delta to be applied to the blue aspect of the RGB/RGBA color model.
	//	da: Number?
	//		The delta to be applied to the alpha aspect of the RGBA color model.
	//	dc: Number?
	//		The delta to be applied to the cyan aspect of the CMY/CMYK color model.
	//	dm: Number?
	//		The delta to be applied to the magenta aspect of the CMY/CMYK color model.
	//	dy: Number?
	//		The delta to be applied to the yellow aspect of the CMY/CMYK color model.
	//	dk: Number?
	//		The delta to be applied to the black aspect of the CMYK color model.
	//	dh: Number?
	//		The delta to be applied to the hue aspect of the HSL/HSV color model.
	//	ds: Number?
	//		The delta to be applied to the saturation aspect of the HSL/HSV color model.
	//	dl: Number?
	//		The delta to be applied to the luminosity aspect of the HSL color model.
	//	dv: Number?
	//		The delta to be applied to the value aspect of the HSV color model.
	this.use = use;
	this.dr = dr;
	this.dg = dg;
	this.db = db;
	this.da = da;
	this.dc = dc;
	this.dm = dm;
	this.dy = dy;
	this.dk = dk;
	this.dh = dh;
	this.ds = ds;
	this.dl = dl;
	this.dv = dv;
}
dojox.color.Palette.__generatorArgs = function(base){
	//	summary:
	//		The keyword arguments object used to create a palette based on a base color.
	//
	//	base: dojo.Color
	//		The base color to be used to generate the palette.
	this.base = base;
}
dojox.color.Palette.__analogousArgs = function(base, high, low){
	//	summary:
	//		The keyword arguments object that is used to create a 5 color palette based on the
	//		analogous rules as implemented at http://kuler.adobe.com, using the HSV color model.
	//
	//	base: dojo.Color
	//		The base color to be used to generate the palette.
	//	high: Number?
	//		The difference between the hue of the base color and the highest hue.  In degrees, default is 60.
	//	low: Number?
	//		The difference between the hue of the base color and the lowest hue.  In degrees, default is 18.
	this.base = base;
	this.high = high;
	this.low = low;
}
dojox.color.Palette.__splitComplementaryArgs = function(base, da){
	//	summary:
	//		The keyword arguments object used to create a palette based on the split complementary rules
	//		as implemented at http://kuler.adobe.com.
	//
	//	base: dojo.Color
	//		The base color to be used to generate the palette.
	//	da: Number?
	//		The delta angle to be used to determine where the split for the complementary rules happen.
	//		In degrees, the default is 30.
	this.base = base;
	this.da = da;
}
=====*/
	dojo.mixin(dxc.Palette, {
		generators: {
			analogous:function(/* dojox.color.Palette.__analogousArgs */args){
				//	summary:
				//		Create a 5 color palette based on the analogous rules as implemented at
				//		http://kuler.adobe.com.
				var high=args.high||60, 	//	delta between base hue and highest hue (subtracted from base)
					low=args.low||18,		//	delta between base hue and lowest hue (added to base)
					base = dojo.isString(args.base)?new dojox.color.Color(args.base):args.base,
					hsv=base.toHsv();

				//	generate our hue angle differences
				var h=[
					(hsv.h+low+360)%360,
					(hsv.h+Math.round(low/2)+360)%360,
					hsv.h,
					(hsv.h-Math.round(high/2)+360)%360,
					(hsv.h-high+360)%360
				];

				var s1=Math.max(10, (hsv.s<=95)?hsv.s+5:(100-(hsv.s-95))),
					s2=(hsv.s>1)?hsv.s-1:21-hsv.s,
					v1=(hsv.v>=92)?hsv.v-9:Math.max(hsv.v+9, 20),
					v2=(hsv.v<=90)?Math.max(hsv.v+5, 20):(95+Math.ceil((hsv.v-90)/2)),
					s=[ s1, s2, hsv.s, s1, s1 ],
					v=[ v1, v2, hsv.v, v1, v2 ]

				return new dxc.Palette(dojo.map(h, function(hue, i){
					return dojox.color.fromHsv(hue, s[i], v[i]);
				}));		//	dojox.color.Palette
			},

			monochromatic: function(/* dojox.color.Palette.__generatorArgs */args){
				//	summary:
				//		Create a 5 color palette based on the monochromatic rules as implemented at
				//		http://kuler.adobe.com.
				var base = dojo.isString(args.base)?new dojox.color.Color(args.base):args.base,
					hsv = base.toHsv();
				
				//	figure out the saturation and value
				var s1 = (hsv.s-30>9)?hsv.s-30:hsv.s+30,
					s2 = hsv.s,
					v1 = rangeDiff(hsv.v, 20, 100),
					v2 = (hsv.v-20>20)?hsv.v-20:hsv.v+60,
					v3 = (hsv.v-50>20)?hsv.v-50:hsv.v+30;

				return new dxc.Palette([
					dojox.color.fromHsv(hsv.h, s1, v1),
					dojox.color.fromHsv(hsv.h, s2, v3),
					base,
					dojox.color.fromHsv(hsv.h, s1, v3),
					dojox.color.fromHsv(hsv.h, s2, v2)
				]);		//	dojox.color.Palette
			},

			triadic: function(/* dojox.color.Palette.__generatorArgs */args){
				//	summary:
				//		Create a 5 color palette based on the triadic rules as implemented at
				//		http://kuler.adobe.com.
				var base = dojo.isString(args.base)?new dojox.color.Color(args.base):args.base,
					hsv = base.toHsv();

				var h1 = (hsv.h+57+360)%360,
					h2 = (hsv.h-157+360)%360,
					s1 = (hsv.s>20)?hsv.s-10:hsv.s+10,
					s2 = (hsv.s>90)?hsv.s-10:hsv.s+10,
					s3 = (hsv.s>95)?hsv.s-5:hsv.s+5,
					v1 = (hsv.v-20>20)?hsv.v-20:hsv.v+20,
					v2 = (hsv.v-30>20)?hsv.v-30:hsv.v+30,
					v3 = (hsv.v-30>70)?hsv.v-30:hsv.v+30;

				return new dxc.Palette([
					dojox.color.fromHsv(h1, s1, hsv.v),
					dojox.color.fromHsv(hsv.h, s2, v2),
					base,
					dojox.color.fromHsv(h2, s2, v1),
					dojox.color.fromHsv(h2, s3, v3)
				]);		//	dojox.color.Palette
			},

			complementary: function(/* dojox.color.Palette.__generatorArgs */args){
				//	summary:
				//		Create a 5 color palette based on the complementary rules as implemented at
				//		http://kuler.adobe.com.
				var base = dojo.isString(args.base)?new dojox.color.Color(args.base):args.base,
					hsv = base.toHsv();

				var h1 = ((hsv.h*2)+137<360)?(hsv.h*2)+137:Math.floor(hsv.h/2)-137,
					s1 = Math.max(hsv.s-10, 0),
					s2 = rangeDiff(hsv.s, 10, 100),
					s3 = Math.min(100, hsv.s+20),
					v1 = Math.min(100, hsv.v+30),
					v2 = (hsv.v>20)?hsv.v-30:hsv.v+30;

				return new dxc.Palette([
					dojox.color.fromHsv(hsv.h, s1, v1),
					dojox.color.fromHsv(hsv.h, s2, v2),
					base,
					dojox.color.fromHsv(h1, s3, v2),
					dojox.color.fromHsv(h1, hsv.s, hsv.v)
				]);		//	dojox.color.Palette
			},

			splitComplementary: function(/* dojox.color.Palette.__splitComplementaryArgs */args){
				//	summary:
				//		Create a 5 color palette based on the split complementary rules as implemented at
				//		http://kuler.adobe.com.
				var base = dojo.isString(args.base)?new dojox.color.Color(args.base):args.base,
					dangle = args.da || 30,
					hsv = base.toHsv();

				var baseh = ((hsv.h*2)+137<360)?(hsv.h*2)+137:Math.floor(hsv.h/2)-137,
					h1 = (baseh-dangle+360)%360,
					h2 = (baseh+dangle)%360,
					s1 = Math.max(hsv.s-10, 0),
					s2 = rangeDiff(hsv.s, 10, 100),
					s3 = Math.min(100, hsv.s+20),
					v1 = Math.min(100, hsv.v+30),
					v2 = (hsv.v>20)?hsv.v-30:hsv.v+30;

				return new dxc.Palette([
					dojox.color.fromHsv(h1, s1, v1),
					dojox.color.fromHsv(h1, s2, v2),
					base,
					dojox.color.fromHsv(h2, s3, v2),
					dojox.color.fromHsv(h2, hsv.s, hsv.v)
				]);		//	dojox.color.Palette
			},

			compound: function(/* dojox.color.Palette.__generatorArgs */args){
				//	summary:
				//		Create a 5 color palette based on the compound rules as implemented at
				//		http://kuler.adobe.com.
				var base = dojo.isString(args.base)?new dojox.color.Color(args.base):args.base,
					hsv = base.toHsv();

				var h1 = ((hsv.h*2)+18<360)?(hsv.h*2)+18:Math.floor(hsv.h/2)-18,
					h2 = ((hsv.h*2)+120<360)?(hsv.h*2)+120:Math.floor(hsv.h/2)-120,
					h3 = ((hsv.h*2)+99<360)?(hsv.h*2)+99:Math.floor(hsv.h/2)-99,
					s1 = (hsv.s-40>10)?hsv.s-40:hsv.s+40,
					s2 = (hsv.s-10>80)?hsv.s-10:hsv.s+10,
					s3 = (hsv.s-25>10)?hsv.s-25:hsv.s+25,
					v1 = (hsv.v-40>10)?hsv.v-40:hsv.v+40,
					v2 = (hsv.v-20>80)?hsv.v-20:hsv.v+20,
					v3 = Math.max(hsv.v, 20);

				return new dxc.Palette([
					dojox.color.fromHsv(h1, s1, v1),
					dojox.color.fromHsv(h1, s2, v2),
					base,
					dojox.color.fromHsv(h2, s3, v3),
					dojox.color.fromHsv(h3, s2, v2)
				]);		//	dojox.color.Palette
			},

			shades: function(/* dojox.color.Palette.__generatorArgs */args){
				//	summary:
				//		Create a 5 color palette based on the shades rules as implemented at
				//		http://kuler.adobe.com.
				var base = dojo.isString(args.base)?new dojox.color.Color(args.base):args.base,
					hsv = base.toHsv();

				var s  = (hsv.s==100 && hsv.v==0)?0:hsv.s,
					v1 = (hsv.v-50>20)?hsv.v-50:hsv.v+30,
					v2 = (hsv.v-25>=20)?hsv.v-25:hsv.v+55,
					v3 = (hsv.v-75>=20)?hsv.v-75:hsv.v+5,
					v4 = Math.max(hsv.v-10, 20);

				return new dxc.Palette([
					new dojox.color.fromHsv(hsv.h, s, v1),
					new dojox.color.fromHsv(hsv.h, s, v2),
					base,
					new dojox.color.fromHsv(hsv.h, s, v3),
					new dojox.color.fromHsv(hsv.h, s, v4)
				]);		//	dojox.color.Palette
			}
		},
		generate: function(/* String|dojox.color.Color */base, /* Function|String */type){
			//	summary:
			//		Generate a new Palette using any of the named functions in
			//		dojox.color.Palette.generators or an optional function definition.  Current
			//		generators include "analogous", "monochromatic", "triadic", "complementary",
			//		"splitComplementary", and "shades".
			if(dojo.isFunction(type)){
				return type({ base: base });	//	dojox.color.Palette
			}
			else if(dxc.Palette.generators[type]){
				return dxc.Palette.generators[type]({ base: base });	//	dojox.color.Palette
			}
			throw new Error("dojox.color.Palette.generate: the specified generator ('" + type + "') does not exist.");
		}
	});
})();

}

if(!dojo._hasResource["dojox.lang.utils"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.utils"] = true;
dojo.provide("dojox.lang.utils");

(function(){
	var empty = {}, du = dojox.lang.utils, opts = Object.prototype.toString;

	var clone = function(o){
		if(o){
			switch(opts.call(o)){
				case "[object Array]":
					return o.slice(0);
				case "[object Object]":
					return dojo.delegate(o);
			}
		}
		return o;
	}
	
	dojo.mixin(du, {
		coerceType: function(target, source){
			// summary: Coerces one object to the type of another.
			// target: Object: object, which typeof result is used to coerce "source" object.
			// source: Object: object, which will be forced to change type.
			switch(typeof target){
				case "number":	return Number(eval("(" + source + ")"));
				case "string":	return String(source);
				case "boolean":	return Boolean(eval("(" + source + ")"));
			}
			return eval("(" + source + ")");
		},
		
		updateWithObject: function(target, source, conv){
			// summary: Updates an existing object in place with properties from an "source" object.
			// target: Object: the "target" object to be updated
			// source: Object: the "source" object, whose properties will be used to source the existed object.
			// conv: Boolean?: force conversion to the original type
			if(!source){ return target; }
			for(var x in target){
				if(x in source && !(x in empty)){
					var t = target[x];
					if(t && typeof t == "object"){
						du.updateWithObject(t, source[x], conv);
					}else{
						target[x] = conv ? du.coerceType(t, source[x]) : clone(source[x]);
					}
				}
			}
			return target;	// Object
		},
	
		updateWithPattern: function(target, source, pattern, conv){
			// summary: Updates an existing object in place with properties from an "source" object.
			// target: Object: the "target" object to be updated
			// source: Object: the "source" object, whose properties will be used to source the existed object.
			// pattern: Object: object, whose properties will be used to pull values from the "source"
			// conv: Boolean?: force conversion to the original type
			if(!source || !pattern){ return target; }
			for(var x in pattern){
				if(x in source && !(x in empty)){
					target[x] = conv ? du.coerceType(pattern[x], source[x]) : clone(source[x]);
				}
			}
			return target;	// Object
		},
		
		merge: function(object, mixin){
			// summary: Merge two objects structurally, mixin properties will override object's properties.
			// object: Object: original object.
			// mixin: Object: additional object, which properties will override object's properties.
			if(mixin){
				var otype = opts.call(object), mtype = opts.call(mixin), t, i, l, m;
				switch(mtype){
					case "[object Array]":
						if(mtype == otype){
							t = new Array(Math.max(object.length, mixin.length));
							for(i = 0, l = t.length; i < l; ++i){
								t[i] = du.merge(object[i], mixin[i]);
							}
							return t;
						}
						return mixin.slice(0);
					case "[object Object]":
						if(mtype == otype && object){
							t = dojo.delegate(object);
							for(i in mixin){
								if(i in object){
									l = object[i];
									m = mixin[i];
									if(m !== l){
										t[i] = du.merge(l, m);
									}
								}else{
									t[i] = dojo.clone(mixin[i]);
								}
							}
							return t;
						}
						return dojo.clone(mixin);
				}
			}
			return mixin;
		}
	});
})();

}

if(!dojo._hasResource["dojox.gfx.gradutils"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.gfx.gradutils"] = true;
dojo.provide("dojox.gfx.gradutils");



// Various generic utilities to deal with a linear gradient

(function(){
	var d = dojo, m = dojox.gfx.matrix, C = d.Color;
	
	function findColor(o, c){
		if(o <= 0){
			return c[0].color;
		}
		var len = c.length;
		if(o >= 1){
			return c[len - 1].color;
		}
		//TODO: use binary search
		for(var i = 0; i < len; ++i){
			var stop = c[i];
			if(stop.offset >= o){
				if(i){
					var prev = c[i - 1];
					return d.blendColors(new C(prev.color), new C(stop.color),
						(o - prev.offset) / (stop.offset - prev.offset));
				}
				return stop.color;
			}
		}
		return c[len - 1].color;
	}

	dojox.gfx.gradutils.getColor = function(fill, pt){
		// summary:
		//		sample a color from a gradient using a point
		// fill: Object:
		//		fill object
		// pt: dojox.gfx.Point:
		//		point where to sample a color
		var o;
		if(fill){
			switch(fill.type){
				case "linear":
					var angle = Math.atan2(fill.y2 - fill.y1, fill.x2 - fill.x1),
						rotation = m.rotate(-angle),
						projection = m.project(fill.x2 - fill.x1, fill.y2 - fill.y1),
						p = m.multiplyPoint(projection, pt),
						pf1 = m.multiplyPoint(projection, fill.x1, fill.y1),
						pf2 = m.multiplyPoint(projection, fill.x2, fill.y2),
						scale = m.multiplyPoint(rotation, pf2.x - pf1.x, pf2.y - pf1.y).x,
						o = m.multiplyPoint(rotation, p.x - pf1.x, p.y - pf1.y).x / scale;
					break;
				case "radial":
					var dx = pt.x - fill.cx, dy = pt.y - fill.cy,
						o = Math.sqrt(dx * dx + dy * dy) / fill.r;
					break;
			}
			return findColor(o, fill.colors);	// dojo.Color
		}
		// simple color
		return new C(fill || [0, 0, 0, 0]);	// dojo.Color
	};

	dojox.gfx.gradutils.reverse = function(fill){
		// summary:
		//		reverses a gradient
		// fill: Object:
		//		fill object
		if(fill){
			switch(fill.type){
				case "linear":
				case "radial":
					fill = dojo.delegate(fill);
					if(fill.colors){
						var c = fill.colors, l = c.length, i = 0, stop,
							n = fill.colors = new Array(c.length);
						for(; i < l; ++i){
							stop = c[i];
							n[i] = {
								offset: 1 - stop.offset,
								color:  stop.color
							};
						}
						n.sort(function(a, b){ return a.offset - b.offset; });
					}
					break;
			}
		}
		return fill;	// Object
	};
})();

}

if(!dojo._hasResource["dojox.charting.Theme"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.Theme"] = true;
dojo.provide("dojox.charting.Theme");






dojo.declare("dojox.charting.Theme", null, {
	//	summary:
	//		A Theme is a pre-defined object, primarily JSON-based, that makes up the definitions to
	//		style a chart.
	//
	//	description:
	//		While you can set up style definitions on a chart directly (usually through the various add methods
	//		on a dojox.charting.Chart2D object), a Theme simplifies this manual setup by allowing you to
	//		pre-define all of the various visual parameters of each element in a chart.
	//
	//		Most of the properties of a Theme are straight-forward; if something is line-based (such as
	//		an axis or the ticks on an axis), they will be defined using basic stroke parameters.  Likewise,
	//		if an element is primarily block-based (such as the background of a chart), it will be primarily
	//		fill-based.
	//
	//		In addition (for convenience), a Theme definition does not have to contain the entire JSON-based
	//		structure.  Each theme is built on top of a default theme (which serves as the basis for the theme
	//		"GreySkies"), and is mixed into the default theme object.  This allows you to create a theme based,
	//		say, solely on colors for data series.
	//
	//		Defining a new theme is relatively easy; see any of the themes in dojox.charting.themes for examples
	//		on how to define your own.
	//
	//		When you set a theme on a chart, the theme itself is deep-cloned.  This means that you cannot alter
	//		the theme itself after setting the theme value on a chart, and expect it to change your chart.  If you
	//		are looking to make alterations to a theme for a chart, the suggestion would be to create your own
	//		theme, based on the one you want to use, that makes those alterations before it is applied to a chart.
	//
	//		Finally, a Theme contains a number of functions to facilitate rendering operations on a chart--the main
	//		helper of which is the ~next~ method, in which a chart asks for the information for the next data series
	//		to be rendered.
	//
	//		A note on colors:
	//		The Theme constructor was on the use of dojox.color.Palette (in general) for creating a visually distinct
	//		set of colors for usage in a chart.  A palette is usually comprised of 5 different color definitions, and
	//		no more.  If you have a need to render a chart with more than 5 data elements, you can simply "push"
	//		new color definitions into the theme's .color array.  Make sure that you do that with the actual
	//		theme object from a Chart, and not in the theme itself (i.e. either do that before using .setTheme
	//		on a chart).
	//
	//		example:
	//			The default theme (and structure) looks like so:
	//	|	// all objects are structs used directly in dojox.gfx
	//	|	chart:{
	//	|		stroke: null,
	//	|		fill: "white",
	//	|		pageStyle: null // suggested page style as an object suitable for dojo.style()
	//	|	},
	//	|	plotarea:{
	//	|		stroke: null,
	//	|		fill: "white"
	//	|	},
	//	|	axis:{
	//	|		stroke:	{ // the axis itself
	//	|			color: "#333",
	//	|			width: 1
	//	|		},
	//	|		tick: {	// used as a foundation for all ticks
	//	|			color:     "#666",
	//	|			position:  "center",
	//	|			font:      "normal normal normal 7pt Tahoma",	// labels on axis
	//	|			fontColor: "#333"								// color of labels
	//	|		},
	//	|		majorTick:	{ // major ticks on axis, and used for major gridlines
	//	|			width:  1,
	//	|			length: 6
	//	|		},
	//	|		minorTick:	{ // minor ticks on axis, and used for minor gridlines
	//	|			width:  0.8,
	//	|			length: 3
	//	|		},
	//	|		microTick:	{ // minor ticks on axis, and used for minor gridlines
	//	|			width:  0.5,
	//	|			length: 1
	//	|		}
	//	|	},
	//	|	series: {
	//	|		stroke:  {width: 1.5, color: "#333"},		// line
	//	|		outline: {width: 0.1, color: "#ccc"},		// outline
	//	|		//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},
	//	|		shadow: null,								// no shadow
	//	|		fill:    "#ccc",							// fill, if appropriate
	//	|		font:    "normal normal normal 8pt Tahoma",	// if there's a label
	//	|		fontColor: "#000"							// color of labels
	//	|		labelWiring: {width: 1, color: "#ccc"},		// connect marker and target data item(slice, column, bar...)
	//	|	},
	//	|	marker: {	// any markers on a series
	//	|		symbol:  "m-3,3 l3,-6 3,6 z",				// symbol
	//	|		stroke:  {width: 1.5, color: "#333"},		// stroke
	//	|		outline: {width: 0.1, color: "#ccc"},		// outline
	//	|		shadow: null,								// no shadow
	//	|		fill:    "#ccc",							// fill if needed
	//	|		font:    "normal normal normal 8pt Tahoma",	// label
	//	|		fontColor: "#000"
	//	|	}
	//
	//	example:
	//		Defining a new theme is pretty simple:
	//	|	dojox.charting.themes.Grasslands = new dojox.charting.Theme({
	//	|		colors: [ "#70803a", "#dde574", "#788062", "#b1cc5d", "#eff2c2" ]
	//	|	});
	//	|
	//	|	myChart.setTheme(dojox.charting.themes.Grasslands);

	shapeSpaces: {shape: 1, shapeX: 1, shapeY: 1},

	constructor: function(kwArgs){
		//	summary:
		//		Initialize a theme using the keyword arguments.  Note that the arguments
		//		look like the example (above), and may include a few more parameters.
		kwArgs = kwArgs || {};

		// populate theme with defaults updating them if needed
		var def = dojox.charting.Theme.defaultTheme;
		dojo.forEach(["chart", "plotarea", "axis", "series", "marker"], function(name){
			this[name] = dojo.delegate(def[name], kwArgs[name]);
		}, this);

		// personalize theme
		if(kwArgs.seriesThemes && kwArgs.seriesThemes.length){
			this.colors  = null;
			this.seriesThemes = kwArgs.seriesThemes.slice(0);
		}else{
			this.seriesThemes = null;
			this.colors = (kwArgs.colors || dojox.charting.Theme.defaultColors).slice(0);
		}
		this.markerThemes = null;
		if(kwArgs.markerThemes && kwArgs.markerThemes.length){
			this.markerThemes = kwArgs.markerThemes.slice(0);
		}
		this.markers = kwArgs.markers ? dojo.clone(kwArgs.markers) : dojo.delegate(dojox.charting.Theme.defaultMarkers);

		// set flags
		this.noGradConv = kwArgs.noGradConv;
		this.noRadialConv = kwArgs.noRadialConv;
		if(kwArgs.reverseFills){
			this.reverseFills();
		}

		//	private housekeeping
		this._current = 0;
		this._buildMarkerArray();
	},

	clone: function(){
		//	summary:
		//		Clone the current theme.
		//	returns: dojox.charting.Theme
		//		The cloned theme; any alterations made will not affect the original.
		var theme = new dojox.charting.Theme({
			// theme components
			chart: this.chart,
			plotarea: this.plotarea,
			axis: this.axis,
			series: this.series,
			marker: this.marker,
			// individual arrays
			colors: this.colors,
			markers: this.markers,
			seriesThemes: this.seriesThemes,
			markerThemes: this.markerThemes,
			// flags
			noGradConv: this.noGradConv,
			noRadialConv: this.noRadialConv
		});
		// copy custom methods
		dojo.forEach(
			["clone", "clear", "next", "skip", "addMixin", "post", "getTick"],
			function(name){
				if(this.hasOwnProperty(name)){
					theme[name] = this[name];
				}
			},
			this
		);
		return theme;	//	dojox.charting.Theme
	},

	clear: function(){
		//	summary:
		//		Clear and reset the internal pointer to start fresh.
		this._current = 0;
	},

	next: function(elementType, mixin, doPost){
		//	summary:
		//		Get the next color or series theme.
		//	elementType: String?
		//		An optional element type (for use with series themes)
		//	mixin: Object?
		//		An optional object to mix into the theme.
		//	doPost: Boolean?
		//		A flag to post-process the results.
		//	returns: Object
		//		An object of the structure { series, marker, symbol }
		var merge = dojox.lang.utils.merge, series, marker;
		if(this.colors){
			series = dojo.delegate(this.series);
			marker = dojo.delegate(this.marker);
			var color = new dojo.Color(this.colors[this._current % this.colors.length]), old;
			// modify the stroke
			if(series.stroke && series.stroke.color){
				series.stroke = dojo.delegate(series.stroke);
				old = new dojo.Color(series.stroke.color);
				series.stroke.color = new dojo.Color(color);
				series.stroke.color.a = old.a;
			}else{
				series.stroke = {color: color};
			}
			if(marker.stroke && marker.stroke.color){
				marker.stroke = dojo.delegate(marker.stroke);
				old = new dojo.Color(marker.stroke.color);
				marker.stroke.color = new dojo.Color(color);
				marker.stroke.color.a = old.a;
			}else{
				marker.stroke = {color: color};
			}
			// modify the fill
			if(!series.fill || series.fill.type){
				series.fill = color;
			}else{
				old = new dojo.Color(series.fill);
				series.fill = new dojo.Color(color);
				series.fill.a = old.a;
			}
			if(!marker.fill || marker.fill.type){
				marker.fill = color;
			}else{
				old = new dojo.Color(marker.fill);
				marker.fill = new dojo.Color(color);
				marker.fill.a = old.a;
			}
		}else{
			series = this.seriesThemes ?
				merge(this.series, this.seriesThemes[this._current % this.seriesThemes.length]) :
				this.series;
			marker = this.markerThemes ?
				merge(this.marker, this.markerThemes[this._current % this.markerThemes.length]) :
				series;
		}

		var symbol = marker && marker.symbol || this._markers[this._current % this._markers.length];

		var theme = {series: series, marker: marker, symbol: symbol};
		
		// advance the counter
		++this._current;

		if(mixin){
			theme = this.addMixin(theme, elementType, mixin);
		}
		if(doPost){
			theme = this.post(theme, elementType);
		}

		return theme;	//	Object
	},

	skip: function(){
		//	summary:
		//		Skip the next internal color.
		++this._current;
	},

	addMixin: function(theme, elementType, mixin, doPost){
		//	summary:
		//		Add a mixin object to the passed theme and process.
		//	theme: dojox.charting.Theme
		//		The theme to mixin to.
		//	elementType: String
		//		The type of element in question. Can be "line", "bar" or "circle"
		//	mixin: Object|Array
		//		The object or objects to mix into the theme.
		//	doPost: Boolean
		//		If true, run the new theme through the post-processor.
		//	returns: dojox.charting.Theme
		//		The new theme.
		if(dojo.isArray(mixin)){
			dojo.forEach(mixin, function(m){
				theme = this.addMixin(theme, elementType, m);
			}, this);
		}else{
			var t = {};
			if("color" in mixin){
				if(elementType == "line" || elementType == "area"){
					dojo.setObject("series.stroke.color", mixin.color, t);
					dojo.setObject("marker.stroke.color", mixin.color, t);
				}else{
					dojo.setObject("series.fill", mixin.color, t);
				}
			}
			dojo.forEach(["stroke", "outline", "shadow", "fill", "font", "fontColor", "labelWiring"], function(name){
				var markerName = "marker" + name.charAt(0).toUpperCase() + name.substr(1),
					b = markerName in mixin;
				if(name in mixin){
					dojo.setObject("series." + name, mixin[name], t);
					if(!b){
						dojo.setObject("marker." + name, mixin[name], t);
					}
				}
				if(b){
					dojo.setObject("marker." + name, mixin[markerName], t);
				}
			});
			if("marker" in mixin){
				t.symbol = mixin.marker;
			}
			theme = dojox.lang.utils.merge(theme, t);
		}
		if(doPost){
			theme = this.post(theme, elementType);
		}
		return theme;	//	dojox.charting.Theme
	},

	post: function(theme, elementType){
		//	summary:
		//		Process any post-shape fills.
		//	theme: dojox.charting.Theme
		//		The theme to post process with.
		//	elementType: String
		//		The type of element being filled.  Can be "bar" or "circle".
		//	returns: dojox.charting.Theme
		//		The post-processed theme.
		var fill = theme.series.fill, t;
		if(!this.noGradConv && this.shapeSpaces[fill.space] && fill.type == "linear"){
			if(elementType == "bar"){
				// transpose start and end points
				t = {
					x1: fill.y1,
					y1: fill.x1,
					x2: fill.y2,
					y2: fill.x2
				};
			}else if(!this.noRadialConv && fill.space == "shape" && (elementType == "slice" || elementType == "circle")){
				// switch to radial
				t = {
					type: "radial",
					cx: 0,
					cy: 0,
					r:  100
				};
			}
			if(t){
				return dojox.lang.utils.merge(theme, {series: {fill: t}});
			}
		}
		return theme;	//	dojox.charting.Theme
	},

	getTick: function(name, mixin){
		//	summary:
		//		Calculates and merges tick parameters.
		//	name: String
		//		Tick name, can be "major", "minor", or "micro".
		//	mixin: Object?
		//		Optional object to mix in to the tick.
		var tick = this.axis.tick, tickName = name + "Tick";
			merge = dojox.lang.utils.merge;
		if(tick){
			if(this.axis[tickName]){
				tick = merge(tick, this.axis[tickName]);
			}
		}else{
			tick = this.axis[tickName];
		}
		if(mixin){
			if(tick){
				if(mixin[tickName]){
					tick = merge(tick, mixin[tickName]);
				}
			}else{
				tick = mixin[tickName];
			}
		}
		return tick;	//	Object
	},

	inspectObjects: function(f){
		dojo.forEach(["chart", "plotarea", "axis", "series", "marker"], function(name){
			f(this[name]);
		}, this);
		if(this.seriesThemes){
			dojo.forEach(this.seriesThemes, f);
		}
		if(this.markerThemes){
			dojo.forEach(this.markerThemes, f);
		}
	},

	reverseFills: function(){
		this.inspectObjects(function(o){
			if(o && o.fill){
				o.fill = dojox.gfx.gradutils.reverse(o.fill);
			}
		});
	},

	addMarker:function(/*String*/ name, /*String*/ segment){
		//	summary:
		//		Add a custom marker to this theme.
		//	example:
		//	|	myTheme.addMarker("Ellipse", foo);
		this.markers[name] = segment;
		this._buildMarkerArray();
	},

	setMarkers:function(/*Object*/ obj){
		//	summary:
		//		Set all the markers of this theme at once.  obj should be a
		//		dictionary of keys and path segments.
		//
		//	example:
		//	|	myTheme.setMarkers({ "CIRCLE": foo });
		this.markers = obj;
		this._buildMarkerArray();
	},

	_buildMarkerArray: function(){
		this._markers = [];
		for(var p in this.markers){
			this._markers.push(this.markers[p]);
		}
	}
});

/*=====
dojox.charting.Theme.__DefineColorArgs = function(num, colors, hue, saturation, low, high, base, generator){
	//	summary:
	//		The arguments object that can be passed to define colors for a theme.
	//	num: Number?
	//		The number of colors to generate.  Defaults to 5.
	//	colors: String[]|dojo.Color[]?
	//		A pre-defined set of colors; this is passed through to the Theme directly.
	//	hue: Number?
	//		A hue to base the generated colors from (a number from 0 - 359).
	//	saturation: Number?
	//		If a hue is passed, this is used for the saturation value (0 - 100).
	//	low: Number?
	//		An optional value to determine the lowest value used to generate a color (HSV model)
	//	high: Number?
	//		An optional value to determine the highest value used to generate a color (HSV model)
	//	base: String|dojo.Color?
	//		A base color to use if we are defining colors using dojox.color.Palette
	//	generator: String?
	//		The generator function name from dojox.color.Palette.
	this.num = num;
	this.colors = colors;
	this.hue = hue;
	this.saturation = saturation;
	this.low = low;
	this.high = high;
	this.base = base;
	this.generator = generator;
}
=====*/
dojo.mixin(dojox.charting.Theme, {
	defaultMarkers: {
		CIRCLE:   "m-3,0 c0,-4 6,-4 6,0 m-6,0 c0,4 6,4 6,0",
		SQUARE:   "m-3,-3 l0,6 6,0 0,-6 z",
		DIAMOND:  "m0,-3 l3,3 -3,3 -3,-3 z",
		CROSS:    "m0,-3 l0,6 m-3,-3 l6,0",
		X:        "m-3,-3 l6,6 m0,-6 l-6,6",
		TRIANGLE: "m-3,3 l3,-6 3,6 z",
		TRIANGLE_INVERTED: "m-3,-3 l3,6 3,-6 z"
	},

	defaultColors:[
		// gray skies
		"#54544c", "#858e94", "#6e767a", "#948585", "#474747"
	],

	defaultTheme: {
		// all objects are structs used directly in dojox.gfx
		chart:{
			stroke: null,
			fill: "white",
			pageStyle: null,
			titleGap:		20,
			titlePos:		"top",
			titleFont:      "normal normal bold 14pt Tahoma",	// labels on axis
			titleFontColor: "#333"
		},
		plotarea:{
			stroke: null,
			fill: "white"
		},
		// TODO: label rotation on axis
		axis:{
			stroke:	{ // the axis itself
				color: "#333",
				width: 1
			},
			tick: {	// used as a foundation for all ticks
				color:     "#666",
				position:  "center",
				font:      "normal normal normal 7pt Tahoma",	// labels on axis
				fontColor: "#333",								// color of labels
				titleGap:  15,
				titleFont: "normal normal normal 11pt Tahoma",	// labels on axis
				titleFontColor: "#333",							// color of labels
				titleOrientation: "axis"						// "axis": facing the axis, "away": facing away
			},
			majorTick:	{ // major ticks on axis, and used for major gridlines
				width:  1,
				length: 6
			},
			minorTick:	{ // minor ticks on axis, and used for minor gridlines
				width:  0.8,
				length: 3
			},
			microTick:	{ // minor ticks on axis, and used for minor gridlines
				width:  0.5,
				length: 1
			}
		},
		series: {
			// used as a "main" theme for series, sThemes augment it
			stroke:  {width: 1.5, color: "#333"},		// line
			outline: {width: 0.1, color: "#ccc"},		// outline
			//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},
			shadow: null,								// no shadow
			fill:    "#ccc",							// fill, if appropriate
			font:    "normal normal normal 8pt Tahoma",	// if there's a label
			fontColor: "#000",							// color of labels
			labelWiring: {width: 1, color: "#ccc"}		// connect marker and target data item(slice, column, bar...)
		},
		marker: {	// any markers on a series
			stroke:  {width: 1.5, color: "#333"},		// stroke
			outline: {width: 0.1, color: "#ccc"},		// outline
			//shadow:  {dx: 1, dy: 1, width: 2, color: [0, 0, 0, 0.3]},
			shadow: null,								// no shadow
			fill:    "#ccc",							// fill if needed
			font:    "normal normal normal 8pt Tahoma",	// label
			fontColor: "#000"
		}
	},

	defineColors: function(kwArgs){
		//	summary:
		//		Generate a set of colors for the theme based on keyword
		//		arguments.
		//	kwArgs: dojox.charting.Theme.__DefineColorArgs
		//		The arguments object used to define colors.
		//	returns: dojo.Color[]
		//		An array of colors for use in a theme.
		//
		//	example:
		//	|	var colors = dojox.charting.Theme.defineColors({
		//	|		base: "#369",
		//	|		generator: "compound"
		//	|	});
		//
		//	example:
		//	|	var colors = dojox.charting.Theme.defineColors({
		//	|		hue: 60,
		//	|		saturation: 90,
		//	|		low: 30,
		//	|		high: 80
		//	|	});
		kwArgs = kwArgs || {};
		var c = [], n = kwArgs.num || 5;	// the number of colors to generate
		if(kwArgs.colors){
			// we have an array of colors predefined, so fix for the number of series.
			var l = kwArgs.colors.length;
			for(var i = 0; i < n; i++){
				c.push(kwArgs.colors[i % l]);
			}
			return c;	//	dojo.Color[]
		}
		if(kwArgs.hue){
			// single hue, generate a set based on brightness
			var s = kwArgs.saturation || 100;	// saturation
			var st = kwArgs.low || 30;
			var end = kwArgs.high || 90;
			// we'd like it to be a little on the darker side.
			var l = (end + st) / 2;
			// alternately, use "shades"
			return dojox.color.Palette.generate(
				dojox.color.fromHsv(kwArgs.hue, s, l), "monochromatic"
			).colors;
		}
		if(kwArgs.generator){
			//	pass a base color and the name of a generator
			return dojox.color.Palette.generate(kwArgs.base, kwArgs.generator).colors;
		}
		return c;	//	dojo.Color[]
	},
	
	generateGradient: function(fillPattern, colorFrom, colorTo){
		var fill = dojo.delegate(fillPattern);
		fill.colors = [
			{offset: 0, color: colorFrom},
			{offset: 1, color: colorTo}
		];
		return fill;
	},
	
	generateHslColor: function(color, luminance){
		color = new dojox.color.Color(color);
		var hsl    = color.toHsl(),
			result = dojox.color.fromHsl(hsl.h, hsl.s, luminance);
		result.a = color.a;	// add missing opacity
		return result;
	},

	generateHslGradient: function(color, fillPattern, lumFrom, lumTo){
		color = new dojox.color.Color(color);
		var hsl       = color.toHsl(),
			colorFrom = dojox.color.fromHsl(hsl.h, hsl.s, lumFrom),
			colorTo   = dojox.color.fromHsl(hsl.h, hsl.s, lumTo);
		colorFrom.a = colorTo.a = color.a;	// add missing opacity
		return dojox.charting.Theme.generateGradient(fillPattern, colorFrom, colorTo);	// Object
	}
});

}

if(!dojo._hasResource["dojox.charting.Series"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.Series"] = true;
dojo.provide("dojox.charting.Series");


/*=====
dojox.charting.__SeriesCtorArgs = function(plot){
	//	summary:
	//		An optional arguments object that can be used in the Series constructor.
	//	plot: String?
	//		The plot (by name) that this series belongs to.
	this.plot = plot;
}
=====*/
dojo.declare("dojox.charting.Series", dojox.charting.Element, {
	//	summary:
	//		An object representing a series of data for plotting on a chart.
	constructor: function(chart, data, kwArgs){
		//	summary:
		//		Create a new data series object for use within charting.
		//	chart: dojox.charting.Chart2D
		//		The chart that this series belongs to.
		//	data: Array|Object:
		//		The array of data points (either numbers or objects) that
		//		represents the data to be drawn. Or it can be an object. In
		//		the latter case, it should have a property "data" (an array),
		//		destroy(), and setSeriesObject().
		//	kwArgs: dojox.charting.__SeriesCtorArgs?
		//		An optional keyword arguments object to set details for this series.
		dojo.mixin(this, kwArgs);
		if(typeof this.plot != "string"){ this.plot = "default"; }
		this.update(data);
	},

	clear: function(){
		//	summary:
		//		Clear the calculated additional parameters set on this series.
		this.dyn = {};
	},
	
	update: function(data){
		//	summary:
		//		Set data and make this object dirty, so it can be redrawn.
		//	data: Array|Object:
		//		The array of data points (either numbers or objects) that
		//		represents the data to be drawn. Or it can be an object. In
		//		the latter case, it should have a property "data" (an array),
		//		destroy(), and setSeriesObject().
		if(dojo.isArray(data)){
			this.data = data;
		}else{
			this.source = data;
			this.data = this.source.data;
			if(this.source.setSeriesObject){
				this.source.setSeriesObject(this);
			}
		}
		this.dirty = true;
		this.clear();
	}
});

}

if(!dojo._hasResource["dojox.charting.axis2d.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.axis2d.common"] = true;
dojo.provide("dojox.charting.axis2d.common");



(function(){
	var g = dojox.gfx;

	var clearNode = function(s){
		s.marginLeft   = "0px";
		s.marginTop    = "0px";
		s.marginRight  = "0px";
		s.marginBottom = "0px";
		s.paddingLeft   = "0px";
		s.paddingTop    = "0px";
		s.paddingRight  = "0px";
		s.paddingBottom = "0px";
		s.borderLeftWidth   = "0px";
		s.borderTopWidth    = "0px";
		s.borderRightWidth  = "0px";
		s.borderBottomWidth = "0px";
	};

	var getBoxWidth = function(n){
		// marginBox is incredibly slow, so avoid it if we can
		if(n["getBoundingClientRect"]){
			var bcr = n.getBoundingClientRect();
			return bcr.width || (bcr.right - bcr.left);
		}else{
			return dojo.marginBox(n).w;
		}
	};

	dojo.mixin(dojox.charting.axis2d.common, {
		//	summary:
		//		Common methods to be used by any axis.  This is considered "static".
		createText: {
			gfx: function(chart, creator, x, y, align, text, font, fontColor){
				//	summary:
				//		Use dojox.gfx to create any text.
				//	chart: dojox.charting.Chart2D
				//		The chart to create the text into.
				//	creator: dojox.gfx.Surface
				//		The graphics surface to use for creating the text.
				//	x: Number
				//		Where to create the text along the x axis (CSS left).
				//	y: Number
				//		Where to create the text along the y axis (CSS top).
				//	align: String
				//		How to align the text.  Can be "left", "right", "center".
				//	text: String
				//		The text to render.
				//	font: String
				//		The font definition, a la CSS "font".
				//	fontColor: String|dojo.Color
				//		The color of the resultant text.
				//	returns: dojox.gfx.Text
				//		The resultant GFX object.
				return creator.createText({
					x: x, y: y, text: text, align: align
				}).setFont(font).setFill(fontColor);	//	dojox.gfx.Text
			},
			html: function(chart, creator, x, y, align, text, font, fontColor, labelWidth){
				//	summary:
				//		Use the HTML DOM to create any text.
				//	chart: dojox.charting.Chart2D
				//		The chart to create the text into.
				//	creator: dojox.gfx.Surface
				//		The graphics surface to use for creating the text.
				//	x: Number
				//		Where to create the text along the x axis (CSS left).
				//	y: Number
				//		Where to create the text along the y axis (CSS top).
				//	align: String
				//		How to align the text.  Can be "left", "right", "center".
				//	text: String
				//		The text to render.
				//	font: String
				//		The font definition, a la CSS "font".
				//	fontColor: String|dojo.Color
				//		The color of the resultant text.
				//	labelWidth: Number?
				//		The maximum width of the resultant DOM node.
				//	returns: DOMNode
				//		The resultant DOMNode (a "div" element).

				// setup the text node
				var p = dojo.doc.createElement("div"), s = p.style, boxWidth;
				clearNode(s);
				s.font = font;
				p.innerHTML = String(text).replace(/\s/g, "&nbsp;");
				s.color = fontColor;
				// measure the size
				s.position = "absolute";
				s.left = "-10000px";
				dojo.body().appendChild(p);
				var size = g.normalizedLength(g.splitFontString(font).size);

				// do we need to calculate the label width?
				if(!labelWidth){
					boxWidth = getBoxWidth(p);
				}

				// new settings for the text node
				dojo.body().removeChild(p);

				s.position = "relative";
				if(labelWidth){
					s.width = labelWidth + "px";
					// s.border = "1px dotted grey";
					switch(align){
						case "middle":
							s.textAlign = "center";
							s.left = (x - labelWidth / 2) + "px";
							break;
						case "end":
							s.textAlign = "right";
							s.left = (x - labelWidth) + "px";
							break;
						default:
							s.left = x + "px";
							s.textAlign = "left";
							break;
					}
				}else{
					switch(align){
						case "middle":
							s.left = Math.floor(x - boxWidth / 2) + "px";
							// s.left = Math.floor(x - p.offsetWidth / 2) + "px";
							break;
						case "end":
							s.left = Math.floor(x - boxWidth) + "px";
							// s.left = Math.floor(x - p.offsetWidth) + "px";
							break;
						//case "start":
						default:
							s.left = Math.floor(x) + "px";
							break;
					}
				}
				s.top = Math.floor(y - size) + "px";
				s.whiteSpace = "nowrap";	// hack for WebKit
				// setup the wrapper node
				var wrap = dojo.doc.createElement("div"), w = wrap.style;
				clearNode(w);
				w.width = "0px";
				w.height = "0px";
				// insert nodes
				wrap.appendChild(p)
				chart.node.insertBefore(wrap, chart.node.firstChild);
				return wrap;	//	DOMNode
			}
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.Chart"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.Chart"] = true;
dojo.provide("dojox.charting.Chart");











/*=====
dojox.charting.__ChartCtorArgs = function(margins, stroke, fill, delayInMs){
	//	summary:
	//		The keyword arguments that can be passed in a Chart constructor.
	//
	//	margins: Object?
	//		Optional margins for the chart, in the form of { l, t, r, b}.
	//	stroke: dojox.gfx.Stroke?
	//		An optional outline/stroke for the chart.
	//	fill: dojox.gfx.Fill?
	//		An optional fill for the chart.
	//	delayInMs: Number
	//		Delay in ms for delayedRender(). Default: 200.
	this.margins = margins;
	this.stroke = stroke;
	this.fill = fill;
	this.delayInMs = delayInMs;
}
 =====*/
(function(){
	var df = dojox.lang.functional, dc = dojox.charting, g = dojox.gfx,
		clear = df.lambda("item.clear()"),
		purge = df.lambda("item.purgeGroup()"),
		destroy = df.lambda("item.destroy()"),
		makeClean = df.lambda("item.dirty = false"),
		makeDirty = df.lambda("item.dirty = true"),
		getName = df.lambda("item.name");

	dojo.declare("dojox.charting.Chart", null, {
		//	summary:
		//		The main chart object in dojox.charting.  This will create a two dimensional
		//		chart based on dojox.gfx.
		//
		//	description:
		//		dojox.charting.Chart is the primary object used for any kind of charts.  It
		//		is simple to create--just pass it a node reference, which is used as the
		//		container for the chart--and a set of optional keyword arguments and go.
		//
		//		Note that like most of dojox.gfx, most of dojox.charting.Chart's methods are
		//		designed to return a reference to the chart itself, to allow for functional
		//		chaining.  This makes defining everything on a Chart very easy to do.
		//
		//	example:
		//		Create an area chart, with smoothing.
		//	|	new dojox.charting.Chart(node))
		//	|		.addPlot("default", { type: "Areas", tension: "X" })
		//	|		.setTheme(dojox.charting.themes.Shrooms)
		//	|		.addSeries("Series A", [1, 2, 0.5, 1.5, 1, 2.8, 0.4])
		//	|		.addSeries("Series B", [2.6, 1.8, 2, 1, 1.4, 0.7, 2])
		//	|		.addSeries("Series C", [6.3, 1.8, 3, 0.5, 4.4, 2.7, 2])
		//	|		.render();
		//
		//	example:
		//		The form of data in a data series can take a number of forms: a simple array,
		//		an array of objects {x,y}, or something custom (as determined by the plot).
		//		Here's an example of a Candlestick chart, which expects an object of
		//		{ open, high, low, close }.
		//	|	new dojox.charting.Chart(node))
		//	|		.addPlot("default", {type: "Candlesticks", gap: 1})
		//	|		.addAxis("x", {fixLower: "major", fixUpper: "major", includeZero: true})
		//	|		.addAxis("y", {vertical: true, fixLower: "major", fixUpper: "major", natural: true})
		//	|		.addSeries("Series A", [
		//	|				{ open: 20, close: 16, high: 22, low: 8 },
		//	|				{ open: 16, close: 22, high: 26, low: 6, mid: 18 },
		//	|				{ open: 22, close: 18, high: 22, low: 11, mid: 21 },
		//	|				{ open: 18, close: 29, high: 32, low: 14, mid: 27 },
		//	|				{ open: 29, close: 24, high: 29, low: 13, mid: 27 },
		//	|				{ open: 24, close: 8, high: 24, low: 5 },
		//	|				{ open: 8, close: 16, high: 22, low: 2 },
		//	|				{ open: 16, close: 12, high: 19, low: 7 },
		//	|				{ open: 12, close: 20, high: 22, low: 8 },
		//	|				{ open: 20, close: 16, high: 22, low: 8 },
		//	|				{ open: 16, close: 22, high: 26, low: 6, mid: 18 },
		//	|				{ open: 22, close: 18, high: 22, low: 11, mid: 21 },
		//	|				{ open: 18, close: 29, high: 32, low: 14, mid: 27 },
		//	|				{ open: 29, close: 24, high: 29, low: 13, mid: 27 },
		//	|				{ open: 24, close: 8, high: 24, low: 5 },
		//	|				{ open: 8, close: 16, high: 22, low: 2 },
		//	|				{ open: 16, close: 12, high: 19, low: 7 },
		//	|				{ open: 12, close: 20, high: 22, low: 8 },
		//	|				{ open: 20, close: 16, high: 22, low: 8 },
		//	|				{ open: 16, close: 22, high: 26, low: 6 },
		//	|				{ open: 22, close: 18, high: 22, low: 11 },
		//	|				{ open: 18, close: 29, high: 32, low: 14 },
		//	|				{ open: 29, close: 24, high: 29, low: 13 },
		//	|				{ open: 24, close: 8, high: 24, low: 5 },
		//	|				{ open: 8, close: 16, high: 22, low: 2 },
		//	|				{ open: 16, close: 12, high: 19, low: 7 },
		//	|				{ open: 12, close: 20, high: 22, low: 8 },
		//	|				{ open: 20, close: 16, high: 22, low: 8 }
		//	|			],
		//	|			{ stroke: { color: "green" }, fill: "lightgreen" }
		//	|		)
		//	|		.render();
		//
		//	theme: dojox.charting.Theme?
		//		An optional theme to use for styling the chart.
		//	axes: dojox.charting.Axis{}?
		//		A map of axes for use in plotting a chart.
		//	stack: dojox.charting.plot2d.Base[]
		//		A stack of plotters.
		//	plots: dojox.charting.plot2d.Base{}
		//		A map of plotter indices
		//	series: dojox.charting.Series[]
		//		The stack of data runs used to create plots.
		//	runs: dojox.charting.Series{}
		//		A map of series indices
		//	margins: Object?
		//		The margins around the chart. Default is { l:10, t:10, r:10, b:10 }.
		//	stroke: dojox.gfx.Stroke?
		//		The outline of the chart (stroke in vector graphics terms).
		//	fill: dojox.gfx.Fill?
		//		The color for the chart.
		//	node: DOMNode
		//		The container node passed to the constructor.
		//	surface: dojox.gfx.Surface
		//		The main graphics surface upon which a chart is drawn.
		//	dirty: Boolean
		//		A boolean flag indicating whether or not the chart needs to be updated/re-rendered.
		//	coords: Object
		//		The coordinates on a page of the containing node, as returned from dojo.coords.

		constructor: function(/* DOMNode */node, /* dojox.charting.__ChartCtorArgs? */kwArgs){
			//	summary:
			//		The constructor for a new Chart.  Initializes all parameters used for a chart.
			//	returns: dojox.charting.Chart
			//		The newly created chart.

			// initialize parameters
			if(!kwArgs){ kwArgs = {}; }
			this.margins   = kwArgs.margins ? kwArgs.margins : {l: 10, t: 10, r: 10, b: 10};
			this.stroke    = kwArgs.stroke;
			this.fill      = kwArgs.fill;
			this.delayInMs = kwArgs.delayInMs || 200;
			this.title     = kwArgs.title;
			this.titleGap  = kwArgs.titleGap;
			this.titlePos  = kwArgs.titlePos;
			this.titleFont = kwArgs.titleFont;
			this.titleFontColor = kwArgs.titleFontColor;
			this.chartTitle = null;

			// default initialization
			this.theme = null;
			this.axes = {};		// map of axes
			this.stack = [];	// stack of plotters
			this.plots = {};	// map of plotter indices
			this.series = [];	// stack of data runs
			this.runs = {};		// map of data run indices
			this.dirty = true;
			this.coords = null;

			// create a surface
			this.node = dojo.byId(node);
			var box = dojo.marginBox(node);
			this.surface = g.createSurface(this.node, box.w || 400, box.h || 300);
		},
		destroy: function(){
			//	summary:
			//		Cleanup when a chart is to be destroyed.
			//	returns: void
			dojo.forEach(this.series, destroy);
			dojo.forEach(this.stack,  destroy);
			df.forIn(this.axes, destroy);
            if(this.chartTitle && this.chartTitle.tagName){
                // destroy title if it is a DOM node
			    dojo.destroy(this.chartTitle);
            }
			this.surface.destroy();
		},
		getCoords: function(){
			//	summary:
			//		Get the coordinates and dimensions of the containing DOMNode, as
			//		returned by dojo.coords.
			//	returns: Object
			//		The resulting coordinates of the chart.  See dojo.coords for details.
			if(!this.coords){
				this.coords = dojo.coords(this.node, true);
			}
			return this.coords;	//	Object
		},
		setTheme: function(theme){
			//	summary:
			//		Set a theme of the chart.
			//	theme: dojox.charting.Theme
			//		The theme to be used for visual rendering.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			this.theme = theme.clone();
			this.dirty = true;
			return this;	//	dojox.charting.Chart
		},
		addAxis: function(name, kwArgs){
			//	summary:
			//		Add an axis to the chart, for rendering.
			//	name: String
			//		The name of the axis.
			//	kwArgs: dojox.charting.axis2d.__AxisCtorArgs?
			//		An optional keyword arguments object for use in defining details of an axis.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
            var axis, axisType = kwArgs && kwArgs.type || "Default";
            if(typeof axisType == "string"){
                if(!dc.axis2d || !dc.axis2d[axisType]){
                    throw Error("Can't find axis: " + axisType + " - didn't you forget to dojo" + ".require() it?");
                }
                axis = new dc.axis2d[axisType](this, kwArgs);
            }else{
                axis = new axisType(this, kwArgs);
            }
			axis.name = name;
			axis.dirty = true;
			if(name in this.axes){
				this.axes[name].destroy();
			}
			this.axes[name] = axis;
			this.dirty = true;
			return this;	//	dojox.charting.Chart
		},
		getAxis: function(name){
			//	summary:
			//		Get the given axis, by name.
			//	name: String
			//		The name the axis was defined by.
			//	returns: dojox.charting.axis2d.Default
			//		The axis as stored in the chart's axis map.
			return this.axes[name];	//	dojox.charting.axis2d.Default
		},
		removeAxis: function(name){
			//	summary:
			//		Remove the axis that was defined using name.
			//	name: String
			//		The axis name, as defined in addAxis.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.axes){
				// destroy the axis
				this.axes[name].destroy();
				delete this.axes[name];
				// mark the chart as dirty
				this.dirty = true;
			}
			return this;	//	dojox.charting.Chart
		},
		addPlot: function(name, kwArgs){
			//	summary:
			//		Add a new plot to the chart, defined by name and using the optional keyword arguments object.
			//		Note that dojox.charting assumes the main plot to be called "default"; if you do not have
			//		a plot called "default" and attempt to add data series to the chart without specifying the
			//		plot to be rendered on, you WILL get errors.
			//	name: String
			//		The name of the plot to be added to the chart.  If you only plan on using one plot, call it "default".
			//	kwArgs: dojox.charting.plot2d.__PlotCtorArgs
			//		An object with optional parameters for the plot in question.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			var plot, plotType = kwArgs && kwArgs.type || "Default";
            if(typeof plotType == "string"){
                if(!dc.plot2d || !dc.plot2d[plotType]){
                    throw Error("Can't find plot: " + plotType + " - didn't you forget to dojo" + ".require() it?");
                }
                plot = new dc.plot2d[plotType](this, kwArgs);
            }else{
                plot = new plotType(this, kwArgs);
            }
			plot.name = name;
			plot.dirty = true;
			if(name in this.plots){
				this.stack[this.plots[name]].destroy();
				this.stack[this.plots[name]] = plot;
			}else{
				this.plots[name] = this.stack.length;
				this.stack.push(plot);
			}
			this.dirty = true;
			return this;	//	dojox.charting.Chart
		},
		removePlot: function(name){
			//	summary:
			//		Remove the plot defined using name from the chart's plot stack.
			//	name: String
			//		The name of the plot as defined using addPlot.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.plots){
				// get the index and remove the name
				var index = this.plots[name];
				delete this.plots[name];
				// destroy the plot
				this.stack[index].destroy();
				// remove the plot from the stack
				this.stack.splice(index, 1);
				// update indices to reflect the shift
				df.forIn(this.plots, function(idx, name, plots){
					if(idx > index){
						plots[name] = idx - 1;
					}
				});
                // remove all related series
                var ns = dojo.filter(this.series, function(run){ return run.plot != name; });
                if(ns.length < this.series.length){
                    // kill all removed series
                    dojo.forEach(this.series, function(run){
                        if(run.plot == name){
                            run.destroy();
                        }
                    });
                    // rebuild all necessary data structures
                    this.runs = {};
                    dojo.forEach(ns, function(run, index){
                        this.runs[run.plot] = index;
                    }, this);
                    this.series = ns;
                }
				// mark the chart as dirty
				this.dirty = true;
			}
			return this;	//	dojox.charting.Chart
		},
		getPlotOrder: function(){
			//	summary:
			//		Returns an array of plot names in the current order
			//		(the top-most plot is the first).
			//	returns: Array
			return df.map(this.stack, getName); // Array
		},
		setPlotOrder: function(newOrder){
			//	summary:
			//		Sets new order of plots. newOrder cannot add or remove
			//		plots. Wrong names, or dups are ignored.
			//	newOrder: Array:
			//		Array of plot names compatible with getPlotOrder().
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			var names = {},
				order = df.filter(newOrder, function(name){
					if(!(name in this.plots) || (name in names)){
						return false;
					}
					names[name] = 1;
					return true;
				}, this);
			if(order.length < this.stack.length){
				df.forEach(this.stack, function(plot){
					var name = plot.name;
					if(!(name in names)){
						order.push(name);
					}
				});
			}
			var newStack = df.map(order, function(name){
					return this.stack[this.plots[name]];
				}, this);
			df.forEach(newStack, function(plot, i){
				this.plots[plot.name] = i;
			}, this);
			this.stack = newStack;
			this.dirty = true;
			return this;	//	dojox.charting.Chart
		},
		movePlotToFront: function(name){
			//	summary:
			//		Moves a given plot to front.
			//	name: String:
			//		Plot's name to move.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.plots){
				var index = this.plots[name];
				if(index){
					var newOrder = this.getPlotOrder();
					newOrder.splice(index, 1);
					newOrder.unshift(name);
					return this.setPlotOrder(newOrder);	//	dojox.charting.Chart
				}
			}
			return this;	//	dojox.charting.Chart
		},
		movePlotToBack: function(name){
			//	summary:
			//		Moves a given plot to back.
			//	name: String:
			//		Plot's name to move.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.plots){
				var index = this.plots[name];
				if(index < this.stack.length - 1){
					var newOrder = this.getPlotOrder();
					newOrder.splice(index, 1);
					newOrder.push(name);
					return this.setPlotOrder(newOrder);	//	dojox.charting.Chart
				}
			}
			return this;	//	dojox.charting.Chart
		},
		addSeries: function(name, data, kwArgs){
			//	summary:
			//		Add a data series to the chart for rendering.
			//	name: String:
			//		The name of the data series to be plotted.
			//	data: Array|Object:
			//		The array of data points (either numbers or objects) that
			//		represents the data to be drawn. Or it can be an object. In
			//		the latter case, it should have a property "data" (an array),
			//		destroy(), and setSeriesObject().
			//	kwArgs: dojox.charting.__SeriesCtorArgs?:
			//		An optional keyword arguments object that will be mixed into
			//		the resultant series object.
			//	returns: dojox.charting.Chart:
			//		A reference to the current chart for functional chaining.
			var run = new dc.Series(this, data, kwArgs);
			run.name = name;
			if(name in this.runs){
				this.series[this.runs[name]].destroy();
				this.series[this.runs[name]] = run;
			}else{
				this.runs[name] = this.series.length;
				this.series.push(run);
			}
			this.dirty = true;
			// fix min/max
			if(!("ymin" in run) && "min" in run){ run.ymin = run.min; }
			if(!("ymax" in run) && "max" in run){ run.ymax = run.max; }
			return this;	//	dojox.charting.Chart
		},
		removeSeries: function(name){
			//	summary:
			//		Remove the series defined by name from the chart.
			//	name: String
			//		The name of the series as defined by addSeries.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.runs){
				// get the index and remove the name
				var index = this.runs[name];
				delete this.runs[name];
				// destroy the run
				this.series[index].destroy();
				// remove the run from the stack of series
				this.series.splice(index, 1);
				// update indices to reflect the shift
				df.forIn(this.runs, function(idx, name, runs){
					if(idx > index){
						runs[name] = idx - 1;
					}
				});
				this.dirty = true;
			}
			return this;	//	dojox.charting.Chart
		},
		updateSeries: function(name, data){
			//	summary:
			//		Update the given series with a new set of data points.
			//	name: String
			//		The name of the series as defined in addSeries.
			//	data: Array|Object:
			//		The array of data points (either numbers or objects) that
			//		represents the data to be drawn. Or it can be an object. In
			//		the latter case, it should have a property "data" (an array),
			//		destroy(), and setSeriesObject().
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.runs){
				var run = this.series[this.runs[name]];
				run.update(data);
				this._invalidateDependentPlots(run.plot, false);
				this._invalidateDependentPlots(run.plot, true);
			}
			return this;	//	dojox.charting.Chart
		},
		getSeriesOrder: function(plotName){
			//	summary:
			//		Returns an array of series names in the current order
			//		(the top-most series is the first) within a plot.
			//	plotName: String:
			//		Plot's name.
			//	returns: Array
			return df.map(df.filter(this.series, function(run){
					return run.plot == plotName;
				}), getName);
		},
		setSeriesOrder: function(newOrder){
			//	summary:
			//		Sets new order of series within a plot. newOrder cannot add
			//		or remove series. Wrong names, or dups are ignored.
			//	newOrder: Array:
			//		Array of series names compatible with getPlotOrder(). All
			//		series should belong to the same plot.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			var plotName, names = {},
				order = df.filter(newOrder, function(name){
					if(!(name in this.runs) || (name in names)){
						return false;
					}
					var run = this.series[this.runs[name]];
					if(plotName){
						if(run.plot != plotName){
							return false;
						}
					}else{
						plotName = run.plot;
					}
					names[name] = 1;
					return true;
				}, this);
			df.forEach(this.series, function(run){
				var name = run.name;
				if(!(name in names) && run.plot == plotName){
					order.push(name);
				}
			});
			var newSeries = df.map(order, function(name){
					return this.series[this.runs[name]];
				}, this);
			this.series = newSeries.concat(df.filter(this.series, function(run){
				return run.plot != plotName;
			}));
			df.forEach(this.series, function(run, i){
				this.runs[run.name] = i;
			}, this);
			this.dirty = true;
			return this;	//	dojox.charting.Chart
		},
		moveSeriesToFront: function(name){
			//	summary:
			//		Moves a given series to front of a plot.
			//	name: String:
			//		Series' name to move.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.runs){
				var index = this.runs[name],
					newOrder = this.getSeriesOrder(this.series[index].plot);
				if(name != newOrder[0]){
					newOrder.splice(index, 1);
					newOrder.unshift(name);
					return this.setSeriesOrder(newOrder);	//	dojox.charting.Chart
				}
			}
			return this;	//	dojox.charting.Chart
		},
		moveSeriesToBack: function(name){
			//	summary:
			//		Moves a given series to back of a plot.
			//	name: String:
			//		Series' name to move.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(name in this.runs){
				var index = this.runs[name],
					newOrder = this.getSeriesOrder(this.series[index].plot);
				if(name != newOrder[newOrder.length - 1]){
					newOrder.splice(index, 1);
					newOrder.push(name);
					return this.setSeriesOrder(newOrder);	//	dojox.charting.Chart
				}
			}
			return this;	//	dojox.charting.Chart
		},
		resize: function(width, height){
			//	summary:
			//		Resize the chart to the dimensions of width and height.
			//	description:
			//		Resize the chart and its surface to the width and height dimensions.
			//		If no width/height or box is provided, resize the surface to the marginBox of the chart.
			//	width: Number
			//		The new width of the chart.
			//	height: Number
			//		The new height of the chart.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			var box;
			switch(arguments.length){
				// case 0, do not resize the div, just the surface
				case 1:
					// argument, override node box
					box = dojo.mixin({}, width);
					dojo.marginBox(this.node, box);
					break;
				case 2:
					box = {w: width, h: height};
					// argument, override node box
					dojo.marginBox(this.node, box);
					break;
			}
			// in all cases take back the computed box
			box = dojo.marginBox(this.node);
			// and set it on the surface
			this.surface.setDimensions(box.w, box.h);
			this.dirty = true;
			this.coords = null;
			return this.render();	//	dojox.charting.Chart
		},
		getGeometry: function(){
			//	summary:
			//		Returns a map of information about all axes in a chart and what they represent
			//		in terms of scaling (see dojox.charting.axis2d.Default.getScaler).
			//	returns: Object
			//		An map of geometry objects, a one-to-one mapping of axes.
			var ret = {};
			df.forIn(this.axes, function(axis){
				if(axis.initialized()){
					ret[axis.name] = {
						name:		axis.name,
						vertical:	axis.vertical,
						scaler:		axis.scaler,
						ticks:		axis.ticks
					};
				}
			});
			return ret;	//	Object
		},
		setAxisWindow: function(name, scale, offset, zoom){
			//	summary:
			//		Zooms an axis and all dependent plots. Can be used to zoom in 1D.
			//	name: String
			//		The name of the axis as defined by addAxis.
			//	scale: Number
			//		The scale on the target axis.
			//	offset: Number
			//		Any offest, as measured by axis tick
			//	zoom: Boolean|Object?
			//		The chart zooming animation trigger.  This is null by default,
			//		e.g. {duration: 1200}, or just set true.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			var axis = this.axes[name];
			if(axis){
				axis.setWindow(scale, offset);
				dojo.forEach(this.stack,function(plot){
					if(plot.hAxis == name || plot.vAxis == name){
						plot.zoom = zoom;
					}
				})
			}
			return this;	//	dojox.charting.Chart
		},
		setWindow: function(sx, sy, dx, dy, zoom){
			//	summary:
			//		Zooms in or out any plots in two dimensions.
			//	sx: Number
			//		The scale for the x axis.
			//	sy: Number
			//		The scale for the y axis.
			//	dx: Number
			//		The pixel offset on the x axis.
			//	dy: Number
			//		The pixel offset on the y axis.
			//	zoom: Boolean|Object?
			//		The chart zooming animation trigger.  This is null by default,
			//		e.g. {duration: 1200}, or just set true.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(!("plotArea" in this)){
				this.calculateGeometry();
			}
			df.forIn(this.axes, function(axis){
				var scale, offset, bounds = axis.getScaler().bounds,
					s = bounds.span / (bounds.upper - bounds.lower);
				if(axis.vertical){
					scale  = sy;
					offset = dy / s / scale;
				}else{
					scale  = sx;
					offset = dx / s / scale;
				}
				axis.setWindow(scale, offset);
			});
			dojo.forEach(this.stack, function(plot){ plot.zoom = zoom; });
			return this;	//	dojox.charting.Chart
		},
		zoomIn:	function(name, range){
			//	summary:
			//		Zoom the chart to a specific range on one axis.  This calls render()
			//		directly as a convenience method.
			//	name: String
			//		The name of the axis as defined by addAxis.
			//	range: Array
			//		The end points of the zoom range, measured in axis ticks.
			var axis = this.axes[name];
			if(axis){
				var scale, offset, bounds = axis.getScaler().bounds;
				var lower = Math.min(range[0],range[1]);
				var upper = Math.max(range[0],range[1]);
				lower = range[0] < bounds.lower ? bounds.lower : lower;
				upper = range[1] > bounds.upper ? bounds.upper : upper;
				scale = (bounds.upper - bounds.lower) / (upper - lower);
				offset = lower - bounds.lower;
				this.setAxisWindow(name, scale, offset);
				this.render();
			}
		},
		calculateGeometry: function(){
			//	summary:
			//		Calculate the geometry of the chart based on the defined axes of
			//		a chart.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(this.dirty){
				return this.fullGeometry();
			}

			// calculate geometry
			var dirty = dojo.filter(this.stack, function(plot){
					return plot.dirty ||
						(plot.hAxis && this.axes[plot.hAxis].dirty) ||
						(plot.vAxis && this.axes[plot.vAxis].dirty);
				}, this);
			calculateAxes(dirty, this.plotArea);

			return this;	//	dojox.charting.Chart
		},
		fullGeometry: function(){
			//	summary:
			//		Calculate the full geometry of the chart.  This includes passing
			//		over all major elements of a chart (plots, axes, series, container)
			//		in order to ensure proper rendering.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			this._makeDirty();

			// clear old values
			dojo.forEach(this.stack, clear);

			// rebuild new connections, and add defaults

			// set up a theme
			if(!this.theme){
				this.setTheme(new dojox.charting.Theme(dojox.charting._def));
			}

			// assign series
			dojo.forEach(this.series, function(run){
				if(!(run.plot in this.plots)){
                    if(!dc.plot2d || !dc.plot2d.Default){
                        throw Error("Can't find plot: Default - didn't you forget to dojo" + ".require() it?");
                    }
					var plot = new dc.plot2d.Default(this, {});
					plot.name = run.plot;
					this.plots[run.plot] = this.stack.length;
					this.stack.push(plot);
				}
				this.stack[this.plots[run.plot]].addSeries(run);
			}, this);
			// assign axes
			dojo.forEach(this.stack, function(plot){
				if(plot.hAxis){
					plot.setAxis(this.axes[plot.hAxis]);
				}
				if(plot.vAxis){
					plot.setAxis(this.axes[plot.vAxis]);
				}
			}, this);

			// calculate geometry

			// 1st pass
			var dim = this.dim = this.surface.getDimensions();
			dim.width  = g.normalizedLength(dim.width);
			dim.height = g.normalizedLength(dim.height);
			df.forIn(this.axes, clear);
			calculateAxes(this.stack, dim);

			// assumption: we don't have stacked axes yet
			var offsets = this.offsets = { l: 0, r: 0, t: 0, b: 0 };
			df.forIn(this.axes, function(axis){
				df.forIn(axis.getOffsets(), function(o, i){ offsets[i] += o; });
			});
			// add title area
			if(this.title){
				this.titleGap = (this.titleGap==0) ? 0 : this.titleGap || this.theme.chart.titleGap || 20;
				this.titlePos = this.titlePos || this.theme.chart.titlePos || "top";
				this.titleFont = this.titleFont || this.theme.chart.titleFont;
				this.titleFontColor = this.titleFontColor || this.theme.chart.titleFontColor || "black";
				var tsize = g.normalizedLength(g.splitFontString(this.titleFont).size);
				offsets[this.titlePos=="top" ? "t":"b"] += (tsize + this.titleGap);
			}
			// add margins
			df.forIn(this.margins, function(o, i){ offsets[i] += o; });

			// 2nd pass with realistic dimensions
			this.plotArea = {
				width: dim.width - offsets.l - offsets.r,
				height: dim.height - offsets.t - offsets.b
			};
			df.forIn(this.axes, clear);
			calculateAxes(this.stack, this.plotArea);

			return this;	//	dojox.charting.Chart
		},
		render: function(){
			//	summary:
			//		Render the chart according to the current information defined.  This should
			//		be the last call made when defining/creating a chart, or if data within the
			//		chart has been changed.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(this.theme){
				this.theme.clear();
			}

			if(this.dirty){
				return this.fullRender();
			}

			this.calculateGeometry();

			// go over the stack backwards
			df.forEachRev(this.stack, function(plot){ plot.render(this.dim, this.offsets); }, this);

			// go over axes
			df.forIn(this.axes, function(axis){ axis.render(this.dim, this.offsets); }, this);

			this._makeClean();

			// BEGIN FOR HTML CANVAS
			if(this.surface.render){ this.surface.render(); };
			// END FOR HTML CANVAS

			return this;	//	dojox.charting.Chart
		},
		fullRender: function(){
			//	summary:
			//		Force a full rendering of the chart, including full resets on the chart itself.
			//		You should not call this method directly unless absolutely necessary.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.

			// calculate geometry
			this.fullGeometry();
			var offsets = this.offsets, dim = this.dim, rect;

			// get required colors
			//var requiredColors = df.foldl(this.stack, "z + plot.getRequiredColors()", 0);
			//this.theme.defineColors({num: requiredColors, cache: false});

			// clear old shapes
			dojo.forEach(this.series, purge);
			df.forIn(this.axes, purge);
			dojo.forEach(this.stack,  purge);
            if(this.chartTitle && this.chartTitle.tagName){
                // destroy title if it is a DOM node
			    dojo.destroy(this.chartTitle);
            }
			this.surface.clear();
            this.chartTitle = null;

			// generate shapes

			// draw a plot background
			var t = this.theme,
				fill   = t.plotarea && t.plotarea.fill,
				stroke = t.plotarea && t.plotarea.stroke,
				rect = {
					x: offsets.l - 1, y: offsets.t - 1,
					width:  dim.width  - offsets.l - offsets.r + 2,
					height: dim.height - offsets.t - offsets.b + 2
				};
			if(fill){
				fill = dc.Element.prototype._shapeFill(dc.Element.prototype._plotFill(fill, dim, offsets), rect);
				this.surface.createRect(rect).setFill(fill);
			}
			if(stroke){
				this.surface.createRect({
					x: offsets.l, y: offsets.t,
					width:  dim.width  - offsets.l - offsets.r + 1,
					height: dim.height - offsets.t - offsets.b + 1
				}).setStroke(stroke);
			}

			// go over the stack backwards
			df.foldr(this.stack, function(z, plot){ return plot.render(dim, offsets), 0; }, 0);

			// pseudo-clipping: matting
			fill   = this.fill   !== undefined ? this.fill   : (t.chart && t.chart.fill);
			stroke = this.stroke !== undefined ? this.stroke : (t.chart && t.chart.stroke);

			//	TRT: support for "inherit" as a named value in a theme.
			if(fill == "inherit"){
				//	find the background color of the nearest ancestor node, and use that explicitly.
				var node = this.node, fill = new dojo.Color(dojo.style(node, "backgroundColor"));
				while(fill.a==0 && node!=document.documentElement){
					fill = new dojo.Color(dojo.style(node, "backgroundColor"));
					node = node.parentNode;
				}
			}

			if(fill){
				fill = dc.Element.prototype._plotFill(fill, dim, offsets);
				if(offsets.l){	// left
					rect = {
						width:  offsets.l,
						height: dim.height + 1
					};
					this.surface.createRect(rect).setFill(dc.Element.prototype._shapeFill(fill, rect));
				}
				if(offsets.r){	// right
					rect = {
						x: dim.width - offsets.r,
						width:  offsets.r + 1,
						height: dim.height + 2
					};
					this.surface.createRect(rect).setFill(dc.Element.prototype._shapeFill(fill, rect));
				}
				if(offsets.t){	// top
					rect = {
						width:  dim.width + 1,
						height: offsets.t
					};
					this.surface.createRect(rect).setFill(dc.Element.prototype._shapeFill(fill, rect));
				}
				if(offsets.b){	// bottom
					rect = {
						y: dim.height - offsets.b,
						width:  dim.width + 1,
						height: offsets.b + 2
					};
					this.surface.createRect(rect).setFill(dc.Element.prototype._shapeFill(fill, rect));
				}
			}
			if(stroke){
				this.surface.createRect({
					width:  dim.width - 1,
					height: dim.height - 1
				}).setStroke(stroke);
			}

			//create title: Whether to make chart title as a widget which extends dojox.charting.Element?
			if(this.title){
				var forceHtmlLabels = (g.renderer == "canvas"),
					labelType = forceHtmlLabels || !dojo.isIE && !dojo.isOpera ? "html" : "gfx",
					tsize = g.normalizedLength(g.splitFontString(this.titleFont).size);
				this.chartTitle = dc.axis2d.common.createText[labelType](
					this,
					this.surface,
					dim.width/2,
					this.titlePos=="top" ? tsize + this.margins.t : dim.height - this.margins.b,
					"middle",
					this.title,
					this.titleFont,
					this.titleFontColor
				);
			}

			// go over axes
			df.forIn(this.axes, function(axis){ axis.render(dim, offsets); });

			this._makeClean();

			// BEGIN FOR HTML CANVAS
			if(this.surface.render){ this.surface.render(); };
			// END FOR HTML CANVAS

			return this;	//	dojox.charting.Chart
		},
		delayedRender: function(){
			//	summary:
			//		Delayed render, which is used to collect multiple updates
			//		within a delayInMs time window.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.

			if(!this._delayedRenderHandle){
				this._delayedRenderHandle = setTimeout(
					dojo.hitch(this, function(){
						clearTimeout(this._delayedRenderHandle);
						this._delayedRenderHandle = null;
						this.render();
					}),
					this.delayInMs
				);
			}

			return this;	//	dojox.charting.Chart
		},
		connectToPlot: function(name, object, method){
			//	summary:
			//		A convenience method to connect a function to a plot.
			//	name: String
			//		The name of the plot as defined by addPlot.
			//	object: Object
			//		The object to be connected.
			//	method: Function
			//		The function to be executed.
			//	returns: Array
			//		A handle to the connection, as defined by dojo.connect (see dojo.connect).
			return name in this.plots ? this.stack[this.plots[name]].connect(object, method) : null;	//	Array
		},
		fireEvent: function(seriesName, eventName, index){
			//	summary:
			//		Fires a synthetic event for a series item.
			//	seriesName: String:
			//		Series name.
			//	eventName: String:
			//		Event name to simulate: onmouseover, onmouseout, onclick.
			//	index: Number:
			//		Valid data value index for the event.
			//	returns: dojox.charting.Chart
			//		A reference to the current chart for functional chaining.
			if(seriesName in this.runs){
				var plotName = this.series[this.runs[seriesName]].plot;
				if(plotName in this.plots){
					var plot = this.stack[this.plots[plotName]];
					if(plot){
						plot.fireEvent(seriesName, eventName, index);
					}
				}
			}
			return this;	//	dojox.charting.Chart
		},
		_makeClean: function(){
			// reset dirty flags
			dojo.forEach(this.axes,   makeClean);
			dojo.forEach(this.stack,  makeClean);
			dojo.forEach(this.series, makeClean);
			this.dirty = false;
		},
		_makeDirty: function(){
			// reset dirty flags
			dojo.forEach(this.axes,   makeDirty);
			dojo.forEach(this.stack,  makeDirty);
			dojo.forEach(this.series, makeDirty);
			this.dirty = true;
		},
		_invalidateDependentPlots: function(plotName, /* Boolean */ verticalAxis){
			if(plotName in this.plots){
				var plot = this.stack[this.plots[plotName]], axis,
					axisName = verticalAxis ? "vAxis" : "hAxis";
				if(plot[axisName]){
					axis = this.axes[plot[axisName]];
					if(axis && axis.dependOnData()){
						axis.dirty = true;
						// find all plots and mark them dirty
						dojo.forEach(this.stack, function(p){
							if(p[axisName] && p[axisName] == plot[axisName]){
								p.dirty = true;
							}
						});
					}
				}else{
					plot.dirty = true;
				}
			}
		}
	});

	function hSection(stats){
		return {min: stats.hmin, max: stats.hmax};
	}

	function vSection(stats){
		return {min: stats.vmin, max: stats.vmax};
	}

	function hReplace(stats, h){
		stats.hmin = h.min;
		stats.hmax = h.max;
	}

	function vReplace(stats, v){
		stats.vmin = v.min;
		stats.vmax = v.max;
	}

	function combineStats(target, source){
		if(target && source){
			target.min = Math.min(target.min, source.min);
			target.max = Math.max(target.max, source.max);
		}
		return target || source;
	}

	function calculateAxes(stack, plotArea){
		var plots = {}, axes = {};
		dojo.forEach(stack, function(plot){
			var stats = plots[plot.name] = plot.getSeriesStats();
			if(plot.hAxis){
				axes[plot.hAxis] = combineStats(axes[plot.hAxis], hSection(stats));
			}
			if(plot.vAxis){
				axes[plot.vAxis] = combineStats(axes[plot.vAxis], vSection(stats));
			}
		});
		dojo.forEach(stack, function(plot){
			var stats = plots[plot.name];
			if(plot.hAxis){
				hReplace(stats, axes[plot.hAxis]);
			}
			if(plot.vAxis){
				vReplace(stats, axes[plot.vAxis]);
			}
			plot.initializeScalers(plotArea, stats);
		});
	}
})();

}

if(!dojo._hasResource["dojox.charting.scaler.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.scaler.common"] = true;
dojo.provide("dojox.charting.scaler.common");

(function(){
	var eq = function(/*Number*/ a, /*Number*/ b){
		// summary: compare two FP numbers for equality
		return Math.abs(a - b) <= 1e-6 * (Math.abs(a) + Math.abs(b));	// Boolean
	};
	
	dojo.mixin(dojox.charting.scaler.common, {
		findString: function(/*String*/ val, /*Array*/ text){
			val = val.toLowerCase();
			for(var i = 0; i < text.length; ++i){
				if(val == text[i]){ return true; }
			}
			return false;
		},
		getNumericLabel: function(/*Number*/ number, /*Number*/ precision, /*Object*/ kwArgs){
			var def = "";
			if(dojo.number){
				def = (kwArgs.fixed ? dojo.number.format(number, {places : precision < 0 ? -precision : 0}) :
					dojo.number.format(number)) || "";
			}else{
				def = kwArgs.fixed ? number.toFixed(precision < 0 ? -precision : 0) : number.toString();
			}
			if(kwArgs.labelFunc){
				var r = kwArgs.labelFunc(def, number, precision);
				if(r){ return r; }
				// else fall through to the regular labels search
			}
			if(kwArgs.labels){
				// classic binary search
				var l = kwArgs.labels, lo = 0, hi = l.length;
				while(lo < hi){
					var mid = Math.floor((lo + hi) / 2), val = l[mid].value;
					if(val < number){
						lo = mid + 1;
					}else{
						hi = mid;
					}
				}
				// lets take into account FP errors
				if(lo < l.length && eq(l[lo].value, number)){
					return l[lo].text;
				}
				--lo;
				if(lo >= 0 && lo < l.length && eq(l[lo].value, number)){
					return l[lo].text;
				}
				lo += 2;
				if(lo < l.length && eq(l[lo].value, number)){
					return l[lo].text;
				}
				// otherwise we will produce a number
			}
			return def;
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.scaler.linear"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.scaler.linear"] = true;
dojo.provide("dojox.charting.scaler.linear");


(function(){
	var deltaLimit = 3,	// pixels
		dc = dojox.charting, dcs = dc.scaler, dcsc = dcs.common,
		findString = dcsc.findString,
		getLabel = dcsc.getNumericLabel;
	
	var calcTicks = function(min, max, kwArgs, majorTick, minorTick, microTick, span){
		kwArgs = dojo.delegate(kwArgs);
		if(!majorTick){
			if(kwArgs.fixUpper == "major"){ kwArgs.fixUpper = "minor"; }
			if(kwArgs.fixLower == "major"){ kwArgs.fixLower = "minor"; }
		}
		if(!minorTick){
			if(kwArgs.fixUpper == "minor"){ kwArgs.fixUpper = "micro"; }
			if(kwArgs.fixLower == "minor"){ kwArgs.fixLower = "micro"; }
		}
		if(!microTick){
			if(kwArgs.fixUpper == "micro"){ kwArgs.fixUpper = "none"; }
			if(kwArgs.fixLower == "micro"){ kwArgs.fixLower = "none"; }
		}
		var lowerBound = findString(kwArgs.fixLower, ["major"]) ?
				Math.floor(kwArgs.min / majorTick) * majorTick :
					findString(kwArgs.fixLower, ["minor"]) ?
						Math.floor(kwArgs.min / minorTick) * minorTick :
							findString(kwArgs.fixLower, ["micro"]) ?
								Math.floor(kwArgs.min / microTick) * microTick : kwArgs.min,
			upperBound = findString(kwArgs.fixUpper, ["major"]) ?
				Math.ceil(kwArgs.max / majorTick) * majorTick :
					findString(kwArgs.fixUpper, ["minor"]) ?
						Math.ceil(kwArgs.max / minorTick) * minorTick :
							findString(kwArgs.fixUpper, ["micro"]) ?
								Math.ceil(kwArgs.max / microTick) * microTick : kwArgs.max;
								
		if(kwArgs.useMin){ min = lowerBound; }
		if(kwArgs.useMax){ max = upperBound; }
		
		var majorStart = (!majorTick || kwArgs.useMin && findString(kwArgs.fixLower, ["major"])) ?
				min : Math.ceil(min / majorTick) * majorTick,
			minorStart = (!minorTick || kwArgs.useMin && findString(kwArgs.fixLower, ["major", "minor"])) ?
				min : Math.ceil(min / minorTick) * minorTick,
			microStart = (! microTick || kwArgs.useMin && findString(kwArgs.fixLower, ["major", "minor", "micro"])) ?
				min : Math.ceil(min / microTick) * microTick,
			majorCount = !majorTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, ["major"]) ?
				Math.round((max - majorStart) / majorTick) :
				Math.floor((max - majorStart) / majorTick)) + 1,
			minorCount = !minorTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, ["major", "minor"]) ?
				Math.round((max - minorStart) / minorTick) :
				Math.floor((max - minorStart) / minorTick)) + 1,
			microCount = !microTick ? 0 : (kwArgs.useMax && findString(kwArgs.fixUpper, ["major", "minor", "micro"]) ?
				Math.round((max - microStart) / microTick) :
				Math.floor((max - microStart) / microTick)) + 1,
			minorPerMajor  = minorTick ? Math.round(majorTick / minorTick) : 0,
			microPerMinor  = microTick ? Math.round(minorTick / microTick) : 0,
			majorPrecision = majorTick ? Math.floor(Math.log(majorTick) / Math.LN10) : 0,
			minorPrecision = minorTick ? Math.floor(Math.log(minorTick) / Math.LN10) : 0,
			scale = span / (max - min);
		if(!isFinite(scale)){ scale = 1; }
		
		return {
			bounds: {
				lower:	lowerBound,
				upper:	upperBound,
				from:	min,
				to:		max,
				scale:	scale,
				span:	span
			},
			major: {
				tick:	majorTick,
				start:	majorStart,
				count:	majorCount,
				prec:	majorPrecision
			},
			minor: {
				tick:	minorTick,
				start:	minorStart,
				count:	minorCount,
				prec:	minorPrecision
			},
			micro: {
				tick:	microTick,
				start:	microStart,
				count:	microCount,
				prec:	0
			},
			minorPerMajor:	minorPerMajor,
			microPerMinor:	microPerMinor,
			scaler:			dcs.linear
		};
	};
	
	dojo.mixin(dojox.charting.scaler.linear, {
		buildScaler: function(/*Number*/ min, /*Number*/ max, /*Number*/ span, /*Object*/ kwArgs){
			var h = {fixUpper: "none", fixLower: "none", natural: false};
			if(kwArgs){
				if("fixUpper" in kwArgs){ h.fixUpper = String(kwArgs.fixUpper); }
				if("fixLower" in kwArgs){ h.fixLower = String(kwArgs.fixLower); }
				if("natural"  in kwArgs){ h.natural  = Boolean(kwArgs.natural); }
			}
			
			// update bounds
			if("min" in kwArgs){ min = kwArgs.min; }
			if("max" in kwArgs){ max = kwArgs.max; }
			if(kwArgs.includeZero){
				if(min > 0){ min = 0; }
				if(max < 0){ max = 0; }
			}
			h.min = min;
			h.useMin = true;
			h.max = max;
			h.useMax = true;
			
			if("from" in kwArgs){
				min = kwArgs.from;
				h.useMin = false;
			}
			if("to" in kwArgs){
				max = kwArgs.to;
				h.useMax = false;
			}
			
			// check for erroneous condition
			if(max <= min){
				return calcTicks(min, max, h, 0, 0, 0, span);	// Object
			}
			
			var mag = Math.floor(Math.log(max - min) / Math.LN10),
				major = kwArgs && ("majorTickStep" in kwArgs) ? kwArgs.majorTickStep : Math.pow(10, mag),
				minor = 0, micro = 0, ticks;
				
			// calculate minor ticks
			if(kwArgs && ("minorTickStep" in kwArgs)){
				minor = kwArgs.minorTickStep;
			}else{
				do{
					minor = major / 10;
					if(!h.natural || minor > 0.9){
						ticks = calcTicks(min, max, h, major, minor, 0, span);
						if(ticks.bounds.scale * ticks.minor.tick > deltaLimit){ break; }
					}
					minor = major / 5;
					if(!h.natural || minor > 0.9){
						ticks = calcTicks(min, max, h, major, minor, 0, span);
						if(ticks.bounds.scale * ticks.minor.tick > deltaLimit){ break; }
					}
					minor = major / 2;
					if(!h.natural || minor > 0.9){
						ticks = calcTicks(min, max, h, major, minor, 0, span);
						if(ticks.bounds.scale * ticks.minor.tick > deltaLimit){ break; }
					}
					return calcTicks(min, max, h, major, 0, 0, span);	// Object
				}while(false);
			}
	
			// calculate micro ticks
			if(kwArgs && ("microTickStep" in kwArgs)){
				micro = kwArgs.microTickStep;
				ticks = calcTicks(min, max, h, major, minor, micro, span);
			}else{
				do{
					micro = minor / 10;
					if(!h.natural || micro > 0.9){
						ticks = calcTicks(min, max, h, major, minor, micro, span);
						if(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }
					}
					micro = minor / 5;
					if(!h.natural || micro > 0.9){
						ticks = calcTicks(min, max, h, major, minor, micro, span);
						if(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }
					}
					micro = minor / 2;
					if(!h.natural || micro > 0.9){
						ticks = calcTicks(min, max, h, major, minor, micro, span);
						if(ticks.bounds.scale * ticks.micro.tick > deltaLimit){ break; }
					}
					micro = 0;
				}while(false);
			}
	
			return micro ? ticks : calcTicks(min, max, h, major, minor, 0, span);	// Object
		},
		buildTicks: function(/*Object*/ scaler, /*Object*/ kwArgs){
			var step, next, tick,
				nextMajor = scaler.major.start,
				nextMinor = scaler.minor.start,
				nextMicro = scaler.micro.start;
			if(kwArgs.microTicks && scaler.micro.tick){
				step = scaler.micro.tick, next = nextMicro;
			}else if(kwArgs.minorTicks && scaler.minor.tick){
				step = scaler.minor.tick, next = nextMinor;
			}else if(scaler.major.tick){
				step = scaler.major.tick, next = nextMajor;
			}else{
				// no ticks
				return null;
			}
			// make sure that we have finite bounds
			var revScale = 1 / scaler.bounds.scale;
			if(scaler.bounds.to <= scaler.bounds.from || isNaN(revScale) || !isFinite(revScale) ||
					step <= 0 || isNaN(step) || !isFinite(step)){
				// no ticks
				return null;
			}
			// loop over all ticks
			var majorTicks = [], minorTicks = [], microTicks = [];
			while(next <= scaler.bounds.to + revScale){
				if(Math.abs(nextMajor - next) < step / 2){
					// major tick
					tick = {value: nextMajor};
					if(kwArgs.majorLabels){
						tick.label = getLabel(nextMajor, scaler.major.prec, kwArgs);
					}
					majorTicks.push(tick);
					nextMajor += scaler.major.tick;
					nextMinor += scaler.minor.tick;
					nextMicro += scaler.micro.tick;
				}else if(Math.abs(nextMinor - next) < step / 2){
					// minor tick
					if(kwArgs.minorTicks){
						tick = {value: nextMinor};
						if(kwArgs.minorLabels && (scaler.minMinorStep <= scaler.minor.tick * scaler.bounds.scale)){
							tick.label = getLabel(nextMinor, scaler.minor.prec, kwArgs);
						}
						minorTicks.push(tick);
					}
					nextMinor += scaler.minor.tick;
					nextMicro += scaler.micro.tick;
				}else{
					// micro tick
					if(kwArgs.microTicks){
						microTicks.push({value: nextMicro});
					}
					nextMicro += scaler.micro.tick;
				}
				next += step;
			}
			return {major: majorTicks, minor: minorTicks, micro: microTicks};	// Object
		},
		getTransformerFromModel: function(/*Object*/ scaler){
			var offset = scaler.bounds.from, scale = scaler.bounds.scale;
			return function(x){ return (x - offset) * scale; };	// Function
		},
		getTransformerFromPlot: function(/*Object*/ scaler){
			var offset = scaler.bounds.from, scale = scaler.bounds.scale;
			return function(x){ return x / scale + offset; };	// Function
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.axis2d.Base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.axis2d.Base"] = true;
dojo.provide("dojox.charting.axis2d.Base");



dojo.declare("dojox.charting.axis2d.Base", dojox.charting.Element, {
	//	summary:
	//		The base class for any axis.  This is more of an interface/API
	//		definition than anything else; see dojox.charting.axis2d.Default
	//		for more details.
	constructor: function(chart, kwArgs){
		//	summary:
		//		Return a new base axis.
		//	chart: dojox.charting.Chart2D
		//		The chart this axis belongs to.
		//	kwArgs: dojox.charting.axis2d.__AxisCtorArgs?
		//		An optional arguments object to define the axis parameters.
		this.vertical = kwArgs && kwArgs.vertical;
	},
	clear: function(){
		//	summary:
		//		Stub function for clearing the axis.
		//	returns: dojox.charting.axis2d.Base
		//		A reference to the axis for functional chaining.
		return this;	//	dojox.charting.axis2d.Base
	},
	initialized: function(){
		//	summary:
		//		Return a flag as to whether or not this axis has been initialized.
		//	returns: Boolean
		//		If the axis is initialized or not.
		return false;	//	Boolean
	},
	calculate: function(min, max, span){
		//	summary:
		//		Stub function to run the calcuations needed for drawing this axis.
		//	returns: dojox.charting.axis2d.Base
		//		A reference to the axis for functional chaining.
		return this;	//	dojox.charting.axis2d.Base
	},
	getScaler: function(){
		//	summary:
		//		A stub function to return the scaler object created during calculate.
		//	returns: Object
		//		The scaler object (see dojox.charting.scaler.linear for more information)
		return null;	//	Object
	},
	getTicks: function(){
		//	summary:
		//		A stub function to return the object that helps define how ticks are rendered.
		//	returns: Object
		//		The ticks object.
		return null;	//	Object
	},
	getOffsets: function(){
		//	summary:
		//		A stub function to return any offsets needed for axis and series rendering.
		//	returns: Object
		//		An object of the form { l, r, t, b }.
		return {l: 0, r: 0, t: 0, b: 0};	//	Object
	},
	render: function(dim, offsets){
		//	summary:
		//		Stub function to render this axis.
		//	returns: dojox.charting.axis2d.Base
		//		A reference to the axis for functional chaining.
		this.dirty = false;
		return this;	//	dojox.charting.axis2d.Base
	}
});

}

if(!dojo._hasResource["dojox.charting.axis2d.Invisible"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.axis2d.Invisible"] = true;
dojo.provide("dojox.charting.axis2d.Invisible");










(function(){
	var dc = dojox.charting,
		df = dojox.lang.functional,
		du = dojox.lang.utils,
		g = dojox.gfx,
		lin = dc.scaler.linear,
		merge = du.merge,
		labelGap = 4,			// in pixels
		centerAnchorLimit = 45;	// in degrees

	dojo.declare("dojox.charting.axis2d.Invisible", dojox.charting.axis2d.Base, {
		//	summary:
		//		The default axis object used in dojox.charting.  See dojox.charting.Chart2D.addAxis for details.
		//
		//	defaultParams: Object
		//		The default parameters used to define any axis.
		//	optionalParams: Object
		//		Any optional parameters needed to define an axis.

		/*
		//	TODO: the documentation tools need these to be pre-defined in order to pick them up
		//	correctly, but the code here is partially predicated on whether or not the properties
		//	actually exist.  For now, we will leave these undocumented but in the code for later. -- TRT

		//	opt: Object
		//		The actual options used to define this axis, created at initialization.
		//	scalar: Object
		//		The calculated helper object to tell charts how to draw an axis and any data.
		//	ticks: Object
		//		The calculated tick object that helps a chart draw the scaling on an axis.
		//	dirty: Boolean
		//		The state of the axis (whether it needs to be redrawn or not)
		//	scale: Number
		//		The current scale of the axis.
		//	offset: Number
		//		The current offset of the axis.

		opt: null,
		scalar: null,
		ticks: null,
		dirty: true,
		scale: 1,
		offset: 0,
		*/
		defaultParams: {
			vertical:    false,		// true for vertical axis
			fixUpper:    "none",	// align the upper on ticks: "major", "minor", "micro", "none"
			fixLower:    "none",	// align the lower on ticks: "major", "minor", "micro", "none"
			natural:     false,		// all tick marks should be made on natural numbers
			leftBottom:  true,		// position of the axis, used with "vertical"
			includeZero: false,		// 0 should be included
			fixed:       true,		// all labels are fixed numbers
			majorLabels: true,		// draw major labels
			minorTicks:  true,		// draw minor ticks
			minorLabels: true,		// draw minor labels
			microTicks:  false,		// draw micro ticks
			rotation:    0			// label rotation angle in degrees
		},
		optionalParams: {
			min:			0,	// minimal value on this axis
			max:			1,	// maximal value on this axis
			from:			0,	// visible from this value
			to:				1,	// visible to this value
			majorTickStep:	4,	// major tick step
			minorTickStep:	2,	// minor tick step
			microTickStep:	1,	// micro tick step
			labels:			[],	// array of labels for major ticks
								// with corresponding numeric values
								// ordered by values
			labelFunc:		null, // function to compute label values
			maxLabelSize:	0,	// size in px. For use with labelFunc
			maxLabelCharCount:	0,	// size in word count.
			trailingSymbol:			null

			// TODO: add support for minRange!
			// minRange:		1,	// smallest distance from min allowed on the axis
		},

		constructor: function(chart, kwArgs){
			//	summary:
			//		The constructor for an axis.
			//	chart: dojox.charting.Chart2D
			//		The chart the axis belongs to.
			//	kwArgs: dojox.charting.axis2d.__AxisCtorArgs?
			//		Any optional keyword arguments to be used to define this axis.
			this.opt = dojo.clone(this.defaultParams);
            du.updateWithObject(this.opt, kwArgs);
			du.updateWithPattern(this.opt, kwArgs, this.optionalParams);
		},
		dependOnData: function(){
			//	summary:
			//		Find out whether or not the axis options depend on the data in the axis.
			return !("min" in this.opt) || !("max" in this.opt);	//	Boolean
		},
		clear: function(){
			//	summary:
			//		Clear out all calculated properties on this axis;
			//	returns: dojox.charting.axis2d.Default
			//		The reference to the axis for functional chaining.
			delete this.scaler;
			delete this.ticks;
			this.dirty = true;
			return this;	//	dojox.charting.axis2d.Default
		},
		initialized: function(){
			//	summary:
			//		Finds out if this axis has been initialized or not.
			//	returns: Boolean
			//		Whether a scaler has been calculated and if the axis is not dirty.
			return "scaler" in this && !(this.dirty && this.dependOnData());
		},
		setWindow: function(scale, offset){
			//	summary:
			//		Set the drawing "window" for the axis.
			//	scale: Number
			//		The new scale for the axis.
			//	offset: Number
			//		The new offset for the axis.
			//	returns: dojox.charting.axis2d.Default
			//		The reference to the axis for functional chaining.
			this.scale  = scale;
			this.offset = offset;
			return this.clear();	//	dojox.charting.axis2d.Default
		},
		getWindowScale: function(){
			//	summary:
			//		Get the current windowing scale of the axis.
			return "scale" in this ? this.scale : 1;	//	Number
		},
		getWindowOffset: function(){
			//	summary:
			//		Get the current windowing offset for the axis.
			return "offset" in this ? this.offset : 0;	//	Number
		},
		_groupLabelWidth: function(labels, font, wcLimit){
			if(!labels.length){
				return 0;
			}
			if(dojo.isObject(labels[0])){
				labels = df.map(labels, function(label){ return label.text; });
			}
			if (wcLimit) {
				labels = df.map(labels, function(label){
					return dojo.trim(label).length == 0 ? "" : label.substring(0, wcLimit) + this.trailingSymbol;
				}, this);
			}
			var s = labels.join("<br>");
			return dojox.gfx._base._getTextBox(s, {font: font}).w || 0;
		},
		calculate: function(min, max, span, labels){
			//	summary:
			//		Perform all calculations needed to render this axis.
			//	min: Number
			//		The smallest value represented on this axis.
			//	max: Number
			//		The largest value represented on this axis.
			//	span: Number
			//		The span in pixels over which axis calculations are made.
			//	labels: String[]
			//		Optional list of labels.
			//	returns: dojox.charting.axis2d.Default
			//		The reference to the axis for functional chaining.
			if(this.initialized()){
				return this;
			}
			var o = this.opt;
			this.labels = "labels" in o  ? o.labels : labels;
			this.scaler = lin.buildScaler(min, max, span, o);
			var tsb = this.scaler.bounds;
			if("scale" in this){
				// calculate new range
				o.from = tsb.lower + this.offset;
				o.to   = (tsb.upper - tsb.lower) / this.scale + o.from;
				// make sure that bounds are correct
				if( !isFinite(o.from) ||
					isNaN(o.from) ||
					!isFinite(o.to) ||
					isNaN(o.to) ||
					o.to - o.from >= tsb.upper - tsb.lower
				){
					// any error --- remove from/to bounds
					delete o.from;
					delete o.to;
					delete this.scale;
					delete this.offset;
				}else{
					// shift the window, if we are out of bounds
					if(o.from < tsb.lower){
						o.to += tsb.lower - o.from;
						o.from = tsb.lower;
					}else if(o.to > tsb.upper){
						o.from += tsb.upper - o.to;
						o.to = tsb.upper;
					}
					// update the offset
					this.offset = o.from - tsb.lower;
				}
				// re-calculate the scaler
				this.scaler = lin.buildScaler(min, max, span, o);
				tsb = this.scaler.bounds;
				// cleanup
				if(this.scale == 1 && this.offset == 0){
					delete this.scale;
					delete this.offset;
				}
			}

			var ta = this.chart.theme.axis, labelWidth = 0, rotation = o.rotation % 360,
				// TODO: we use one font --- of major tick, we need to use major and minor fonts
				taFont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font),
				size = taFont ? g.normalizedLength(g.splitFontString(taFont).size) : 0,
				cosr = Math.abs(Math.cos(rotation * Math.PI / 180)),
				sinr = Math.abs(Math.sin(rotation * Math.PI / 180));

			if(rotation < 0){
				rotation += 360;
			}

			if(size){
				if(this.vertical ? rotation != 0 && rotation != 180 : rotation != 90 && rotation != 270){
					// we need width of all labels
					if(this.labels){
						labelWidth = this._groupLabelWidth(this.labels, taFont, o.maxLabelCharCount);
					}else{
						var labelLength = Math.ceil(
								Math.log(
									Math.max(
										Math.abs(tsb.from),
										Math.abs(tsb.to)
									)
								) / Math.LN10
							),
							t = [];
						if(tsb.from < 0 || tsb.to < 0){
							t.push("-");
						}
						t.push(dojo.string.rep("9", labelLength));
						var precision = Math.floor(
							Math.log( tsb.to - tsb.from ) / Math.LN10
						);
						if(precision > 0){
							t.push(".");
							t.push(dojo.string.rep("9", precision));
						}
						labelWidth = dojox.gfx._base._getTextBox(
							t.join(""),
							{ font: taFont }
						).w;
					}
					labelWidth = o.maxLabelSize ? Math.min(o.maxLabelSize, labelWidth) : labelWidth;
				}else{
					labelWidth = size;
				}
				switch(rotation){
					case 0:
					case 90:
					case 180:
					case 270:
						// trivial cases: use labelWidth
						break;
					default:
						// rotated labels
						var gap1 = Math.sqrt(labelWidth * labelWidth + size * size),									// short labels
							gap2 = this.vertical ? size * cosr + labelWidth * sinr : labelWidth * cosr + size * sinr;	// slanted labels
						labelWidth = Math.min(gap1, gap2);
						break;
				}
			}

			this.scaler.minMinorStep = labelWidth + labelGap;
			this.ticks = lin.buildTicks(this.scaler, o);
			return this;	//	dojox.charting.axis2d.Default
		},
		getScaler: function(){
			//	summary:
			//		Get the pre-calculated scaler object.
			return this.scaler;	//	Object
		},
		getTicks: function(){
			//	summary:
			//		Get the pre-calculated ticks object.
			return this.ticks;	//	Object
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.axis2d.Default"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.axis2d.Default"] = true;
dojo.provide("dojox.charting.axis2d.Default");












/*=====
	dojox.charting.axis2d.__AxisCtorArgs = function(
		vertical, fixUpper, fixLower, natural, leftBottom,
		includeZero, fixed, majorLabels, minorTicks, minorLabels, microTicks, htmlLabels,
		min, max, from, to, majorTickStep, minorTickStep, microTickStep,
		labels, labelFunc, maxLabelSize,
		stroke, majorTick, minorTick, microTick, tick,
		font, fontColor
	){
	//	summary:
	//		Optional arguments used in the definition of an axis.
	//
	//	vertical: Boolean?
	//		A flag that says whether an axis is vertical (i.e. y axis) or horizontal. Default is false (horizontal).
	//	fixUpper: String?
	//		Align the greatest value on the axis with the specified tick level. Options are "major", "minor", "micro", or "none".  Defaults to "none".
	//	fixLower: String?
	//		Align the smallest value on the axis with the specified tick level. Options are "major", "minor", "micro", or "none".  Defaults to "none".
	//	natural: Boolean?
	//		Ensure tick marks are made on "natural" numbers. Defaults to false.
	//	leftBottom: Boolean?
	//		The position of a vertical axis; if true, will be placed against the left-bottom corner of the chart.  Defaults to true.
	//	includeZero: Boolean?
	//		Include 0 on the axis rendering.  Default is false.
	//	fixed: Boolean?
	//		Force all axis labels to be fixed numbers.  Default is true.
	//	majorLabels: Boolean?
	//		Flag to draw all labels at major ticks. Default is true.
	//	minorTicks: Boolean?
	//		Flag to draw minor ticks on an axis.  Default is true.
	//	minorLabels: Boolean?
	//		Flag to draw labels on minor ticks. Default is true.
	//	microTicks: Boolean?
	//		Flag to draw micro ticks on an axis. Default is false.
	//	htmlLabels: Boolean?
	//		Flag to use HTML (as opposed to the native vector graphics engine) to draw labels. Default is true.
	//	min: Number?
	//		The smallest value on an axis. Default is 0.
	//	max: Number?
	//		The largest value on an axis. Default is 1.
	//	from: Number?
	//		Force the chart to render data visible from this value. Default is 0.
	//	to: Number?
	//		Force the chart to render data visible to this value. Default is 1.
	//	majorTickStep: Number?
	//		The amount to skip before a major tick is drawn.  Default is 4.
	//	minorTickStep: Number?
	//		The amount to skip before a minor tick is drawn. Default is 2.
	//	microTickStep: Number?
	//		The amount to skip before a micro tick is drawn. Default is 1.
	//	labels: Object[]?
	//		An array of labels for major ticks, with corresponding numeric values, ordered by value.
	//	labelFunc: Function?
	//		An optional function used to compute label values.
	//	maxLabelSize: Number?
	//		The maximum size, in pixels, for a label.  To be used with the optional label function.
	//	stroke: dojox.gfx.Stroke?
	//		An optional stroke to be used for drawing an axis.
	//	majorTick: Object?
	//		An object containing a dojox.gfx.Stroke, and a length (number) for a major tick.
	//	minorTick: Object?
	//		An object containing a dojox.gfx.Stroke, and a length (number) for a minor tick.
	//	microTick: Object?
	//		An object containing a dojox.gfx.Stroke, and a length (number) for a micro tick.
	//	tick: Object?
	//		An object containing a dojox.gfx.Stroke, and a length (number) for a tick.
	//	font: String?
	//		An optional font definition (as used in the CSS font property) for labels.
	//	fontColor: String|dojo.Color?
	//		An optional color to be used in drawing labels.

	this.vertical = vertical;
	this.fixUpper = fixUpper;
	this.fixLower = fixLower;
	this.natural = natural;
	this.leftBottom = leftBottom;
	this.includeZero = includeZero;
	this.fixed = fixed;
	this.majorLabels = majorLabels;
	this.minorTicks = minorTicks;
	this.minorLabels = minorLabels;
	this.microTicks = microTicks;
	this.htmlLabels = htmlLabels;
	this.min = min;
	this.max = max;
	this.from = from;
	this.to = to;
	this.majorTickStep = majorTickStep;
	this.minorTickStep = minorTickStep;
	this.microTickStep = microTickStep;
	this.labels = labels;
	this.labelFunc = labelFunc;
	this.maxLabelSize = maxLabelSize;
	this.stroke = stroke;
	this.majorTick = majorTick;
	this.minorTick = minorTick;
	this.microTick = microTick;
	this.tick = tick;
	this.font = font;
	this.fontColor = fontColor;
}
=====*/
(function(){
	var dc = dojox.charting,
		du = dojox.lang.utils,
		g = dojox.gfx,
		lin = dc.scaler.linear,
		labelGap = 4,			// in pixels
		centerAnchorLimit = 45;	// in degrees

	dojo.declare("dojox.charting.axis2d.Default", dojox.charting.axis2d.Invisible, {
		//	summary:
		//		The default axis object used in dojox.charting.  See dojox.charting.Chart.addAxis for details.
		//
		//	defaultParams: Object
		//		The default parameters used to define any axis.
		//	optionalParams: Object
		//		Any optional parameters needed to define an axis.

		/*
		//	TODO: the documentation tools need these to be pre-defined in order to pick them up
		//	correctly, but the code here is partially predicated on whether or not the properties
		//	actually exist.  For now, we will leave these undocumented but in the code for later. -- TRT

		//	opt: Object
		//		The actual options used to define this axis, created at initialization.
		//	scalar: Object
		//		The calculated helper object to tell charts how to draw an axis and any data.
		//	ticks: Object
		//		The calculated tick object that helps a chart draw the scaling on an axis.
		//	dirty: Boolean
		//		The state of the axis (whether it needs to be redrawn or not)
		//	scale: Number
		//		The current scale of the axis.
		//	offset: Number
		//		The current offset of the axis.

		opt: null,
		scalar: null,
		ticks: null,
		dirty: true,
		scale: 1,
		offset: 0,
		*/
		defaultParams: {
			vertical:    false,		// true for vertical axis
			fixUpper:    "none",	// align the upper on ticks: "major", "minor", "micro", "none"
			fixLower:    "none",	// align the lower on ticks: "major", "minor", "micro", "none"
			natural:     false,		// all tick marks should be made on natural numbers
			leftBottom:  true,		// position of the axis, used with "vertical"
			includeZero: false,		// 0 should be included
			fixed:       true,		// all labels are fixed numbers
			majorLabels: true,		// draw major labels
			minorTicks:  true,		// draw minor ticks
			minorLabels: true,		// draw minor labels
			microTicks:  false,		// draw micro ticks
			rotation:    0,			// label rotation angle in degrees
			htmlLabels:  true		// use HTML to draw labels
		},
		optionalParams: {
			min:			0,	// minimal value on this axis
			max:			1,	// maximal value on this axis
			from:			0,	// visible from this value
			to:				1,	// visible to this value
			majorTickStep:	4,	// major tick step
			minorTickStep:	2,	// minor tick step
			microTickStep:	1,	// micro tick step
			labels:			[],	// array of labels for major ticks
								// with corresponding numeric values
								// ordered by values
			labelFunc:		null, // function to compute label values
			maxLabelSize:	0,	// size in px. For use with labelFunc
			maxLabelCharCount:	0,	// size in word count.
			trailingSymbol:	null,

			// TODO: add support for minRange!
			// minRange:		1,	// smallest distance from min allowed on the axis

			// theme components
			stroke:			{},	// stroke for an axis
			majorTick:		{},	// stroke + length for a tick
			minorTick:		{},	// stroke + length for a tick
			microTick:		{},	// stroke + length for a tick
			tick:           {},	// stroke + length for a tick
			font:			"",	// font for labels
			fontColor:		"",	// color for labels as a string
			title:		 		"",	// axis title
			titleGap:	 		0,		// gap between axis title and axis label
			titleFont:	 		"",		// axis title font
			titleFontColor:	 	"",		// axis title font color
			titleOrientation: 	""		// "axis" means the title facing the axis, "away" means facing away
		},

		constructor: function(chart, kwArgs){
			//	summary:
			//		The constructor for an axis.
			//	chart: dojox.charting.Chart2D
			//		The chart the axis belongs to.
			//	kwArgs: dojox.charting.axis2d.__AxisCtorArgs?
			//		Any optional keyword arguments to be used to define this axis.
			this.opt = dojo.clone(this.defaultParams);
            du.updateWithObject(this.opt, kwArgs);
			du.updateWithPattern(this.opt, kwArgs, this.optionalParams);
		},
		getOffsets: function(){
			//	summary:
			//		Get the physical offset values for this axis (used in drawing data series).
			//	returns: Object
			//		The calculated offsets in the form of { l, r, t, b } (left, right, top, bottom).
			var s = this.scaler, offsets = { l: 0, r: 0, t: 0, b: 0 };
			if(!s){
				return offsets;
			}
			var o = this.opt, labelWidth = 0, a, b, c, d,
				gl = dc.scaler.common.getNumericLabel,
				offset = 0, ma = s.major, mi = s.minor,
				ta = this.chart.theme.axis,
				// TODO: we use one font --- of major tick, we need to use major and minor fonts
				taFont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font),
				taTitleFont = o.titleFont || (ta.tick && ta.tick.titleFont),
				taTitleGap = (o.titleGap==0) ? 0 : o.titleGap || (ta.tick && ta.tick.titleGap) || 15,
				taMajorTick = this.chart.theme.getTick("major", o),
				taMinorTick = this.chart.theme.getTick("minor", o),
				size = taFont ? g.normalizedLength(g.splitFontString(taFont).size) : 0,
				tsize = taTitleFont ? g.normalizedLength(g.splitFontString(taTitleFont).size) : 0,
				rotation = o.rotation % 360, leftBottom = o.leftBottom,
				cosr = Math.abs(Math.cos(rotation * Math.PI / 180)),
				sinr = Math.abs(Math.sin(rotation * Math.PI / 180));
			this.trailingSymbol = (o.trailingSymbol === undefined || o.trailingSymbol === null) ? this.trailingSymbol : o.trailingSymbol;
			if(rotation < 0){
				rotation += 360;
			}

			if(size){
				// we need width of all labels
				if(this.labels){
					labelWidth = this._groupLabelWidth(this.labels, taFont, o.maxLabelCharCount);
				}else{
					labelWidth = this._groupLabelWidth([
						gl(ma.start, ma.prec, o),
						gl(ma.start + ma.count * ma.tick, ma.prec, o),
						gl(mi.start, mi.prec, o),
						gl(mi.start + mi.count * mi.tick, mi.prec, o)
					], taFont, o.maxLabelCharCount);
				}
				labelWidth = o.maxLabelSize ? Math.min(o.maxLabelSize, labelWidth) : labelWidth;
				if(this.vertical){
					var side = leftBottom ? "l" : "r";
					switch(rotation){
						case 0:
						case 180:
							offsets[side] = labelWidth;
							offsets.t = offsets.b = size / 2;
							break;
						case 90:
						case 270:
							offsets[side] = size;
							offsets.t = offsets.b = labelWidth / 2;
							break;
						default:
							if(rotation <= centerAnchorLimit || (180 < rotation && rotation <= (180 + centerAnchorLimit))){
								offsets[side] = size * sinr / 2 + labelWidth * cosr;
								offsets[leftBottom ? "t" : "b"] = size * cosr / 2 + labelWidth * sinr;
								offsets[leftBottom ? "b" : "t"] = size * cosr / 2;
							}else if(rotation > (360 - centerAnchorLimit) || (180 > rotation && rotation > (180 - centerAnchorLimit))){
								offsets[side] = size * sinr / 2 + labelWidth * cosr;
								offsets[leftBottom ? "b" : "t"] = size * cosr / 2 + labelWidth * sinr;
								offsets[leftBottom ? "t" : "b"] = size * cosr / 2;
							}else if(rotation < 90 || (180 < rotation && rotation < 270)){
								offsets[side] = size * sinr + labelWidth * cosr;
								offsets[leftBottom ? "t" : "b"] = size * cosr + labelWidth * sinr;
							}else{
								offsets[side] = size * sinr + labelWidth * cosr;
								offsets[leftBottom ? "b" : "t"] = size * cosr + labelWidth * sinr;
							}
							break;
					}
					offsets[side] += labelGap + Math.max(taMajorTick.length, taMinorTick.length) + (o.title ? (tsize + taTitleGap) : 0);
				}else{
					var side = leftBottom ? "b" : "t";
					switch(rotation){
						case 0:
						case 180:
							offsets[side] = size;
							offsets.l = offsets.r = labelWidth / 2;
							break;
						case 90:
						case 270:
							offsets[side] = labelWidth;
							offsets.l = offsets.r = size / 2;
							break;
						default:
							if((90 - centerAnchorLimit) <= rotation && rotation <= 90 || (270 - centerAnchorLimit) <= rotation && rotation <= 270){
								offsets[side] = size * sinr / 2 + labelWidth * cosr;
								offsets[leftBottom ? "r" : "l"] = size * cosr / 2 + labelWidth * sinr;
								offsets[leftBottom ? "l" : "r"] = size * cosr / 2;
							}else if(90 <= rotation && rotation <= (90 + centerAnchorLimit) || 270 <= rotation && rotation <= (270 + centerAnchorLimit)){
								offsets[side] = size * sinr / 2 + labelWidth * cosr;
								offsets[leftBottom ? "l" : "r"] = size * cosr / 2 + labelWidth * sinr;
								offsets[leftBottom ? "r" : "l"] = size * cosr / 2;
							}else if(rotation < centerAnchorLimit || (180 < rotation && rotation < (180 - centerAnchorLimit))){
								offsets[side] = size * sinr + labelWidth * cosr;
								offsets[leftBottom ? "r" : "l"] = size * cosr + labelWidth * sinr;
							}else{
								offsets[side] = size * sinr + labelWidth * cosr;
								offsets[leftBottom ? "l" : "r"] = size * cosr + labelWidth * sinr;
							}
							break;
					}
					offsets[side] += labelGap + Math.max(taMajorTick.length, taMinorTick.length) + (o.title ? (tsize + taTitleGap) : 0);
				}
			}
			if(labelWidth){
				this._cachedLabelWidth = labelWidth;
			}
			return offsets;	//	Object
		},
		render: function(dim, offsets){
			//	summary:
			//		Render/draw the axis.
			//	dim: Object
			//		An object of the form { width, height}.
			//	offsets: Object
			//		An object of the form { l, r, t, b }.
			//	returns: dojox.charting.axis2d.Default
			//		The reference to the axis for functional chaining.
			if(!this.dirty){
				return this;	//	dojox.charting.axis2d.Default
			}
			// prepare variable
			var o = this.opt, ta = this.chart.theme.axis, leftBottom = o.leftBottom, rotation = o.rotation % 360,
				start, stop, titlePos, titleRotation=0, titleOffset, axisVector, tickVector, anchorOffset, labelOffset, labelAlign,

				// TODO: we use one font --- of major tick, we need to use major and minor fonts
				taFont = o.font || (ta.majorTick && ta.majorTick.font) || (ta.tick && ta.tick.font),
				taTitleFont = o.titleFont || (ta.tick && ta.tick.titleFont),
				// TODO: we use one font color --- we need to use different colors
				taFontColor = o.fontColor || (ta.majorTick && ta.majorTick.fontColor) || (ta.tick && ta.tick.fontColor) || "black",
				taTitleFontColor = o.titleFontColor || (ta.tick && ta.tick.titleFontColor) || "black",
				taTitleGap = (o.titleGap==0) ? 0 : o.titleGap || (ta.tick && ta.tick.titleGap) || 15,
				taTitleOrientation = o.titleOrientation || (ta.tick && ta.tick.titleOrientation) || "axis",
				taMajorTick = this.chart.theme.getTick("major", o),
				taMinorTick = this.chart.theme.getTick("minor", o),
				taMicroTick = this.chart.theme.getTick("micro", o),

				tickSize = Math.max(taMajorTick.length, taMinorTick.length, taMicroTick.length),
				taStroke = "stroke" in o ? o.stroke : ta.stroke,
				size = taFont ? g.normalizedLength(g.splitFontString(taFont).size) : 0,
				cosr = Math.abs(Math.cos(rotation * Math.PI / 180)),
				sinr = Math.abs(Math.sin(rotation * Math.PI / 180)),
				tsize = taTitleFont ? g.normalizedLength(g.splitFontString(taTitleFont).size) : 0;
			if(rotation < 0){
				rotation += 360;
			}
			if(this.vertical){
				start = {y: dim.height - offsets.b};
				stop  = {y: offsets.t};
				titlePos = {y: (dim.height - offsets.b + offsets.t)/2};
				titleOffset = size * sinr + (this._cachedLabelWidth || 0) * cosr + labelGap + Math.max(taMajorTick.length, taMinorTick.length) + tsize + taTitleGap;
				axisVector = {x: 0, y: -1};
				labelOffset = {x: 0, y: 0};
				tickVector = {x: 1, y: 0};
				anchorOffset = {x: labelGap, y: 0};
				switch(rotation){
					case 0:
						labelAlign = "end";
						labelOffset.y = size * 0.4;
						break;
					case 90:
						labelAlign = "middle";
						labelOffset.x = -size;
						break;
					case 180:
						labelAlign = "start";
						labelOffset.y = -size * 0.4;
						break;
					case 270:
						labelAlign = "middle";
						break;
					default:
						if(rotation < centerAnchorLimit){
							labelAlign = "end";
							labelOffset.y = size * 0.4;
						}else if(rotation < 90){
							labelAlign = "end";
							labelOffset.y = size * 0.4;
						}else if(rotation < (180 - centerAnchorLimit)){
							labelAlign = "start";
						}else if(rotation < (180 + centerAnchorLimit)){
							labelAlign = "start";
							labelOffset.y = -size * 0.4;
						}else if(rotation < 270){
							labelAlign = "start";
							labelOffset.x = leftBottom ? 0 : size * 0.4;
						}else if(rotation < (360 - centerAnchorLimit)){
							labelAlign = "end";
							labelOffset.x = leftBottom ? 0 : size * 0.4;
						}else{
							labelAlign = "end";
							labelOffset.y = size * 0.4;
						}
				}
				if(leftBottom){
					start.x = stop.x = offsets.l;
					titleRotation = (taTitleOrientation && taTitleOrientation == "away") ? 90 : 270;
					titlePos.x = offsets.l - titleOffset + (titleRotation == 270 ? tsize : 0);
					tickVector.x = -1;
					anchorOffset.x = -anchorOffset.x;
				}else{
					start.x = stop.x = dim.width - offsets.r;
					titleRotation = (taTitleOrientation && taTitleOrientation == "axis") ? 90 : 270;
					titlePos.x = dim.width - offsets.r + titleOffset - (titleRotation == 270 ? 0 : tsize);
					switch(labelAlign){
						case "start":
							labelAlign = "end";
							break;
						case "end":
							labelAlign = "start";
							break;
						case "middle":
							labelOffset.x += size;
							break;
					}
				}
			}else{
				start = {x: offsets.l};
				stop  = {x: dim.width - offsets.r};
				titlePos = {x: (dim.width - offsets.r + offsets.l)/2};
				titleOffset = size * cosr + (this._cachedLabelWidth || 0) * sinr + labelGap + Math.max(taMajorTick.length, taMinorTick.length) + tsize + taTitleGap;
				axisVector = {x: 1, y: 0};
				labelOffset = {x: 0, y: 0};
				tickVector = {x: 0, y: 1};
				anchorOffset = {x: 0, y: labelGap};
				switch(rotation){
					case 0:
						labelAlign = "middle";
						labelOffset.y = size;
						break;
					case 90:
						labelAlign = "start";
						labelOffset.x = -size * 0.4;
						break;
					case 180:
						labelAlign = "middle";
						break;
					case 270:
						labelAlign = "end";
						labelOffset.x = size * 0.4;
						break;
					default:
						if(rotation < (90 - centerAnchorLimit)){
							labelAlign = "start";
							labelOffset.y = leftBottom ? size : 0;
						}else if(rotation < (90 + centerAnchorLimit)){
							labelAlign = "start";
							labelOffset.x = -size * 0.4;
						}else if(rotation < 180){
							labelAlign = "start";
							labelOffset.y = leftBottom ? 0 : -size;
						}else if(rotation < (270 - centerAnchorLimit)){
							labelAlign = "end";
							labelOffset.y = leftBottom ? 0 : -size;
						}else if(rotation < (270 + centerAnchorLimit)){
							labelAlign = "end";
							labelOffset.y = leftBottom ? size * 0.4 : 0;
						}else{
							labelAlign = "end";
							labelOffset.y = leftBottom ? size : 0;
						}
				}
				if(leftBottom){
					start.y = stop.y = dim.height - offsets.b;
					titleRotation = (taTitleOrientation && taTitleOrientation == "axis") ? 180 : 0;
					titlePos.y = dim.height - offsets.b + titleOffset - (titleRotation ? tsize : 0);
				}else{
					start.y = stop.y = offsets.t;
					titleRotation = (taTitleOrientation && taTitleOrientation == "away") ? 180 : 0;
					titlePos.y = offsets.t - titleOffset + (titleRotation ? 0 : tsize);
					tickVector.y = -1;
					anchorOffset.y = -anchorOffset.y;
					switch(labelAlign){
						case "start":
							labelAlign = "end";
							break;
						case "end":
							labelAlign = "start";
							break;
						case "middle":
							labelOffset.y -= size;
							break;
					}
				}
			}

			// render shapes

			this.cleanGroup();

			try{
				var s = this.group,
					c = this.scaler,
					t = this.ticks,
					canLabel,
					f = lin.getTransformerFromModel(this.scaler),
					// GFX Canvas now supports labels, so let's _not_ fallback to HTML anymore on canvas, just use
					// HTML labels if explicitly asked + no rotation + no IE + no Opera
					labelType = !titleRotation && !rotation && this.opt.htmlLabels && !dojo.isIE && !dojo.isOpera ? "html" : "gfx",
					dx = tickVector.x * taMajorTick.length,
					dy = tickVector.y * taMajorTick.length;

				s.createLine({
					x1: start.x,
					y1: start.y,
					x2: stop.x,
					y2: stop.y
				}).setStroke(taStroke);
				
				//create axis title
				if(o.title){
					var axisTitle = dc.axis2d.common.createText[labelType](
						this.chart,
						s,
						titlePos.x,
						titlePos.y,
						"middle",
						o.title,
						taTitleFont,
						taTitleFontColor
					);
					if(labelType == "html"){
						this.htmlElements.push(axisTitle);
					}else{
						//as soon as rotation is provided, labelType won't be "html"
						//rotate gfx labels
						axisTitle.setTransform(g.matrix.rotategAt(titleRotation, titlePos.x, titlePos.y));
					}
				}

				dojo.forEach(t.major, function(tick){
					var offset = f(tick.value), elem,
						x = start.x + axisVector.x * offset,
						y = start.y + axisVector.y * offset;
						s.createLine({
							x1: x, y1: y,
							x2: x + dx,
							y2: y + dy
						}).setStroke(taMajorTick);
						if(tick.label){
							var label = o.maxLabelCharCount ? this.getTextWithLimitCharCount(tick.label, taFont, o.maxLabelCharCount) : {
								text: tick.label,
								truncated: false
							};
							label = o.maxLabelSize ? this.getTextWithLimitLength(label.text, taFont, o.maxLabelSize, label.truncated) : label;
							elem = dc.axis2d.common.createText[labelType](
								this.chart,
								s,
								x + dx + anchorOffset.x + (rotation ? 0 : labelOffset.x),
								y + dy + anchorOffset.y + (rotation ? 0 : labelOffset.y),
								labelAlign,
								label.text,
								taFont,
								taFontColor
								//this._cachedLabelWidth
							);
							label.truncated && this.labelTooltip(elem, this.chart, tick.label, label.text, taFont, labelType);
							if(labelType == "html"){
								this.htmlElements.push(elem);
							}else if(rotation){
								elem.setTransform([
									{dx: labelOffset.x, dy: labelOffset.y},
									g.matrix.rotategAt(
										rotation,
										x + dx + anchorOffset.x,
										y + dy + anchorOffset.y
									)
								]);
							}
						}
				}, this);

				dx = tickVector.x * taMinorTick.length;
				dy = tickVector.y * taMinorTick.length;
				canLabel = c.minMinorStep <= c.minor.tick * c.bounds.scale;
				dojo.forEach(t.minor, function(tick){
					var offset = f(tick.value), elem,
						x = start.x + axisVector.x * offset,
						y = start.y + axisVector.y * offset;
						s.createLine({
							x1: x, y1: y,
							x2: x + dx,
							y2: y + dy
						}).setStroke(taMinorTick);
						if(canLabel && tick.label){
							var label = o.maxLabelCharCount ? this.getTextWithLimitCharCount(tick.label, taFont, o.maxLabelCharCount) : {
								text: tick.label,
								truncated: false
							};
							label = o.maxLabelSize ? this.getTextWithLimitLength(label.text, taFont, o.maxLabelSize, label.truncated) : label;
							elem = dc.axis2d.common.createText[labelType](
								this.chart,
								s,
								x + dx + anchorOffset.x + (rotation ? 0 : labelOffset.x),
								y + dy + anchorOffset.y + (rotation ? 0 : labelOffset.y),
								labelAlign,
								label.text,
								taFont,
								taFontColor
								//this._cachedLabelWidth
							);
							label.truncated && this.labelTooltip(elem, this.chart, tick.label, label.text, taFont, labelType);
							if(labelType == "html"){
								this.htmlElements.push(elem);
							}else if(rotation){
								elem.setTransform([
									{dx: labelOffset.x, dy: labelOffset.y},
									g.matrix.rotategAt(
										rotation,
										x + dx + anchorOffset.x,
										y + dy + anchorOffset.y
									)
								]);
							}
						}
				}, this);

				dx = tickVector.x * taMicroTick.length;
				dy = tickVector.y * taMicroTick.length;
				dojo.forEach(t.micro, function(tick){
					var offset = f(tick.value), elem,
						x = start.x + axisVector.x * offset,
						y = start.y + axisVector.y * offset;
						s.createLine({
							x1: x, y1: y,
							x2: x + dx,
							y2: y + dy
						}).setStroke(taMicroTick);
				}, this);
			}catch(e){
				// squelch
			}

			this.dirty = false;
			return this;	//	dojox.charting.axis2d.Default
		},
		labelTooltip: function(elem, chart, label, truncatedLabel, font, elemType){
			// to avoid requiring dijit module for that feature, let's test that
			// dynamically and return if we can't do it
			if(!dijit || !dijit.Tooltip){
				return;
			}
			var aroundRect = {type: "rect"}, position = ["above", "below"],
				fontWidth = dojox.gfx._base._getTextBox(truncatedLabel, {font: font}).w || 0;
				fontHeight = font ? g.normalizedLength(g.splitFontString(font).size) : 0;
			if(elemType == "html"){
				dojo.mixin(aroundRect, dojo.coords(elem.firstChild, true));
				aroundRect.width = Math.ceil(fontWidth);
				aroundRect.height = Math.ceil(fontHeight);
				this._events.push({
					shape:  dojo,
					handle: dojo.connect(elem.firstChild, "onmouseover", this, function(e){
						dijit.showTooltip(label, aroundRect, position);
					})
				});
				this._events.push({
					shape:  dojo,
					handle: dojo.connect(elem.firstChild, "onmouseout", this, function(e){
						dijit.hideTooltip(aroundRect);
					})
				});
			}else{
				var shp = elem.getShape(),
					lt = dojo.coords(chart.node, true);
				aroundRect = dojo.mixin(aroundRect, {
					x: shp.x - fontWidth / 2,
					y: shp.y
				});
				aroundRect.x += lt.x;
				aroundRect.y += lt.y;
				aroundRect.x = Math.round(aroundRect.x);
				aroundRect.y = Math.round(aroundRect.y);
				aroundRect.width = Math.ceil(fontWidth);
				aroundRect.height = Math.ceil(fontHeight);
				this._events.push({
					shape:  elem,
					handle: elem.connect("onmouseenter", this, function(e){
						dijit.showTooltip(label, aroundRect, position);
					})
				});
				this._events.push({
					shape:  elem,
					handle: elem.connect("onmouseleave", this, function(e){
						dijit.hideTooltip(aroundRect);
					})
				});
			}
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.plot2d.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.plot2d.common"] = true;
dojo.provide("dojox.charting.plot2d.common");





(function(){
	var df = dojox.lang.functional, dc = dojox.charting.plot2d.common;

	dojo.mixin(dojox.charting.plot2d.common, {
		makeStroke: function(stroke){
			if(!stroke){ return stroke; }
			if(typeof stroke == "string" || stroke instanceof dojo.Color){
				stroke = {color: stroke};
			}
			return dojox.gfx.makeParameters(dojox.gfx.defaultStroke, stroke);
		},
		augmentColor: function(target, color){
			var t = new dojo.Color(target),
				c = new dojo.Color(color);
			c.a = t.a;
			return c;
		},
		augmentStroke: function(stroke, color){
			var s = dc.makeStroke(stroke);
			if(s){
				s.color = dc.augmentColor(s.color, color);
			}
			return s;
		},
		augmentFill: function(fill, color){
			var fc, c = new dojo.Color(color);
			if(typeof fill == "string" || fill instanceof dojo.Color){
				return dc.augmentColor(fill, color);
			}
			return fill;
		},

		defaultStats: {
			vmin: Number.POSITIVE_INFINITY, vmax: Number.NEGATIVE_INFINITY,
			hmin: Number.POSITIVE_INFINITY, hmax: Number.NEGATIVE_INFINITY
		},

		collectSimpleStats: function(series){
			var stats = dojo.delegate(dc.defaultStats);
			for(var i = 0; i < series.length; ++i){
				var run = series[i];
				for(var j = 0; j < run.data.length; j++){
					if(run.data[j] !== null){
						if(typeof run.data[j] == "number"){
							// 1D case
							var old_vmin = stats.vmin, old_vmax = stats.vmax;
							if(!("ymin" in run) || !("ymax" in run)){
								dojo.forEach(run.data, function(val, i){
									if(val !== null){
										var x = i + 1, y = val;
										if(isNaN(y)){ y = 0; }
										stats.hmin = Math.min(stats.hmin, x);
										stats.hmax = Math.max(stats.hmax, x);
										stats.vmin = Math.min(stats.vmin, y);
										stats.vmax = Math.max(stats.vmax, y);
									}
								});
							}
							if("ymin" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }
							if("ymax" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }
						}else{
							// 2D case
							var old_hmin = stats.hmin, old_hmax = stats.hmax,
								old_vmin = stats.vmin, old_vmax = stats.vmax;
							if(!("xmin" in run) || !("xmax" in run) || !("ymin" in run) || !("ymax" in run)){
								dojo.forEach(run.data, function(val, i){
									if(val !== null){
										var x = "x" in val ? val.x : i + 1, y = val.y;
										if(isNaN(x)){ x = 0; }
										if(isNaN(y)){ y = 0; }
										stats.hmin = Math.min(stats.hmin, x);
										stats.hmax = Math.max(stats.hmax, x);
										stats.vmin = Math.min(stats.vmin, y);
										stats.vmax = Math.max(stats.vmax, y);
									}
								});
							}
							if("xmin" in run){ stats.hmin = Math.min(old_hmin, run.xmin); }
							if("xmax" in run){ stats.hmax = Math.max(old_hmax, run.xmax); }
							if("ymin" in run){ stats.vmin = Math.min(old_vmin, run.ymin); }
							if("ymax" in run){ stats.vmax = Math.max(old_vmax, run.ymax); }
						}

						break;
					}
				}
			}
			return stats;
		},

		calculateBarSize: function(/* Number */ availableSize, /* Object */ opt, /* Number? */ clusterSize){
			if(!clusterSize){
				clusterSize = 1;
			}
			var gap = opt.gap, size = (availableSize - 2 * gap) / clusterSize;
			if("minBarSize" in opt){
				size = Math.max(size, opt.minBarSize);
			}
			if("maxBarSize" in opt){
				size = Math.min(size, opt.maxBarSize);
			}
			size = Math.max(size, 1);
			gap = (availableSize - size * clusterSize) / 2;
			return {size: size, gap: gap};	// Object
		},

		collectStackedStats: function(series){
			// collect statistics
			var stats = dojo.clone(dc.defaultStats);
			if(series.length){
				// 1st pass: find the maximal length of runs
				stats.hmin = Math.min(stats.hmin, 1);
				stats.hmax = df.foldl(series, "seed, run -> Math.max(seed, run.data.length)", stats.hmax);
				// 2nd pass: stack values
				for(var i = 0; i < stats.hmax; ++i){
					var v = series[0].data[i];
                    v = v && (typeof v == "number" ? v : v.y);
					if(isNaN(v)){ v = 0; }
					stats.vmin = Math.min(stats.vmin, v);
					for(var j = 1; j < series.length; ++j){
						var t = series[j].data[i];
                        t = t && (typeof t == "number" ? t : t.y);
						if(isNaN(t)){ t = 0; }
						v += t;
					}
					stats.vmax = Math.max(stats.vmax, v);
				}
			}
			return stats;
		},

		curve: function(/* Number[] */a, /* Number|String */tension){
			//	FIX for #7235, submitted by Enzo Michelangeli.
			//	Emulates the smoothing algorithms used in a famous, unnamed spreadsheet
			//		program ;)
			var arr = a.slice(0);
			if(tension == "x") {
				arr[arr.length] = arr[0];   // add a last element equal to the first, closing the loop
			}
			var p=dojo.map(arr, function(item, i){
				if(i==0){ return "M" + item.x + "," + item.y; }
				if(!isNaN(tension)) { // use standard Dojo smoothing in tension is numeric
					var dx=item.x-arr[i-1].x, dy=arr[i-1].y;
					return "C"+(item.x-(tension-1)*(dx/tension))+","+dy+" "+(item.x-(dx/tension))+","+item.y+" "+item.x+","+item.y;
				} else if(tension == "X" || tension == "x" || tension == "S") {
					// use Excel "line smoothing" algorithm (http://xlrotor.com/resources/files.shtml)
					var p0, p1 = arr[i-1], p2 = arr[i], p3;
					var bz1x, bz1y, bz2x, bz2y;
					var f = 1/6;
					if(i==1) {
						if(tension == "x") {
							p0 = arr[arr.length-2];
						} else { // "tension == X || tension == "S"
							p0 = p1;
						}
						f = 1/3;
					} else {
						p0 = arr[i-2];
					}
					if(i==(arr.length-1)) {
						if(tension == "x") {
							p3 = arr[1];
						} else { // "tension == X || tension == "S"
							p3 = p2;
						}
						f = 1/3;
					} else {
						p3 = arr[i+1];
					}
					var p1p2 = Math.sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));
					var p0p2 = Math.sqrt((p2.x-p0.x)*(p2.x-p0.x)+(p2.y-p0.y)*(p2.y-p0.y));
					var p1p3 = Math.sqrt((p3.x-p1.x)*(p3.x-p1.x)+(p3.y-p1.y)*(p3.y-p1.y));

					var p0p2f = p0p2 * f;
					var p1p3f = p1p3 * f;

					if(p0p2f > p1p2/2 && p1p3f > p1p2/2) {
						p0p2f = p1p2/2;
						p1p3f = p1p2/2;
					} else if(p0p2f > p1p2/2) {
						p0p2f = p1p2/2;
						p1p3f = p1p2/2 * p1p3/p0p2;
					} else if(p1p3f > p1p2/2) {
						p1p3f = p1p2/2;
						p0p2f = p1p2/2 * p0p2/p1p3;
					}

					if(tension == "S") {
						if(p0 == p1) { p0p2f = 0; }
						if(p2 == p3) { p1p3f = 0; }
					}

					bz1x = p1.x + p0p2f*(p2.x - p0.x)/p0p2;
					bz1y = p1.y + p0p2f*(p2.y - p0.y)/p0p2;
					bz2x = p2.x - p1p3f*(p3.x - p1.x)/p1p3;
					bz2y = p2.y - p1p3f*(p3.y - p1.y)/p1p3;
				}
				return "C"+(bz1x+","+bz1y+" "+bz2x+","+bz2y+" "+p2.x+","+p2.y);
			});
			return p.join(" ");
		},
		
		getLabel: function(/*Number*/number, /*Boolean*/fixed, /*Number*/precision){
			if(dojo.number){
				return (fixed ? dojo.number.format(number, {places : precision}) :
					dojo.number.format(number)) || "";
			}
			return fixed ? number.toFixed(precision) : number.toString();
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.plot2d._PlotEvents"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.plot2d._PlotEvents"] = true;
dojo.provide("dojox.charting.plot2d._PlotEvents");

dojo.declare("dojox.charting.plot2d._PlotEvents", null, {
	constructor: function(){
		this._shapeEvents = [];
		this._eventSeries = {};
	},
	destroy: function(){
		//	summary:
		//		Destroy any internal elements and event handlers.
		this.resetEvents();
		this.inherited(arguments);
	},
	plotEvent: function(o){
		//	summary:
		//		Stub function for use by specific plots.
		//	o: Object
		//		An object intended to represent event parameters.
	},
	raiseEvent: function(o){
		//	summary:
		//		Raises events in predefined order
		//	o: Object
		//		An object intended to represent event parameters.
		this.plotEvent(o);
		var t = dojo.delegate(o);
		t.originalEvent = o.type;
		t.originalPlot  = o.plot;
		t.type = "onindirect";
		dojo.forEach(this.chart.stack, function(plot){
			if(plot !== this && plot.plotEvent){
				t.plot = plot;
				plot.plotEvent(t);
			}
		}, this);
	},
	connect: function(object, method){
		//	summary:
		//		Helper function to connect any object's method to our plotEvent.
		//	object: Object
		//		The object to connect to.
		//	method: String|Function
		//		The method to fire when our plotEvent is fired.
		//	returns: Array
		//		The handle as returned from dojo.connect (see dojo.connect).
		this.dirty = true;
		return dojo.connect(this, "plotEvent", object, method);	//	Array
	},
	events: function(){
		//	summary:
		//		Find out if any event handlers have been connected to our plotEvent.
		//	returns: Boolean
		//		A flag indicating that there are handlers attached.
		var ls = this.plotEvent._listeners;
		if(!ls || !ls.length){ return false; }
		for(var i in ls){
			if(!(i in Array.prototype)){
				return true;
			}
		}
		return false;
	},
	resetEvents: function(){
		//	summary:
		//		Reset all events attached to our plotEvent (i.e. disconnect).
		if(this._shapeEvents.length){
			dojo.forEach(this._shapeEvents, function(item){
				item.shape.disconnect(item.handle);
			});
			this._shapeEvents = [];
		}
		this.raiseEvent({type: "onplotreset", plot: this});
	},
	_connectSingleEvent: function(o, eventName){
		this._shapeEvents.push({
			shape:  o.eventMask,
			handle: o.eventMask.connect(eventName, this, function(e){
				o.type  = eventName;
				o.event = e;
				this.raiseEvent(o);
				o.event = null;
			})
		});
	},
	_connectEvents: function(o){
        if(o){
            o.chart = this.chart;
            o.plot  = this;
            o.hAxis = this.hAxis || null;
            o.vAxis = this.vAxis || null;
            o.eventMask = o.eventMask || o.shape;
            this._connectSingleEvent(o, "onmouseover");
            this._connectSingleEvent(o, "onmouseout");
            this._connectSingleEvent(o, "onclick");
        }
	},
	_reconnectEvents: function(seriesName){
		var a = this._eventSeries[seriesName];
		if(a){
			dojo.forEach(a, this._connectEvents, this);
		}
	},
	fireEvent: function(seriesName, eventName, index, eventObject){
		//	summary:
		//		Emulates firing an event for a given data value (specified by
		//		an index) of a given series.
		//	seriesName: String:
		//		Series name.
		//	eventName: String:
		//		Event name to emulate.
		//	index:	Number:
		//		Valid data value index used to raise an event.
		//	eventObject: Object?:
		//		Optional event object. Especially useful for synthetic events.
		//		Default: null.
		var s = this._eventSeries[seriesName];
		if(s && s.length && index < s.length){
			var o = s[index];
			o.type  = eventName;
			o.event = eventObject || null;
			this.raiseEvent(o);
			o.event = null;
		}
	}
});

}

if(!dojo._hasResource["dojox.charting.plot2d.Pie"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.plot2d.Pie"] = true;
dojo.provide("dojox.charting.plot2d.Pie");










/*=====
dojo.declare("dojox.charting.plot2d.__PieCtorArgs", dojox.charting.plot2d.__DefaultCtorArgs, {
	//	summary:
	//		Specialized keyword arguments object for use in defining parameters on a Pie chart.

	//	labels: Boolean?
	//		Whether or not to draw labels within each pie slice.  Default is true.
	labels:			true,

	//	ticks: Boolean?
	//		Whether or not to draw ticks to labels within each slice. Default is false.
	ticks:			false,

	//	fixed: Boolean?
	//		TODO
	fixed:			true,

	//	precision: Number?
	//		The precision at which to sum/add data values. Default is 1.
	precision:		1,

	//	labelOffset: Number?
	//		The amount in pixels by which to offset labels.  Default is 20.
	labelOffset:	20,

	//	labelStyle: String?
	//		Options as to where to draw labels.  Values include "default", "rows", and "auto". Default is "default".
	labelStyle:		"default",	// default/rows/auto

	//	htmlLabels: Boolean?
	//		Whether or not to use HTML to render slice labels. Default is true.
	htmlLabels:		true,

	//	radGrad: String?
	//		The type of radial gradient to use in rendering.  Default is "native".
	radGrad:        "native",

	//	fanSize: Number?
	//		The amount for a radial gradient.  Default is 5.
	fanSize:		5,

	//	startAngle: Number?
	//		Where to being rendering gradients in slices, in degrees.  Default is 0.
	startAngle:     0,

	//	radius: Number?
	//		The size of the radial gradient.  Default is 0.
	radius:		0
});
=====*/
(function(){
	var df = dojox.lang.functional, du = dojox.lang.utils,
		dc = dojox.charting.plot2d.common,
		da = dojox.charting.axis2d.common,
		g = dojox.gfx, m = g.matrix,
		FUDGE_FACTOR = 0.2; // use to overlap fans

	dojo.declare("dojox.charting.plot2d.Pie", [dojox.charting.Element, dojox.charting.plot2d._PlotEvents], {
		//	summary:
		//		The plot that represents a typical pie chart.
		defaultParams: {
			labels:			true,
			ticks:			false,
			fixed:			true,
			precision:		1,
			labelOffset:	20,
			labelStyle:		"default",	// default/rows/auto/columns
			htmlLabels:		true,		// use HTML to draw labels
			radGrad:        "native",	// or "linear", or "fan"
			fanSize:		5,			// maximum fan size in degrees
			startAngle:     0			// start angle for slices in degrees
		},
		optionalParams: {
			radius:		0,
			// theme components
			stroke:		{},
			outline:	{},
			shadow:		{},
			fill:		{},
			font:		"",
			fontColor:	"",
			labelWiring: {}
		},

		constructor: function(chart, kwArgs){
			//	summary:
			//		Create a pie plot.
			this.opt = dojo.clone(this.defaultParams);
			du.updateWithObject(this.opt, kwArgs);
			du.updateWithPattern(this.opt, kwArgs, this.optionalParams);
			this.run = null;
			this.dyn = [];
		},
		clear: function(){
			//	summary:
			//		Clear out all of the information tied to this plot.
			//	returns: dojox.charting.plot2d.Pie
			//		A reference to this plot for functional chaining.
			this.dirty = true;
			this.dyn = [];
			this.run = null;
			return this;	//	dojox.charting.plot2d.Pie
		},
		setAxis: function(axis){
			//	summary:
			//		Dummy method, since axes are irrelevant with a Pie chart.
			//	returns: dojox.charting.plot2d.Pie
			//		The reference to this plot for functional chaining.
			return this;	//	dojox.charting.plot2d.Pie
		},
		addSeries: function(run){
			//	summary:
			//		Add a series of data to this plot.
			//	returns: dojox.charting.plot2d.Pie
			//		The reference to this plot for functional chaining.
			this.run = run;
			return this;	//	dojox.charting.plot2d.Pie
		},
		getSeriesStats: function(){
			//	summary:
			//		Returns default stats (irrelevant for this type of plot).
			//	returns: Object
			//		{hmin, hmax, vmin, vmax} min/max in both directions.
			return dojo.delegate(dc.defaultStats);
		},
		initializeScalers: function(){
			//	summary:
			//		Does nothing (irrelevant for this type of plot).
			return this;
		},
		getRequiredColors: function(){
			//	summary:
			//		Return the number of colors needed to draw this plot.
			return this.run ? this.run.data.length : 0;
		},

		render: function(dim, offsets){
			//	summary:
			//		Render the plot on the chart.
			//	dim: Object
			//		An object of the form { width, height }.
			//	offsets: Object
			//		An object of the form { l, r, t, b }.
			//	returns: dojox.charting.plot2d.Pie
			//		A reference to this plot for functional chaining.
			if(!this.dirty){ return this; }
			this.resetEvents();
			this.dirty = false;
			this._eventSeries = {};
			this.cleanGroup();
			var s = this.group, t = this.chart.theme;

			if(!this.run || !this.run.data.length){
				return this;
			}

			// calculate the geometry
			var rx = (dim.width  - offsets.l - offsets.r) / 2,
				ry = (dim.height - offsets.t - offsets.b) / 2,
				r  = Math.min(rx, ry),
				taFont = "font" in this.opt ? this.opt.font : t.axis.font,
				size = taFont ? g.normalizedLength(g.splitFontString(taFont).size) : 0,
				taFontColor = "fontColor" in this.opt ? this.opt.fontColor : t.axis.fontColor,
				startAngle = m._degToRad(this.opt.startAngle),
				start = startAngle, step, filteredRun, slices, labels, shift, labelR,
				run = this.run.data,
				events = this.events();
			if(typeof run[0] == "number"){
				filteredRun = df.map(run, "x ? Math.max(x, 0) : 0");
				if(df.every(filteredRun, "<= 0")){
					return this;
				}
				slices = df.map(filteredRun, "/this", df.foldl(filteredRun, "+", 0));
				if(this.opt.labels){
					labels = dojo.map(slices, function(x){
						return x > 0 ? this._getLabel(x * 100) + "%" : "";
					}, this);
				}
			}else{
				filteredRun = df.map(run, "x ? Math.max(x.y, 0) : 0");
				if(df.every(filteredRun, "<= 0")){
					return this;
				}
				slices = df.map(filteredRun, "/this", df.foldl(filteredRun, "+", 0));
				if(this.opt.labels){
					labels = dojo.map(slices, function(x, i){
						if(x <= 0){ return ""; }
						var v = run[i];
						return "text" in v ? v.text : this._getLabel(x * 100) + "%";
					}, this);
				}
			}
			var themes = df.map(run, function(v, i){
				if(v === null || typeof v == "number"){
					return t.next("slice", [this.opt, this.run], true);
				}
				return t.next("slice", [this.opt, this.run, v], true);
			}, this);
			if(this.opt.labels){
				shift = df.foldl1(df.map(labels, function(label, i){
					var font = themes[i].series.font;
					return dojox.gfx._base._getTextBox(label, {font: font}).w;
				}, this), "Math.max(a, b)") / 2;
				if(this.opt.labelOffset < 0){
					r = Math.min(rx - 2 * shift, ry - size) + this.opt.labelOffset;
				}
				labelR = r - this.opt.labelOffset;
			}
			if("radius" in this.opt){
				r = this.opt.radius;
				labelR = r - this.opt.labelOffset;
			}
			var	circle = {
					cx: offsets.l + rx,
					cy: offsets.t + ry,
					r:  r
				};

			this.dyn = [];
			// draw slices
			var eventSeries = new Array(slices.length);
			dojo.some(slices, function(slice, i){
				if(slice < 0){
					// degenerated slice
					return false;	// continue
				}
                if(slice == 0){
                    this.dyn.push({fill:null,stroke:null});
                    return false;
                }
				var v = run[i], theme = themes[i], specialFill;
				if(slice >= 1){
					// whole pie
					specialFill = this._plotFill(theme.series.fill, dim, offsets);
					specialFill = this._shapeFill(specialFill,
						{
							x: circle.cx - circle.r, y: circle.cy - circle.r,
							width: 2 * circle.r, height: 2 * circle.r
						});
					specialFill = this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, circle.r);
					var shape = s.createCircle(circle).setFill(specialFill).setStroke(theme.series.stroke);
					this.dyn.push({fill: specialFill, stroke: theme.series.stroke});

					if(events){
						var o = {
							element: "slice",
							index:   i,
							run:     this.run,
							shape:   shape,
							x:       i,
							y:       typeof v == "number" ? v : v.y,
							cx:      circle.cx,
							cy:      circle.cy,
							cr:      r
						};
						this._connectEvents(o);
						eventSeries[i] = o;
					}

					return true;	// stop iteration
				}
				// calculate the geometry of the slice
				var end = start + slice * 2 * Math.PI;
				if(i + 1 == slices.length){
					end = startAngle + 2 * Math.PI;
				}
				var	step = end - start,
					x1 = circle.cx + r * Math.cos(start),
					y1 = circle.cy + r * Math.sin(start),
					x2 = circle.cx + r * Math.cos(end),
					y2 = circle.cy + r * Math.sin(end);
				// draw the slice
				var fanSize = m._degToRad(this.opt.fanSize);
				if(theme.series.fill && theme.series.fill.type === "radial" && this.opt.radGrad === "fan" && step > fanSize){
					var group = s.createGroup(), nfans = Math.ceil(step / fanSize), delta = step / nfans;
					specialFill = this._shapeFill(theme.series.fill,
						{x: circle.cx - circle.r, y: circle.cy - circle.r, width: 2 * circle.r, height: 2 * circle.r});
					for(var j = 0; j < nfans; ++j){
						var fansx = j == 0 ? x1 : circle.cx + r * Math.cos(start + (j - FUDGE_FACTOR) * delta),
							fansy = j == 0 ? y1 : circle.cy + r * Math.sin(start + (j - FUDGE_FACTOR) * delta),
							fanex = j == nfans - 1 ? x2 : circle.cx + r * Math.cos(start + (j + 1 + FUDGE_FACTOR) * delta),
							faney = j == nfans - 1 ? y2 : circle.cy + r * Math.sin(start + (j + 1 + FUDGE_FACTOR) * delta),
							fan = group.createPath({}).
								moveTo(circle.cx, circle.cy).
								lineTo(fansx, fansy).
								arcTo(r, r, 0, delta > Math.PI, true, fanex, faney).
								lineTo(circle.cx, circle.cy).
								closePath().
								setFill(this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, r, start + (j + 0.5) * delta, start + (j + 0.5) * delta));
					}
					group.createPath({}).
						moveTo(circle.cx, circle.cy).
						lineTo(x1, y1).
						arcTo(r, r, 0, step > Math.PI, true, x2, y2).
						lineTo(circle.cx, circle.cy).
						closePath().
						setStroke(theme.series.stroke);
					shape = group;
				}else{
					shape = s.createPath({}).
						moveTo(circle.cx, circle.cy).
						lineTo(x1, y1).
						arcTo(r, r, 0, step > Math.PI, true, x2, y2).
						lineTo(circle.cx, circle.cy).
						closePath().
						setStroke(theme.series.stroke);
					var specialFill = theme.series.fill;
					if(specialFill && specialFill.type === "radial"){
						specialFill = this._shapeFill(specialFill, {x: circle.cx - circle.r, y: circle.cy - circle.r, width: 2 * circle.r, height: 2 * circle.r});
						if(this.opt.radGrad === "linear"){
							specialFill = this._pseudoRadialFill(specialFill, {x: circle.cx, y: circle.cy}, r, start, end);
						}
					}else if(specialFill && specialFill.type === "linear"){
						specialFill = this._plotFill(specialFill, dim, offsets);
						specialFill = this._shapeFill(specialFill, shape.getBoundingBox());
					}
					shape.setFill(specialFill);
				}
				this.dyn.push({fill: specialFill, stroke: theme.series.stroke});

				if(events){
					var o = {
						element: "slice",
						index:   i,
						run:     this.run,
						shape:   shape,
						x:       i,
						y:       typeof v == "number" ? v : v.y,
						cx:      circle.cx,
						cy:      circle.cy,
						cr:      r
					};
					this._connectEvents(o);
					eventSeries[i] = o;
				}

				start = end;

				return false;	// continue
			}, this);
			// draw labels
			if(this.opt.labels){
				if(this.opt.labelStyle == "default"){
					start = startAngle;
					dojo.some(slices, function(slice, i){
						if(slice < 0){
							// degenerated slice
							return false;	// continue
						}
                        if(slice == 0){
                            this.dyn.push({fill:null,stroke:null});
                            return false;
                        }
						var theme = themes[i];
						if(slice >= 1){
							// whole pie
							var v = run[i], elem = da.createText[this.opt.htmlLabels && dojox.gfx.renderer != "vml" ? "html" : "gfx"](
									this.chart, s, circle.cx, circle.cy + size / 2, "middle", labels[i],
									theme.series.font, theme.series.fontColor);
							if(this.opt.htmlLabels){
								this.htmlElements.push(elem);
							}
							return true;	// stop iteration
						}
						// calculate the geometry of the slice
						var end = start + slice * 2 * Math.PI, v = run[i];
						if(i + 1 == slices.length){
							end = startAngle + 2 * Math.PI;
						}
						var	labelAngle = (start + end) / 2,
							x = circle.cx + labelR * Math.cos(labelAngle),
							y = circle.cy + labelR * Math.sin(labelAngle) + size / 2;
						// draw the label
						var elem = da.createText[this.opt.htmlLabels && dojox.gfx.renderer != "vml" ? "html" : "gfx"]
								(this.chart, s, x, y, "middle", labels[i], theme.series.font, theme.series.fontColor);
						if(this.opt.htmlLabels){
							this.htmlElements.push(elem);
						}
						start = end;
						return false;	// continue
					}, this);
				}else if(this.opt.labelStyle == "columns"){
					start = startAngle;
					//calculate label angles
					var labeledSlices = [];
					dojo.forEach(slices, function(slice, i){
						var end = start + slice * 2 * Math.PI;
						if(i + 1 == slices.length){
							end = startAngle + 2 * Math.PI;
						}
						var labelAngle = (start + end) / 2;
						labeledSlices.push({
							angle: labelAngle,
							left: Math.cos(labelAngle) < 0,
							theme: themes[i],
							index: i,
							omit: end - start < 0.001
						});
						start = end;
					});
					//calculate label radius to each slice
					var labelHeight = dojox.gfx._base._getTextBox("a",{font:taFont}).h;
					this._getProperLabelRadius(labeledSlices, labelHeight, circle.r * 1.1);
					//draw label and wiring
					dojo.forEach(labeledSlices, function(slice, i){
						if (!slice.omit) {
							var leftColumn = circle.cx - circle.r * 2,
								rightColumn = circle.cx + circle.r * 2,
								labelWidth = dojox.gfx._base._getTextBox(labels[i], {font: taFont}).w,
								x = circle.cx + slice.labelR * Math.cos(slice.angle),
								y = circle.cy + slice.labelR * Math.sin(slice.angle),
								jointX = (slice.left) ? (leftColumn + labelWidth) : (rightColumn - labelWidth),
								labelX = (slice.left) ? leftColumn : jointX;
							var wiring = s.createPath().moveTo(circle.cx + circle.r * Math.cos(slice.angle), circle.cy + circle.r * Math.sin(slice.angle))
							if (Math.abs(slice.labelR * Math.cos(slice.angle)) < circle.r * 2 - labelWidth) {
								wiring.lineTo(x, y);
							}
							wiring.lineTo(jointX, y).setStroke(slice.theme.series.labelWiring);
							var elem = da.createText[this.opt.htmlLabels && dojox.gfx.renderer != "vml" ? "html" : "gfx"](
								this.chart, s, labelX, y, "left", labels[i], slice.theme.series.font, slice.theme.series.fontColor);
							if (this.opt.htmlLabels) {
								this.htmlElements.push(elem);
							}
						}
					},this);
				}
			}
			// post-process events to restore the original indexing
			var esi = 0;
			this._eventSeries[this.run.name] = df.map(run, function(v){
				return v <= 0 ? null : eventSeries[esi++];
			});
			return this;	//	dojox.charting.plot2d.Pie
		},
		
		_getProperLabelRadius: function(slices, labelHeight, minRidius){
			var leftCenterSlice = {},rightCenterSlice = {},leftMinSIN = 1, rightMinSIN = 1;
			if (slices.length == 1) {
				slices[0].labelR = minRidius;
				return;
			}
			for(var i = 0;i<slices.length;i++){
				var tempSIN = Math.abs(Math.sin(slices[i].angle));
				if(slices[i].left){
					if(leftMinSIN > tempSIN){
						leftMinSIN = tempSIN;
						leftCenterSlice = slices[i];
					}
				}else{
					if(rightMinSIN > tempSIN){
						rightMinSIN = tempSIN;
						rightCenterSlice = slices[i];
					}
				}
			}
			leftCenterSlice.labelR = rightCenterSlice.labelR = minRidius;
			this._caculateLabelR(leftCenterSlice,slices,labelHeight);
			this._caculateLabelR(rightCenterSlice,slices,labelHeight);
		},
		_caculateLabelR: function(firstSlice,slices,labelHeight){
			var i = firstSlice.index,length = slices.length,
				currentLabelR = firstSlice.labelR;
			while(!(slices[i%length].left ^ slices[(i+1)%length].left)){
				if (!slices[(i + 1) % length].omit) {
					var nextLabelR = (Math.sin(slices[i % length].angle) * currentLabelR + ((slices[i % length].left) ? (-labelHeight) : labelHeight)) /
					Math.sin(slices[(i + 1) % length].angle);
					currentLabelR = (nextLabelR < firstSlice.labelR) ? firstSlice.labelR : nextLabelR;
					slices[(i + 1) % length].labelR = currentLabelR;
				}
				i++;
			}
			i = firstSlice.index,j = (i == 0)?length-1 : i - 1;
			while(!(slices[i].left ^ slices[j].left)){
				if (!slices[j].omit) {
					var nextLabelR = (Math.sin(slices[i].angle) * currentLabelR + ((slices[i].left) ? labelHeight : (-labelHeight))) /
					Math.sin(slices[j].angle);
					currentLabelR = (nextLabelR < firstSlice.labelR) ? firstSlice.labelR : nextLabelR;
					slices[j].labelR = currentLabelR;
				}
				i--;j--;
				i = (i < 0)?i+slices.length:i;
				j = (j < 0)?j+slices.length:j;
			}
		},
		// utilities
		_getLabel: function(number){
			return dc.getLabel(number, this.opt.fixed, this.opt.precision);
		}
	});
})();

}

if(!dojo._hasResource["dojo.fx.easing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.easing"] = true;
dojo.provide("dojo.fx.easing");

dojo.getObject("fx.easing", true, dojo);

dojo.fx.easing = {
	// summary:
	//		Collection of easing functions to use beyond the default
	//		`dojo._defaultEasing` function.
	//
	// description:
	//
	//		Easing functions are used to manipulate the iteration through
	//		an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	//		and the easing function progresses through that Line determing
	//		how quickly (or slowly) it should go. Or more accurately: modify
	//		the value of the _Line based on the percentage of animation completed.
	//
	//		All functions follow a simple naming convention of "ease type" + "when".
	//		If the name of the function ends in Out, the easing described appears
	//		towards the end of the animation. "In" means during the beginning,
	//		and InOut means both ranges of the Animation will applied, both
	//		beginning and end.
	//
	//		One does not call the easing function directly, it must be passed to
	//		the `easing` property of an animation.
	//
	//	example:
	//	|	
	//	|	var anim = dojo.fadeOut({
	//	|		node: 'node',
	//	|		duration: 2000,
	//	|		//	note there is no ()
	//	|		easing: dojo.fx.easing.quadIn
	//	|	}).play();
	//
	
	linear: function(/* Decimal? */n){
		// summary: A linear easing function
		return n;
	},

	quadIn: function(/* Decimal? */n){
		return Math.pow(n, 2);
	},

	quadOut: function(/* Decimal? */n){
		return n * (n - 2) * -1;
	},

	quadInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 2) / 2; }
		return -1 * ((--n) * (n - 2) - 1) / 2;
	},

	cubicIn: function(/* Decimal? */n){
		return Math.pow(n, 3);
	},

	cubicOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 3) + 1;
	},

	cubicInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 3) / 2; }
		n -= 2;
		return (Math.pow(n, 3) + 2) / 2;
	},

	quartIn: function(/* Decimal? */n){
		return Math.pow(n, 4);
	},

	quartOut: function(/* Decimal? */n){
		return -1 * (Math.pow(n - 1, 4) - 1);
	},

	quartInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 4) / 2; }
		n -= 2;
		return -1 / 2 * (Math.pow(n, 4) - 2);
	},

	quintIn: function(/* Decimal? */n){
		return Math.pow(n, 5);
	},

	quintOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 5) + 1;
	},

	quintInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 5) / 2; };
		n -= 2;
		return (Math.pow(n, 5) + 2) / 2;
	},

	sineIn: function(/* Decimal? */n){
		return -1 * Math.cos(n * (Math.PI / 2)) + 1;
	},

	sineOut: function(/* Decimal? */n){
		return Math.sin(n * (Math.PI / 2));
	},

	sineInOut: function(/* Decimal? */n){
		return -1 * (Math.cos(Math.PI * n) - 1) / 2;
	},

	expoIn: function(/* Decimal? */n){
		return (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));
	},

	expoOut: function(/* Decimal? */n){
		return (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);
	},

	expoInOut: function(/* Decimal? */n){
		if(n == 0){ return 0; }
		if(n == 1){ return 1; }
		n = n * 2;
		if(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }
		--n;
		return (-1 * Math.pow(2, -10 * n) + 2) / 2;
	},

	circIn: function(/* Decimal? */n){
		return -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
	},

	circOut: function(/* Decimal? */n){
		n = n - 1;
		return Math.sqrt(1 - Math.pow(n, 2));
	},

	circInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }
		n -= 2;
		return 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);
	},

	backIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that starts away from the target,
		//		and quickly accelerates towards the end value.
		//
		//		Use caution when the easing will cause values to become
		//		negative as some properties cannot be set to negative values.
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n - s);
	},

	backOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that pops past the range briefly, and slowly comes back.
		//
		// description:
		//		An easing function that pops past the range briefly, and slowly comes back.
		//
		//		Use caution when the easing will cause values to become negative as some
		//		properties cannot be set to negative values.
		
		n = n - 1;
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n + s) + 1;
	},

	backInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function combining the effects of `backIn` and `backOut`
		//
		// description:
		//		An easing function combining the effects of `backIn` and `backOut`.
		//		Use caution when the easing will cause values to become negative
		//		as some properties cannot be set to negative values.
		var s = 1.70158 * 1.525;
		n = n * 2;
		if(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }
		n-=2;
		return (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;
	},

	elasticIn: function(/* Decimal? */n){
		// summary:
		//		An easing function the elastically snaps from the start value
		//
		// description:
		//		An easing function the elastically snaps from the start value
		//
		//		Use caution when the elasticity will cause values to become negative
		//		as some properties cannot be set to negative values.
		if(n == 0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		n = n - 1;
		return -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);
	},

	elasticOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		//
		// description:
		//		An easing function that elasticly snaps around the target value,
		//		near the end of the Animation
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n==0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		return Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;
	},

	elasticInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		//
		// description:
		//		An easing function that elasticly snaps around the value, near
		//		the beginning and end of the Animation.
		//
		//		Use caution when the elasticity will cause values to become
		//		negative as some properties cannot be set to negative values.
		if(n == 0) return 0;
		n = n * 2;
		if(n == 2) return 1;
		var p = .3 * 1.5;
		var s = p / 4;
		if(n < 1){
			n -= 1;
			return -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));
		}
		n -= 1;
		return .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;
	},

	bounceIn: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the beginning of an Animation
		return (1 - dojo.fx.easing.bounceOut(1 - n)); // Decimal
	},

	bounceOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' near the end of an Animation
		var s = 7.5625;
		var p = 2.75;
		var l;
		if(n < (1 / p)){
			l = s * Math.pow(n, 2);
		}else if(n < (2 / p)){
			n -= (1.5 / p);
			l = s * Math.pow(n, 2) + .75;
		}else if(n < (2.5 / p)){
			n -= (2.25 / p);
			l = s * Math.pow(n, 2) + .9375;
		}else{
			n -= (2.625 / p);
			l = s * Math.pow(n, 2) + .984375;
		}
		return l;
	},

	bounceInOut: function(/* Decimal? */n){
		// summary:
		//		An easing function that 'bounces' at the beginning and end of the Animation
		if(n < 0.5){ return dojo.fx.easing.bounceIn(n * 2) / 2; }
		return (dojo.fx.easing.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal
	}
};

}

if(!dojo._hasResource["dojox.gfx.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.gfx.fx"] = true;
dojo.provide("dojox.gfx.fx");



(function(){
	var d = dojo, g = dojox.gfx, m = g.matrix;

	// Generic interpolators. Should they be moved to dojox.fx?

	function InterpolNumber(start, end){
		this.start = start, this.end = end;
	}
	InterpolNumber.prototype.getValue = function(r){
		return (this.end - this.start) * r + this.start;
	};

	function InterpolUnit(start, end, units){
		this.start = start, this.end = end;
		this.units = units;
	}
	InterpolUnit.prototype.getValue = function(r){
		return (this.end - this.start) * r + this.start + this.units;
	};

	function InterpolColor(start, end){
		this.start = start, this.end = end;
		this.temp = new dojo.Color();
	}
	InterpolColor.prototype.getValue = function(r){
		return d.blendColors(this.start, this.end, r, this.temp);
	};

	function InterpolValues(values){
		this.values = values;
		this.length = values.length;
	}
	InterpolValues.prototype.getValue = function(r){
		return this.values[Math.min(Math.floor(r * this.length), this.length - 1)];
	};

	function InterpolObject(values, def){
		this.values = values;
		this.def = def ? def : {};
	}
	InterpolObject.prototype.getValue = function(r){
		var ret = dojo.clone(this.def);
		for(var i in this.values){
			ret[i] = this.values[i].getValue(r);
		}
		return ret;
	};

	function InterpolTransform(stack, original){
		this.stack = stack;
		this.original = original;
	}
	InterpolTransform.prototype.getValue = function(r){
		var ret = [];
		dojo.forEach(this.stack, function(t){
			if(t instanceof m.Matrix2D){
				ret.push(t);
				return;
			}
			if(t.name == "original" && this.original){
				ret.push(this.original);
				return;
			}
			if(!(t.name in m)){ return; }
			var f = m[t.name];
			if(typeof f != "function"){
				// constant
				ret.push(f);
				return;
			}
			var val = dojo.map(t.start, function(v, i){
							return (t.end[i] - v) * r + v;
						}),
				matrix = f.apply(m, val);
			if(matrix instanceof m.Matrix2D){
				ret.push(matrix);
			}
		}, this);
		return ret;
	};

	var transparent = new d.Color(0, 0, 0, 0);

	function getColorInterpol(prop, obj, name, def){
		if(prop.values){
			return new InterpolValues(prop.values);
		}
		var value, start, end;
		if(prop.start){
			start = g.normalizeColor(prop.start);
		}else{
			start = value = obj ? (name ? obj[name] : obj) : def;
		}
		if(prop.end){
			end = g.normalizeColor(prop.end);
		}else{
			if(!value){
				value = obj ? (name ? obj[name] : obj) : def;
			}
			end = value;
		}
		return new InterpolColor(start, end);
	}

	function getNumberInterpol(prop, obj, name, def){
		if(prop.values){
			return new InterpolValues(prop.values);
		}
		var value, start, end;
		if(prop.start){
			start = prop.start;
		}else{
			start = value = obj ? obj[name] : def;
		}
		if(prop.end){
			end = prop.end;
		}else{
			if(typeof value != "number"){
				value = obj ? obj[name] : def;
			}
			end = value;
		}
		return new InterpolNumber(start, end);
	}

	g.fx.animateStroke = function(/*Object*/ args){
		// summary:
		//	Returns an animation which will change stroke properties over time
		// example:
		//	|	dojox.gfx.fx.animateStroke{{
		//	|		shape: shape,
		//	|		duration: 500,
		//	|		color: {start: "red", end: "green"},
		//	|		width: {end: 15},
		//	|		join:  {values: ["miter", "bevel", "round"]}
		//	|	}).play();
		if(!args.easing){ args.easing = d._defaultEasing; }
		var anim = new d.Animation(args), shape = args.shape, stroke;
		d.connect(anim, "beforeBegin", anim, function(){
			stroke = shape.getStroke();
			var prop = args.color, values = {}, value, start, end;
			if(prop){
				values.color = getColorInterpol(prop, stroke, "color", transparent);
			}
			prop = args.style;
			if(prop && prop.values){
				values.style = new InterpolValues(prop.values);
			}
			prop = args.width;
			if(prop){
				values.width = getNumberInterpol(prop, stroke, "width", 1);
			}
			prop = args.cap;
			if(prop && prop.values){
				values.cap = new InterpolValues(prop.values);
			}
			prop = args.join;
			if(prop){
				if(prop.values){
					values.join = new InterpolValues(prop.values);
				}else{
					start = prop.start ? prop.start : (stroke && stroke.join || 0);
					end = prop.end ? prop.end : (stroke && stroke.join || 0);
					if(typeof start == "number" && typeof end == "number"){
						values.join = new InterpolNumber(start, end);
					}
				}
			}
			this.curve = new InterpolObject(values, stroke);
		});
		d.connect(anim, "onAnimate", shape, "setStroke");
		return anim; // dojo.Animation
	};

	g.fx.animateFill = function(/*Object*/ args){
		// summary:
		//	Returns an animation which will change fill color over time.
		//	Only solid fill color is supported at the moment
		// example:
		//	|	dojox.gfx.fx.animateFill{{
		//	|		shape: shape,
		//	|		duration: 500,
		//	|		color: {start: "red", end: "green"}
		//	|	}).play();
		if(!args.easing){ args.easing = d._defaultEasing; }
		var anim = new d.Animation(args), shape = args.shape, fill;
		d.connect(anim, "beforeBegin", anim, function(){
			fill = shape.getFill();
			var prop = args.color, values = {};
			if(prop){
				this.curve = getColorInterpol(prop, fill, "", transparent);
			}
		});
		d.connect(anim, "onAnimate", shape, "setFill");
		return anim; // dojo.Animation
	};

	g.fx.animateFont = function(/*Object*/ args){
		// summary:
		//	Returns an animation which will change font properties over time
		// example:
		//	|	dojox.gfx.fx.animateFont{{
		//	|		shape: shape,
		//	|		duration: 500,
		//	|		variant: {values: ["normal", "small-caps"]},
		//	|		size:  {end: 10, units: "pt"}
		//	|	}).play();
		if(!args.easing){ args.easing = d._defaultEasing; }
		var anim = new d.Animation(args), shape = args.shape, font;
		d.connect(anim, "beforeBegin", anim, function(){
			font = shape.getFont();
			var prop = args.style, values = {}, value, start, end;
			if(prop && prop.values){
				values.style = new InterpolValues(prop.values);
			}
			prop = args.variant;
			if(prop && prop.values){
				values.variant = new InterpolValues(prop.values);
			}
			prop = args.weight;
			if(prop && prop.values){
				values.weight = new InterpolValues(prop.values);
			}
			prop = args.family;
			if(prop && prop.values){
				values.family = new InterpolValues(prop.values);
			}
			prop = args.size;
			if(prop && prop.units){
				start = parseFloat(prop.start ? prop.start : (shape.font && shape.font.size || "0"));
				end = parseFloat(prop.end ? prop.end : (shape.font && shape.font.size || "0"));
				values.size = new InterpolUnit(start, end, prop.units);
			}
			this.curve = new InterpolObject(values, font);
		});
		d.connect(anim, "onAnimate", shape, "setFont");
		return anim; // dojo.Animation
	};

	g.fx.animateTransform = function(/*Object*/ args){
		// summary:
		//	Returns an animation which will change transformation over time
		// example:
		//	|	dojox.gfx.fx.animateTransform{{
		//	|		shape: shape,
		//	|		duration: 500,
		//	|		transform: [
		//	|			{name: "translate", start: [0, 0], end: [200, 200]},
		//	|			{name: "original"}
		//	|		]
		//	|	}).play();
		if(!args.easing){ args.easing = d._defaultEasing; }
		var anim = new d.Animation(args), shape = args.shape, original;
		d.connect(anim, "beforeBegin", anim, function(){
			original = shape.getTransform();
			this.curve = new InterpolTransform(args.transform, original);
		});
		d.connect(anim, "onAnimate", shape, "setTransform");
		return anim; // dojo.Animation
	};
})();

}

if(!dojo._hasResource["dojox.charting.action2d.Base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.action2d.Base"] = true;
dojo.provide("dojox.charting.action2d.Base");





/*=====
dojox.charting.action2d.__BaseCtorArgs = function(duration, easing){
 	//	summary:
	//		The base keyword arguments object for creating an action2d.
	//	duration: Number?
	//		The amount of time in milliseconds for an animation to last.  Default is 400.
	//	easing: dojo.fx.easing.*?
	//		An easing object (see dojo.fx.easing) for use in an animation.  The
	//		default is dojo.fx.easing.backOut.
	this.duration = duration;
	this.easing = easing;
}
=====*/
(function(){
	var DEFAULT_DURATION = 400,	// ms
		DEFAULT_EASING   = dojo.fx.easing.backOut,
		df = dojox.lang.functional;

	dojo.declare("dojox.charting.action2d.Base", null, {

		overOutEvents: {onmouseover: 1, onmouseout: 1},

		constructor: function(chart, plot, kwargs){
			//	summary:
			//		Create a new base Action.
			//	chart: dojox.charting.Chart2D
			//		The chart this action applies to.
			//	plot: String?
			//		The name of the plot this action belongs to.  If none is passed "default" is assumed.
			//	kwargs: dojox.charting.action2d.__BaseCtorArgs?
			//		Optional arguments for the action.
			this.chart = chart;
			this.plot = plot || "default";
			this.anim = {};

			// process common optional named parameters
			if(!kwargs){ kwargs = {}; }
			this.duration = kwargs.duration ? kwargs.duration : DEFAULT_DURATION;
			this.easing   = kwargs.easing   ? kwargs.easing   : DEFAULT_EASING;
		},

		connect: function(){
			//	summary:
			//		Connect this action to the given plot.
			this.handle = this.chart.connectToPlot(this.plot, this, "process");
		},

		disconnect: function(){
			//	summary:
			//		Disconnect this action from the given plot, if connected.
			if(this.handle){
				dojo.disconnect(this.handle);
				this.handle = null;
			}
		},

		reset: function(){
			//	summary:
			//		Reset the action.
		},

		destroy: function(){
			//	summary:
			//		Do any cleanup needed when destroying parent elements.
			this.disconnect();
			df.forIn(this.anim, function(o){
				df.forIn(o, function(anim){
					anim.action.stop(true);
				});
			});
			this.anim = {};
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.action2d.Highlight"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.action2d.Highlight"] = true;
dojo.provide("dojox.charting.action2d.Highlight");




/*=====
dojo.declare("dojox.charting.action2d.__HighlightCtorArgs", dojox.charting.action2d.__BaseCtorArgs, {
	//	summary:
	//		Additional arguments for highlighting actions.

	//	highlight: String|dojo.Color|Function?
	//		Either a color or a function that creates a color when highlighting happens.
	highlight: null
});
=====*/
(function(){
	var DEFAULT_SATURATION  = 100,	// %
		DEFAULT_LUMINOSITY1 = 75,	// %
		DEFAULT_LUMINOSITY2 = 50,	// %

		c = dojox.color,

		cc = function(color){
			return function(){ return color; };
		},

		hl = function(color){
			var a = new c.Color(color),
				x = a.toHsl();
			if(x.s == 0){
				x.l = x.l < 50 ? 100 : 0;
			}else{
				x.s = DEFAULT_SATURATION;
				if(x.l < DEFAULT_LUMINOSITY2){
					x.l = DEFAULT_LUMINOSITY1;
				}else if(x.l > DEFAULT_LUMINOSITY1){
					x.l = DEFAULT_LUMINOSITY2;
				}else{
					x.l = x.l - DEFAULT_LUMINOSITY2 > DEFAULT_LUMINOSITY1 - x.l ?
						DEFAULT_LUMINOSITY2 : DEFAULT_LUMINOSITY1;
				}
			}
			return c.fromHsl(x);
		};

	dojo.declare("dojox.charting.action2d.Highlight", dojox.charting.action2d.Base, {
		//	summary:
		//		Creates a highlighting action on a plot, where an element on that plot
		//		has a highlight on it.

		// the data description block for the widget parser
		defaultParams: {
			duration: 400,	// duration of the action in ms
			easing:   dojo.fx.easing.backOut	// easing for the action
		},
		optionalParams: {
			highlight: "red"	// name for the highlight color
								// programmatic instantiation can use functions and color objects
		},

		constructor: function(chart, plot, kwArgs){
			//	summary:
			//		Create the highlighting action and connect it to the plot.
			//	chart: dojox.charting.Chart2D
			//		The chart this action belongs to.
			//	plot: String?
			//		The plot this action is attached to.  If not passed, "default" is assumed.
			//	kwArgs: dojox.charting.action2d.__HighlightCtorArgs?
			//		Optional keyword arguments object for setting parameters.
			var a = kwArgs && kwArgs.highlight;
			this.colorFun = a ? (dojo.isFunction(a) ? a : cc(a)) : hl;

			this.connect();
		},

		process: function(o){
			//	summary:
			//		Process the action on the given object.
			//	o: dojox.gfx.Shape
			//		The object on which to process the highlighting action.
			if(!o.shape || !(o.type in this.overOutEvents)){ return; }

			var runName = o.run.name, index = o.index, anim, startFill, endFill;

			if(runName in this.anim){
				anim = this.anim[runName][index];
			}else{
				this.anim[runName] = {};
			}

			if(anim){
				anim.action.stop(true);
			}else{
				var color = o.shape.getFill();
				if(!color || !(color instanceof dojo.Color)){
					return;
				}
				this.anim[runName][index] = anim = {
					start: color,
					end:   this.colorFun(color)
				};
			}

			var start = anim.start, end = anim.end;
			if(o.type == "onmouseout"){
				// swap colors
				var t = start;
				start = end;
				end = t;
			}

			anim.action = dojox.gfx.fx.animateFill({
				shape:    o.shape,
				duration: this.duration,
				easing:   this.easing,
				color:    {start: start, end: end}
			});
			if(o.type == "onmouseout"){
				dojo.connect(anim.action, "onEnd", this, function(){
					if(this.anim[runName]){
						delete this.anim[runName][index];
					}
				});
			}
			anim.action.play();
		}
	});
})();

}

if(!dojo._hasResource["dojox.lang.functional.scan"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.functional.scan"] = true;
dojo.provide("dojox.lang.functional.scan");



// This module adds high-level functions and related constructs:
//	- "scan" family of functions

// Notes:
//	- missing high-level functions are provided with the compatible API:
//		scanl, scanl1, scanr, scanr1

// Defined methods:
//	- take any valid lambda argument as the functional argument
//	- operate on dense arrays
//	- take a string as the array argument
//	- take an iterator objects as the array argument (only scanl, and scanl1)

(function(){
	var d = dojo, df = dojox.lang.functional, empty = {};

	d.mixin(df, {
		// classic reduce-class functions
		scanl: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object*/ z, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from left
			//	to right using a seed value as a starting point; returns an array
			//	of values produced by foldl() at that point.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var t, n, i;
			if(d.isArray(a)){
				// array
				t = new Array((n = a.length) + 1);
				t[0] = z;
				for(i = 0; i < n; z = f.call(o, z, a[i], i, a), t[++i] = z);
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				t = [z];
				for(i = 0; a.hasNext(); t.push(z = f.call(o, z, a.next(), i++, a)));
			}else{
				// object/dictionary
				t = [z];
				for(i in a){
					if(!(i in empty)){
						t.push(z = f.call(o, z, a[i], i, a));
					}
				}
			}
			return t;	// Array
		},
		scanl1: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from left
			//	to right; returns an array of values produced by foldl1() at that
			//	point.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var t, n, z, first = true;
			if(d.isArray(a)){
				// array
				t = new Array(n = a.length);
				t[0] = z = a[0];
				for(var i = 1; i < n; t[i] = z = f.call(o, z, a[i], i, a), ++i);
			}else if(typeof a.hasNext == "function" && typeof a.next == "function"){
				// iterator
				if(a.hasNext()){
					t = [z = a.next()];
					for(var i = 1; a.hasNext(); t.push(z = f.call(o, z, a.next(), i++, a)));
				}
			}else{
				// object/dictionary
				for(var i in a){
					if(!(i in empty)){
						if(first){
							t = [z = a[i]];
							first = false;
						}else{
							t.push(z = f.call(o, z, a[i], i, a));
						}
					}
				}
			}
			return t;	// Array
		},
		scanr: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object*/ z, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from right
			//	to left using a seed value as a starting point; returns an array
			//	of values produced by foldr() at that point.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var n = a.length, t = new Array(n + 1), i = n;
			t[n] = z;
			for(; i > 0; --i, z = f.call(o, z, a[i], i, a), t[i] = z);
			return t;	// Array
		},
		scanr1: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){
			// summary: repeatedly applies a binary function to an array from right
			//	to left; returns an array of values produced by foldr1() at that
			//	point.
			if(typeof a == "string"){ a = a.split(""); }
			o = o || d.global; f = df.lambda(f);
			var n = a.length, t = new Array(n), z = a[n - 1], i = n - 1;
			t[i] = z;
			for(; i > 0; --i, z = f.call(o, z, a[i], i, a), t[i] = z);
			return t;	// Array
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.action2d.MoveSlice"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.action2d.MoveSlice"] = true;
dojo.provide("dojox.charting.action2d.MoveSlice");








/*=====
dojo.declare("dojox.charting.action2d.__MoveSliceCtorArgs", dojox.charting.action2d.__BaseCtorArgs, {
	//	summary:
	//		Additional arguments for highlighting actions.

	//	scale: Number?
	//		The amount to scale the pie slice.  Default is 1.05.
	scale: 1.05,

	//	shift: Number?
	//		The amount in pixels to shift the pie slice.  Default is 7.
	shift: 7
});
=====*/
(function(){
	var DEFAULT_SCALE = 1.05,
		DEFAULT_SHIFT = 7,	// px
		m = dojox.gfx.matrix,
		gf = dojox.gfx.fx,
		df = dojox.lang.functional;

	dojo.declare("dojox.charting.action2d.MoveSlice", dojox.charting.action2d.Base, {
		//	summary:
		//		Create an action for a pie chart that moves and scales a pie slice.

		// the data description block for the widget parser
		defaultParams: {
			duration: 400,	// duration of the action in ms
			easing:   dojo.fx.easing.backOut,	// easing for the action
			scale:    DEFAULT_SCALE,	// scale of magnification
			shift:    DEFAULT_SHIFT		// shift of the slice
		},
		optionalParams: {},	// no optional parameters

		constructor: function(chart, plot, kwArgs){
			//	summary:
			//		Create the slice moving action and connect it to the plot.
			//	chart: dojox.charting.Chart2D
			//		The chart this action belongs to.
			//	plot: String?
			//		The plot this action is attached to.  If not passed, "default" is assumed.
			//	kwArgs: dojox.charting.action2d.__MoveSliceCtorArgs?
			//		Optional keyword arguments object for setting parameters.
			if(!kwArgs){ kwArgs = {}; }
			this.scale = typeof kwArgs.scale == "number" ? kwArgs.scale : DEFAULT_SCALE;
			this.shift = typeof kwArgs.shift == "number" ? kwArgs.shift : DEFAULT_SHIFT;

			this.connect();
		},

		process: function(o){
			//	summary:
			//		Process the action on the given object.
			//	o: dojox.gfx.Shape
			//		The object on which to process the slice moving action.
			if(!o.shape || o.element != "slice" || !(o.type in this.overOutEvents)){ return; }

			if(!this.angles){
				// calculate the running total of slice angles
				var startAngle = m._degToRad(o.plot.opt.startAngle);
				if(typeof o.run.data[0] == "number"){
					this.angles = df.map(df.scanl(o.run.data, "+", startAngle),
						"* 2 * Math.PI / this", df.foldl(o.run.data, "+", 0));
				}else{
					this.angles = df.map(df.scanl(o.run.data, "a + b.y", startAngle),
						"* 2 * Math.PI / this", df.foldl(o.run.data, "a + b.y", 0));
				}
			}

			var index = o.index, anim, startScale, endScale, startOffset, endOffset,
				angle = (this.angles[index] + this.angles[index + 1]) / 2,
				rotateTo0  = m.rotateAt(-angle, o.cx, o.cy),
				rotateBack = m.rotateAt( angle, o.cx, o.cy);

			anim = this.anim[index];

			if(anim){
				anim.action.stop(true);
			}else{
				this.anim[index] = anim = {};
			}

			if(o.type == "onmouseover"){
				startOffset = 0;
				endOffset   = this.shift;
				startScale  = 1;
				endScale    = this.scale;
			}else{
				startOffset = this.shift;
				endOffset   = 0;
				startScale  = this.scale;
				endScale    = 1;
			}

			anim.action = dojox.gfx.fx.animateTransform({
				shape:    o.shape,
				duration: this.duration,
				easing:   this.easing,
				transform: [
					rotateBack,
					{name: "translate", start: [startOffset, 0], end: [endOffset, 0]},
					{name: "scaleAt",   start: [startScale, o.cx, o.cy],  end: [endScale, o.cx, o.cy]},
					rotateTo0
				]
			});

			if(o.type == "onmouseout"){
				dojo.connect(anim.action, "onEnd", this, function(){
					delete this.anim[index];
				});
			}
			anim.action.play();
		},

		reset: function(){
			delete this.angles;
		}
	});
})();

}

if(!dojo._hasResource["dojox.charting.themes.PlotKit.base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.themes.PlotKit.base"] = true;
dojo.provide("dojox.charting.themes.PlotKit.base");



// the baseline theme for all PlotKIt themes
(function(){
	var dc = dojox.charting, pk = dc.themes.PlotKit;

	pk.base = new dc.Theme({
		chart:{
			stroke: null,
			fill:   "yellow"
		},
		plotarea:{
			stroke: null,
			fill:   "yellow"
		},
		axis:{
			stroke:    {color:"#fff", width:1},
			line:      {color:"#fff", width:.5},
			majorTick: {color: "#fff", width: .5, length: 6},
			minorTick: {color: "#fff", width: .5, length: 3},
			tick:      {font: "normal normal normal 7pt Helvetica,Arial,sans-serif", fontColor: "#999"}
		},
		series:{
			stroke:    {width: 2.5, color:"#fff"},
			fill:      "#666",
			font:      "normal normal normal 7.5pt Helvetica,Arial,sans-serif",	//	label
			fontColor: "#666"
		},
		marker:{	//	any markers on a series.
			stroke:    {width: 2},
			fill:      "#333",
			font:      "normal normal normal 7pt Helvetica,Arial,sans-serif",	//	label
			fontColor: "#666"
		},
		colors: ["red", "green", "blue"]
	});

	pk.base.next = function(elementType, mixin, doPost){
		var theme = dc.Theme.prototype.next.apply(this, arguments);
		if(elementType == "line"){
			theme.marker.outline = {width: 2, color: "#fff"};
			theme.series.stroke.width = 3.5;
			theme.marker.stroke.width = 2;
		} else if (elementType == "candlestick"){
			theme.series.stroke.width = 1;
		} else {
			theme.series.stroke.color = "#fff";
		}
		return theme;
	};
})();

}

if(!dojo._hasResource["dojox.charting.themes.PlotKit.cyan"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.themes.PlotKit.cyan"] = true;
dojo.provide("dojox.charting.themes.PlotKit.cyan");


(function(){
	var dc = dojox.charting, pk = dc.themes.PlotKit;

	pk.cyan = pk.base.clone();
	pk.cyan.chart.fill = pk.cyan.plotarea.fill = "#e6f1f5";
	pk.cyan.colors = dc.Theme.defineColors({hue: 194, saturation: 60, low: 40, high: 88});
})();

}

if(!dojo._hasResource["dojox.charting.widget.Legend"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.widget.Legend"] = true;
dojo.provide("dojox.charting.widget.Legend");







dojo.declare("dojox.charting.widget.Legend", [dijit._Widget, dijit._Templated], {
	// summary: A legend for a chart. A legend contains summary labels for
	// each series of data contained in the chart.
	//
	// Set the horizontal attribute to boolean false to layout legend labels vertically.
	// Set the horizontal attribute to a number to layout legend labels in horizontal
	// rows each containing that number of labels (except possibly the last row).
	//
	// (Line or Scatter charts (colored lines with shape symbols) )
	// -o- Series1		-X- Series2		-v- Series3
	//
	// (Area/Bar/Pie charts (letters represent colors))
	// [a] Series1		[b] Series2		[c] Series3
	
	chartRef:   "",
	horizontal: true,
	swatchSize: 18,
	
	templateString: "<table dojoAttachPoint='legendNode' class='dojoxLegendNode' role='group' aria-label='chart legend'><tbody dojoAttachPoint='legendBody'></tbody></table>",
	
	legendNode: null,
	legendBody: null,
	
	postCreate: function(){
		if(!this.chart){
			if(!this.chartRef){ return; }
			this.chart = dijit.byId(this.chartRef);
			if(!this.chart){
				var node = dojo.byId(this.chartRef);
				if(node){
					this.chart = dijit.byNode(node);
				}else{
					console.log("Could not find chart instance with id: " + this.chartRef);
					return;
				}
			}
			this.series = this.chart.chart.series;
		}else{
			this.series = this.chart.series;
		}
		
		this.refresh();
	},
	refresh: function(){
		// summary: regenerates the legend to reflect changes to the chart
		
		var df = dojox.lang.functional;

		// cleanup
		if(this._surfaces){
			dojo.forEach(this._surfaces, function(surface){
				surface.destroy();
			});
		}
		this._surfaces = [];
		while(this.legendBody.lastChild){
			dojo.destroy(this.legendBody.lastChild);
		}

		if(this.horizontal){
			dojo.addClass(this.legendNode, "dojoxLegendHorizontal");
			// make a container <tr>
			this._tr = dojo.create("tr", null, this.legendBody);
			this._inrow = 0;
		}
		
		var s = this.series;
		if(s.length == 0){
			return;
		}
		if(s[0].chart.stack[0].declaredClass == "dojox.charting.plot2d.Pie"){
			var t = s[0].chart.stack[0];
			if(typeof t.run.data[0] == "number"){
				var filteredRun = df.map(t.run.data, "Math.max(x, 0)");
				if(df.every(filteredRun, "<= 0")){
					return;
				}
				var slices = df.map(filteredRun, "/this", df.foldl(filteredRun, "+", 0));
				dojo.forEach(slices, function(x, i){
					this._addLabel(t.dyn[i], t._getLabel(x * 100) + "%");
				}, this);
			}else{
				dojo.forEach(t.run.data, function(x, i){
					this._addLabel(t.dyn[i], x.legend || x.text || x.y);
				}, this);
			}
		}else{
			dojo.forEach(s, function(x){
				this._addLabel(x.dyn, x.legend || x.name);
			}, this);
		}
	},
	_addLabel: function(dyn, label){
		// create necessary elements
		var wrapper = dojo.create("td"),
			icon = dojo.create("div", null, wrapper),
			text = dojo.create("label", null, wrapper),
			div  = dojo.create("div", {
				style: {
					"width": this.swatchSize + "px",
					"height":this.swatchSize + "px",
					"float": "left"
				}
			}, icon);
		dojo.addClass(icon, "dojoxLegendIcon dijitInline");
		dojo.addClass(text, "dojoxLegendText");
		// create a skeleton
		if(this._tr){
			// horizontal
			this._tr.appendChild(wrapper);
			if(++this._inrow === this.horizontal){
				// make a fresh container <tr>
				this._tr = dojo.create("tr", null, this.legendBody);
				this._inrow = 0;
			}
		}else{
			// vertical
			var tr = dojo.create("tr", null, this.legendBody);
			tr.appendChild(wrapper);
		}
		
		// populate the skeleton
		this._makeIcon(div, dyn);
		text.innerHTML = String(label);
	},
	_makeIcon: function(div, dyn){
		var mb = { h: this.swatchSize, w: this.swatchSize };
		var surface = dojox.gfx.createSurface(div, mb.w, mb.h);
		this._surfaces.push(surface);
		if(dyn.fill){
			// regions
			surface.createRect({x: 2, y: 2, width: mb.w - 4, height: mb.h - 4}).
				setFill(dyn.fill).setStroke(dyn.stroke);
		}else if(dyn.stroke || dyn.marker){
			// draw line
			var line = {x1: 0, y1: mb.h / 2, x2: mb.w, y2: mb.h / 2};
			if(dyn.stroke){
				surface.createLine(line).setStroke(dyn.stroke);
			}
			if(dyn.marker){
				// draw marker on top
				var c = {x: mb.w / 2, y: mb.h / 2};
				if(dyn.stroke){
					surface.createPath({path: "M" + c.x + " " + c.y + " " + dyn.marker}).
						setFill(dyn.stroke.color).setStroke(dyn.stroke);
				}else{
					surface.createPath({path: "M" + c.x + " " + c.y + " " + dyn.marker}).
						setFill(dyn.color).setStroke(dyn.color);
				}
			}
		}else{
			// nothing
			surface.createRect({x: 2, y: 2, width: mb.w - 4, height: mb.h - 4}).
				setStroke("black");
			surface.createLine({x1: 2, y1: 2, x2: mb.w - 2, y2: mb.h - 2}).setStroke("black");
			surface.createLine({x1: 2, y1: mb.h - 2, x2: mb.w - 2, y2: 2}).setStroke("black");
		}
	}
});

}

if(!dojo._hasResource["dojox.fx.easing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx.easing"] = true;
dojo.provide("dojox.fx.easing");
dojo.deprecated("dojox.fx.easing","Upgraded to Core, use dojo.fx.easing instead","2.0");

/*=====
	dojox.fx.easing = {
		// summary:
		//		An Alias to `dojo.fx.easing`. Moved to Core in Dojo 1.2.
	};
=====*/
dojox.fx.easing = dojo.fx.easing;

}

if(!dojo._hasResource["dojox.charting.themes.gradientGenerator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.themes.gradientGenerator"] = true;
dojo.provide("dojox.charting.themes.gradientGenerator");


(function(){
	var gg = dojox.charting.themes.gradientGenerator;

	gg.generateFills = function(colors, fillPattern, lumFrom, lumTo){
		//	summary:
		//		generates 2-color gradients using pure colors, a fill pattern, and two luminance values
		//	colors: Array:
		//		Array of colors to generate gradients for each.
		//	fillPattern: Object:
		//		Gradient fill descriptor which colors list will be generated.
		//	lumFrom: Number:
		//		Initial luminance value (0-100).
		//	lumTo: Number:
		//		Final luminance value (0-100).
		var Theme = dojox.charting.Theme;
		return dojo.map(colors, function(c){	// Array
			return Theme.generateHslGradient(c, fillPattern, lumFrom, lumTo);
		});
	};
	
	gg.updateFills = function(themes, fillPattern, lumFrom, lumTo){
		//	summary:
		//		transforms solid color fills into 2-color gradients using a fill pattern, and two luminance values
		//	themes: Array:
		//		Array of mini-themes (usually series themes or marker themes), which fill will be transformed.
		//	fillPattern: Object:
		//		Gradient fill descriptor which colors list will be generated.
		//	lumFrom: Number:
		//		Initial luminance value (0-100).
		//	lumTo: Number:
		//		Final luminance value (0-100).
		var Theme = dojox.charting.Theme;
		dojo.forEach(themes, function(t){
			if(t.fill && !t.fill.type){
				t.fill = Theme.generateHslGradient(t.fill, fillPattern, lumFrom, lumTo);
			}
		});
	};
	
	gg.generateMiniTheme = function(colors, fillPattern, lumFrom, lumTo, lumStroke){
		//	summary:
		//		generates mini-themes with 2-color gradients using colors, a fill pattern, and three luminance values
		//	colors: Array:
		//		Array of colors to generate gradients for each.
		//	fillPattern: Object:
		//		Gradient fill descriptor which colors list will be generated.
		//	lumFrom: Number:
		//		Initial luminance value (0-100).
		//	lumTo: Number:
		//		Final luminance value (0-100).
		//	lumStroke: Number:
		//		Stroke luminance value (0-100).
		var Theme = dojox.charting.Theme;
		return dojo.map(colors, function(c){	// Array
			c = new dojox.color.Color(c);
			return {
				fill:   Theme.generateHslGradient(c, fillPattern, lumFrom, lumTo),
				stroke: {color: Theme.generateHslColor(c, lumStroke)}
			}
		});
	};
	
	gg.generateGradientByIntensity = function(color, intensityMap){
		//	summary:
		//		generates gradient colors using an intensity map
		//	color: dojo.Color:
		//		Color to use to generate gradients.
		//	intensityMap: Array:
		//		Array of tuples {o, i}, where o is a gradient offset (0-1),
		//		and i is an intensity (0-255).
		color = new dojo.Color(color);
		return dojo.map(intensityMap, function(stop){	// Array
			var s = stop.i / 255;
			return {
				offset: stop.o,
				color:  new dojo.Color([color.r * s, color.g * s, color.b * s, color.a])
			};
		});
	}
})();

}

if(!dojo._hasResource["versa.widget.zone.metrics.themes.VersaColors"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["versa.widget.zone.metrics.themes.VersaColors"] = true;
dojo.provide("versa.widget.zone.metrics.themes.VersaColors");




(function(){
	var dc = dojox.charting, themes = dc.themes,
		colors = ["#f00", "#0f0", "#00f", "#ff0", "#0ff", "#f0f"],
		defaultFill = {type: "linear", space: "plot", x1: 0, y1: 0, x2: 0, y2: 100};

	themes.VersaColors = new dc.Theme({
        chart: {fill: "transparent"},
        plotarea: { fill: "transparent" },
		seriesThemes: themes.gradientGenerator.generateMiniTheme(colors, defaultFill, 90, 40, 25)
	});
})();

}

if(!dojo._hasResource['versa.widget.zone.metrics.themes.VersaBlank']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.themes.VersaBlank'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 21/02/12
 * Time: 5:15 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.themes.VersaBlank');




(function(){
	var dc = dojox.charting, themes = dc.themes,
		colors = ['#000'],
		defaultFill = {type: 'linear', space: 'plot', x1: 0, y1: 0, x2: 0, y2: 100};

	themes.VersaBlank = new dc.Theme({
        chart: {fill: 'transparent'},
        plotarea: { fill: 'transparent' },
		seriesThemes: themes.gradientGenerator.generateMiniTheme(colors, defaultFill, 90, 40, 25)
	});
})();

}

if(!dojo._hasResource['versa.widget.zone.metrics.DocTypes']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.DocTypes'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 27/01/12
 * Time: 9:52 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.DocTypes');


















dojo.declare('versa.widget.zone.metrics.DocTypes', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("versa/widget/zone/metrics", "template/DocTypes.html", "<div style=\"height:100%;width:100%;position:relative;\">\n\n    <div dojoAttachPoint=\"chartNode\" style=\"height:160px;width:160px;margin: 0px auto\"></div>\n    <div class=\"dijitMediumLabel dijitDarkLabel\" style=\"position:absolute;bottom:16px;left:0;text-align:center;width:100%\">Document Type Distribution</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _wdgChart: null,

    metrics: null,

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        var seriesData = [];
        var total_docs = 0;

        dojo.forEach(this.metrics, function(doc_type, idx){
            if(doc_type.document_count > 0){
                seriesData.push({
                    y: doc_type.document_count,
                    text: dojo.replace('{0}: {1}', [doc_type.name, doc_type.document_count])
                });
            }
            total_docs += doc_type.document_count;
        }, this);

        if(total_docs < 1){
            seriesData.push({
                y: 1,
                text: 'No documents have been added'
            })
        }

        this._wdgChart = new dojox.charting.Chart(this.chartNode);
        this._wdgChart.addPlot('default', {
            type: 'Pie',
            radius:56,
            startAngle:-90,
            ticks: true,
            labelStyle: 'default',
            labels: false
        });
        this._wdgChart.addSeries('Series1', seriesData);

        if(total_docs < 1){
            this._wdgChart.setTheme(dojox.charting.themes.VersaBlank);
        }
        else{
             this._wdgChart.setTheme(dojox.charting.themes.VersaColors);
        }

        new dojox.charting.action2d.Tooltip(this._wdgChart, 'default');
        new dojox.charting.action2d.MoveSlice(this._wdgChart, 'default', { series: 'Series1', scale: 1.25, shift: 0 });

        this._wdgChart.render();

    },

    startup: function(){
        this.inherited('startup', arguments);

    }

});


}

if(!dojo._hasResource["dojox.charting.action2d.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.charting.action2d.Tooltip"] = true;
dojo.provide("dojox.charting.action2d.Tooltip");










/*=====
dojo.declare("dojox.charting.action2d.__TooltipCtorArgs", dojox.charting.action2d.__BaseCtorArgs, {
	//	summary:
	//		Additional arguments for tooltip actions.

	//	text: Function?
	//		The function that produces the text to be shown within a tooltip.  By default this will be
	//		set by the plot in question, by returning the value of the element.
	text: null
});
=====*/
(function(){
	var DEFAULT_TEXT = function(o){
		var t = o.run && o.run.data && o.run.data[o.index];
		if(t && typeof t != "number" && (t.tooltip || t.text)){
			return t.tooltip || t.text;
		}
		if(o.element == "candlestick"){
			return '<table cellpadding="1" cellspacing="0" border="0" style="font-size:0.9em;">'
				+ '<tr><td>Open:</td><td align="right"><strong>' + o.data.open + '</strong></td></tr>'
				+ '<tr><td>High:</td><td align="right"><strong>' + o.data.high + '</strong></td></tr>'
				+ '<tr><td>Low:</td><td align="right"><strong>' + o.data.low + '</strong></td></tr>'
				+ '<tr><td>Close:</td><td align="right"><strong>' + o.data.close + '</strong></td></tr>'
				+ (o.data.mid !== undefined ? '<tr><td>Mid:</td><td align="right"><strong>' + o.data.mid + '</strong></td></tr>' : '')
				+ '</table>';
		}
		return o.element == "bar" ? o.x : o.y;
	};

	var df = dojox.lang.functional, m = dojox.gfx.matrix, pi4 = Math.PI / 4, pi2 = Math.PI / 2;
	
	dojo.declare("dojox.charting.action2d.Tooltip", dojox.charting.action2d.Base, {
		//	summary:
		//		Create an action on a plot where a tooltip is shown when hovering over an element.

		// the data description block for the widget parser
		defaultParams: {
			text: DEFAULT_TEXT	// the function to produce a tooltip from the object
		},
		optionalParams: {},	// no optional parameters

		constructor: function(chart, plot, kwArgs){
			//	summary:
			//		Create the tooltip action and connect it to the plot.
			//	chart: dojox.charting.Chart2D
			//		The chart this action belongs to.
			//	plot: String?
			//		The plot this action is attached to.  If not passed, "default" is assumed.
			//	kwArgs: dojox.charting.action2d.__TooltipCtorArgs?
			//		Optional keyword arguments object for setting parameters.
			this.text = kwArgs && kwArgs.text ? kwArgs.text : DEFAULT_TEXT;
			
			this.connect();
		},
		
		process: function(o){
			//	summary:
			//		Process the action on the given object.
			//	o: dojox.gfx.Shape
			//		The object on which to process the highlighting action.
			if(o.type === "onplotreset" || o.type === "onmouseout"){
                dijit.hideTooltip(this.aroundRect);
				this.aroundRect = null;
				if(o.type === "onplotreset"){
					delete this.angles;
				}
				return;
			}
			
			if(!o.shape || o.type !== "onmouseover"){ return; }
			
			// calculate relative coordinates and the position
			var aroundRect = {type: "rect"}, position = ["after", "before"];
			switch(o.element){
				case "marker":
					aroundRect.x = o.cx;
					aroundRect.y = o.cy;
					aroundRect.width = aroundRect.height = 1;
					break;
				case "circle":
					aroundRect.x = o.cx - o.cr;
					aroundRect.y = o.cy - o.cr;
					aroundRect.width = aroundRect.height = 2 * o.cr;
					break;
				case "column":
					position = ["above", "below"];
					// intentional fall down
				case "bar":
					aroundRect = dojo.clone(o.shape.getShape());
					break;
				case "candlestick":
					aroundRect.x = o.x;
					aroundRect.y = o.y;
					aroundRect.width = o.width;
					aroundRect.height = o.height;
					break;
				default:
				//case "slice":
					if(!this.angles){
						// calculate the running total of slice angles
						if(typeof o.run.data[0] == "number"){
							this.angles = df.map(df.scanl(o.run.data, "+", 0),
								"* 2 * Math.PI / this", df.foldl(o.run.data, "+", 0));
						}else{
							this.angles = df.map(df.scanl(o.run.data, "a + b.y", 0),
								"* 2 * Math.PI / this", df.foldl(o.run.data, "a + b.y", 0));
						}
					}
					var startAngle = m._degToRad(o.plot.opt.startAngle),
						angle = (this.angles[o.index] + this.angles[o.index + 1]) / 2 + startAngle;
					aroundRect.x = o.cx + o.cr * Math.cos(angle);
					aroundRect.y = o.cy + o.cr * Math.sin(angle);
					aroundRect.width = aroundRect.height = 1;
					// calculate the position
					if(angle < pi4){
						// do nothing: the position is right
					}else if(angle < pi2 + pi4){
						position = ["below", "above"];
					}else if(angle < Math.PI + pi4){
						position = ["before", "after"];
					}else if(angle < 2 * Math.PI - pi4){
						position = ["above", "below"];
					}
					/*
					else{
						// do nothing: the position is right
					}
					*/
					break;
			}
			
			// adjust relative coordinates to absolute, and remove fractions
			var lt = dojo.coords(this.chart.node, true);
			aroundRect.x += lt.x;
			aroundRect.y += lt.y;
			aroundRect.x = Math.round(aroundRect.x);
			aroundRect.y = Math.round(aroundRect.y);
			aroundRect.width = Math.ceil(aroundRect.width);
			aroundRect.height = Math.ceil(aroundRect.height);
			this.aroundRect = aroundRect;

			var tooltip = this.text(o);
			if(tooltip){
                dijit.showTooltip(tooltip, this.aroundRect, position);
			}
		}
	});
})();

}

if(!dojo._hasResource["versa.widget.zone.metrics.themes.VersaGaugeOK"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["versa.widget.zone.metrics.themes.VersaGaugeOK"] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 29/01/12
 * Time: 8:38 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide("versa.widget.zone.metrics.themes.VersaGaugeOK");




(function(){
	var dc = dojox.charting, themes = dc.themes,
		colors = ["#76EE00", "#000"],
		defaultFill = {type: "linear", space: "plot", x1: 0, y1: 0, x2: 0, y2: 100};

	themes.VersaGaugeOK = new dc.Theme({
        chart: {fill: "transparent"},
        plotarea: { fill: "transparent" },
		seriesThemes: themes.gradientGenerator.generateMiniTheme(colors, defaultFill, 90, 40, 25)
	});
})();

}

if(!dojo._hasResource["versa.widget.zone.metrics.themes.VersaGaugeWarning"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["versa.widget.zone.metrics.themes.VersaGaugeWarning"] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 29/01/12
 * Time: 5:03 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide("versa.widget.zone.metrics.themes.VersaGaugeWarning");




(function(){
	var dc = dojox.charting, themes = dc.themes,
		colors = ["#FFE303", "#000000"],
		defaultFill = {type: "linear", space: "plot", x1: 0, y1: 0, x2: 0, y2: 100};

	themes.VersaGaugeWarning = new dc.Theme({
        chart: {fill: "transparent"},
        plotarea: { fill: "transparent" },
		seriesThemes: themes.gradientGenerator.generateMiniTheme(colors, defaultFill, 90, 40, 25)
	});
})();

}

if(!dojo._hasResource["versa.widget.zone.metrics.themes.VersaGaugeDanger"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["versa.widget.zone.metrics.themes.VersaGaugeDanger"] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 29/01/12
 * Time: 5:03 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide("versa.widget.zone.metrics.themes.VersaGaugeDanger");




(function(){
	var dc = dojox.charting, themes = dc.themes,
		colors = ["#f00", "#000"],
		defaultFill = {type: "linear", space: "plot", x1: 0, y1: 0, x2: 0, y2: 100};

	themes.VersaGaugeDanger = new dc.Theme({
        chart: {fill: "transparent"},
        plotarea: { fill: "transparent" },
		seriesThemes: themes.gradientGenerator.generateMiniTheme(colors, defaultFill, 90, 40, 25)
	});
})();

}

if(!dojo._hasResource['versa.widget.zone.metrics.DiskQuota']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.DiskQuota'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 31/01/12
 * Time: 8:46 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.DiskQuota');




















dojo.declare('versa.widget.zone.metrics.DiskQuota', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("versa/widget/zone/metrics", "template/DiskQuota.html", "<div style=\"height:128px;width:100%;position:relative;\">\n\n    <div dojoAttachPoint=\"chartNode\" style=\"height:128px;width:128px;\"></div>\n    <div style=\"position:absolute;left:128px;top:0;width:144px;height:100%;margin-bottom:24px\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n    <div class=\"dijitMediumLabel dijitDarkLabel\" style=\"position:absolute;bottom:0;left:0;width:128px;text-align:center;margin-right:24px\">Disk Quota</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _lblDiskFree: null,
    _lblDiskUsed: null,
    _lblDiskQuota: null,
    _tblProperties: null,
    _wdgChart: null,
    _wdgLegend: null,

    diskQuota: 0,
    diskUsed: 0,

    zone: null,

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        var delta = (this.diskUsed >= this.diskQuota) ? this.diskQuota : this.diskQuota - this.diskUsed

        var seriesData = [];

        var sizeText = dojo.replace('Used Space: {0}', [bfree.api.Utilities.readablizeBytes({bytes: this.diskUsed})]);
        var freeText = dojo.replace('Free Space: {0}', [bfree.api.Utilities.readablizeBytes({bytes: delta})]);

        seriesData.push({y: this.diskUsed, text: sizeText, 'legend': 'Used'});
        seriesData.push({y: delta, text: freeText, 'legend': 'Free'});

        this._wdgChart = new dojox.charting.Chart(this.chartNode);
        this._wdgChart.addPlot('default', {
            type: 'Pie',
            radius:48,
            startAngle: -90,
            ticks: true,
            labelStyle: 'default',
            labels: false,
            labelOffset: -16
        });
        this._wdgChart.addSeries('Series1', seriesData);

        var pct = this.userCount / this.userQuota;
        if(pct > 0.85){
            this._wdgChart.setTheme(dojox.charting.themes.VersaGaugeDanger);
        }
        else if((pct <= 0.85) && (pct > 0.66)){
            this._wdgChart.setTheme(dojox.charting.themes.VersaGaugeWarning);
        }
        else{
            this._wdgChart.setTheme(dojox.charting.themes.VersaGaugeOK);
        }

        new dojox.charting.action2d.Tooltip(this._wdgChart, 'default');
        new dojox.charting.action2d.MoveSlice(this._wdgChart, 'default', { series: 'Series1', scale: 1.25, shift: 0 });

        this._wdgChart.render();

        this._tblProperties = new bfree.widget.PropertyTable({
            customClass: 'versathin',
            showLabels: true,
            cols: 1,
            labelWidth: 64,
            style: 'position:relative;top: 50%;margin-top:-29px'
        }, this.tableNode);

        this._lblDiskUsed = new bfree.widget.Label({
            label: 'Used Space:',
            value: bfree.api.Utilities.readablizeBytes({bytes: this.diskUsed})
        });
        this._tblProperties.addChild(this._lblDiskUsed);

        this._lblDiskFree = new bfree.widget.Label({
            label: 'Free Space:',
            value: bfree.api.Utilities.readablizeBytes({bytes: delta})
        });
        this._tblProperties.addChild(this._lblDiskFree);

        this._lblDiskQuota = new bfree.widget.Label({
            label: 'Capacity',
            value: bfree.api.Utilities.readablizeBytes({bytes: this.diskQuota})
        });
        this._tblProperties.addChild(this._lblDiskQuota);

    },

    startup: function(){
        this.inherited('startup', arguments);

        this._tblProperties.startup();

    }

});

}

if(!dojo._hasResource['versa.widget.zone.metrics.UserQuota']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.UserQuota'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 29/01/12
 * Time: 3:38 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.UserQuota');




















dojo.declare('versa.widget.zone.metrics.UserQuota', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("versa/widget/zone/metrics", "template/UserQuota.html", "<div style=\"height:128px;width:256px;position:relative;\">\n\n    <div dojoAttachPoint=\"chartNode\" style=\"height:128px;width:128px;\"></div>\n    <div style=\"position:absolute;left:128px;top:0;width:128px;height:100%;margin-bottom:24px\">\n        <div dojoAttachPoint=\"tableNode\"></div>\n    </div>\n    <div class=\"dijitMediumLabel dijitDarkLabel\" style=\"position:absolute;bottom:0;left:0;width:128px;text-align:center;margin-right:24px\">User Quota</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _lblUserCount: null,
    _lblUserQuota: null,
    _tblProperties: null,
    _wdgChart: null,
    _wdgLegend: null,

    userCount: 0,
    userQuota: 3,

    zone: null,

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        var delta = (this.userCount >= this.userQuota) ? this.userQuota : this.userQuota - this.userCount;
        var seriesData = [];

        var userText = dojo.replace('{0} out of {1} user slots taken', [this.userCount, this.userQuota]);
        var quotaText = dojo.replace('{0} out of {1} user slots remaining', [delta, this.userQuota] )
        seriesData.push({y: this.userCount, text: userText, legend: 'Users'});
        seriesData.push({y: delta, text: quotaText, legend: 'Quota'});

        this._wdgChart = new dojox.charting.Chart(this.chartNode);
        this._wdgChart.addPlot('default', {
            type: 'Pie',
            radius:48,
            startAngle:-90,
            ticks: true,
            labelStyle: 'default',
            labels: false,
            labelOffset: -16
        });
        this._wdgChart.addSeries('Series1', seriesData);

        var pct = this.userCount / this.userQuota;
        if(pct > 0.85){
            this._wdgChart.setTheme(dojox.charting.themes.VersaGaugeDanger);
        }
        else if((pct <= 0.85) && (pct > 0.66)){
            this._wdgChart.setTheme(dojox.charting.themes.VersaGaugeWarning);
        }
        else{
            this._wdgChart.setTheme(dojox.charting.themes.VersaGaugeOK);
        }

        new dojox.charting.action2d.Tooltip(this._wdgChart, 'default');
        new dojox.charting.action2d.MoveSlice(this._wdgChart, 'default', { series: 'Series1', scale: 1.25, shift: 0 });

        this._wdgChart.render();

        this._tblProperties = new bfree.widget.PropertyTable({
            customClass: 'versathin',
            showLabels: true,
            cols: 1,
            labelWidth: 64,
            style: 'position:relative;top: 50%;margin-top:-20px'
        }, this.tableNode);

        this._lblUserCount = new bfree.widget.Label({
            label: 'User Count:',
            value: this.userCount
        });
        this._tblProperties.addChild(this._lblUserCount);

        this._lblUserQuota = new bfree.widget.Label({
            label: 'User Quota:',
            value: this.userQuota
        });
        this._tblProperties.addChild(this._lblUserQuota);

    },

    startup: function(){
        this.inherited('startup', arguments);

        this._tblProperties.startup();

    }

});

}

if(!dojo._hasResource['versa.widget.zone.metrics.Quotas']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.Quotas'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/02/12
 * Time: 3:52 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.Quotas');












dojo.declare('versa.widget.zone.metrics.Quotas', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("versa/widget/zone/metrics", "template/Quotas.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        dojoAttachPoint=\"mainContainer\"\n        design=\"headline\"\n        gutters=\"true\"\n        style=\"height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"headline\"\n            gutters=\"false\"\n            region=\"center\"\n            class=\"highlightPane\"\n            style=\"height:100%;width:100%;\">\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"top\"\n                style=\"overflow:hidden;padding:8px 8px 0 8px;position:relative\">\n\n            <div class=\"dijitBoldLabel dijitLargeLabel dijitDarkLabel\" style=\"\">Quotas</div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.BorderContainer\"\n                design=\"sidebar\"\n                gutters=\"false\"\n                splitter=\"false\"\n                region=\"center\"\n                style=\"width:100%;height:100%\">\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    splitter=\"false\"\n                    region=\"center\"\n                    style=\"overflow:hidden;padding:0;position:relative\">\n\n                <div dojoAttachPoint=\"userQuotaNode\"></div>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    splitter=\"false\"\n                    region=\"right\"\n                    style=\"overflow:hidden;padding:0;position:relative;width:272px\">\n\n                <div dojoAttachPoint=\"diskQuotaNode\"></div>\n\n            </div>\n\n         </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _wdgDiskQuota: null,
    _wdgUserQuota: null,

    diskQuota: null,
    diskUsed: null,
    userCount: null,
    userQuota: null,

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._wdgUserQuota = new versa.widget.zone.metrics.UserQuota({
            userCount: this.userCount,
            userQuota: this.userQuota
        }, this.userQuotaNode);

        this._wdgDiskQuota = new versa.widget.zone.metrics.DiskQuota({
            diskUsed: this.diskUsed,
            diskQuota: this.diskQuota
        }, this.diskQuotaNode);

    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainContainer.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);

        this._wdgUserQuota.startup();
    }

});

}

if(!dojo._hasResource['versa.widget.zone.metrics.Statistics']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.Statistics'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 20/02/12
 * Time: 5:22 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.Statistics');









dojo.declare('versa.widget.zone.metrics.Statistics', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("versa/widget/zone/metrics", "template/Statistics.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        dojoAttachPoint=\"mainContainer\"\n        design=\"headline\"\n        gutters=\"true\"\n        style=\"height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.BorderContainer\"\n            design=\"sidebar\"\n            gutters=\"false\"\n            region=\"center\"\n            class=\"highlightPane\"\n            style=\"height:100%;width:100%;\">\n\n        <div    dojoType=\"dijit.layout.BorderContainer\"\n                design=\"headline\"\n                gutters=\"false\"\n                region=\"center\"\n                style=\"height:100%;width:100%\">\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    splitter=\"false\"\n                    region=\"top\"\n                    style=\"overflow:hidden;padding:8px 8px 0 8px;position:relative\">\n\n                <div class=\"dijitBoldLabel dijitLargeLabel dijitDarkLabel\" style=\"\">Statistics</div>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.ContentPane\"\n                    splitter=\"false\"\n                    region=\"center\"\n                    style=\"overflow:hidden;padding:0 8px 0 8px;position:relative\">\n\n                <div dojoAttachPoint=\"tableNode\"></div>\n\n            </div>\n\n        </div>\n\n        <div    dojoType=\"dijit.layout.ContentPane\"\n                splitter=\"false\"\n                region=\"right\"\n                style=\"overflow:hidden;padding:0 8px 8px 8px;position:relative;width:50%\">\n\n            <div dojoAttachPoint=\"docTypesNode\"></div>\n\n        </div>\n\n    </div>\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _lblChoiceCount: null,
    _lblPropDefCount: null,
    _lblDocTypeCount: null,
    _lblDocCount: null,
    _lblFldrCount: null,
    _lblGroupCount: null,
    _lblUserCount: null,
    _lblVerCount: null,
    _lblViewDefCount: null,
    _tblStats: null,
    _wdgDocTypes: null,

    choiceListCount: 0,
    documentCount: 0,
    documentTypeCount: 0,
    documentTypeMetrics: null,
    folderCount: 0,
    groupCount: 0,
    propertyDefinitionCount: 0,
    userCount: 0,
    versionCount: 0,
    viewDefinitionCount: 0,

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._tblStats = new bfree.widget.PropertyTable({
            customClass: 'versathin',
            showLabels: true,
            cols: 1,
            labelWidth: 156,
            style: 'position:relative;left:24px;'
        }, this.tableNode);

        this._lblGroupCount = new bfree.widget.Label({
            label: 'Group Count:',
            value: this.groupCount
        });
        this._tblStats.addChild(this._lblGroupCount);

        this._lblUserCount = new bfree.widget.Label({
            label: 'User Count:',
            value: this.userCount
        });
        this._tblStats.addChild(this._lblUserCount);

        this._lblChoiceCount = new bfree.widget.Label({
            label: 'Choice List Count:',
            value: this.choiceListCount
        });
        this._tblStats.addChild(this._lblChoiceCount);

        this._lblPropDefCount = new bfree.widget.Label({
            label: 'Property Definition Count:',
            value: this.propertyDefinitionCount
        });
        this._tblStats.addChild(this._lblPropDefCount);

        this._lblDocTypeCount = new bfree.widget.Label({
            label: 'Document Type Count:',
            value: this.documentTypeCount
        });
        this._tblStats.addChild(this._lblDocTypeCount);

        this._lblViewDefCount = new bfree.widget.Label({
            label: 'View Count:',
            value: this.viewDefinitionCount
        });
        this._tblStats.addChild(this._lblViewDefCount);

        this._lblFldrCount = new bfree.widget.Label({
            label: 'Folder Count:',
            value: this.folderCount
        });
        this._tblStats.addChild(this._lblFldrCount);

        this._lblDocCount = new bfree.widget.Label({
            label: 'Document Count:',
            value: this.documentCount
        });
        this._tblStats.addChild(this._lblDocCount);

        this._lblVerCount = new bfree.widget.Label({
            label: 'Version Count:',
            value: this.versionCount
        });
        this._tblStats.addChild(this._lblVerCount);

        this._wdgDocTypes = new versa.widget.zone.metrics.DocTypes({
            metrics: this.documentTypeMetrics
        }, this.docTypesNode)

    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainContainer.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);

    }

});

}

if(!dojo._hasResource['versa.widget.zone.metrics.Zone']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.Zone'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 27/01/12
 * Time: 3:53 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.Zone');









dojo.declare('versa.widget.zone.metrics.Zone', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("versa/widget/zone/metrics", "template/Zone.html", "<div style=\"height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        dojoAttachPoint=\"mainContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"top\"\n            style=\"overflow:hidden;padding:8px 8px 0 8px;position:relative;height:172px\">\n\n         <div dojoAttachPoint=\"quotasNode\"></div>\n\n    </div>\n\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            splitter=\"false\"\n            region=\"center\"\n            style=\"overflow:hidden;padding:0 8px 0 8px;position:relative\">\n\n        <div dojoAttachPoint=\"statsNode\"></div>\n\n    </div>\n\n\n</div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _metrics: null,
    _wdgQuotas: null,
    _wdgStatistics: null,

    library: null,
    zone: null,

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);

    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._metrics = this.zone.getMetrics();

        var userQuota = parseInt(this.zone.getValue('user_quota'));
        var diskQuota = parseInt(this.zone.getValue('disk_quota'));

        var choicelist_count = 0;
        var propdef_count = 0;
        var doctype_count = 0;
        var viewdef_count = 0;
        var folder_count = 0;
        var document_count = 0;
        var version_count = 0;
        var content_size = 0;
        dojo.forEach(this._metrics.libraries, function(library, idx){
            choicelist_count += library.choicelist_count;
            propdef_count += library.propertydefinition_count,
            doctype_count += library.documenttype_count,
            viewdef_count += library.viewdefinition_count,
            folder_count += library.folder_count;
            document_count += library.document_count;
            version_count += library.version_count;
            content_size += library.content_size;
        }, this);

        this._wdgQuotas = new versa.widget.zone.metrics.Quotas({
            diskQuota: diskQuota,
            diskUsed: content_size,
            userCount: this._metrics.user_count,
            userQuota: userQuota
        }, this.quotasNode);

        this._wdgStatistics = new versa.widget.zone.metrics.Statistics({
            groupCount: this._metrics.group_count,
            userCount: this._metrics.user_count,
            choiceListCount: choicelist_count,
            propertyDefinitionCount: propdef_count,
            documentTypeCount: doctype_count,
            viewDefinitionCount: viewdef_count,
            folderCount: folder_count,
            documentCount: document_count,
            versionCount: version_count,
            documentTypeMetrics: this._metrics.libraries[0].document_types
        }, this.statsNode);

    },

    resize: function(){
        this.inherited('resize', arguments);
        this.mainContainer.resize();
    },

    startup: function(){
        this.inherited('startup', arguments);

        this._wdgQuotas.startup();
        this._wdgStatistics.startup();

    }

});


}

if(!dojo._hasResource['versa.widget.zone.metrics.Info']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.widget.zone.metrics.Info'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 27/01/12
 * Time: 9:44 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.widget.zone.metrics.Info');












dojo.declare('versa.widget.zone.metrics.Info', [dijit._Widget, dijit._Templated, bfree.widget._DialogWidget], {
    templateString: dojo.cache("versa/widget/zone/metrics", "template/Info.html", "<div style=\"height:100%;width:100%;\">\n\n    <div dojoAttachPoint=\"zoneNode\"></div>\n\n</div>\n"),
    widgetsInTemplate: true,

    _wdgDocTypes: null,
    _wdgZone: null,

    library: null,
    zone: null,

    _loadItem: function(){

        try{

        }
        finally{
            this.onWidgetLoaded();
        }

    },

    constructor: function(args){

    },

    destroy: function(){
        this.inherited('destroy', arguments);

    },

    isValid: function(){
        return true;
    },

    onDialogClosing: function(dlgResult){
        var canClose = false;

        try{


            canClose = true;
        }
        catch(e){
           var err = new bfree.api.Error('Failed to close \'Quota Information\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

        return canClose;
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        this._wdgZone = new versa.widget.zone.metrics.Zone({
            library: this.library,
            zone: this.zone
        }, this.zoneNode);


    },

    startup: function(){
        this.inherited('startup', arguments);

        this._wdgZone.startup();

        setTimeout(versa.widget.zone.metrics.Info._loadFnRef(this), 10);
    }

});

versa.widget.zone.metrics.Info._loadFnRef = function(that){
    return ( function() {
       that._loadItem();
    });
}


versa.widget.zone.metrics.Info.show = function(args){

    var dlg = new bfree.widget.Dialog({
        id: 'dlgMetrics',
        title: 'VersaFile Quotas/Metrics',
        widgetConstructor: versa.widget.zone.metrics.Info,
        widgetParams: {
            library: args.library,
            zone: args.zone
        },
        noResize: true,
        height: 448,
        width: 544,
        buttons: bfree.widget.Dialog.buttons.close,
        onClose: args.onClose
    });
    dlg.startup();
    dlg.show();

}

}

if(!dojo._hasResource['versa.VersaFile']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['versa.VersaFile'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 16/02/12
 * Time: 2:44 PM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('versa.VersaFile');

dojo.declare('versa.VersaFile', null,{
});

versa.VersaFile.messages = {
    'TRIAL_REMAINING': 'You have <strong>{days_left}</strong> days remaining on your free trial.',
    'TRIAL_FINAL': '<strong>This is your final day remaining on your free trial.</strong>',
    'TRIAL_EXPIRED': '<strong>!!! YOUR TRIAL PERIOD HAS EXPIRED !!!</strong>',
    'ACTIVATE_LINK': 'Click <a href="http://www.versafile.com" class="dijitBoldLabel versaLink" target="_blank">here</a> to upgrade.'

}

}

if(!dojo._hasResource['bfree.widget.zone.Show']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['bfree.widget.zone.Show'] = true;
/**
 * Created by JetBrains RubyMine.
 * User: scotth
 * Date: 13/09/11
 * Time: 9:32 AM
 * To change this template use File | Settings | File Templates.
 */
dojo.provide('bfree.widget.zone.Show');












//dojo.require('bfree.widget.document.Grid');




















//dojo.require('versa.widget.dnd.Avatar');








dojo.declare('bfree.widget.zone.Show', [dijit._Widget, dijit._Templated], {
    templateString: dojo.cache("bfree.widget.zone", "template/Show.html", "<div style=\"background:#D9D9D6;height:100%;width:100%;\">\n\n<div    dojoType=\"dijit.layout.BorderContainer\"\n        design=\"headline\"\n        gutters=\"false\"\n        style=\"height:100%;width:100%;\">\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"center\"\n            spitter=\"false\"\n            style=\"padding:8px 8px 0 8px\">\n\n        <div    dojoType=\"dijit.layout.BorderContainer\"\n                design=\"headline\"\n                gutters=\"false\"\n                style=\"height:100%;width:100%\">\n\n            <div    dojoType=\"dijit.layout.BorderContainer\"\n                    design=\"sidebar\"\n                    gutters=\"false\"\n                    region=\"top\"\n                    splitter=\"false\"\n                    class=\"versaTopPane\">\n\n                <div    dojoType=\"dijit.layout.ContentPane\"\n                        region=\"left\"\n                        splitter=\"false\"\n                        class=\"versaHeadPane\">\n                    <img src=\"/images/versafile-64-tm.png\" height=\"56\" style=\"position:relative;top:-8px;left:0\"/>\n                </div>\n\n                <div    dojoType=\"dijit.layout.BorderContainer\"\n                        design=\"sidebar\"\n                        gutters=\"false\"\n                        region=\"center\"\n                        class=\"versaBarPane\">\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            region=\"center\"\n                            splitter=\"false\"\n                            style=\"padding:0;overflow:hidden;position:relative;\">\n\n                        <div    dojoAttachPoint=\"trialStateNode\"\n                                style=\"display:none;margin-left:auto;margin-right:auto;text-align: center\">\n                            <span dojoAttachPoint=\"trialMsgNode\" class=\"dijitMediumLabel dijitDarkLabelV\" style=\"display:inline-block\"></span>\n                            <span dojoAttachPoint=\"activateMsgNode\" class=\"dijitMediumLabel dijitDarkLabelV\" style=\"display:inline-block\"></span>\n                        </div>\n\n                        <div dojoAttachPoint=\"toolbarNode\"></div>\n\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.BorderContainer\"\n                            design=\"headline\"\n                            gutters=\"false\"\n                            region=\"right\"\n                            splitter=\"false\"\n                            style=\"width:256px;\">\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"center\"\n                                splitter=\"false\"\n                                style=\"position:relative;text-align:right;padding:2px 0 0 0\">\n\n                            <table cellpadding=\"0\" cellspacing=\"0\" style=\"position:absolute;right:0\"><tr>\n                                <td  style=\"padding-right:4px; border-right: 1px solid #75787B\">\n                                    <a href=\"javascript://\" class=\"versaLink\" title=\"Edit Profile\" dojoAttachEvent=\"onclick: _onUserEdit\">\n                                    <span  dojoAttachPoint=\"nameNode\"></span>\n                                    </a>\n                                </td>\n                                <td style=\"padding-left:4px;\"><a href=\"javascript://\" class=\"versaLink\" dojoAttachEvent=\"onclick: _onLogoff\">Logout</a></td>\n                            </tr>\n                            </table>\n\n                        </div>\n\n                        <div    dojoType=\"dijit.layout.ContentPane\"\n                                region=\"bottom\"\n                                splitter=\"false\"\n                                style=\"height:32px;padding:0;\">\n                            <div dojoAttachPoint=\"searchBoxNode\" style=\"\"></div>\n                        </div>\n\n                    </div>\n\n                </div>\n\n            </div>\n\n            <div    dojoType=\"dijit.layout.BorderContainer\"\n                    design=\"headline\"\n                    gutters=\"false\"\n                    region=\"center\"\n                    splitter=\"false\"\n                    class=\"versaMainPane\">\n\n                <div    dojoType=\"dijit.layout.BorderContainer\"\n                        design=\"sidebar\"\n                        gutters=\"true\"\n                        region=\"center\"\n                        splitter=\"false\"\n                        class=\"\">\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            dojoAttachPoint=\"folderPane\"\n                            region=\"left\"\n                            splitter=\"true\"\n                            class=\"versaInfoPane\"\n                            style=\"padding:0;width:256px;\">\n\n                        <div style=\"height: 100%\">\n                           <div dojoAttachPoint=\"folderTreeNode\" style=\"height: 100%\"></div>\n                       </div>\n\n                    </div>\n\n                    <div    dojoType=\"dijit.layout.ContentPane\"\n                            dojoAttachPoint=\"contentPane\"\n                            region=\"center\"\n                            splitter=\"true\"\n                            class=\"versaInfoPane\"\n                            style=\"padding:0\">\n\n                        <div dojoAttachPoint=\"documentGridNode\"></div>\n\n                    </div>\n\n                </div>\n\n                <div    dojoType=\"dijit.layout.ContentPane\"\n                        region=\"bottom\"\n                        splitter=\"false\"\n                        style=\"height:96px;padding: 0 6px 8px 6px\">\n\n                   <div style=\"height:100%\" class=\"versaInfoPane\">\n                       <div dojoAttachPoint=\"itemInfoNode\" style=\"width: 100%\"></div>\n                   </div>\n\n                </div>\n\n            </div>\n\n\n        </div>\n\n    </div>\n\n\n    <div    dojoType=\"dijit.layout.ContentPane\"\n            region=\"bottom\"\n            splitter=\"false\"\n            style=\"position:relative;height:16px;overflow:hidden;\">\n\n        <span class=\"dijitMediumLabel dijitDarkLabelV\">VersaFile is an RKO Business Solutions product. Copyright © 2012 All rights reserved.</span>\n\n        <span style=\"position:absolute;right:16px;\">\n            <table>\n                <tr>\n                    <td style=\"padding-right:4px; border-right: 1px solid #75787B\">\n                        <span dojoAttachPoint=\"versionSpan\" class=\"dijitMediumLabel dijitDarkLabelV\"></span>\n                    </td><td style=\"padding-right:4px; border-right: 1px solid #75787B\">\n                        <a dojoAttachPoint=\"guideAnchor\" href=\"http://www.versafile.com/assets/VersaFile%20Quick%20Reference%20Guide.pdf\" target=\"_blank\">How-to</a>\n                    </td><td>\n                        <a href=\"mailto:support@versafile.com\" class=\"versaLink\">Contact Support</a>\n                    </td>\n                </tr>\n            </table>\n        </span>\n\n    </div>\n\n</div>\n\n</div>\n\n\n\n"),
    widgetsInTemplate: true,

    _duration: 60000,   //check session state once a minute

    _btnAvatar: null,
    _cmdBar: null,
    _grdDocuments: null,

    activeDocuments: [],
    activeFolder: null,
    activeGroup: null,
    activeLibrary: null,
    activeType: bfree.widget.Bfree.ObjectTypes.FOLDER,
    activeUser: null,

    zone: null,
    folders:null,

    location: null,

    //Method to apply a function to all document items with
    // - consistent error handling
    // - consistent state change handling
    __doAction: function(items, actionFn, onComplete, onError){
        var grdIdx = -1;

        if((items == null) || (items.length < 1))
            return;

        try{

            //Set item to busy
            dojo.forEach(items, function(item, idx){
                this._grdDocuments.setBusy(item, true);
            }, this);

            //Retrieve the row index of the first selected item...
            ///will select this index if all current items are removed.
            grdIdx = this._grdDocuments.getItemIndex(items[0]);

            //Set grid to 'updating' to defer updates until 'endUpdate'
            this._grdDocuments.beginUpdate();

            //perform action on each item...
            dojo.forEach(items, function(item, idx){
                try{
                    actionFn(item);
                }
                catch(e){
                    onError(item, e);
                    if(e.status == 404){
                        this._grdDocuments.store.onDelete(item);
                    }
                }
            }, this);

        }
        finally{

            //Mark grid changes complete...do update.
            this._grdDocuments.endUpdate();

            //Unset busy state
            dojo.forEach(items, function(item, idx){
                this._grdDocuments.setBusy(item, false);
            }, this);

            //Reselect items
            this._grdDocuments.selectItems(items, grdIdx);

            onComplete(items);
        }

    },

    __doDialog: function(items, showFn, closeFn, onError){
        var grdIdx = -1;

        if((items == null) || (items.length < 1))
            return;

        function __onClose(dlgResult, items){
            var canClose = false;

            if(closeFn(dlgResult, items)){

                //Mark grid changes complete...do update.
                this._grdDocuments.endUpdate();

                //Unset busy state
                dojo.forEach(items, function(item, idx){
                    this._grdDocuments.setBusy(item, false);
                }, this);

                //Reselect items
                this._grdDocuments.selectItems(items, grdIdx);

                canClose = true;
            }

            return canClose;
        }

        try{

             //Set item to busy
            dojo.forEach(items, function(item, idx){
                this._grdDocuments.setBusy(item, true);
            }, this)

            //Retrieve the row index of the first selected item...
            ///will select this index if all current items are removed.
            grdIdx = this._grdDocuments.getItemIndex(items[0]);

            //Set grid to 'updating' to defer updates until 'endUpdate'
            this._grdDocuments.beginUpdate();

            showFn({
                zone: this.zone,
                user: this.activeUser,
                group: this.activeGroup,
                library: this.activeLibrary,
                folder: this.activeFolder,
                items: items,
                onClose: dojo.hitch(this, __onClose)
            });

        }
        catch(e){
            //Mark grid changes complete...do update.
            this._grdDocuments.endUpdate();

            onError(items, e);

            //Unset busy state
            dojo.forEach(items, function(item, idx){
                this._grdDocuments.setBusy(item, false);
            }, this);

            //Reselect items
            this._grdDocuments.selectItems(items, grdIdx);
        }

    },

    __onDocumentLoad: function(document){

        //only load item in preview if document pane has focus
        if(this.activeType == bfree.widget.Bfree.ObjectTypes.DOCUMENT){
            this._wdgItemInfo.loadItem({
                item: document
            });
        }

    },

    __onDocumentLoadError: function(document, e){
        var isDeleted = false;

        var err = new bfree.api.Error(dojo.replace('Failed to retrieve document \'{0}\'', [document.name]), e);
        bfree.widget.ErrorManager.handleError({
            error: err
        });

        if(e.status == 404){
            isDeleted = true;
            this._grdDocuments.store.onDelete(document);
        }

        this._wdgItemInfo.errorItem({
            item: document,
            isDeleted: isDeleted
        });

    },

    __onFolderLoad: function(folder){

        //only load item in preview if folder pane has focus
        if(this.activeType == bfree.widget.Bfree.ObjectTypes.FOLDER){
            this._wdgItemInfo.loadItem({
                item: folder
            });
        }
    },

    __onFolderLoadError: function(item, e){

        var err = new bfree.api.Error(dojo.replace('Failed to retrieve folder \'{0}\'', [folder.name]), e);
        bfree.widget.ErrorManager.handleError({
            error: err
        });

    },

    __onCommand: function(cmdId, option, params){

        switch(cmdId){
            case bfree.widget.Bfree.Commands.ADMIN:
                this.__onAdmin(option);
                break;
            case bfree.widget.Bfree.Commands.REFRESH:
                this.__onRefresh(option);
                break;
            case bfree.widget.Bfree.Commands.EDIT:
                this.__onEdit(option, params);
                break;
            case bfree.widget.Bfree.Commands.NEW:
                this.__onNew(option, params);
                break;
            case bfree.widget.Bfree.Commands.VIEW:
                this.__onView(option, params);
                break;
            case bfree.widget.Bfree.Commands.COPY:
                this.__onCopy(option, params);
                break;
            case bfree.widget.Bfree.Commands.MOVE:
                this.__onMove(option, params);
                break;
            case bfree.widget.Bfree.Commands.CHECKOUT:
                this.__onCheckout(option, params);
                break;
            case bfree.widget.Bfree.Commands.CHECKIN:
                this.__onCheckin(option, params);
                break;
            case bfree.widget.Bfree.Commands.CANCEL_CKO:
                this.__onCancelCheckout(option, params);
                break;
            case bfree.widget.Bfree.Commands.DELETE:
                this.__onDelete(option, params);
                break;
            case bfree.widget.Bfree.Commands.DESTROY:
                this.__onDestroy(option, params);
                break;
            case bfree.widget.Bfree.Commands.RESTORE:
                this.__onRestore(option, params);
                break;
            case bfree.widget.Bfree.Commands.SECURE:
                this.__onSecure(option, params);
                break;
            case bfree.widget.Bfree.Commands.SHARE:
                this.__onShare(option, params);
                break;
            case bfree.widget.Bfree.Commands.UNSHARE:
                this.__onUnshare(option, params);
                break;
            case bfree.widget.Bfree.Commands.RENAME:
                this.__onRename(option, params);
                break;
            case bfree.widget.Bfree.Commands.EMPTY:
                this._onFolderTrashEmpty();
                break;
            case bfree.widget.Bfree.Commands.PRINT:
                this._onPrint();
                break;
            case bfree.widget.Bfree.Commands.EXPORT:
                this._onExport(option);
                break;
            case bfree.widget.Bfree.Commands.LOGOFF:
                this._onLogoff();
                break;
        };

    },

     __onAdmin: function(object_type){

        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.USER:
                this._onUserAdmin();
                break;
            case bfree.widget.Bfree.ObjectTypes.GROUP:
                this._onGroupAdmin();
                break;
            case bfree.widget.Bfree.ObjectTypes.PROP_DEF:
                this._onAdminPropDefs();
                break;
            case bfree.widget.Bfree.ObjectTypes.CHOICE_LIST:
                this._onChoiceListAdmin();
                break;
            case bfree.widget.Bfree.ObjectTypes.DOC_TYPE:
                this._onDocTypeAdmin();
                break;
            case bfree.widget.Bfree.ObjectTypes.VIEW_DEF:
                this._onViewDefAdmin();
                break;
            case bfree.widget.Bfree.ObjectTypes.QUOTA:
                this._onAdminQuota();
                break;

        }
    },

    __onCancelCheckout: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentCancelCKO(params.items);
                break;
        }
    },

    __onCheckin: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentCKI(params.items);
                break;
        }
    },

    __onCheckout: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentCKO(params.items);
                break;
        }
    },

    __onCopy: function(object_type, params){

        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentCopy(params.items);
                break;
            case bfree.widget.Bfree.ObjectTypes.VERSION:
                this._onVersionCopy(params.document, params.version);
                break;
            case bfree.widget.Bfree.ObjectTypes.SHARE:
                this._onShareShowLink(params.folder);
                break;
        }

    },

    __onDelete: function(object_type, params){

        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentDelete(params.items);
                break;
            case bfree.widget.Bfree.ObjectTypes.SHARE:
                this._onShar
        }

    },

    __onDestroy: function(object_type, params){

        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentDestroy(params.items);
                break;
            case bfree.widget.Bfree.ObjectTypes.FOLDER:
                this._onFolderDestroy(params.folder);
                break
            case bfree.widget.Bfree.ObjectTypes.SHARE:
                this._onShareDestroy(params.folder);
                break;
        }

    },

    __onEdit: function(object_type, params){

        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentEdit(params.items);
                break
            case bfree.widget.Bfree.ObjectTypes.SHARE:
                this._onShareEdit(params.folder);
                break
            case bfree.widget.Bfree.ObjectTypes.USER:
                this._onUserEdit();
                break
            case bfree.widget.Bfree.ObjectTypes.VERSION:
                this._onVersionEdit(params.items);
                break;
        }

    },

    __onMove: function(object_type, params){
       switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                (!params.folder) ?
                    this._onDocumentMove(params.items):
                    this._onDocumentQuickMove(params.folder, params.items);
                break;
        }
    },

    __onNew: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentNew(params.folder);
                break;
            case bfree.widget.Bfree.ObjectTypes.FOLDER:
                this._onFolderNew(params.folder);
                break;
            case bfree.widget.Bfree.ObjectTypes.SHARE:
                this._onShareNew(params.folder);
                break;
        }
    },

    __onRefresh: function(object_type){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentsRefresh();
                break;
        }
    },

    __onRename: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.FOLDER:
                this._onFolderRename(params.folder);
                break;
        }
    },

    __onRestore: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                 this._onDocumentRestore(params.items);
                break;
        }
    },

    __onSecure: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentSecure(params.items);
                break;
            case bfree.widget.Bfree.ObjectTypes.FOLDER:
                this._onFolderSecure(params.folder);
                break;
        }
    },

    __onShare: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentShare(params.folder, params.items);
                break;
            case bfree.widget.Bfree.ObjectTypes.FOLDER:
                this._onFolderShare(params.folder);
                break;
        }
    },

    __onUnshare: function(object_type, params){
        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentUnshare(params.items);
                break;
        }
    },

    __onView: function(object_type, params){

        switch(object_type){
            case bfree.widget.Bfree.ObjectTypes.DOCUMENT:
                this._onDocumentView(params.items);
                break;
            case bfree.widget.Bfree.ObjectTypes.VERSION:
                this._onVersionView(params.document, params.version);
                break;
        }

    },

    __wdg_onFocus: function(type){
        this.set('activeType', type);
    },

    __wdgDocuments_onSelectedItems: function(items){
         this.set('activeDocuments', items);
    },

    __wdgFolders_onSelected: function(item, node){
        this.set('activeFolder', item);
    },

    __wdgFolders_onNewNode: function(node){
        var folder = node.item;
        if((this.activeType == bfree.widget.Bfree.ObjectTypes.FOLDER) && (folder === this.activeFolder)){
            this.activeFolder.document_count = this._grdDocuments.rowCount;
            this._wdgItemInfo.preload(bfree.widget.Bfree.ObjectTypes.FOLDER, [folder]);
            this._wdgItemInfo.loadItem({
                item: folder
            });
        }
    },

    __wdgFolders_onUpdateNode: function(node){

        var folder = node.item;
        if((this.activeType == bfree.widget.Bfree.ObjectTypes.FOLDER) && (folder === this.activeFolder)){
            this._wdgItemInfo.preload(bfree.widget.Bfree.ObjectTypes.FOLDER, [folder]);
            this._wdgItemInfo.loadItem({
                item: folder
            });
        }

    },

    /*
    __wdgPane_onFocus: function(pane){
        if(pane === this.contentPane){
            this.set('activeType', bfree.widget.Bfree.ObjectTypes.DOCUMENT);
        }
        else if (pane === this.folderPane){
            this.set('activeType', bfree.widget.Bfree.ObjectTypes.FOLDER);
        }
        else{
            this.set('activeType', bfree.widget.Bfree.ObjectTypes.NONE);
        }
    },
    */

    _checkSession: function(){
        var isAlive = false;
        try{
            isAlive = this.zone.isAlive();
        }
        catch(e){
        }

        if(isAlive){
            setTimeout(bfree.widget.zone.Show._buildCheckFnRef(this), this._duration);
        }
        else{
            this._showLogon();
        }

    },

    _doAdHocQuery: function(queryItem){

        if(queryItem.queryData==""){
            return;
        }
        var searchFolder = this.activeLibrary.getFolders().getSearchFolder();
        if(searchFolder){
            searchFolder.setActiveQuery(queryItem);
            this._tvwFolders.showSearch();
            this._tvwFolders.setSelectedItem(searchFolder);

        }
    },

    _onAdminPropDefs: function(){

        try{
            function __onClose(dlgResult, retValue){
                this._grdDocuments.refreshViews(false);
                return true;
            }

            bfree.widget.propdef.Administration.show({
                zone: this.zone,
                library: this.activeLibrary,
                user: this.activeUser,
                onClose: dojo.hitch(this, __onClose)
            });
        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Property Definition Administration\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    _onAdminQuota: function(){

        try{

            function __onClose(dlgResult, retValue){
                return true;
            }

            versa.widget.zone.metrics.Info.show({
                library: this.activeLibrary,
                zone: this.zone,
                onClose: dojo.hitch(this, __onClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Quota Information\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    _onDocTypeAdmin: function(){

        try{
            bfree.widget.doctype.Administration.show({
                user: this.activeUser,
                zone: this.zone,
                library: this.activeLibrary,
                onClose: dojo.hitch(this,
                    function(dlgResult, retValue){
                       return true;
                    })
            });
        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Property Definition Administration\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    _onChoiceListAdmin: function(){
       try{
            bfree.widget.choiceList.Administration.show({
                user: this.activeUser,
                zone: this.zone,
                library: this.activeLibrary,
                onClose: dojo.hitch(this,
                    function(dlgResult, retValue){
                       return true;
                    })
            });
        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Choice List Administration\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },


    _onDocumentCancelCKO: function(items){

        this._wdgItemInfo.setBusy(true);

        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            var msg = dojo.replace('Are you sure you want to cancel the checkout of document \'{name}\'?', item);
            if(confirm(msg)){
                accessor.doCancelCheckout(item);
            }
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to cancel checkout of document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, __action, __onComplete, __onError);

    },

    _onDocumentCKI: function(items){

        this._wdgItemInfo.setBusy(true);

        function __onClose(dlgResult, items){
            dojo.forEach(items, function(item, idx){
                this.activeLibrary.getReferences().refreshItem(item.getId());
            }, this);
            return true;
        };

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to checkin document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doDialog(items, bfree.widget.document.Checkin.show, dojo.hitch(this, __onClose), __onError);

    },

    _onDocumentCKO: function(items){

        this._wdgItemInfo.setBusy(true);

        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            accessor.doCheckout(item);
            accessor.doCopyLocal(item);
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to checkout document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, dojo.hitch(this, __action), dojo.hitch(this, __onComplete), dojo.hitch(this, __onError));

    },

    //Copies document content from the server to the client machine
    _onDocumentCopy: function(items){

        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            accessor.doCopyLocal(item);
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to copy document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, __action, __onComplete, __onError);
    },

    _onDocumentDelete: function(items){

        var msg = 'Are you sure you want to delete the selected documents?';
        if(!confirm(msg))
            return;

        function __action(item){
             this.activeLibrary.getReferences().destroy({
                soft: true,
                item: item
            });
        }

        function __onComplete(items){
            //this._grdDocuments.update();
            //dojo.forEach(items, function(item, idx){
            //    this._grdDocuments.store.onDelete(item);
            //}, this);
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to delete document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, dojo.hitch(this, __action), dojo.hitch(this, __onComplete), __onError);

    },

    _onDocumentDestroy: function(items){

        var msg = 'Are you sure you want to permanently delete the selected documents?\nWarning: This cannot be undone.';
        if(!confirm(msg))
            return;

        function __action(item){
            this.activeLibrary.getReferences().destroy({
                item: item
            });
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to destroy document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, dojo.hitch(this, __action), dojo.hitch(this, __onComplete), __onError);

    },

    //Opens a dialog to edit document properties
    _onDocumentEdit: function(items){

        this._wdgItemInfo.setBusy(true);

        function __onClose(dlgResult, items){
            dojo.forEach(items, function(item, idx){
                this.activeLibrary.getReferences().refreshItem(item.getId());
            }, this);
            return true;
        };

        function __onError(items, e){
            dojo.forEach(items, function(item, idx){
                var err = new bfree.api.Error(dojo.replace('Failed to edit document \'{0}\'', [item.name]), e);
                bfree.widget.ErrorManager.handleError({
                    error: err
                });
            }, this);
        };

        this.__doDialog(items, bfree.widget.document.PropertyEditor.show, dojo.hitch(this, __onClose), __onError);
    },

    _onDocumentMove: function(items){

        function __onClose(dlgResult, items){
            return true;
        };

        function __onError(items, e){
            var err = new bfree.api.Error('Failed to move documents', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        };

        this.__doDialog(items, bfree.widget.document.Move.show, dojo.hitch(this, __onClose), __onError);

    },

    _onDocumentNew: function(folder){

        try{

            this._grdDocuments.beginUpdate();

            bfree.widget.document.Creator.show({
                folder: (folder),
                library: this.activeLibrary,
                zone: this.zone,
                onClose: dojo.hitch(this,
                    function(dlgResult, retValue){
                       this._grdDocuments.endUpdate();
                       this._grdDocuments.refresh();

                       if(this._grdDocuments.selection.getSelectedCount() < 1)
                        this._grdDocuments.setSelectedIndex(0);

                       this.__wdgFolders_onSelected(this.activeFolder, null);
                       return true;
                    })
            });
        }
        catch(e){
            this._grdDocuments.endUpdate();
            var err = new bfree.api.Error('Failed to open \'Create Documents\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    _onDocumentQuickMove: function(folder, items){

        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            accessor.doMove(folder, item);
        }

        function __onComplete(items){
            dojo.forEach(items, function(item, idx){
                this.activeLibrary.getDocuments()
            }, this);
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to move document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, __action, __onComplete, __onError);
    },

     _onDocumentRestore: function(items){

        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            accessor.doRestore(item);
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to restore document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, __action, __onComplete, __onError);

    },

    _onDocumentSecure: function(items){

        function __onClose(dlgResult, items){
            return true;
        };

        function __onError(items, e){
            dojo.forEach(items, function(item, idx){
                var err = new bfree.api.Error(dojo.replace('Failed to edit document security \'{0}\'', [item.name]), e);
                bfree.widget.ErrorManager.handleError({
                    error: err
                });
            }, this);
        };

        this.__doDialog(items, bfree.widget.acl.Editor.show, dojo.hitch(this, __onClose), __onError);

    },

    _onDocumentShare: function(folder, items){
        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            accessor.doShare(folder, item);
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to share document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, __action, __onComplete, __onError)
    },

    _onDocumentUnshare: function(items){

        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            accessor.doUnshare(item);
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to un-share document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, __action, __onComplete, __onError)
    },

     //Streams document content from the server for display in the browser
    _onDocumentView: function(items){

        var accessor = new versa.widget.reference.Accessor({
            activeLibrary: this.activeLibrary,
            activeZone: this.zone
        });

        function __action(item){
            accessor.doView(item);
        }

        function __onComplete(items){
        }

        function __onError(item, e){
            var err = new bfree.api.Error(dojo.replace('Failed to view document \'{0}\'', [item.name]), e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

        this.__doAction(items, __action, __onComplete, __onError);

    },

    _onDocumentsRefresh: function(){
        this._grdDocuments.refresh();
    },

    _onFolderDestroy: function(folder){

        try{

            if(!folder)
                return;

            //make sure folder is loaded (not a reference) before creating a new sub-folder
            this.activeLibrary.getFolders().loadItem({
                item: folder,
                callback: dojo.hitch(this, function(item){
                    this._tvwFolders.deleteFolder(item);
                })
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to delete folder', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onFolderEdit: function(folder){

    },

    _onFolderNew: function(folder){

        try{

            if(!folder)
                return;

            if(folder.root){
                this._tvwFolders.createFolder(folder);
            }
            else{
                //make sure folder is loaded (not a reference) before creating a new sub-folder
                this.activeLibrary.getFolders().loadItem({
                    item: folder,
                    callback: dojo.hitch(this, function(item){
                        this._tvwFolders.createFolder(item);
                    })
                });
            }

		}
		catch(e){
			var err = new bfree.api.Error('Failed to create a new folder', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
		}

    },

    _onFolderRename: function(folder){

        try{

            if(!folder)
                return;

            //make sure folder is loaded (not a reference) before creating a new sub-folder
            this.activeLibrary.getFolders().loadItem({
                item: folder,
                callback: dojo.hitch(this, function(item){
                    this._tvwFolders.editFolder(item);
                })
            });

		}
		catch(e){
			var err = new bfree.api.Error('Failed to rename folder', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
		}
    },

    _onFolderSecure: function(folder){

        try{

            function __onClose(dlgResult, retValue){
                return true;
            }

            if(!folder)
                return;

            if(folder.root){

                bfree.widget.acl.Editor.show({
                    user: this.activeUser,
                    group: this.activeGroup,
                    library: this.activeLibrary,
                    zone: this.zone,
                    item: this.activeLibrary,
                    onClose: dojo.hitch(this, __onClose)
                });
            }
            else{
                //make sure folder is loaded (not a reference) before creating a new sub-folder
                this.activeLibrary.getFolders().loadItem({
                    item: folder,
                    callback: dojo.hitch(this, function(item){
                        bfree.widget.acl.Editor.show({
                            user: this.activeUser,
                            group: this.activeGroup,
                            library: this.activeLibrary,
                            zone: this.zone,
                            item: folder,
                            onClose: dojo.hitch(this, __onClose)
                        });
                    })
                });
            }

		}
		catch(e){
			var err = new bfree.api.Error('Failed to create a new folder', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
		}

    },

    _onFolderTrashEmpty: function(){

        var msg = 'Are you sure you want to permanently delete all of the documents in the Recycle Bin?\nWarning: This cannot be undone.'
        if(!confirm(msg))
            return;

        try{
            this.activeLibrary.empty_trash({zone: this.zone});
            this._grdDocuments.refresh();
        }
        catch(e){
            var err = new bfree.api.Error('Failed to empty the Recycle Bin', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }

    },

    _onGroupAdmin: function(){

        try{
            bfree.widget.group.Administration.show({
                user: this.activeUser,
                zone: this.zone,
                onClose: dojo.hitch(this,
                    function(dlgResult, retValue){
                       return true;
                    })
            });
        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Group Administration\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    _onExport: function(export_type){
        try{
           this._grdDocuments.export_results(export_type);
		}
		catch(e){
			var err = new bfree.api.Error('Failed to export results', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
		}
    },

    _onPrint: function(){
        try{

           this._grdDocuments.print_results();
		}
		catch(e){
			var err = new bfree.api.Error('Failed to print results', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
		}

    },

    _onLogoff: function(){
        try{

           var doConfirm = true;

            if(doConfirm){
                var msg = 'Continue to exit VersaFile?';
                if(!confirm(msg))
                    return;
            }

            this.onWorking();
            this.zone.logoff();
            parent.frames['zoneframe'].location.reload(true);
        }
        catch(e){
            var err = new bfree.api.Error('Failed to logout', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onShareDestroy: function(share){
         try{

            if(!share)
                return;

            this._tvwFolders.setBusy(share, true);

            //make sure folder is loaded (not a reference) before creating a new sub-folder
            this.activeLibrary.getFolders().loadItem({
                item: share,
                callback: dojo.hitch(this, function(item){
                    this._tvwFolders.deleteFolder(item);
                })
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to delete folder', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onShareEdit: function(folder){
        try{

            function __onClose(dlgResult, retValue){
                return true;
            }

           versa.widget.share.Editor.show({
                share: folder,
                seed: null,
                library: this.activeLibrary,
                zone: this.zone,
                onClose: dojo.hitch(this, __onClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Share Edit\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onShareNew: function(folder){
        try{

            function __onClose(dlgResult, retValue){
                return true;
            }

            versa.widget.share.Editor.show({
                share: null,
                seed: folder,
                library: this.activeLibrary,
                zone: this.zone,
                onClose: dojo.hitch(this, __onClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Share Creation\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _onShareShowLink: function(share){

        try{

            function __onClose(dlgResult, retValue){
                return true;
            }

           versa.widget.share.CopyLink.show({
                share: share,
                library: this.activeLibrary,
                zone: this.zone,
                onClose: dojo.hitch(this, __onClose)
            });

        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Share Link\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }


    },


    _onUserAdmin: function(){

        try{
            bfree.widget.user.Administration.show({
                user: this.activeUser,
                zone: this.zone,
                onClose: dojo.hitch(this,
                    function(dlgResult, retValue){
                        this.activeUser = this.zone.getUsers().fetchById({id: this.activeUser.id});
                        this.nameNode.innerHTML = this.activeUser.getFullName();
                        return true;
                    })
            });
        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'User Administration\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    _onUserEdit: function(){

        try{

            if(!this.activeUser)
                return;

            function __onClose(dlgResult, retValue){
                if(dlgResult == bfree.widget.Dialog.dialogResult.ok){
                    this.nameNode.innerHTML = this.activeUser.getFullName();
                }
                return true;
            }

            bfree.widget.user.ProfileEditor.show({
                user: this.activeUser,
                zone: this.zone,
                onClose: dojo.hitch(this, __onClose)
            });

		}
		catch(e){
			var err = new bfree.api.Error('Failed to edit user properties', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
		}
    },

    _onVersionCopy: function(document, version){

        try{

            if(!document||!version)
                return;

            var accessor = new bfree.widget.document.version.Accessor({
                library: this.activeLibrary,
                zone: this.zone
            });
            accessor.doCopyLocal(document, version);

        }
        catch(e){
            var err = new bfree.api.Error('Failed to copy document', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }
        finally{
        }
    },

    //Opens the dialog to view version information for a document
    _onVersionEdit: function(items){

        function __onClose(dlgResult, items){
            return true;
        }

        function __onError(items, e){
            dojo.forEach(items, function(item, idx){
                var err = new bfree.api.Error(dojo.replace('Failed to display version information for document \'{0}\'', [item.name]), e);
                bfree.widget.ErrorManager.handleError({
                    error: err
                });
            }, this);
        }

        this.__doDialog(items, bfree.widget.document.version.Versions.show, dojo.hitch(this, __onClose), __onError);

    },

    _onVersionView: function(document, version){

        if(!document && !version)
            return;

        try{

            var accessor = new bfree.widget.document.version.Accessor({
                library: this.activeLibrary,
                zone: this.zone
            });
            accessor.doView(document, version);

        }
        catch(e){
            var err = new bfree.api.Error('Failed to view version', e);
			bfree.widget.ErrorManager.handleError({
				error: err
			});
        }
        finally{
        }

    },

    _onViewDefAdmin: function(){
        try{

            function __onClose(dlgResult, doRefresh){

                if(doRefresh)
                    this._grdDocuments.refreshViews(true);
                return true;
            }

            bfree.widget.view.Administration.show({
                user: this.activeUser,
                library: this.activeLibrary,
                zone: this.zone,
                onClose: dojo.hitch(this, __onClose)
            });
        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'View Definition\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }
    },

    _setActiveDocumentsAttr: function(items){

        //items may have "null" elements in it...remove them
        items.clean();

        if((!items) || (items.length < 1)){
            this.activeDocuments = [];
            return;
        }

        this.activeDocuments = items;

        //Set command bar/grid active folder (for context menu updates)
        this._cmdBar.set('activeDocuments', this.activeDocuments);

        //Set info pane widget to "loading" of item
        //only if the folder pane has focus
        if(this.activeType == bfree.widget.Bfree.ObjectTypes.DOCUMENT){
            this._wdgItemInfo.preload(bfree.widget.Bfree.ObjectTypes.DOCUMENT, items);

            dojo.forEach(items, function(item, idx){
                this.activeLibrary.getDocuments().refreshAsync({
                    scope: this,
                    identity: item.document_id,
                    onItem: this.__onDocumentLoad,
                    onError: this.__onDocumentLoadError
                });
            }, this);

            /*
            dojo.forEach(items, function(item, idx){



                this.activeLibrary.getDocuments().store.fetchItemByIdentity({
                    scope: this,
                    identity: item.document_id,
                    onItem: this.__onDocumentLoad,
                    onError: this.__onDocumentLoadError
                });

            }, this);
            */

        }

    },

    _setActiveFolderAttr: function(item){

        //Now set new active folder
        this.activeFolder = item;

        //Set info pane widget to "loading" of item
        //only if the folder pane has focus
        if(this.activeType == bfree.widget.Bfree.ObjectTypes.FOLDER){
            this._wdgItemInfo.preload(bfree.widget.Bfree.ObjectTypes.FOLDER, [item]);
        }

        //Set command bar/grid active folder (for context menu updates)
        this._cmdBar.set('activeFolder', this.activeFolder);
        this._grdDocuments.set('activeFolder', item);

        if(this.activeType == bfree.widget.Bfree.ObjectTypes.FOLDER){
            //Load folder from server if it is a reference.
            this.activeLibrary.getFolders().loadItem({
                item: this.activeFolder,
                scope: this,
                onItem: this.__onFolderLoad,
                onError: function(errData){
                    this.__onFolderLoadError(item, new bfree.api.Error(errData.responseText, errData));
                }
            });
        }
        return;

        this.activeFolder.document_count = this._grdDocuments.rowCount;

        //Load folder from server if it is a reference.
        this.activeLibrary.getFolders().loadItem({
            item: this.activeFolder,
            scope: this,
            onItem: this.__onFolderLoad,
            onError: function(errData){
                this.__onFolderLoadError(item, new bfree.api.Error(errData.responseText, errData));
            }
        });

    },

    _showLogon: function(){

        function __onClose(dlgResult){
            if(dlgResult == bfree.widget.Dialog.dialogResult.ok){
                setTimeout(bfree.widget.zone.Show._buildCheckFnRef(this), this._duration);
            }
            else{
                this.logoff(false);
            }
            return true;
        };

        var dlg = new bfree.widget.Dialog({
            title: 'Bfree Logon',
            widgetConstructor: bfree.widget.zone.ReLogon,
            widgetParams: {
                zone: this.zone,
                activeUser: this.activeUser
            },
            noResize: true,
            height: 240,
            width: 400,
            zIndex: 1024,
            onClose: dojo.hitch(this, __onClose)
        });
        dlg.startup();
        dlg.show(); 

    },

    constructor: function(args){

    },

    editUserGroups: function(){
       var dlg = new bfree.widget.Dialog({
            title: 'Edit User/Groups',
            widgetConstructor: bfree.widget.zone.UserGroupsAdmin,
            widgetParams: {
                zone: this.zone
            },
            noResize: true,
            height: 240,
            width: 400,
            zIndex: 1024
        });
        dlg.startup();
        dlg.show();
    },

    onLoad: function(wdg){
    },
    onWorking: function(){
    },

    postCreate: function(){
        this.inherited('postCreate', arguments);

        //preloading
        bfree.api.Application.getDataTypes();
        bfree.api.Application.getOperators();

        this.activeLibrary.getPropertyDefinitions().fetch();
        this.activeLibrary.getDocumentTypes().fetch();
        this.activeLibrary.getViewDefinitions().fetch();

        if((this.zone.trial_expiry != bfree.api.Zone.TrialStates.NO_TRIAL) &&
            (this.zone.trial_expiry != bfree.api.Zone.TrialStates.INFINITE) ){

            if(this.zone.trial_expiry > bfree.api.Zone.TrialStates.EXPIRED + 1){
                this.trialMsgNode.innerHTML = dojo.replace(versa.VersaFile.messages.TRIAL_REMAINING, {days_left: this.zone.trial_expiry});
            }
            else if(this.zone.trial_expiry == bfree.api.Zone.TrialStates.EXPIRED + 1){
                this.trialMsgNode.innerHTML = versa.VersaFile.messages.TRIAL_FINAL;
            }
            else{
                 this.trialMsgNode.innerHTML = versa.VersaFile.messages.TRIAL_EXPIRED;
            }
            dojo.style(this.trialStateNode, {display: 'block'});
        }

        this.nameNode.innerHTML = this.activeUser.getFullName();

        this._cmdBar = new bfree.widget.zone.Toolbar({
            user: this.activeUser,
            group: this.activeGroup,
            library: this.activeLibrary,
            zone: this.zone,
            onCommand: dojo.hitch(this, this.__onCommand),
            style:'z-index: 512;bottom:4px;left:0;position:absolute'
        }, this.toolbarNode);

        new bfree.widget.search.TextBox({
            library: this.activeLibrary,
			onSearch: dojo.hitch(this, this._doAdHocQuery),
            style: 'width:100%'
		},  this.searchBoxNode);

        this._tvwFolders = new bfree.widget.folder.Tree({
            library: this.activeLibrary,
            group: this.activeGroup,
            user: this.activeUser,
            folders: this.activeLibrary.getFolders(),
            documents: this.activeLibrary.getDocuments(),
            dndController: 'bfree.widget.folder.DndSource',
            onCommand: dojo.hitch(this, this.__onCommand),
            onSelected: dojo.hitch(this, this.__wdgFolders_onSelected),
            onNewNode: dojo.hitch(this, this.__wdgFolders_onNewNode),
            onUpdateNode: dojo.hitch(this, this.__wdgFolders_onUpdateNode),
            onFocus: dojo.hitch(this, this.__wdg_onFocus, bfree.widget.Bfree.ObjectTypes.FOLDER),
            style: "height: 100%"
        }, this.folderTreeNode);

        this._grdDocuments = new versa.widget.reference.Grid({
            id: 'grdReferences',
            activeLibrary: this.activeLibrary,
            activeUser: this.activeUser,
            activeZone: this.zone,
            onCommand: dojo.hitch(this, this.__onCommand),
            onSelectedItems: dojo.hitch(this, this.__wdgDocuments_onSelectedItems),
            onFocus: dojo.hitch(this, this.__wdg_onFocus, bfree.widget.Bfree.ObjectTypes.DOCUMENT)
        }, this.documentGridNode);

        this._wdgItemInfo = new bfree.widget.ItemInfo({
			library: this.activeLibrary,
            root: this._tvwFolders.rootNode
		}, this.itemInfoNode);

        bfree.widget.document.PropertyEditor.refresh = dojo.hitch(this, this._onDocumentsRefresh);
        bfree.widget.acl.Editor.refresh = dojo.hitch(this, this._onDocumentsRefresh);

        this.versionSpan.innerHTML = dojo.replace('v{version}', this);

        //dojo.connect(this.folderPane, 'onFocus', dojo.hitch(this, this.__wdgPane_onFocus, this.folderPane));
        //dojo.connect(this.contentPane, 'onFocus', dojo.hitch(this, this.__wdgPane_onFocus, this.contentPane));

        this.onLoad(this);
    },
	showEditDocumentTypes: function(){

        try{

            function __onClose(dlgResult, retValue){

                if(dlgResult == bfree.widget.Dialog.dialogResult.ok){

                }

                return true;
            }


        }
        catch(e){
            var err = new bfree.api.Error('Failed to open \'Edit Property Definitions\' dialog', e);
            bfree.widget.ErrorManager.handleError({
                error: err
            });
        }

    },

    startup: function(){
        this._cmdBar.set('activeLibrary', this.activeLibrary);
        this._cmdBar.set('activeUser', this.activeUser);

        this.inherited('startup', arguments);

        dijit.focus(this._tvwFolders.domNode);
        this._tvwFolders.selectRoot();
    }

});

bfree.widget.zone.Show._buildCheckFnRef = function(that){
    return ( function() {
       that._checkSession();
    });
};


}


dojo.i18n._preloadLocalizations("dojo.nls.bfree", ["ROOT","en","en-us","xx"]);
